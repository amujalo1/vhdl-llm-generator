"input","output"
"This entity implements a priority arbiter. The left-most bit (highest bit) of the request vector that was asserted is granted (i.e. asserted in the grant  vector). The arbiter is implemented using the very logic-and timing-efficient parallel prefix computation approach. The arbiter can be implemented with or without an output registers. The waveform below shows its implementation with andwithout output register (_Latency\_g = 0_ resp. 1).

# VHDL Analysis for 'olo_base_arb_prio.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements an efficient priority arbiter. The highest index of
- Plus 21 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_arb_prio

## Architecture: rtl of olo_base_arb_prio

### Signals
- Grant_I: std_logic_vector(Out_Grant'range)
- RdPipe: Data_t(1 to Latency_g)

### Processes
- Process 'p_comb :' with sensitivity list: In_Req
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_comb :' with sensitivity list: None (uses wait statements)
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Calculate Grant with Edge Detection
            Grant_I <= OredRequest_v and not ('0' & OredRequest_v(OredRequest_v'high downto 1))

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 101
- Process count: 4
- Signal count: 2

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_arb_prio.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_arb_prio is
    generic (
        Width_g    : positive;
        Latency_g  : natural := 1
    );
    port (
        Clk        : in    std_logic;
        Rst        : in    std_logic;
        In_Req     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Grant  : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_arb_prio is

    type Data_t is array (natural range<>) of std_logic_vector(Out_Grant'range);

    signal Grant_I : std_logic_vector(Out_Grant'range);
    signal RdPipe  : Data_t(1 to Latency_g);

begin

    g_non_zero : if Width_g > 0 generate

        p_comb : process (In_Req) is
            variable OredRequest_v : std_logic_vector(In_Req'range);
        begin
            OredRequest_v := ppcOr(In_Req);

            Grant_I <= OredRequest_v and not ('0' & OredRequest_v(OredRequest_v'high downto 1));
        end process;

        g_reg : if Latency_g > 0 generate

            p_outreg : process (Clk) is
            begin
                if rising_edge(Clk) then
                    if Rst = '1' then
                        RdPipe <= (others => (others => '0'));
                    else
                        RdPipe(1)              <= Grant_I;
                        RdPipe(2 to Latency_g) <= RdPipe(1 to Latency_g-1);
                    end if;
                end if;
            end process;

            Out_Grant <= RdPipe(Latency_g);
        end generate;

        g_nreg : if Latency_g = 0 generate
            Out_Grant <= Grant_I;
        end generate;

    end generate;

end architecture;"
"This entity implements a round-robin arbiter. If multiple bits are asserted in the _In_Req_ vector, the left-most bit is forwarded to the grant vector first. Next, the second left-most bit that is set is forwarded etc. Whenever at least one bit in the _Out_Grant_ vector is asserted, the _Out_Valid_ handshaking signal is asserted to signal that a request was granted. The consumer of the _Out_Grant_ vector signalizes that the granted access was executed by pulling _Out\_Ready_ high. Note that the round-robin arbiter is implemented without an output register. Therefore combinatorial paths between input and output exist and it is recommended to add a register-stage to the output as early as possible. Especially interesting is the part in orange. At this point the arbiter does not grant access to bit 3 because it already granted this request in the clock cycle before. However, it continues to grant access to the highest-priority (i.e. left-most) bit of the request vector that is still left of the bit set in the last _Out_Grant_ output. If the _In_Req_ vector asserts a higher priority this change is directly forwarded to the output. This is shown in the orange section of the waveform.

# VHDL Analysis for 'olo_base_arb_rr.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements an efficient round-robin arbiter.
- Plus 22 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_arb_rr

## Architecture: rtl of olo_base_arb_rr

### Signals
- r: TwoProcess_t
- r_next: TwoProcess_t
- RequestMasked: std_logic_vector(In_Req'range)
- GrantMasked: std_logic_vector(Out_Grant'range)
- GrantUnmasked: std_logic_vector(Out_Grant'range)

### Component Instantiations
- Instance 'i_prio_masked' of component 'olo_base_arb_prio'
- Instance 'i_prio_unmasked' of component 'olo_base_arb_prio'

### Processes
- Process 'p_comb :' with sensitivity list: r, In_Req, Out_Ready, GrantMasked, GrantUnmasked
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Round Robing Logic
            RequestMasked <= In_Req and r.Mask
- -- Generate Grant
            if unsigned(GrantMasked) = 0 then
                Grant_v := GrantUnmasked
- else
                Grant_v := GrantMasked

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 143
- Process count: 4
- Signal count: 5

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_arb_rr.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_arb_rr is
    generic (
        Width_g    : positive
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Req      : in    std_logic_vector(Width_g-1 downto 0);
        Out_Grant   : out   std_logic_vector(Width_g-1 downto 0);
        Out_Ready   : in    std_logic;
        Out_Valid   : out   std_logic
    );
end entity;

architecture rtl of olo_base_arb_rr is

    type TwoProcess_t is record
        Mask : std_logic_vector(In_Req'range);
    end record;

    signal r, r_next : TwoProcess_t;

    signal RequestMasked : std_logic_vector(In_Req'range);
    signal GrantMasked   : std_logic_vector(Out_Grant'range);
    signal GrantUnmasked : std_logic_vector(Out_Grant'range);

begin

    g_non_zero : if Width_g > 0 generate

        p_comb : process (r, In_Req, Out_Ready, GrantMasked, GrantUnmasked) is
            variable v       : TwoProcess_t;
            variable Grant_v : std_logic_vector(Out_Grant'range);
        begin
            v := r;

            RequestMasked <= In_Req and r.Mask;

            if unsigned(GrantMasked) = 0 then
                Grant_v := GrantUnmasked;
            else
                Grant_v := GrantMasked;
            end if;

            if (unsigned(Grant_v) /= 0) and (Out_Ready = '1') then
                v.Mask := '0' & ppcOr(Grant_v(Grant_v'high downto 1));
            end if;

            if unsigned(Grant_v) /= 0 then
                Out_Valid <= '1';
            else
                Out_Valid <= '0';
            end if;

            Out_Grant <= Grant_v;

            r_next <= v;

        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.Mask <= (others => '0');
                end if;
            end if;
        end process;

        i_prio_masked : entity work.olo_base_arb_prio
            generic map (
                Width_g   => Width_g,
                Latency_g => 0
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Req      => RequestMasked,
                Out_Grant   => GrantMasked
            );

        i_prio_unmasked : entity work.olo_base_arb_prio
            generic map (
                Width_g   => Width_g,
                Latency_g => 0
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Req      => In_Req,
                Out_Grant   => GrantUnmasked
            );

    end generate;

end architecture;"
"This component implements a content addressable memory. Content addressable memories are usually used for fast-lookups in caches, routing tables and other similar scenarios. The concept of mapping a CAM into block and/or distributed RAM described in the [AMD application not XAPP 1151](https://docs.amd.com/v/u/en-US/xapp1151_Param_CAM) is applied. However, _olo_base_cam_ has a very different and much easier to understand user interface than the component described in the application note. The _olo_base_cam_ does allow to write address/content pairs and to find out in which address a queried content is stored. Reads take one clock cycle, writes take two clock cycles and the two things cannot happen at the same time. Below example assumes a _olo_base_cam_ with 4 addresses and 16 bit content. The CAM has logically separated read and write interfaces. They share some resources internally but from a users perspective they are independent. Every read-request issues through _Rd_..._ is followed by one output on both read-response streams: - _OneHot_..._ provides a match response - A vector with one entry per address, indicating if the requested _Rd_Content_ was stored in this address or not - _Addr_..._ provides the binary encoded address where _Rd_Content_ is stored - The first (lowest) matching address is returned - If _Rd_Content_ is not found, _Addr_Found='0'_ is returned. **Note:** By default the content of the CAM is cleared after reset. During the _RamBlockDepth_g_ clock cycles this takes, it is not ready to accept any requests and holds _Rd/Wr_Ready_ low. This behavior can be changed through generics if needed. **Warning:** The user must ensure that an address is NOT occupied when new content is written to this address. Failure to adhere to this rule may lead to undefined behavior.

# VHDL Analysis for 'olo_base_cam.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- --------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This components implements a content addressable memory.
- Documentation:
- Plus 75 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: WrReady is low)
                InRdReady_v := '1'

## Entity: olo_base_cam

## Architecture: rtl of olo_base_cam

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- Types ***
    type RamData_t is array (natural range <>) of std_logic_vector(Addresses_g-1 downto 0);

    -- *** Instantiation Signals ***
    signal ReadContent_0: std_logic_vector(ContentWidth_g-1 downto 0)
- RamRead_1: RamData_t(0 to BlocksParallel_c-1)
- RamWrite_1: RamData_t(0 to BlocksParallel_c-1)
- WrMem_1: std_logic
- MatchInt: std_logic_vector(Addresses_g-1 downto 0)
- MatchValid: std_logic
- if r.RstClearDone = '0' then
                -- Deasserting ready signals is done further up where the ready signals are assigned
                -- Clear CAM
                v.RstClearWr: = '1'
- ***
        r_next <= v;
    end process;

    -- Output signals
    Match_Valid <= MatchValid;
    Match_Match <= MatchInt;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next
- ContentExtended_0: std_logic_vector(TotalAddrBits_c-1 downto 0) := (others => '0')
- RdAddr_0: std_logic_vector(BlockAddrBits_c-1 downto 0)
- WrAddr_1: std_logic_vector(BlockAddrBits_c-1 downto 0)

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_cob :' (Has Reset) with sensitivity list: Rd_Valid, Rd_Content, Wr_Valid, Wr_Content, Wr_Addr, Wr_Write, Wr_Clear,
                     RamRead_1, Rst, r
  - Implements conditional logic
  - Contains wait statements: until write is done
        if r.Write_0 = '1' or r.Clear_0 = '1' or r.ClearAll_0 = '1' then
            InWrReady_v := '0', for RAM to respond
            v.ContentExtended_1                            := (others => '0')
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
  - Contains wait statements: until write is done
        if r.Write_0 = '1' or r.Clear_0 = '1' or r.ClearAll_0 = '1' then
            InWrReady_v := '0', for RAM to respond
            v.ContentExtended_1                            := (others => '0')
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Input Ready Handling ***
        if ReadPriority_g then
            InRdReady_v := '1'
- InWrReady_v := not Rd_Valid
- else
            InWrReady_v := '1'
- InRdReady_v := not Wr_Valid

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): RstClearWr, FirstBitDecLatency_g, Reset, reset, Rst, olo_base_decode_firstbit, First, RstClearDone, Out_FirstBit, RstClearCounter, ClearAfterReset_g
- Implements memory functionality
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 390
- Process count: 4
- Signal count: 13

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cam.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_cam is
    generic (
        Addresses_g          : positive;
        ContentWidth_g       : positive;
        RamStyle_g           : string   := ""auto"";
        RamBehavior_g        : string   := ""RBW"";
        RamBlockWidth_g      : positive := 32;
        RamBlockDepth_g      : positive := 512;
        ClearAfterReset_g    : boolean  := true;
        ReadPriority_g       : boolean  := true;
        StrictOrdering_g     : boolean  := false;
        UseAddrOut_g         : boolean  := true;
        RegisterInput_g      : boolean  := true;
        RegisterMatch_g      : boolean  := true;
        FirstBitDecLatency_g : natural  := 1
    );
    port (
        Clk                     : in    std_logic;
        Rst                     : in    std_logic;

        Rd_Valid                : in    std_logic;
        Rd_Ready                : out   std_logic;
        Rd_Content              : in    std_logic_vector(ContentWidth_g-1 downto 0);

        Wr_Valid                : in    std_logic;
        Wr_Ready                : out   std_logic;
        Wr_Content              : in    std_logic_vector(ContentWidth_g-1 downto 0);
        Wr_Addr                 : in    std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Wr_Write                : in    std_logic;
        Wr_Clear                : in    std_logic := '0';
        Wr_ClearAll             : in    std_logic := '0';

        Match_Valid             : out   std_logic;
        Match_Match             : out   std_logic_vector(Addresses_g-1 downto 0);

        Addr_Valid              : out   std_logic;
        Addr_Found              : out   std_logic;
        Addr_Addr               : out   std_logic_vector(log2ceil(Addresses_g)-1 downto 0)
    );
end entity;

architecture rtl of olo_base_cam is

    constant BlockAddrBits_c  : positive := log2ceil(RamBlockDepth_g);
    constant BlocksParallel_c : positive := integer(ceil(real(ContentWidth_g) / real(BlockAddrBits_c)));
    constant TotalAddrBits_c  : positive := BlocksParallel_c * BlockAddrBits_c;

    type TwoProcess_r is record
        Content_0         : std_logic_vector(ContentWidth_g - 1 downto 0);
        Addr_0            : std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Write_0           : std_logic;
        Clear_0           : std_logic;
        ClearAll_0        : std_logic;
        Read_0            : std_logic;
        ContentExtended_1 : std_logic_vector(TotalAddrBits_c - 1 downto 0);
        Addr_1            : std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Write_1           : std_logic;
        Clear_1           : std_logic;
        ClearAll_1        : std_logic;
        Read_1            : std_logic;
        Match_2           : std_logic_vector(Addresses_g-1 downto 0);
        Read_2            : std_logic;
        RstClearDone      : std_logic;
        RstClearCounter   : unsigned(BlockAddrBits_c-1 downto 0);
        RstClearWr        : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    type RamData_t is array (natural range <>) of std_logic_vector(Addresses_g-1 downto 0);

    signal ReadContent_0 : std_logic_vector(ContentWidth_g-1 downto 0);
    signal RamRead_1     : RamData_t(0 to BlocksParallel_c-1);
    signal RamWrite_1    : RamData_t(0 to BlocksParallel_c-1);
    signal WrMem_1       : std_logic;
    signal MatchInt      : std_logic_vector(Addresses_g-1 downto 0);
    signal MatchValid    : std_logic;

begin

    assert isPower2(RamBlockDepth_g)
        report ""olo_base_cam - RamBlockDepth_g must be a power of 2""
        severity error;

    p_cob : process (Rd_Valid, Rd_Content, Wr_Valid, Wr_Content, Wr_Addr, Wr_Write, Wr_Clear,
                     RamRead_1, Rst, r) is
        variable v                        : TwoProcess_r;
        variable ClearMask_v, SetMask_v   : std_logic_vector(Addresses_g-1 downto 0);
        variable InRdReady_v, InWrReady_v : std_logic;
    begin
        v := r;

        if ReadPriority_g then
            InRdReady_v := '1';
            InWrReady_v := not Rd_Valid;
        else
            InWrReady_v := '1';
            InRdReady_v := not Wr_Valid;
        end if;
        if r.Write_0 = '1' or r.Clear_0 = '1' or r.ClearAll_0 = '1' then
            InWrReady_v := '0';
            if StrictOrdering_g and RamBehavior_g = ""RBW"" then
                InRdReady_v := '0';
            else
                InRdReady_v := '1';
            end if;
        end if;
        if Rst = '1' or (ClearAfterReset_g and r.RstClearDone = '0') then
            InRdReady_v := '0';
            InWrReady_v := '0';
        end if;
        Rd_Ready <= InRdReady_v;
        Wr_Ready <= InWrReady_v;

        v.Addr_0     := Wr_Addr;
        v.Write_0    := '0';
        v.Clear_0    := '0';
        v.Read_0     := '0';
        v.ClearAll_0 := '0';
        if InWrReady_v = '1' and Wr_Valid = '1' then
            v.Content_0  := Wr_Content;
            v.Write_0    := Wr_Write;
            v.Clear_0    := Wr_Clear;
            v.ClearAll_0 := Wr_ClearAll;
        elsif InRdReady_v = '1' and Rd_Valid = '1' then
            v.Content_0 := Rd_Content;
            v.Read_0    := '1';
        end if;
        if RegisterInput_g then
            ReadContent_0 <= r.Content_0;
        else
            ReadContent_0 <= v.Content_0;
        end if;

        if RegisterInput_g then
            v.ContentExtended_1                            := (others => '0');
            v.ContentExtended_1(ContentWidth_g-1 downto 0) := r.Content_0;
            v.Addr_1                                       := r.Addr_0;
            v.Write_1                                      := r.Write_0;
            v.Clear_1                                      := r.Clear_0;
            v.Read_1                                       := r.Read_0;
            v.ClearAll_1                                   := r.ClearAll_0;
        else
            v.ContentExtended_1                            := (others => '0');
            v.ContentExtended_1(ContentWidth_g-1 downto 0) := v.Content_0;
            v.Addr_1                                       := v.Addr_0;
            v.Write_1                                      := v.Write_0;
            v.Clear_1                                      := v.Clear_0;
            v.Read_1                                       := v.Read_0;
            v.ClearAll_1                                   := v.ClearAll_0;
        end if;

        v.Read_2 := r.Read_1;
        v.Match_2 := RamRead_1(0);

        for i in 1 to BlocksParallel_c-1 loop
            v.Match_2 := v.Match_2 and RamRead_1(i);
        end loop;

        ClearMask_v := (others => '1');
        SetMask_v   := (others => '0');
        if r.Write_1 = '1' then
            SetMask_v(fromUslv(to01(r.Addr_1))) := '1';
        end if;
        if r.Clear_1 = '1' then
            ClearMask_v(fromUslv(to01(r.Addr_1))) := '0';
        end if;
        if r.ClearAll_1 = '1' then
            ClearMask_v := not v.Match_2;
        end if;

        for i in 0 to BlocksParallel_c-1 loop
            RamWrite_1(i) <= (RamRead_1(i) and ClearMask_v) or SetMask_v;
        end loop;

        WrMem_1 <= r.Write_1 or r.Clear_1 or r.ClearAll_1 or r.RstClearWr;
        if RegisterMatch_g then
            MatchValid <= r.Read_2;
            MatchInt   <= r.Match_2;
        else
            MatchValid <= v.Read_2;
            MatchInt   <= v.Match_2;
        end if;

        v.RstClearWr := '0';
        if ClearAfterReset_g then
            if r.RstClearDone = '0' then
                if r.RstClearCounter = 2**BlockAddrBits_c-1 then
                    v.RstClearDone := '1';
                else
                    v.RstClearCounter := r.RstClearCounter + 1;
                end if;
            else
                v.RstClearDone := '1';
            end if;
            if r.RstClearDone = '0' then
                v.RstClearWr := '1'; -- Assignment to memory write done further up in code

                for i in 0 to BlocksParallel_c-1 loop
                    v.ContentExtended_1((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c) := std_logic_vector(r.RstClearCounter);
                end loop;

            end if;
            if r.RstClearWr = '1' then
                RamWrite_1 <= (others => (others => '0'));
            end if;
        end if;

        r_next <= v;
    end process;

    Match_Valid <= MatchValid;
    Match_Match <= MatchInt;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Write_0         <= '0';
                r.Clear_0         <= '0';
                r.ClearAll_0      <= '0';
                r.Read_0          <= '0';
                r.Write_1         <= '0';
                r.Clear_1         <= '0';
                r.ClearAll_1      <= '0';
                r.Read_1          <= '0';
                r.Read_2          <= '0';
                r.RstClearDone    <= '0';
                r.RstClearCounter <= (others => '0');
            end if;
        end if;
    end process;

    g_addr : for i in 0 to BlocksParallel_c-1 generate
        signal ContentExtended_0 : std_logic_vector(TotalAddrBits_c-1 downto 0) := (others => '0');
        signal RdAddr_0          : std_logic_vector(BlockAddrBits_c-1 downto 0);
        signal WrAddr_1          : std_logic_vector(BlockAddrBits_c-1 downto 0);
    begin
        ContentExtended_0(ContentWidth_g-1 downto 0) <= ReadContent_0;

        RdAddr_0 <= to01(ContentExtended_0((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c));
        WrAddr_1 <= to01(r.ContentExtended_1((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c));

        i_ram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => RamBlockDepth_g,
                Width_g         => Addresses_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Wr_Addr     => WrAddr_1,
                Wr_Ena      => WrMem_1,
                Wr_Data     => RamWrite_1(i),
                Rd_Addr     => RdAddr_0,
                Rd_Data     => RamRead_1(i)
            );

    end generate;

    g_addrout : if UseAddrOut_g generate

        i_addrout : entity work.olo_base_decode_firstbit
            generic map (
                InWidth_g       => Addresses_g,
                InReg_g         => false,   -- Regiser is in r
                OutReg_g        => choose(FirstBitDecLatency_g = 0, false, true),
                PlRegs_g        => choose(FirstBitDecLatency_g = 0, 0, FirstBitDecLatency_g-1)
            )
            port map (
                Clk          => Clk,
                Rst          => Rst,
                In_Data      => MatchInt,
                In_Valid     => MatchValid,
                Out_FirstBit => Addr_Addr,
                Out_Found    => Addr_Found,
                Out_Valid    => Addr_Valid
            );

    end generate;

    g_naddrout : if not UseAddrOut_g generate

        Addr_Valid <= '0';
        Addr_Found <= '0';
        Addr_Addr  <= (others => '0');

    end generate;

end architecture;"
"This component implements a clock crossing for multiple independent single-bit signals. It contains double-stage synchronizers and sets all the attributes required for proper synthesis. Note that this clock crossing does not guarantee that all bits arrive in the same clock cycle at the destination clock domain, therefore it can only be used for independent single-bit signals. Do not use it to transfer multi-bit signals (e.g. numbers) where it is important that all the bits are updated in the same clock cycle. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_bits.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing multple independent
- Plus 35 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_cc_bits

## Architecture: struct of olo_base_cc_bits

### Signals
- RegIn: std_logic_vector(Width_g - 1 downto 0) := (others => '0')
- Reg0: std_logic_vector(Width_g - 1 downto 0) := (others => '0')
- RegN: SyncStages_t                           := (others => (others => '0'))
- is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN: signal is ShregExtract_SuppressExtraction_c
- is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of Reg0: signal is SynSrlstyle_FlipFlops_c
- is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegIn: signal is SynSrlstyle_FlipFlops_c
- is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN: signal is DontMerge_SuppressChanges_c
- is DontMerge_SuppressChanges_c;

    attribute preserve of Reg0: signal is Preserve_SuppressChanges_c
- is Preserve_SuppressChanges_c;
    attribute preserve of RegIn: signal is Preserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN: signal is SynPreserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;

    attribute syn_keep of Reg0: signal is SynKeep_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegIn: signal is SynKeep_SuppressChanges_c
- is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN: signal is AsyncReg_TreatAsync_c
- is AsyncReg_TreatAsync_c;

    -- Input clock (required for automatic constraining in vivado)
    signal In_Clk_Sig: std_logic
- is DontTouch_SuppressChanges_c;
    attribute keep of In_Clk_Sig: signal is Keep_SuppressChanges_c

### Processes
- Process 'p_inff :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_outff :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_inff :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- if In_Rst = '1' then
                RegIn <= (others => '0')

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): Reset, Out_Rst, In_Rst, First
- May be part of a pipeline architecture

## Code Metrics
- Line count: 150
- Process count: 4
- Signal count: 15

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_bits.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;


entity olo_base_cc_bits is
    generic (
        Width_g      : positive              := 1;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk   : in    std_logic;
        In_Rst   : in    std_logic := '0';
        In_Data  : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk  : in    std_logic;
        Out_Rst  : in    std_logic := '0';
        Out_Data : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;


architecture struct of olo_base_cc_bits is

    type SyncStages_t is array(0 to SyncStages_g - 2) of std_logic_vector(Width_g - 1 downto 0);

    signal RegIn : std_logic_vector(Width_g - 1 downto 0) := (others => '0');
    signal Reg0  : std_logic_vector(Width_g - 1 downto 0) := (others => '0');
    signal RegN  : SyncStages_t                           := (others => (others => '0'));

    attribute shreg_extract of Reg0  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegIn : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of Reg0  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegN  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegIn : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of Reg0  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegIn : signal is DontMerge_SuppressChanges_c;

    attribute preserve of Reg0  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegN  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegIn : signal is Preserve_SuppressChanges_c;

    attribute syn_preserve of Reg0  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegIn : signal is SynPreserve_SuppressChanges_c;

    attribute syn_keep of Reg0  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegN  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegIn : signal is SynKeep_SuppressChanges_c;

    attribute async_reg of Reg0  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegIn : signal is AsyncReg_TreatAsync_c;

    signal In_Clk_Sig : std_logic;

    attribute dont_touch of In_Clk_Sig : signal is DontTouch_SuppressChanges_c;
    attribute keep of In_Clk_Sig       : signal is Keep_SuppressChanges_c;

begin

    In_Clk_Sig <= In_Clk;

    p_inff : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            RegIn <= In_Data;
            if In_Rst = '1' then
                RegIn <= (others => '0');
            end if;
        end if;
    end process;

    p_outff : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            Reg0    <= RegIn;
            RegN(0) <= Reg0;

            for i in 1 to RegN'high loop
                RegN(i) <= RegN(i - 1);
            end loop;

            if Out_Rst = '1' then
                Reg0 <= (others => '0');
                RegN <= (others => (others => '0'));
            end if;
        end if;
    end process;

    Out_Data <= RegN(RegN'high);

end architecture;
"
"This component implements a clock crossing with AXI-S handshaking for transferring data from one clock domain to another one that runs at a potentially completely asynchronous clock It can for example be used to transfer data from a 100 MHz clock domain to a 55.32 MHz clock domain. This component implements full AXI-S handshaking but is not made for high performance. It can transfer one data-word every _(2 + SyncStages_g) x InputClockPeriods + (2 + SyncStages_g) x OutputClockPeriods_ . Whenever distributed RAM can be used (i.e. LUTs can be used as small RAMs), [olo_base_fifo_async](./olo_base_fifo_async.md) is to be preferred over this entity. For small FIFO depths, it is more resource efficient. Hence _olo_base_cc_handshake_ shall only be used in cases where distributed RAM is not an option (e.g. because it is in not supported by the target technology or because the design is short the related LUT resources). This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_handshake.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing of data with the
- commonly used Valid/Ready handshake.
- Plus 28 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: may override the clause above
            if In_Valid = '1' and In_ReadyI = '1' then
                InLatched <= '1'

## Entity: olo_base_cc_handshake

## Architecture: rtl of olo_base_cc_handshake

### Signals
- RstInI: std_logic
- In_ReadyI: std_logic
- InLatched: std_logic := '0'
- InTransaction: std_logic
- InAck: std_logic
- RstOutI: std_logic
- OutTransaction: std_logic
- OutLatched: std_logic := '0'
- OutAck: std_logic
- Out_ValidI: std_logic

### Component Instantiations
- Instance 'i_scc' of component 'olo_base_cc_simple'
- Instance 'i_bcc' of component 'olo_base_cc_pulse'

### Processes
- Process 'p_in :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_out :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_in :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_out :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): ReadyRstState_g, Reset, reset, In_RstOut, Out_RstIn, In_RstIn, RstInI, RstOutI, Out_RstOut

## Code Metrics
- Line count: 163
- Process count: 4
- Signal count: 10

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_handshake.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_handshake is
    generic (
        Width_g         : positive;
        ReadyRstState_g : std_logic             := '1';
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1'
    );
end entity;

architecture rtl of olo_base_cc_handshake is

    signal RstInI        : std_logic;
    signal In_ReadyI     : std_logic;
    signal InLatched     : std_logic := '0';
    signal InTransaction : std_logic;
    signal InAck         : std_logic;

    signal RstOutI        : std_logic;
    signal OutTransaction : std_logic;
    signal OutLatched     : std_logic := '0';
    signal OutAck         : std_logic;
    signal Out_ValidI     : std_logic;

begin

    p_in : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then

            if InAck = '1' then
                InLatched <= '0';
            end if;

            if In_Valid = '1' and In_ReadyI = '1' then
                InLatched <= '1';
            end if;

            if RstInI = '1' then
                InLatched <= '0';
            end if;
        end if;
    end process;

    In_ReadyI     <= (not InLatched) or InAck when ReadyRstState_g = '1' else
                     ((not InLatched) or InAck) and (not RstInI); -- Actively pull Ready low during reset if required
    InTransaction <= In_Valid and In_ReadyI;
    In_Ready      <= In_ReadyI;

    i_scc : entity work.olo_base_cc_simple
        generic map (
            Width_g      => Width_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => In_Clk,
            In_RstIn    => In_RstIn,
            In_RstOut   => RstInI,
            In_Data     => In_Data,
            In_Valid    => InTransaction,
            Out_Clk     => Out_Clk,
            Out_RstIn   => Out_RstIn,
            Out_RstOut  => RstOutI,
            Out_Data    => Out_Data,
            Out_Valid   => OutTransaction
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    i_bcc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk          => Out_Clk,
            In_RstIn        => RstOutI,
            In_Pulse(0)     => OutAck,
            Out_Clk         => In_Clk,
            Out_RstIn       => RstInI,
            Out_Pulse(0)    => InAck
        );

    p_out : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then

            if OutTransaction = '1' and Out_Ready = '0' then
                OutLatched <= '1';
            elsif Out_Ready = '1' then
                OutLatched <= '0';
            end if;

            if RstOutI = '1' then
                OutLatched <= '0';
            end if;
        end if;
    end process;

    Out_ValidI <= OutTransaction or OutLatched;
    OutAck     <= Out_ValidI and Out_Ready;
    Out_Valid  <= Out_ValidI;

end architecture;"
"This component implements a clock crossing with AXI-S handshaking for transferring data from one clock domain to another one that runs at an integer multiple of the frequency of the input clock frequency. It can for example be used to transfer data from a 50 MHz clock domain to a 100 MHz clock domain (both generated by the same PLL). Note that the two clocks must be phase aligned. Note that the clock crossing **does not work if the two clocks have the same frequency**. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_n2xn.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a clock crossing between two synchronous clocks where
- Plus 19 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all

## Entity: olo_base_cc_n2xn

## Architecture: rtl of olo_base_cc_n2xn

### Signals
- InRstInt: std_logic
- InDataReg: std_logic_vector(Width_g - 1 downto 0)
- InToggle: std_logic
- OutRstInt: std_logic
- OutDataReg: std_logic_vector(Width_g - 1 downto 0)
- OutDataVld: std_logic
- OutToggle: std_logic

### Component Instantiations
- Instance 'i_rst_cc' of component 'olo_base_cc_reset'

### Processes
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- InToggle  <= not InToggle

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, i_rst_cc, olo_base_cc_reset, A_RstIn, B_RstOut, Reset, In_RstOut, Out_RstIn, In_RstIn, A_RstOut, Out_RstOut, InRstInt, OutRstInt

## Code Metrics
- Line count: 125
- Process count: 4
- Signal count: 7

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_n2xn.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_cc_n2xn is
    generic (
        Width_g       : positive := 8
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_n2xn is

    signal InRstInt  : std_logic;
    signal InDataReg : std_logic_vector(Width_g - 1 downto 0);
    signal InToggle  : std_logic;

    signal OutRstInt  : std_logic;
    signal OutDataReg : std_logic_vector(Width_g - 1 downto 0);
    signal OutDataVld : std_logic;
    signal OutToggle  : std_logic;

begin

    In_Ready <= '1' when (InToggle = OutToggle) and (InRstInt = '0') else '0';

    p_input : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' and (InToggle = OutToggle) then
                InDataReg <= In_Data;
                InToggle  <= not InToggle;
            end if;
            if InRstInt = '1' then
                InToggle <= '0';
            end if;
        end if;
    end process;

    p_output : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then

            if (OutDataVld = '1' and Out_Ready = '1') then
                OutDataVld <= '0';
            end if;

            if (InToggle /= OutToggle)  and (OutDataVld = '0' or Out_Ready = '1') then
                OutDataReg <= InDataReg;
                OutDataVld <= '1';
                OutToggle  <= InToggle;
            end if;

            if OutRstInt = '1' then
                OutDataVld <= '0';
                OutToggle  <= '0';
            end if;
        end if;
    end process;

    Out_Data  <= OutDataReg;
    Out_Valid <= OutDataVld;

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_RstIn,
            A_RstOut    => InRstInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_RstIn,
            B_RstOut    => OutRstInt
        );

    In_RstOut  <= InRstInt;
    Out_RstOut <= OutRstInt;

end architecture;"
"This component implements a clock crossing for transferring single pulses from one clock domain to another (completely asynchronous clocks). The entity shall only be used for single-cycle pulses and the pulse frequency must be lower than twice the frequency of the slower clock for it to work correctly. The entity does only guarantee that all pulses arrive at the destination clock domain. It does not guarantee that pulses that occur in the same clock cycle on the source clock domain, occur on the target clock domain in the same clock cycle. As a result it should only be used to do clock-crossings for individual pulses. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_pulse.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing pulses from one clock
- Plus 27 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: register is in olo_base_cc_bits
    ToggleIn <= ToggleLast xor In_Pulse

## Entity: olo_base_cc_pulse

## Architecture: rtl of olo_base_cc_pulse

### Signals
- RstInI: std_logic
- RstOutI: std_logic
- ToggleIn: std_logic_vector(NumPulses_g - 1 downto 0)
- ToggleLast: std_logic_vector(NumPulses_g - 1 downto 0)
- ToggleOut: std_logic_vector(NumPulses_g - 1 downto 0)
- ToggleOutLast: std_logic_vector(NumPulses_g - 1 downto 0)

### Component Instantiations
- Instance 'i_rst' of component 'olo_base_cc_reset'
- Instance 'i_sync' of component 'olo_base_cc_bits'

### Processes
- Process 'p_reg :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_pulseout :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_reg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_pulseout :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- if RstInI = '1' then
                ToggleLast <= (others => '0')

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, olo_base_cc_reset, A_RstIn, Reset, In_RstOut, Out_RstIn, In_RstIn, RstInI, RstOutI, A_RstOut, i_rst, In_Rst, Out_RstOut, Resets, Out_Rst, B_RstOut
- May be part of a pipeline architecture

## Code Metrics
- Line count: 131
- Process count: 4
- Signal count: 6

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_pulse.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_pulse is
    generic (
        NumPulses_g     : positive              := 1;
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk          : in    std_logic;
        In_RstIn        : in    std_logic := '0';
        In_RstOut       : out   std_logic;
        In_Pulse        : in    std_logic_vector(NumPulses_g - 1 downto 0);
        Out_Clk         : in    std_logic;
        Out_RstIn       : in    std_logic := '0';
        Out_RstOut      : out   std_logic;
        Out_Pulse       : out   std_logic_vector(NumPulses_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_pulse is

    type Pulse_t is array (natural range <>) of std_logic_vector(NumPulses_g - 1 downto 0);

    signal RstInI  : std_logic;
    signal RstOutI : std_logic;

    signal ToggleIn      : std_logic_vector(NumPulses_g - 1 downto 0);
    signal ToggleLast    : std_logic_vector(NumPulses_g - 1 downto 0);
    signal ToggleOut     : std_logic_vector(NumPulses_g - 1 downto 0);
    signal ToggleOutLast : std_logic_vector(NumPulses_g - 1 downto 0);

begin

    i_rst : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_RstIn,
            A_RstOut    => RstInI,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_RstIn,
            B_RstOut    => RstOutI
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    p_reg : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            ToggleLast <= ToggleIn;
            if RstInI = '1' then
                ToggleLast <= (others => '0');
            end if;
        end if;
    end process;

    ToggleIn <= ToggleLast xor In_Pulse;

    i_sync : entity work.olo_base_cc_bits
        generic map (
            Width_g      => NumPulses_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => In_Clk,
            In_Rst   => RstInI,
            In_Data  => ToggleIn,
            Out_Clk  => Out_Clk,
            Out_Rst  => RstOutI,
            Out_Data => ToggleOut
        );

    Out_Pulse <= ToggleOutLast xor ToggleOut;

    p_pulseout : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            ToggleOutLast <= ToggleOut;

            if RstOutI = '1' then
                ToggleOutLast <= (others => '0');
            end if;
        end if;
    end process;

end architecture;"
"This component synchronizes reset inputs from two clock domains in both directions. Whenever a reset is received on one clock domain, it produces reset outputs on both clock domains and ensures that both reset outputs are asserted at the same time for at least one clock cycle before they are released again. This type of reset synchronization is required in many clock crossings. Usually both sides of the clock crossing must be reset at the same time to avoid unwanted behavior in corner conditions around resets. When using the block, you should connect any reset request signals to _A/B_RstIn_ and reset your logic with the outputs _A/B_RstOut_. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_reset.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows to clock-cross resets. It
- Plus 32 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_cc_reset

## Architecture: struct of olo_base_cc_reset

### Signals
- RstALatch: std_logic                    := '1'
- RstRqstB2A: std_logic_vector(2 downto 0) := (others => '0')
- RstAckB2A: std_logic
- RstBLatch: std_logic                    := '1'
- RstRqstA2B: std_logic_vector(2 downto 0) := (others => '0')
- RstAckA2B: std_logic
- is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckB2A: signal is ShregExtract_SuppressExtraction_c
- is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckA2B: signal is ShregExtract_SuppressExtraction_c
- is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckB2A: signal is SynSrlstyle_FlipFlops_c
- is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckA2B: signal is SynSrlstyle_FlipFlops_c
- is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckB2A: signal is DontMerge_SuppressChanges_c
- is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckA2B: signal is DontMerge_SuppressChanges_c
- is Preserve_SuppressChanges_c;
    attribute preserve of RstAckB2A: signal is Preserve_SuppressChanges_c
- is Preserve_SuppressChanges_c;
    attribute preserve of RstAckA2B: signal is Preserve_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckB2A: signal is SynKeep_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckA2B: signal is SynKeep_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckB2A: signal is SynPreserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckA2B: signal is SynPreserve_SuppressChanges_c
- is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckB2A: signal is AsyncReg_TreatAsync_c
- is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckA2B: signal is AsyncReg_TreatAsync_c

### Component Instantiations
- Instance 'i_ackb2a' of component 'olo_base_cc_bits'
- Instance 'i_acka2b' of component 'olo_base_cc_bits'

### Processes
- Process 'p_a_rst_sync :' (Clocked) (Has Reset) with sensitivity list: A_Clk, RstBLatch
  - Implements synchronous logic
- Process 'p_a_rst :' (Clocked) (Has Reset) with sensitivity list: A_Clk
  - Implements synchronous logic with reset
- Process 'p_b_rst_sync :' (Clocked) (Has Reset) with sensitivity list: B_Clk, RstALatch
  - Implements synchronous logic
- Process 'p_b_rst :' (Clocked) (Has Reset) with sensitivity list: B_Clk
  - Implements synchronous logic with reset
- Process 'p_a_rst_sync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_a_rst :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_b_rst_sync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_b_rst :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- elsif rising_edge(A_Clk) then
            RstRqstB2A <= RstRqstB2A(RstRqstB2A'left - 1 downto 0) & '0'

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, A_RstIn, RstBLatch, In_Rst, B_RstOut, resets, RstAckB2A, RstRqstB2A, A_RstOut, p_b_rst, p_a_rst, RstALatch, p_a_rst_sync, reset, olo_base_cc_reset, p_b_rst_sync, RstAckA2B, Out_Rst, RstRqstA2B

## Code Metrics
- Line count: 190
- Process count: 8
- Signal count: 20

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_reset.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_base_cc_reset is
    generic (
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        A_Clk       : in    std_logic;
        A_RstIn     : in    std_logic := '0';
        A_RstOut    : out   std_logic;
        B_Clk       : in    std_logic;
        B_RstIn     : in    std_logic := '0';
        B_RstOut    : out   std_logic
    );
end entity;

architecture struct of olo_base_cc_reset is

    signal RstALatch  : std_logic                    := '1';
    signal RstRqstB2A : std_logic_vector(2 downto 0) := (others => '0');
    signal RstAckB2A  : std_logic;

    signal RstBLatch  : std_logic                    := '1';
    signal RstRqstA2B : std_logic_vector(2 downto 0) := (others => '0');
    signal RstAckA2B  : std_logic;

    attribute shreg_extract of RstRqstB2A : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckB2A  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstRqstA2B : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckA2B  : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of RstRqstB2A : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckB2A  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstRqstA2B : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckA2B  : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of RstRqstB2A : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckB2A  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstRqstA2B : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckA2B  : signal is DontMerge_SuppressChanges_c;

    attribute preserve of RstRqstB2A : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstAckB2A  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstRqstA2B : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstAckA2B  : signal is Preserve_SuppressChanges_c;

    attribute syn_keep of RstRqstB2A : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckB2A  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstRqstA2B : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckA2B  : signal is SynKeep_SuppressChanges_c;

    attribute syn_preserve of RstRqstB2A : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckB2A  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstRqstA2B : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckA2B  : signal is SynPreserve_SuppressChanges_c;

    attribute async_reg of RstRqstB2A : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckB2A  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstRqstA2B : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckA2B  : signal is AsyncReg_TreatAsync_c;

begin

    p_a_rst_sync : process (A_Clk, RstBLatch) is
    begin
        if RstBLatch = '1' then
            RstRqstB2A <= (others => '1');
        elsif rising_edge(A_Clk) then
            RstRqstB2A <= RstRqstB2A(RstRqstB2A'left - 1 downto 0) & '0';
        end if;
    end process;

    p_a_rst : process (A_Clk) is
    begin
        if rising_edge(A_Clk) then
            if A_RstIn = '1' then
                RstALatch <= '1';
            elsif RstAckB2A = '1' then
                RstALatch <= '0';
            end if;
        end if;
    end process;

    A_RstOut <= RstALatch or RstRqstB2A(RstRqstB2A'left);

    p_b_rst_sync : process (B_Clk, RstALatch) is
    begin
        if RstALatch = '1' then
            RstRqstA2B <= (others => '1');
        elsif rising_edge(B_Clk) then
            RstRqstA2B <= RstRqstA2B(RstRqstA2B'left - 1 downto 0) & '0';
        end if;
    end process;

    p_b_rst : process (B_Clk) is
    begin
        if rising_edge(B_Clk) then
            if B_RstIn = '1' then
                RstBLatch <= '1';
            elsif RstAckA2B = '1' then
                RstBLatch <= '0';
            end if;
        end if;
    end process;

    B_RstOut <= RstBLatch or RstRqstA2B(RstRqstA2B'left);

    i_ackb2a : entity work.olo_base_cc_bits
        generic map (
            Width_g      => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => B_Clk,
            In_Rst      => '0',
            In_Data(0)  => RstRqstA2B(RstRqstA2B'left),
            Out_Clk     => A_Clk,
            Out_Rst     => '0',
            Out_Data(0) => RstAckB2A
        );

    i_acka2b : entity work.olo_base_cc_bits
        generic map (
            Width_g      => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => A_Clk,
            In_Rst      => '0',
            In_Data(0)  => RstRqstB2A(RstRqstA2B'left),
            Out_Clk     => B_Clk,
            Out_Rst     => '0',
            Out_Data(0) => RstAckA2B
        );

end architecture;"
"This component implements a clock crossing for transferring single values from one clock domain to another (completely asynchronous clocks). In both clock domains the valid samples are marked with a Valid signal according to the AXI-S specification but back-pressure (Ready) is not handled. **For the entity to work correctly, the data-rate must be significantly lower ( (_3+SyncStages_g_ x lower) than the slower clock frequency.** This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_simple.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing single samples of data
- Plus 22 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_cc_simple

## Architecture: struct of olo_base_cc_simple

### Signals
- RstInI: std_logic
- DataLatchIn: std_logic_vector(Width_g - 1 downto 0)
- RstOutI: std_logic
- VldOutI: std_logic
- Out_Data_Sig: std_logic_vector(Width_g - 1 downto 0)
- is DontTouch_SuppressChanges_c;
    attribute keep of Out_Data_Sig: signal is Keep_SuppressChanges_c

### Component Instantiations
- Instance 'i_pulse_cc' of component 'olo_base_cc_pulse'

### Processes
- Process 'p_data_a :' (Clocked) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_data_b :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_data_a :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_data_b :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): Reset, In_RstOut, Out_RstIn, In_RstIn, RstInI, RstOutI, Out_RstOut

## Code Metrics
- Line count: 121
- Process count: 4
- Signal count: 6

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_simple.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_base_cc_simple is
    generic (
        Width_g      : positive              := 1;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid    : in    std_logic;
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic
    );
end entity;

architecture struct of olo_base_cc_simple is

    signal RstInI      : std_logic;
    signal DataLatchIn : std_logic_vector(Width_g - 1 downto 0);
    signal RstOutI     : std_logic;
    signal VldOutI     : std_logic;

    signal Out_Data_Sig : std_logic_vector(Width_g - 1 downto 0);

    attribute dont_touch of Out_Data_Sig : signal is DontTouch_SuppressChanges_c;
    attribute keep of Out_Data_Sig       : signal is Keep_SuppressChanges_c;

begin

    i_pulse_cc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk       => In_Clk,
            In_RstIn     => In_RstIn,
            In_RstOut    => RstInI,
            In_Pulse(0)  => In_Valid,
            Out_Clk      => Out_Clk,
            Out_RstIn    => Out_RstIn,
            Out_RstOut   => RstOutI,
            Out_Pulse(0) => VldOutI
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    p_data_a : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' then
                DataLatchIn <= In_Data;
            end if;
        end if;
    end process;

    p_data_b : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            Out_Valid <= VldOutI;
            if VldOutI = '1' then
                Out_Data_Sig <= DataLatchIn;
            end if;
            if RstOutI = '1' then
                Out_Valid <= '0';
            end if;
        end if;
    end process;

    Out_Data <= Out_Data_Sig;

end architecture;"
"This component implements a clock crossing for slowly changing status information that does not have exact sample rates. It can for example be used to  transfer a buffer fill level from one clock domain to another with minimal effort and without knowing anything about the frequencies of the two clocks (e.g. without knowing which one runs faster). The entity ensures that data from the source clock domain is correctly transferred to the destination clock domain. The value at the destination clock domain is always correct in terms of ""the exact same value was present on the input clock domain in one clock-cycle"". The exact timing of the sampling points at which the data is transferred is generated by the entity itself, so it is unknown to the user. As a result, the entity does not guarantee to show transient states of the data signal in the source clock domain to the destination clock domain in cases of fast changing signals. For the entity to work correctly, the data-rate must be significantly lower (_6 + 2 * SyncStages_g_ x lower) than the slower clock frequency. Of course the signal can change more quickly but the clock crossing will skip some values in this case. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_status.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing of static-data
- Plus 26 more comments

## Libraries and Packages
- Library: ieee
- Use: cause of this entity is to pass status information or configuration
-- register values between clock domains.
--
-- Documentation:
-- https://github.com/open-logic/open-logic/blob/main/doc/base/olo_base_cc_status.md
--
-- Note: The link points to the documentation of the latest release. If you
--       use an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: olo_base_cc_status

## Architecture: rtl of olo_base_cc_status

### Signals
- RstInI: std_logic
- Started: std_logic := '0'
- RstOutI_Sync: std_logic_vector(1 downto 0)
- VldIn: std_logic
- VldFb: std_logic
- RstOutI: std_logic
- VldOut: std_logic

### Component Instantiations
- Instance 'i_scc' of component 'olo_base_cc_simple'
- Instance 'i_bcc' of component 'olo_base_cc_pulse'

### Processes
- Process 'p_vldgen :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_vldgen :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): first, Reset, In_RstOut, RstOutI_Sync, Out_RstIn, In_RstIn, RstInI, RstOutI, Out_RstOut

## Code Metrics
- Line count: 129
- Process count: 2
- Signal count: 7

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_status.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_status is
    generic (
        Width_g      : positive;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic;
        Out_RstOut  : out   std_logic := '0';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_status is

    signal RstInI       : std_logic;
    signal Started      : std_logic := '0';
    signal RstOutI_Sync : std_logic_vector(1 downto 0);
    signal VldIn        : std_logic;
    signal VldFb        : std_logic;

    signal RstOutI : std_logic;
    signal VldOut  : std_logic;

begin

    p_vldgen : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            VldIn <= VldFb;

            if (Started = '0') then
                VldIn   <= '1';
                Started <= '1';
            end if;

            if RstInI = '1' then
                RstOutI_Sync <= (others => '1');
                Started      <= '0';
                VldIn        <= '0';
            end if;
        end if;
    end process;

    i_scc : entity work.olo_base_cc_simple
        generic map (
            Width_g      => Width_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => In_Clk,
            In_RstIn    => In_RstIn,
            In_RstOut   => RstInI,
            In_Data     => In_Data,
            In_Valid    => VldIn,
            Out_Clk     => Out_Clk,
            Out_RstIn   => Out_RstIn,
            Out_RstOut  => RstOutI,
            Out_Data    => Out_Data,
            Out_Valid   => VldOut
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    i_bcc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk          => Out_Clk,
            In_RstIn        => RstOutI,
            In_Pulse(0)     => VldOut,
            Out_Clk         => In_Clk,
            Out_RstIn       => RstInI,
            Out_Pulse(0)    => VldFb
        );

end architecture;"
"This component implements a clock crossing with AXI-S handshaking for transferring data from one clock domain to another one that runs at an integer fraction of the frequency of the input clock frequency. It can for example be used to transfer data from a 100 MHz clock domain to a 50 MHz clock domain (both generated by the same PLL). Note that the two clocks must be phase aligned. Note that the clock crossing **does not work if the two clocks have the same frequency**. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_xn2n.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a clock crossing between two synchronous clocks where
- Plus 18 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all

## Entity: olo_base_cc_xn2n

## Architecture: rtl of olo_base_cc_xn2n

### Signals
- InCnt: unsigned(1 downto 0)
- InRstInt: std_logic
- InDataReg: std_logic_vector(Width_g - 1 downto 0)
- InDataRegLast: std_logic_vector(Width_g - 1 downto 0)
- OutCnt: unsigned(1 downto 0)
- OutRstInt: std_logic
- OutIn_Valid: std_logic

### Component Instantiations
- Instance 'i_rst_cc' of component 'olo_base_cc_reset'

### Processes
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- InDataReg     <= In_Data
- InDataRegLast <= InDataReg

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, i_rst_cc, olo_base_cc_reset, A_RstIn, B_RstOut, Reset, In_RstOut, Out_RstIn, In_RstIn, A_RstOut, Out_RstOut, InRstInt, OutRstInt

## Code Metrics
- Line count: 125
- Process count: 4
- Signal count: 7

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_xn2n.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_cc_xn2n is
    generic (
        Width_g       : positive
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic;
        In_RstOut   : out   std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_xn2n is

    signal InCnt         : unsigned(1 downto 0);
    signal InRstInt      : std_logic;
    signal InDataReg     : std_logic_vector(Width_g - 1 downto 0);
    signal InDataRegLast : std_logic_vector(Width_g - 1 downto 0);

    signal OutCnt      : unsigned(1 downto 0);
    signal OutRstInt   : std_logic;
    signal OutIn_Valid : std_logic;

begin

    In_Ready <= '1' when (InCnt - OutCnt /= 2) and (InRstInt = '0') else '0';

    p_input : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' and InCnt - OutCnt /= 2 then
                InCnt         <= InCnt + 1;
                InDataReg     <= In_Data;
                InDataRegLast <= InDataReg;
            end if;
            if InRstInt = '1' then
                InCnt <= (others => '0');
            end if;
        end if;
    end process;

    p_output : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            if OutIn_Valid = '1' and Out_Ready = '1' then
                OutIn_Valid <= '0';
            end if;
            if InCnt /= OutCnt and (OutIn_Valid = '0' or Out_Ready = '1') then
                if InCnt - OutCnt = 1 then
                    Out_Data <= InDataReg;
                else
                    Out_Data <= InDataRegLast;
                end if;
                OutIn_Valid <= '1';
                OutCnt      <= OutCnt + 1;
            end if;
            if OutRstInt = '1' then
                OutCnt      <= (others => '0');
                OutIn_Valid <= '0';
            end if;
        end if;
    end process;

    Out_Valid <= OutIn_Valid;

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_RstIn,
            A_RstOut    => InRstInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_RstIn,
            B_RstOut    => OutRstInt
        );

    In_RstOut  <= InRstInt;
    Out_RstOut <= OutRstInt;

end architecture;"
"This component is a CRC checksum generator. It can be used to generate CRC checksums to send together with data (TX side) or to calculate the CRC checksum of received data and compare it to the CRC received (RX side). _olo_base_crc_ can take one input data word per clock cycle. One CRC is produced per packet - the _Out_Valid_ signal is presented to the output after _In_Last_ was received. Although _Out_Valid_ is asserted only upon the _In_Last_ being received, the output _Out_Crc_ is updated exactly one clock cycle after an input word being received. This allows for special applications where the CRC has to be checked after every data-word. The component is highly configurable in order to allow calculating CRC checksums for all known standard protocols without any external logic. Regarding the notation of parametrization, the website [crccalc.com](https://crccalc.com) is taken as reference. On this website many commonly used CRCs are listed.

# VHDL Analysis for 'olo_base_crc.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description:
- -------------------------------------------------------------------------------------------------
- A CRC generator based on a linear-feedback shifter register. Can be used to generate CRCs to add
- on TX side or to calculate CRCs to compare to received CRC on RX side.
- Plus 33 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.std_logic_misc.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_logic.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_crc

## Architecture: rtl of olo_base_crc

### Signals
- LfsrReg: std_logic_vector(CrcWidth_g-1 downto 0)
- Out_Valid_I: std_logic
- In_Ready_I: std_logic

### Processes
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- if BitOrder_g = ""MSB_FIRST"" then
                if ByteOrder_g = ""LSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v)

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): In_First, MSB_FIRST, first, Reset, Rst, First, LSB_FIRST
- Implements arithmetic/computational functionality
- Implements control logic

## Code Metrics
- Line count: 171
- Process count: 2
- Signal count: 3

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_crc.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_math.all;

entity olo_base_crc is
    generic (
        CrcWidth_g      : positive range 2 to natural'high;
        DataWidth_g     : positive;
        Polynomial_g    : natural;  -- according to https://crccalc.com/?crc=01&method=CRC-8&datatype=hex&outtype=bin
        InitialValue_g  : natural := 0;
        BitOrder_g      : string  := ""MSB_FIRST""; -- ""MSB_FIRST"" or ""LSB_FIRST""
        ByteOrder_g     : string  := ""NONE"";      -- ""NONE"", ""MSB_FIRST"" or ""LSB_FIRST""
        BitflipOutput_g : boolean := false;
        XorOutput_g     : natural := 0
    );
    port (
        Clk              : in    std_logic;
        Rst              : in    std_logic;
        In_Data          : in    std_logic_vector(DataWidth_g-1 downto 0);
        In_Valid         : in    std_logic := '1';
        In_Ready         : out   std_logic;
        In_Last          : in    std_logic := '0';
        In_First         : in    std_logic := '0';
        Out_Crc          : out   std_logic_vector(CrcWidth_g-1 downto 0);
        Out_Valid        : out   std_logic;
        Out_Ready        : in    std_logic := '1'
    );
end entity;


architecture rtl of olo_base_crc is

    constant Polynomial_c   : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(Polynomial_g, CrcWidth_g);
    constant InitialValue_c : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(InitialValue_g, CrcWidth_g);
    constant XorOutput_c    : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(XorOutput_g, CrcWidth_g);

    signal LfsrReg     : std_logic_vector(CrcWidth_g-1 downto 0);
    signal Out_Valid_I : std_logic;
    signal In_Ready_I  : std_logic;

begin

    assert BitOrder_g = ""MSB_FIRST"" or BitOrder_g = ""LSB_FIRST""
        report ""###ERROR###: olo_base_crc - Illegal value for BitOrder_g""
        severity error;
    assert ByteOrder_g = ""NONE"" or ByteOrder_g = ""LSB_FIRST"" or ByteOrder_g = ""MSB_FIRST""
        report ""###ERROR###: olo_base_crc - Illegal value for ByteOrder_g""
        severity error;
    assert ByteOrder_g = ""NONE"" or DataWidth_g mod 8 = 0
        report ""###ERROR###: olo_base_crc - For DataWidth_g not being a multiple of 8, only ByteOrder_g=NONE is allowed""
        severity error;

    p_lfsr : process (Clk) is
        variable Input_v : std_logic_vector(In_Data'range);
        variable Lfsr_v  : std_logic_vector(LfsrReg'range);
        variable InBit_v : std_logic;
        variable Out_v   : std_logic_vector(CrcWidth_g-1 downto 0);
    begin
        if rising_edge(Clk) then
            Input_v := In_Data;
            if BitOrder_g = ""MSB_FIRST"" then
                if ByteOrder_g = ""LSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v);
                end if;
            else
                if ByteOrder_g = ""MSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v);
                end if;
                Input_v := invertBitOrder(Input_v);
            end if;

            if Out_Valid_I = '1' and Out_Ready = '1' then
                Out_Valid_I <= '0';
            end if;

            if In_Valid = '1' and In_Ready_I = '1' then
                if In_First = '1' then
                    Lfsr_v := InitialValue_c;
                else
                    Lfsr_v := LfsrReg;
                end if;

                for bit in DataWidth_g-1 downto 0 loop

                    InBit_v := Input_v(bit) xor Lfsr_v(Lfsr_v'high);

                    Lfsr_v := Lfsr_v(Lfsr_v'high-1 downto 0) & '0';
                    if InBit_v = '1' then
                        Lfsr_v := Lfsr_v xor Polynomial_c;
                    end if;

                end loop;

                Out_v := Lfsr_v;
                if BitflipOutput_g then
                    Out_v := invertBitOrder(Out_v);
                end if;
                Out_Crc <= Out_v xor XorOutput_c;

                if In_Last = '1' then
                    Lfsr_v      := InitialValue_c;
                    Out_Valid_I <= '1';
                end if;
                LfsrReg <= Lfsr_v;
            end if;

            if Rst = '1' then
                LfsrReg     <= InitialValue_c;
                Out_Crc     <= (others => '0');
                Out_Valid_I <= '0';
            end if;

        end if;
    end process;

    In_Ready_I <= Out_Ready or not Out_Valid_I;

    Out_Valid <= Out_Valid_I;
    In_Ready  <= In_Ready_I;

end architecture;"
"This entity implements a first-bit decoder. It does return the index of the lowest bit set in a vector. First bit decoding can be done in only a few lines of code if all the decoding is done in one clock cycles. However, for doing first-bit decoding on very wide vectors this leads to poor timing performance. In this case using _olo_base_decode_firstbit_ makes sense - because it allows pipelining the operation. The figure below assumes _InReg_g=false_, _OutReg_g=false_ and _PlRegs_g=2_.

# VHDL Analysis for 'olo_base_decode_firstbit.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a pipelined first bit decoder. It finds out which
- is the lowest index of a bit set in the input vecotr.
- Plus 50 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_decode_firstbit

## Architecture: rtl of olo_base_decode_firstbit

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
        r_next <= v;
    end process;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Data, In_Valid
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Optional Input Register ***
        DataIn_v := (others => '0')
- if InReg_g then
            v.DataIn                       := In_Data
- v.ValidIn                      := In_Valid
- InValid_v                      := r.ValidIn
- DataIn_v(InWidth_g-1 downto 0) := r.DataIn
- Plus 2 more statements

## Functional Analysis

- Contains 2 clock domain(s): Clk, Clock
- Uses reset signal(s): FirstBit, first, Reset, Rst, lowerst, First, Out_FirstBit, olo_base_decode_firstbit
- May be part of a pipeline architecture

## Code Metrics
- Line count: 243
- Process count: 4
- Signal count: 3

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_decode_firstbit.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_decode_firstbit is
    generic (
        InWidth_g       : positive;
        InReg_g         : boolean := true;
        OutReg_g        : boolean := true;
        PlRegs_g        : natural := 1
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;

        In_Data         : in    std_logic_vector(InWidth_g-1 downto 0);
        In_Valid        : in    std_logic := '1';

        Out_FirstBit    : out   std_logic_vector(log2ceil(InWidth_g)-1 downto 0);
        Out_Found       : out   std_logic;
        Out_Valid       : out   std_logic
    );
end entity;

architecture rtl of olo_base_decode_firstbit is

    constant Stages_c         : natural := PlRegs_g+1;
    constant BinBits_c        : natural := log2ceil(InWidth_g);
    constant InWidthPow2_c    : natural := 2**BinBits_c;
    constant AddrBitsStageN_c : natural := BinBits_c/Stages_c;
    constant AddrBitsStage1_c : natural := BinBits_c - AddrBitsStageN_c*(Stages_c-1);
    constant ParallelStage1_c : natural := InWidthPow2_c/2**AddrBitsStage1_c;

    type BinStage_t is array (0 to ParallelStage1_c-1) of std_logic_vector(BinBits_c-1 downto 0);
    type BinAll_t is array(0 to Stages_c-1) of BinStage_t;
    type Found_t is array(0 to Stages_c-1) of std_logic_vector(ParallelStage1_c-1 downto 0);

    type TwoProcess_r is record
        DataIn   : std_logic_vector(In_Data'range);
        ValidIn  : std_logic;
        Addr     : BinAll_t;
        Found    : Found_t;
        Valid    : std_logic_vector(Stages_c-1 downto 0);
        FirstBit : std_logic_vector(Out_FirstBit'range);
        FoundOut : std_logic;
        ValidOut : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert PlRegs_g < BinBits_c/2
        report ""olo_base_decode_firstbit - PlRegs_g must be smaller than ceil(log2(InWidth_g))/2""
        severity error;

    p_comb : process (r, In_Data, In_Valid) is
        variable v                : TwoProcess_r;
        variable DataIn_v         : std_logic_vector(2**BinBits_c-1 downto 0);
        variable InValid_v        : std_logic;
        variable AddrBits_v       : natural;
        variable AddrLowIdx_v     : natural;
        variable AddrHighIdx_v    : natural;
        variable Parallelism_v    : natural;
        variable AddrBitsRemain_v : natural;
        variable StartIdx_v       : natural;
        variable InBitsPerInst_v  : natural;
    begin
        v := r;

        DataIn_v := (others => '0');
        if InReg_g then
            v.DataIn                       := In_Data;
            v.ValidIn                      := In_Valid;
            InValid_v                      := r.ValidIn;
            DataIn_v(InWidth_g-1 downto 0) := r.DataIn;
        else
            DataIn_v(InWidth_g-1 downto 0) := In_Data;
            InValid_v                      := In_Valid;
        end if;

        AddrLowIdx_v     := 0;
        AddrBitsRemain_v := BinBits_c;

        for stg in 0 to Stages_c-1 loop
            if stg = 0 then
                v.Valid(stg) := InValid_v;
            else
                v.Valid(stg) := r.Valid(stg-1);
            end if;

            if stg = 0 then
                AddrBits_v := AddrBitsStage1_c;
            else
                AddrBits_v := AddrBitsStageN_c;
            end if;
            AddrHighIdx_v    := AddrLowIdx_v + AddrBits_v - 1;
            AddrBitsRemain_v := AddrBitsRemain_v - AddrBits_v;
            Parallelism_v    := 2**AddrBitsRemain_v;

            InBitsPerInst_v := 2**AddrBits_v;
            StartIdx_v      := 0;

            if stg = 0 then

                for inst in 0 to Parallelism_v-1 loop
                    v.Found(0)(inst) := '0';

                    for bit in 0 to InBitsPerInst_v-1 loop
                        if DataIn_v(StartIdx_v+bit) = '1' then
                            v.Addr(0)(inst)  := toUslv(bit, BinBits_c);
                            v.Found(0)(inst) := '1';
                            exit;
                        end if;
                    end loop;

                    StartIdx_v := StartIdx_v + InBitsPerInst_v;
                end loop;

            else

                for inst in 0 to Parallelism_v-1 loop
                    v.Found(stg)(inst) := '0';

                    for bit in 0 to InBitsPerInst_v-1 loop
                        if r.Found(stg-1)(StartIdx_v+bit) = '1' then
                            v.Addr(stg)(inst)                                    := r.Addr(stg-1)(StartIdx_v+bit);
                            v.Addr(stg)(inst)(AddrHighIdx_v downto AddrLowIdx_v) := toUslv(bit, AddrBits_v);
                            v.Found(stg)(inst)                                   := '1';
                            exit;
                        end if;
                    end loop;

                    StartIdx_v := StartIdx_v + InBitsPerInst_v;
                end loop;

            end if;

            AddrLowIdx_v := AddrLowIdx_v + AddrBits_v;

        end loop;

        v.FoundOut := r.Found(Stages_c-1)(0);
        if v.FoundOUt = '1' then
            v.FirstBit := r.Addr(Stages_c-1)(0);
        else
            v.FirstBit := (others => '0'); -- Output zero if not found, simplifies testing in many cases
        end if;
        v.ValidOut := r.Valid(Stages_c-1);
        if OutReg_g then
            Out_FirstBit <= r.FirstBit;
            Out_Found    <= r.FoundOut;
            Out_Valid    <= r.ValidOut;
        else
            Out_FirstBit <= v.FirstBit;
            Out_Found    <= v.FoundOut;
            Out_Valid    <= v.ValidOut;
        end if;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.ValidIn  <= '0';
                r.Valid    <= (others => '0');
                r.ValidOut <= '0';
            end if;
        end if;
    end process;

end architecture;"
"This component is an efficient implementation for delay chains. It uses FPGA memory resources (Block-RAM and distributed RAM resp. SRLs) for implementing the delays (instead of many FFs). The last delay stage is always implemented in FFs to ensure good timing (RAM outputs are usually slow). The delay is specified as a number of data-beats (samples). For a delay in clock-cycles, simply connect _In_Valid_='1' - or lave _In_Valid_ unconnected to rely on its default value. One Problem with using RAM resources to implement delays is that they don't have a reset, so the content of the RAM persists after resetting the logic. The _olo_base_delay_ entity works around this issue by some logic that ensures that any persisting data is replaced by zeros after a reset. The replacement is done at the output of the _olo_base_delay_, so no time to overwrite memory cells after a reset is required and the entity is ready to operate on the first clock cycle after the reset. If the delay is implemented using a RAM, the behavior of the RAM (read-before-write or write-before-read) can be selected to allow efficient implementation independently of the target technology. Note that output data is valid together with Input data (when _In_Valid_ is high). Below figure shows the behavior for _Delay_g_=3 with both possible settings for _RstState_g_: In cases a delayed version of an AXI4-Stream with back-pressure (_Ready_ signal) is required, the ANDed _Ready_ and _Valid_ signals shall be connected to the _In_Valid_ input of _olo_base_delay_.

# VHDL Analysis for 'olo_base_delay.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a delay element. It is either emplemented in BRAM or SRL. The output
- Plus 32 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_delay

## Architecture: rtl of olo_base_delay

### Signals
- MemOut: std_logic_vector(Width_g - 1 downto 0)
- SrlSig: Srl_t := (others => (others => '0'))
- is ShregExtract_AllowExtraction_c;
        attribute srl_style of SrlSig: signal is SrlStyle_Srl_c
- RdAddr: std_logic_vector(log2ceil(MemTaps_c) - 1 downto 0) := (others => '0')
- WrAddr: std_logic_vector(log2ceil(MemTaps_c) - 1 downto 0) := (others => '0')
- RstStateCnt: integer range 0 to Delay_g - 1

### Component Instantiations
- Instance 'i_bram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_srl :' (Clocked) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_bram :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_srl :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- SrlSig(1 to SrlSig'high) <= SrlSig(0 to SrlSig'high - 1)

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst, RstState_g, RstStateCnt
- Implements memory functionality
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 192
- Process count: 6
- Signal count: 6

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_delay.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;

entity olo_base_delay is
    generic (
        Width_g         : positive;
        Delay_g         : natural;
        Resource_g      : string                            := ""AUTO"";
        BramThreshold_g : positive range 3 to positive'high := 128;
        RstState_g      : boolean                           := True;
        RamBehavior_g   : string                            := ""RBW""
    );
    port (
        Clk      : in    std_logic;
        Rst      : in    std_logic;
        In_Data  : in    std_logic_vector(Width_g-1 downto 0);
        In_Valid : in    std_logic := '1';
        Out_Data : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_delay is

    signal MemOut      : std_logic_vector(Width_g - 1 downto 0);
    constant MemTaps_c : natural := work.olo_base_pkg_math.max(Delay_g - 1, 0);

begin

    assert Resource_g = ""AUTO"" or Resource_g = ""SRL"" or Resource_g = ""BRAM""
        report ""###ERROR###: olo_base_delay: Unknown Resource_g - "" & Resource_g
        severity error;
    assert Resource_g /= ""BRAM"" or Delay_g >= 3
        report ""###ERROR###: olo_base_delay: Delay_g >= 3 required for Resource_g=BRAM""
        severity error;
    assert BramThreshold_g > 3
        report ""###ERROR###: olo_base_delay: BramThreshold_g must be > 3""
        severity error;

    g_srl : if (Delay_g > 1) and ((Resource_g = ""SRL"") or ((Resource_g = ""AUTO"") and (Delay_g < BramThreshold_g))) generate
        type Srl_t is array (0 to MemTaps_c - 1) of std_logic_vector(Width_g - 1 downto 0);

        signal SrlSig : Srl_t := (others => (others => '0'));

        attribute shreg_extract of SrlSig : signal is ShregExtract_AllowExtraction_c;
        attribute srl_style of SrlSig     : signal is SrlStyle_Srl_c;
    begin

        p_srl : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    SrlSig(0)                <= In_Data;
                    SrlSig(1 to SrlSig'high) <= SrlSig(0 to SrlSig'high - 1);
                end if;
            end if;
        end process;

        MemOut <= SrlSig(SrlSig'high);
    end generate;

    g_bram : if (Delay_g > 1) and ((Resource_g = ""BRAM"") or ((Resource_g = ""AUTO"") and (Delay_g >= BramThreshold_g))) generate
        signal RdAddr, WrAddr : std_logic_vector(log2ceil(MemTaps_c) - 1 downto 0) := (others => '0');
    begin

        p_bram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    if unsigned(WrAddr) = MemTaps_c - 1 then
                        WrAddr <= (others => '0');
                    else
                        WrAddr <= std_logic_vector(unsigned(WrAddr) + 1);
                    end if;
                    if unsigned(RdAddr) = MemTaps_c - 1 then
                        RdAddr <= (others => '0');
                    else
                        RdAddr <= std_logic_vector(unsigned(RdAddr) + 1);
                    end if;
                end if;

                if Rst = '1' then
                    WrAddr <= std_logic_vector(to_unsigned(MemTaps_c - 1, WrAddr'length));
                    RdAddr <= (others => '0');
                end if;
            end if;
        end process;

        i_bram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => MemTaps_c,
                Width_g         => Width_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk     => Clk,
                Wr_Addr => WrAddr,
                Wr_Ena  => In_Valid,
                Wr_Data => In_Data,
                Rd_Addr => RdAddr,
                Rd_Ena  => In_Valid,
                Rd_Data => MemOut
            );

    end generate;

    g_single : if Delay_g = 1 generate
        MemOut <= In_Data;
    end generate;

    g_zero : if Delay_g = 0 generate
        Out_Data <= In_Data;
    end generate;

    g_nonzero : if Delay_g > 0 generate
        signal RstStateCnt : integer range 0 to Delay_g - 1;
    begin

        p_outreg : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    if RstState_g = false or RstStateCnt = Delay_g - 1 then
                        Out_Data <= MemOut;
                    else
                        Out_Data    <= (others => '0');
                        RstStateCnt <= RstStateCnt + 1;
                    end if;
                end if;

                if Rst = '1' then
                    Out_Data    <= (others => '0');
                    RstStateCnt <= 0;
                end if;
            end if;
        end process;

    end generate;

end architecture;"
"This component is an efficient implementation for runtime configurable delay chains. It uses FPGA memory resources (Block-RAM) for implementing the delays (instead of many FFs). The last delay stage is always implemented in FFs to ensure good timing (RAM outputs are usually slow). For general usage of the _olo_base_delay_cfg_ entity, the same considerations as for [olo_base_delay](./olo_base_delay.md) apply. Refer to this documentation for details on the input and output signaling. Note that any changes of the delay are reflected at the output (_Out_Data_) within less than 5 samples / data-beats. During those 5 samples, the content of (_Out_Data_) is undefined. This is illustrated in the figure below.

# VHDL Analysis for 'olo_base_delay_cfg.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef & Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a delay element. It is either implemented in BRAM & SRL. The output
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_delay_cfg

## Architecture: rtl of olo_base_delay_cfg

### Signals
- SrlSig: Srl_t                                  := (others => (others => '0'))
- OutNonzero: std_logic_vector(Width_g - 1 downto 0)
- MemOut: std_logic_vector(Width_g - 1 downto 0) := (others => '0')
- RdAddr: std_logic_vector(log2ceil(MaxDelay_g) - 1 downto 0) := (others => '0')
- WrAddr: std_logic_vector(log2ceil(MaxDelay_g) - 1 downto 0) := (others => '0')

### Processes
- Process 'p_bram :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_srl :' (Clocked) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_srl :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- RdAddr <= std_logic_vector(unsigned(WrAddr) - unsigned(Delay) + 3)

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst
- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 157
- Process count: 6
- Signal count: 5

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_delay_cfg.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_delay_cfg is
    generic (
        Width_g         : positive;
        MaxDelay_g      : positive := 256;
        SupportZero_g   : boolean  := false;
        RamBehavior_g   : string   := ""RBW""
    );
    port (
        Clk      : in    std_logic;
        Rst      : in    std_logic;
        Delay    : in    std_logic_vector(log2ceil(MaxDelay_g+1)-1 downto 0);
        In_Data  : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid : in    std_logic;
        Out_Data : out   std_logic_vector((Width_g - 1) downto 0)
    );
end entity;

architecture rtl of olo_base_delay_cfg is

    type Srl_t is array (0 to 1) of std_logic_vector(Width_g - 1 downto 0);

    signal SrlSig     : Srl_t                                  := (others => (others => '0'));
    signal OutNonzero : std_logic_vector(Width_g - 1 downto 0);
    signal MemOut     : std_logic_vector(Width_g - 1 downto 0) := (others => '0');

begin

    g_ram : if MaxDelay_g > 3 generate
        signal RdAddr, WrAddr : std_logic_vector(log2ceil(MaxDelay_g) - 1 downto 0) := (others => '0');
    begin

        p_bram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    WrAddr <= std_logic_vector(unsigned(WrAddr) + 1);
                    RdAddr <= std_logic_vector(unsigned(WrAddr) - unsigned(Delay) + 3);
                end if;

                if Rst = '1' then
                    WrAddr <= (others => '0');
                    RdAddr <= (others => '0');
                end if;
            end if;
        end process;

        i_bram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => 2**log2ceil(MaxDelay_g),
                Width_g         => Width_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk     => Clk,
                Wr_Addr => WrAddr,
                Wr_Ena  => In_Valid,
                Wr_Data => In_Data,
                Rd_Addr => RdAddr,
                Rd_Ena  => In_Valid,
                Rd_Data => MemOut
            );

    end generate;

    p_srl : process (Clk) is
    begin
        if rising_edge(Clk) then
            if In_Valid = '1' then
                SrlSig(0) <= In_Data;
                SrlSig(1) <= SrlSig(0);
            end if;
        end if;
    end process;

    p_outreg : process (Clk) is
        variable DelayInt_v : natural range 0 to MaxDelay_g;
    begin
        if rising_edge(Clk) then
            DelayInt_v := fromUslv(Delay);
            if In_Valid = '1' then

                case DelayInt_v is
                    when 1 =>  OutNonzero <= In_Data;
                    when 2 =>  OutNonzero <= SrlSig(0);
                    when 3 =>  OutNonzero <= SrlSig(1);
                    when others => OutNonzero <= MemOut;
                end case;

            end if;

            if Rst = '1' then
                OutNonzero <= (others => '0');
            end if;
        end if;
    end process;

    g_supportzero : if SupportZero_g generate
        Out_Data <= OutNonzero when fromUslv(Delay) /= 0 else In_Data;
    end generate;

    g_nozero : if not SupportZero_g generate
        Out_Data <= OutNonzero;
    end generate;

end architecture;"
"This entity implements a dynamic shift (barrel shift) implemented in multiple stages in order to achieve good timing. The number of bits to shift can be selected at runtime for each data-sample.

# VHDL Analysis for 'olo_base_dyn_sft.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2020 by Oliver Bruendler
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a dynamic shift implemented in multiple stages in
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: this line can't be reached in valid configurations
            -- coverage off
            else
                report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT, is '"" & Direction_g & ""'"" severity error

## Entity: olo_base_dyn_sft

## Architecture: rtl of olo_base_dyn_sft

### Signals
- r: TwoProcess_t
- r_next: TwoProcess_t

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Valid, In_Data, In_Shift
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Input stages
        v.Data(0)  := In_Data
- v.Shift(0) := In_Shift
- v.Vld(0)   := In_Valid
- -- Shift stages
        for stg in 0 to Stages_c - 1 loop
            -- Stage constants calculation
            StepSize_v := 2**(stg * SelBitsPerStageLimited_c)
- -- Shift implementation
            Select_v := to_integer(unsigned(r.Shift(stg)(SelBitsPerStageLimited_c - 1 downto 0)))
- Plus 2 more statements

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst, SelBitsPerStageLimited_c, SelBitsPerStage_g
- May be part of a pipeline architecture

## Code Metrics
- Line count: 151
- Process count: 4
- Signal count: 2

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_dyn_sft.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_dyn_sft is
    generic (
        Direction_g         : string;
        SelBitsPerStage_g   : positive := 4;
        MaxShift_g          : positive;
        Width_g             : positive;
        SignExtend_g        : boolean  := false
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic := '1';
        In_Shift    : in    std_logic_vector(log2ceil(MaxShift_g+1)- 1 downto 0);
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_dyn_sft is

    constant Stages_c                 : integer := integer(ceil(real(In_Shift'length) / real(SelBitsPerStage_g)));
    constant SelBitsPerStageLimited_c : integer := work.olo_base_pkg_math.min(SelBitsPerStage_g, In_Shift'length);

    type Data_t is array (natural range <>) of std_logic_vector(In_Data'range);
    type Shift_t is array (natural range <>) of std_logic_vector(In_Shift'range);

    type TwoProcess_t is record
        Vld   : std_logic_vector(0 to Stages_c);
        Data  : Data_t(0 to Stages_c);
        Shift : Shift_t(0 to Stages_c);
    end record;

    signal r, r_next : TwoProcess_t;

begin

    assert Direction_g = ""LEFT"" or Direction_g = ""RIGHT""
        report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT""
        severity error;
    assert MaxShift_g <= Width_g
        report ""###ERROR###: olo_base_dyn_sft - MaxShift_g must be smaller or equal to Width_g""
        severity error;

    p_comb : process (r, In_Valid, In_Data, In_Shift) is
        variable v          : TwoProcess_t;
        variable StepSize_v : natural;
        variable Select_v   : natural range 0 to 2**SelBitsPerStage_g - 1;
        variable TempData_v : std_logic_vector(Width_g * 2 - 1 downto 0);
    begin
        v := r;

        v.Data(0)  := In_Data;
        v.Shift(0) := In_Shift;
        v.Vld(0)   := In_Valid;

        for stg in 0 to Stages_c - 1 loop
            StepSize_v := 2**(stg * SelBitsPerStageLimited_c);

            Select_v := to_integer(unsigned(r.Shift(stg)(SelBitsPerStageLimited_c - 1 downto 0)));
            if Direction_g = ""RIGHT"" then
                if SignExtend_g then
                    TempData_v := (others => r.Data(stg)(Width_g - 1));
                else
                    TempData_v := (others => '0');
                end if;
                TempData_v(2 * Width_g - 1 - Select_v * StepSize_v downto Width_g - Select_v * StepSize_v) := r.Data(stg);
                v.Data(stg + 1)                                                                            := TempData_v(2 * Width_g - 1 downto Width_g);
            elsif Direction_g = ""LEFT"" then
                TempData_v                                                                   := (others => '0');
                TempData_v(Select_v * StepSize_v + Width_g - 1 downto Select_v * StepSize_v) := r.Data(stg);
                v.Data(stg + 1)                                                              := TempData_v(Width_g - 1 downto 0);
            else
                report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT, is '"" & Direction_g & ""'"" severity error;
            end if;
            v.Shift(stg + 1) := shiftRight(r.Shift(stg), SelBitsPerStageLimited_c, '0');
            v.Vld(stg + 1)   := r.Vld(stg);
        end loop;

        Out_Data  <= r.Data(Stages_c);
        Out_Valid <= r.Vld(Stages_c);

        r_next <= v;

    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Vld <= (others => '0');
            end if;
        end if;
    end process;

end architecture;"
"This component implements an asynchronous FIFO (different clocks for write and read port). The memory is described in a way that it utilizes RAM resources (Block-RAM or distributed RAM) available in FPGAs with commonly used tools. For this purpose [olo_base_ram_sdp](./olo_base_ram_sdp.md) is used. The FIFO is a fall-through FIFO and has AXI-S interfaces on read and write side. The RAM behavior (read-before-write or write-before-read) can be selected. This allows efficiently implementing FIFOs for different technologies (some technologies implement one, some the other behavior). An asynchronous FIFO is a clock-crossing and hence this block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_fifo_async.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic asynchronous FIFO. The clocks can be fully asynchronous
- Plus 51 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: unregistered signal because CC contains register
            Out_Clk  => In_Clk,
            Out_Rst  => RstInInt,
            Out_Data => RdAddrGray
        )

## Entity: olo_base_fifo_async

## Architecture: rtl of olo_base_fifo_async

### Signals
- ri: TwoProcessIn_r := (WrAddr          => (others => '0'),
                                             WrAddrGray     => (others => '0'),
                                             RdAddr         => (others => '0'),
                                             WrAddrReg      => (others => '0'),
                                             RamWr          => '0',
                                            DataReg         => (others => '0'))
- ri_next: TwoProcessIn_r := (WrAddr          => (others => '0'),
                                             WrAddrGray     => (others => '0'),
                                             RdAddr         => (others => '0'),
                                             WrAddrReg      => (others => '0'),
                                             RamWr          => '0',
                                            DataReg         => (others => '0'))
- ro: TwoProcessOut_r := (RdAddr          => (others => '0'),
                                              RdAddrGray     => (others => '0'),
                                              WrAddr         => (others => '0'),
                                              OutLevel       => (others => '0'))
- ro_next: TwoProcessOut_r := (RdAddr          => (others => '0'),
                                              RdAddrGray     => (others => '0'),
                                              WrAddr         => (others => '0'),
                                              OutLevel       => (others => '0'))
- RstInInt: std_logic
- RstOutInt: std_logic
- RamRdAddr: std_logic_vector(RamAddrWidth_c-1 downto 0)
- RamWrAddr: std_logic_vector(RamAddrWidth_c-1 downto 0)
- RamWr: std_logic
- RamWrData: std_logic_vector(Width_g-1 downto 0)
- WrAddrGray: std_logic_vector(AddrWidth_c-1 downto 0)
- RdAddrGray: std_logic_vector(AddrWidth_c-1 downto 0)
- WrAddrGrayIn: std_logic_vector(AddrWidth_c-1 downto 0)
- RdAddrGrayIn: std_logic_vector(AddrWidth_c-1 downto 0)
- ***
        ri_next <= vi;
        ro_next <= vo;

    end process;

    p_seq_in: process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            ri <= ri_next
- because CC contains register
            Out_Clk  => In_Clk: entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        )
- Out_Rst  => RstInInt: entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        )
- Out_Data => RdAddrGray
        );

    -- Reset CC
    i_rst_cc: entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        )

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'
- Instance 'i_cc_wr_rd' of component 'olo_base_cc_bits'
- Instance 'i_cc_rd_wr' of component 'olo_base_cc_bits'
- Instance 'i_rst_cc' of component 'olo_base_cc_reset'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: In_Valid, Out_Ready, ri, ro, RstInInt, WrAddrGray, RdAddrGray, In_Data
  - Implements conditional logic
- Process 'p_seq_in :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_seq_out :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq_in :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_seq_out :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- vo := ro
- -- *** Write Side ***
        -- Defaults
        In_Ready    <= '0'
- In_Full     <= '0'
- In_Empty    <= '0'
- In_AlmFull  <= '0'
- Plus 8 more statements

## Functional Analysis

- Contains 7 clock domain(s): Clk, Out_Clk, B_Clk, In_Clk, A_Clk, Rd_Clk, Clock
- Uses reset signal(s): B_RstIn, i_rst_cc, olo_base_cc_reset, A_RstIn, ReadyRstState_g, RstInInt, reset, Reset, In_RstOut, A_RstOut, In_Rst, Out_RstOut, RstOutInt, Out_Rst, B_RstOut
- Implements memory functionality
- Implements interface or communication protocol
- May be part of a pipeline architecture
- This appears to be a CPU component
- Implements instruction execution functionality

## Code Metrics
- Line count: 344
- Process count: 6
- Signal count: 18

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_fifo_async.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_fifo_async is
    generic (
        Width_g         : positive;
        Depth_g         : positive; -- must be power of two
        AlmFullOn_g     : boolean               := false;
        AlmFullLevel_g  : natural               := 0;
        AlmEmptyOn_g    : boolean               := false;
        AlmEmptyLevel_g : natural               := 0;
        RamStyle_g      : string                := ""auto"";
        RamBehavior_g   : string                := ""RBW"";
        ReadyRstState_g : std_logic             := '1';
        Optimization_g  : string                := ""SPEED""; -- SPEED or LATENCY
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk          : in    std_logic;
        In_Rst          : in    std_logic;
        In_RstOut       : out   std_logic;
        In_Data         : in    std_logic_vector(Width_g-1 downto 0);
        In_Valid        : in    std_logic := '1';
        In_Ready        : out   std_logic;
        In_Full         : out   std_logic;
        In_Empty        : out   std_logic;
        In_AlmFull      : out   std_logic;
        In_AlmEmpty     : out   std_logic;
        In_Level        : out   std_logic_vector(log2ceil(Depth_g+1)-1 downto 0);
        Out_Clk         : in    std_logic;
        Out_Rst         : in    std_logic;
        Out_RstOut      : out   std_logic;
        Out_Data        : out   std_logic_vector(Width_g-1 downto 0);
        Out_Valid       : out   std_logic;
        Out_Ready       : in    std_logic := '1';
        Out_Full        : out   std_logic;
        Out_Empty       : out   std_logic;
        Out_AlmFull     : out   std_logic;
        Out_AlmEmpty    : out   std_logic;
        Out_Level       : out   std_logic_vector(log2ceil(Depth_g+1)-1 downto 0)
    );
end entity;

architecture rtl of olo_base_fifo_async is

    constant AddrWidth_c    : positive := log2ceil(Depth_g)+1;
    constant RamAddrWidth_c : positive := log2ceil(Depth_g);

    type TwoProcessIn_r is record
        WrAddr     : unsigned(AddrWidth_c-1 downto 0); -- One additional bit for full/empty detection
        WrAddrGray : std_logic_vector(AddrWidth_c-1 downto 0);
        RdAddr     : unsigned(AddrWidth_c-1 downto 0);
        WrAddrReg  : unsigned(AddrWidth_c-1 downto 0);
        RamWr      : std_logic;
        DataReg    : std_logic_vector(Width_g-1 downto 0);
    end record;

    type TwoProcessOut_r is record
        RdAddr     : unsigned(AddrWidth_c-1 downto 0); -- One additional bit for full/empty detection
        RdAddrGray : std_logic_vector(AddrWidth_c-1 downto 0);
        WrAddr     : unsigned(AddrWidth_c-1 downto 0);
        OutLevel   : unsigned(AddrWidth_c-1 downto 0);
    end record;

    signal ri, ri_next : TwoProcessIn_r := (WrAddr          => (others => '0'),
                                             WrAddrGray     => (others => '0'),
                                             RdAddr         => (others => '0'),
                                             WrAddrReg      => (others => '0'),
                                             RamWr          => '0',
                                            DataReg         => (others => '0'));

    signal ro, ro_next : TwoProcessOut_r := (RdAddr          => (others => '0'),
                                              RdAddrGray     => (others => '0'),
                                              WrAddr         => (others => '0'),
                                              OutLevel       => (others => '0'));

    signal RstInInt     : std_logic;
    signal RstOutInt    : std_logic;
    signal RamRdAddr    : std_logic_vector(RamAddrWidth_c-1 downto 0);
    signal RamWrAddr    : std_logic_vector(RamAddrWidth_c-1 downto 0);
    signal RamWr        : std_logic;
    signal RamWrData    : std_logic_vector(Width_g-1 downto 0);
    signal WrAddrGray   : std_logic_vector(AddrWidth_c-1 downto 0);
    signal RdAddrGray   : std_logic_vector(AddrWidth_c-1 downto 0);
    signal WrAddrGrayIn : std_logic_vector(AddrWidth_c-1 downto 0);
    signal RdAddrGrayIn : std_logic_vector(AddrWidth_c-1 downto 0);

begin

    assert log2(Depth_g) = log2ceil(Depth_g)
        report ""###ERROR###: olo_base_fifo_async: only power of two Depth_g is allowed""
        severity error;

    p_comb : process (In_Valid, Out_Ready, ri, ro, RstInInt, WrAddrGray, RdAddrGray, In_Data) is
        variable vi        : TwoProcessIn_r;
        variable vo        : TwoProcessOut_r;
        variable InLevel_v : unsigned(log2ceil(Depth_g) downto 0);
    begin
        vi := ri;
        vo := ro;

        In_Ready    <= '0';
        In_Full     <= '0';
        In_Empty    <= '0';
        In_AlmFull  <= '0';
        In_AlmEmpty <= '0';
        vi.RamWr    := '0';

        InLevel_v := ri.WrAddr - ri.RdAddr;
        In_Level  <= std_logic_vector(InLevel_v);

        if (ri.WrAddr(ri.WrAddr'left) /= ri.RdAddr(ri.RdAddr'left)) and
           (ri.WrAddr(ri.WrAddr'left-1 downto 0) = ri.RdAddr(ri.RdAddr'left-1 downto 0)) then
            In_Full <= '1';
        else
            In_Ready <= '1';
            if In_Valid = '1' then
                vi.WrAddr := ri.WrAddr + 1;
                vi.RamWr  := '1';
            end if;
        end if;
        if (ReadyRstState_g = '0') and (RstInInt = '1') then
            In_Ready <= '0';
        end if;

        if InLevel_v = 0 then
            In_Empty <= '1';
        end if;
        if InLevel_v >= AlmFullLevel_g and AlmFullOn_g then
            In_AlmFull <= '1';
        end if;
        if InLevel_v <= AlmEmptyLevel_g and AlmEmptyOn_g then
            In_AlmEmpty <= '1';
        end if;

        vi.WrAddrReg := ri.WrAddr;
        vi.DataReg   := In_Data;

        Out_Valid    <= '0';
        Out_Full     <= '0';
        Out_Empty    <= '0';
        Out_AlmFull  <= '0';
        Out_AlmEmpty <= '0';

        if ro.WrAddr = ro.RdAddr then
            vo.OutLevel := (others => '0');
        else
            vo.OutLevel := ro.WrAddr - ro.RdAddr;
            if (Out_Ready = '1') and (ro.OutLevel /= 0) then
                vo.OutLevel := vo.OutLevel - 1;
            end if;
        end if;
        Out_Level <= std_logic_vector(ro.OutLevel);

        if ro.OutLevel = 0 then
            Out_Empty <= '1';
        else
            Out_Valid <= '1';
            if Out_Ready = '1' then
                vo.RdAddr := ro.RdAddr + 1;
            end if;
        end if;
        RamRdAddr <= std_logic_vector(vo.RdAddr(log2ceil(Depth_g) - 1 downto 0));

        if ro.OutLevel = Depth_g then
            Out_Full <= '1';
        end if;
        if ro.OutLevel >= AlmFullLevel_g and AlmFullOn_g then
            Out_AlmFull <= '1';
        end if;
        if ro.OutLevel <= AlmEmptyLevel_g and AlmEmptyOn_g then
            Out_AlmEmpty <= '1';
        end if;

        vi.WrAddrGray := binaryToGray(std_logic_vector(vi.WrAddr));
        vo.RdAddrGray := binaryToGray(std_logic_vector(vo.RdAddr));

        vi.RdAddr := unsigned(grayToBinary(RdAddrGray));
        vo.WrAddr := unsigned(grayToBinary(WrAddrGray));

        ri_next <= vi;
        ro_next <= vo;

    end process;

    p_seq_in : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            ri <= ri_next;
            if RstInInt = '1' then
                ri.WrAddr     <= (others => '0');
                ri.WrAddrGray <= (others => '0');
                ri.RdAddr     <= (others => '0');
                ri.RamWr      <= '0';
            end if;
        end if;
    end process;

    p_seq_out : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            ro <= ro_next;
            if RstOutInt = '1' then
                ro.RdAddr     <= (others => '0');
                ro.RdAddrGray <= (others => '0');
                ro.WrAddr     <= (others => '0');
                ro.OutLevel   <= (others => '0');
            end if;
        end if;
    end process;

    RamWrAddr <= std_logic_vector(ri.WrAddr(log2ceil(Depth_g) - 1 downto 0)) when Optimization_g = ""LATENCY"" else
                 std_logic_vector(ri.WrAddrReg(log2ceil(Depth_g) - 1 downto 0));
    RamWr     <= ri_next.RamWr when Optimization_g = ""LATENCY"" else ri.RamWr;
    RamWrData <= In_Data when Optimization_g = ""LATENCY"" else ri.DataReg;

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            IsAsync_g       => true,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk         => In_Clk,
            Wr_Addr     => RamWrAddr,
            Wr_Ena      => RamWr,
            Wr_Data     => RamWrData,
            Rd_Clk      => Out_Clk,
            Rd_Addr     => RamRdAddr,
            Rd_Data     => Out_Data
        );

    WrAddrGrayIn <= ri_next.WrAddrGray when Optimization_g = ""LATENCY"" else ri.WrAddrGray; -- optional register stage

    i_cc_wr_rd : entity work.olo_base_cc_bits
        generic map (
            Width_g      => AddrWidth_c,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => In_Clk,
            In_Rst   => RstInInt,
            In_Data  => WrAddrGrayIn,
            Out_Clk  => Out_Clk,
            Out_Rst  => RstOutInt,
            Out_Data => WrAddrGray
        );

    RdAddrGrayIn <= ro_next.RdAddrGray when Optimization_g = ""LATENCY"" else ro.RdAddrGray; -- optional register stage

    i_cc_rd_wr : entity work.olo_base_cc_bits
        generic map (
            Width_g      => AddrWidth_c,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => Out_Clk,
            In_Rst   => RstOutInt,
            In_Data  => RdAddrGrayIn, -- use unregistered signal because CC contains register
            Out_Clk  => In_Clk,
            Out_Rst  => RstInInt,
            Out_Data => RdAddrGray
        );

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        );

    Out_RstOut <= RstOutInt;
    In_RstOut  <= RstInInt;

end architecture;"
"This component implements a synchronous packet FIFO. The FIFO works in store and forward mode. This means a packet is only presented to the output after it is written into the FIFO completely. This component offers the following additional features compared to [olo_base_fifo_sync](./olo_base_fifo_sync.md): - Due to the store and forward implementation, packets are compressed. Even if the data is written into the FIFO at low rate, it is guaranteed that the packet can be read in a single short burst once it is presented at the output. - Writing of a packet into a FIFO can be aborted at any time during writing the packet (see [Dropping Packets on Write Side](#dropping-packets-on-write-side)). The write pointer is automatically rewinded in this case. - Example use-case: A CRC error can only be detected at the end of the packet. User logic can still write the packet into the FIFO directly and just asserts _In_Drop_ if a CRC error is detected at the end of the packet. The full packet (including already written data) is ignored. - On the read side, it is possible to skip the remaining data of a packet at any time during reading a packet (see [Skipping Packets on Read Side](#skipping-packets-on-read-side)). - Example use-case: The user logic is interested only in some packet types. If a different packet type is found in the header, _Out_Next_ can be asserted to skip the rest of the packet and directly continue reading the next packet. - On the read side, it is possible to repeat a packet (see [Repeating Packets on Read Side](#repeating-packets-on-read-side)). - Example use-case: A packet is read from the FIFO and transmitted wirelessly. During sending the packet a collision occurs and the transmission is aborted. In this situation the user logic can assert _Out_Repeat_ to read the same packet again and retry the transmission. Below samples assumes _Depth_g_=32. The memory is described in a way that it utilizes RAM resources (Block-RAM or distributed RAM) available in FPGAs with commonly used tools. For this purpose [olo_base_ram_sdp](./olo_base_ram_sdp.md) is used. The FIFO  has AXI-S interfaces on read and write side. The RAM behavior (read-before-write or write-before-read) can be selected. This allows efficiently implementing FIFOs for different technologies (some technologies implement one, some the other behavior). The FIFO contains a large RAM for packet data and a small [olo_base_fifo_sync](./olo_base_fifo_sync.md) for storing the sizes of individual packets. **Note:** Due to implementation reasons the FIFO introduces one stall cycle per packet on the read-side. Hence the FIFO throughput is suboptimal for very small packets. Packets exceeding _Depth_g_ cannot be processed in store and forward mode and are therefore dropped automatically.

# VHDL Analysis for 'olo_base_fifo_packet.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- - This is a synchronous packet FIFO. In contrast to a normal FIFO, it allows
- - dropping and repeating packets as well as detecting how many packets
- Plus 93 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: it does not have any effect on the last word of a packet

                    -- To to idle cycle for fetch after packet completed
                    v.RdValid := '0'

## Entity: olo_base_fifo_packet

## Architecture: rtl of olo_base_fifo_packet

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- RamRdAddr: std_logic_vector(Addr_c)
- FifoInReady: std_logic
- RdPacketEnd: std_logic_vector(Addr_c)
- RdPacketEndValid: std_logic
- RamWrEna: std_logic
- FifoInValid: std_logic
- FifoOutRdy: std_logic
- WrAddrStdlv: std_logic_vector(Addr_c)
- r_next <= v;

    end process;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: In_Valid, In_Data, In_Last, In_Drop, Out_Ready, Out_Next, Out_Repeat, Rst, r,
                      FifoInReady, RdPacketEnd, RdPacketEndValid
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Write side ***

        -- Default Values
        In_Ready_v  := ((not r.Full) and FifoInReady) or r.DropLatch
- InDrop_v    := r.DropLatch
- RamWrEna    <= '0'
- FifoInValid <= '0'
- -- Implement getting free aftter Full
        if r.WrAddr /= r.RdPacketStart then
            v.Full := '0'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst, WrAddrStdlv, ReadyRstState_g
- Implements memory functionality
- Implements control logic
- This appears to be a CPU component
- Implements instruction fetching functionality

## Code Metrics
- Line count: 421
- Process count: 4
- Signal count: 11

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_fifo_packet.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_fifo_packet is
    generic (
        Width_g             : positive;
        Depth_g             : positive;
        RamStyle_g          : string                            := ""auto"";
        RamBehavior_g       : string                            := ""RBW"";
        SmallRamStyle_g     : string                            := ""auto"";
        SmallRamBehavior_g  : string                            := ""same"";
        MaxPackets_g        : positive range 2 to positive'high := 17
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        In_Valid      : in    std_logic := '1';
        In_Ready      : out   std_logic;
        In_Data       : in    std_logic_vector(Width_g - 1 downto 0);
        In_Last       : in    std_logic := '1';
        In_Drop       : in    std_logic := '0';
        In_IsDropped  : out   std_logic;
        Out_Valid     : out   std_logic;
        Out_Ready     : in    std_logic := '1';
        Out_Data      : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Size      : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Out_Last      : out   std_logic;
        Out_Next      : in    std_logic := '0';
        Out_Repeat    : in    std_logic := '0';
        PacketLevel   : out   std_logic_vector(log2ceil(MaxPackets_g + 1) - 1 downto 0);
        FreeWords     : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_fifo_packet is

    constant SmallRamStyle_c    : string := choose(SmallRamStyle_g = ""same"", RamStyle_g, SmallRamStyle_g);
    constant SmallRamBehavior_c : string := choose(SmallRamBehavior_g = ""same"", RamBehavior_g, SmallRamBehavior_g);

    subtype Addr_c is integer range log2ceil(Depth_g) downto 0; -- one additional bit to differentiate between full/empty
    subtype AddrApp_c is integer range log2ceil(Depth_g) - 1 downto 0; -- one additional bit to differentiate between full/empty

    type RdFsm_t is (Fetch_s, Data_s, Last_s);

    type TwoProcess_r is record
        WrAddr         : unsigned(Addr_c); -- Shifted by Depth_g to Read pointer
        WrPacketStart  : unsigned(Addr_c); -- Shifted by Depth_g to Read pointer
        WrSize         : unsigned(Addr_c);
        WrPacketActive : std_logic;
        DropLatch      : std_logic;
        Full           : std_logic;
        RdAddr         : unsigned(Addr_c);
        RdPacketStart  : unsigned(Addr_c);
        RdPacketEnd    : unsigned(Addr_c);
        RdValid        : std_logic;
        RdFsm          : RdFsm_t;
        RdRepeat       : std_logic;
        RdSize         : unsigned(log2ceil(Depth_g + 1) - 1 downto 0);
        NextLatch      : std_logic;
        PacketLevel    : unsigned(log2ceil(MaxPackets_g + 1)-1 downto 0);
    end record;


    signal r, r_next : TwoProcess_r;

    signal RamRdAddr        : std_logic_vector(Addr_c);
    signal FifoInReady      : std_logic;
    signal RdPacketEnd      : std_logic_vector(Addr_c);
    signal RdPacketEndValid : std_logic;
    signal RamWrEna         : std_logic;
    signal FifoInValid      : std_logic;
    signal FifoOutRdy       : std_logic;
    signal WrAddrStdlv      : std_logic_vector(Addr_c);

begin

    assert log2(Depth_g) = log2ceil(Depth_g)
        report ""olo_base_fifo_packet: only power of two Depth_g is allowed""
        severity error;

    p_comb : process (In_Valid, In_Data, In_Last, In_Drop, Out_Ready, Out_Next, Out_Repeat, Rst, r,
                      FifoInReady, RdPacketEnd, RdPacketEndValid) is
        variable v          : TwoProcess_r;
        variable In_Ready_v : std_logic;
        variable InDrop_v   : std_logic;
        variable OutLast_v  : std_logic;
    begin
        v := r;


        In_Ready_v  := ((not r.Full) and FifoInReady) or r.DropLatch;
        InDrop_v    := r.DropLatch;
        RamWrEna    <= '0';
        FifoInValid <= '0';

        if r.WrAddr /= r.RdPacketStart then
            v.Full := '0';
        end if;

        if In_Drop = '1' and (r.WrPacketActive = '1' or In_Valid = '1') then
            v.DropLatch := '1';
        end if;

        if In_Valid = '1' and In_Ready_v = '1' then
            v.WrPacketActive := '1';

            if r.WrAddr = r.RdPacketStart-1 then
                v.Full := '1';
            end if;

            if r.WrAddr = Depth_g*2 - 1 then
                v.WrAddr := (others => '0');
            else
                v.WrAddr := r.WrAddr + 1;
            end if;

            if In_Drop = '1' then
                InDrop_v    := '1';
                v.DropLatch := '1';
            end if;

            if r.WrSize = Depth_g then
                v.DropLatch := '1';
            else
                v.WrSize := r.WrSize + 1;
            end if;

            if In_Last = '1' then
                if InDrop_v = '1' then
                    v.WrAddr := r.WrPacketStart;
                else
                    v.WrPacketStart := r.WrAddr + 1;
                    FifoInValid     <= '1';
                end if;
                v.DropLatch      := '0';
                v.WrSize         := to_unsigned(1, r.WrSize'length);
                v.WrPacketActive := '0';
            end if;

            RamWrEna <= '1';

        end if;

        if r.DropLatch = '1' then
            v.WrAddr := r.WrPacketStart;
            v.Full   := '0';
        end if;

        In_IsDropped <= InDrop_v;
        In_Ready     <= In_Ready_v;



        FifoOutRdy <= '0';
        OutLast_v  := '0';

        case r.RdFsm is
            when Fetch_s =>
                v.RdPacketStart := r.RdAddr;

                if r.RdRepeat = '1' then
                    if r.RdPacketEnd = r.RdPacketStart then
                        v.RdFsm := Last_s;
                    else
                        v.RdFsm := Data_s;
                    end if;
                    v.RdRepeat := '0';
                    v.RdAddr   := r.RdPacketStart;
                    v.RdValid  := '1';
                    v.RdPacketStart := r.RdPacketStart;

                elsif RdPacketEndValid = '1' then
                    FifoOutRdy <= '1';
                    v.RdRepeat := '0';
                    if unsigned(RdPacketEnd) = r.RdAddr then
                        v.RdFsm := Last_s;
                    else
                        v.RdFsm := Data_s;
                    end if;
                    v.RdPacketEnd := unsigned(RdPacketEnd);
                    v.RdValid     := '1';
                    v.RdSize      := unsigned(RdPacketEnd) - r.RdAddr + 1;

                end if;

            when Data_s =>
                if Out_Ready = '1' then
                    if v.RdAddr = Depth_g*2 - 1 then
                        v.RdAddr := (others => '0');
                    else
                        v.RdAddr := v.RdAddr + 1;
                    end if;

                    if r.RdAddr = r.RdPacketEnd - 1 then
                        v.RdFsm := Last_s;
                    end if;

                    if Out_Next = '1' or r.NextLatch = '1' then
                        OutLast_v := '1';
                        v.RdValid := '0';
                        v.RdFsm   := Fetch_s;
                        v.RdAddr  := r.RdPacketEnd + 1;
                    end if;

                end if;

            when Last_s =>
                OutLast_v := '1';

                if Out_Ready = '1' then
                    if v.RdAddr = Depth_g*2 - 1 then
                        v.RdAddr := (others => '0');
                    else
                        v.RdAddr := v.RdAddr + 1;
                    end if;


                    v.RdValid := '0';
                    v.RdFsm   := Fetch_s;
                end if;

            when others => null; -- unreacable code

        end case;

        RamRdAddr <= std_logic_vector(v.RdAddr);
        Out_Valid <= r.RdValid;
        Out_Last  <= OutLast_v;
        Out_Size  <= std_logic_vector(r.RdSize);

        if r.RdValid = '1' and Out_Ready = '1' and OutLast_v = '1' then
            v.NextLatch := '0';
        elsif r.RdValid = '1' and Out_Next = '1' then
            v.NextLatch := '1';
        end if;

        if In_Valid = '1' and In_Ready_v = '1' and In_Last = '1' and InDrop_v = '0' then
            v.PacketLevel := r.PacketLevel + 1;
        end if;
        if r.RdValid = '1' and Out_Ready = '1' and OutLast_v = '1' and r.RdRepeat = '0' and Out_Repeat = '0' then
            v.PacketLevel := v.PacketLevel - 1;
        end if;
        PacketLevel <= std_logic_vector(r.PacketLevel);

        FreeWords <= std_logic_vector(r.RdPacketStart(FreeWords'range) - r.WrAddr(FreeWords'range));

        if Out_Repeat = '1' and r.RdValid = '1' then
            v.RdRepeat := '1';
        end if;

        r_next <= v;

    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.WrAddr         <= to_unsigned(Depth_g, r.WrAddr'length);
                r.WrPacketStart  <= to_unsigned(Depth_g, r.WrPacketStart'length);
                r.WrSize         <= to_unsigned(1, r.WrSize'length);
                r.WrPacketActive <= '0';
                r.DropLatch      <= '0';
                r.Full           <= '0';
                r.RdAddr         <= (others => '0');
                r.RdPacketStart  <= (others => '0');
                r.RdFsm          <= Fetch_s;
                r.RdRepeat       <= '0';
                r.RdValid        <= '0';
                r.NextLatch      <= '0';
                r.PacketLevel    <= (others => '0');
            end if;
        end if;
    end process;


    WrAddrStdlv(AddrApp_c)        <= std_logic_vector(r.WrAddr(AddrApp_c));
    WrAddrStdlv(WrAddrStdlv'high) <= not r.WrAddr(r.WrAddr'high);

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk     => Clk,
            Wr_Addr => WrAddrStdlv(AddrApp_c), -- Additional bit for full/empty differentiation is stripped
            Wr_Ena  => RamWrEna,
            Wr_Data => In_Data,
            Rd_Addr => RamRdAddr(AddrApp_c),   -- Additional bit for full/empty differentiation is stripped
            Rd_Data => Out_Data
        );

    i_pktend_fifo : entity work.olo_base_fifo_sync
        generic map (
            Width_g         => log2ceil(Depth_g)+1,
            Depth_g         => MaxPackets_g-1,     -- One packet is currently read out (not in the FIFO anymore)
            RamStyle_g      => SmallRamStyle_c,
            RamBehavior_g   => SmallRamBehavior_c,
            ReadyRstState_g => '0'
        )
        port map (
            Clk           => Clk,
            Rst           => Rst,
            In_Data       => WrAddrStdlv,
            In_Valid      => FifoInValid,
            In_Ready      => FifoInReady,
            Out_Data      => RdPacketEnd,
            Out_Valid     => RdPacketEndValid,
            Out_Ready     => FifoOutRdy
        );

end architecture;"
"This component implements a synchronous FIFO (same clock for write and read port). The memory is described in a way that it utilizes RAM resources (Block-RAM or distributed RAM) available in FPGAs with commonly used tools. For this purpose [olo_base_ram_sdp](./olo_base_ram_sdp.md) is used. The FIFO is a fall-through FIFO and has AXI-S interfaces on read and write side. The RAM behavior (read-before-write or write-before-read) can be selected. This allows efficiently implementing FIFOs for different technologies (some technologies implement one, some the other behavior).

# VHDL Analysis for 'olo_base_fifo_sync.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic synchronous FIFO. It  has optional level- and
- Plus 26 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_fifo_sync

## Architecture: rtl of olo_base_fifo_sync

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- RamWr: std_logic
- RamRdAddr: std_logic_vector(log2ceil(Depth_g) - 1 downto 0)
- r_next <= v;

    end process;

    -- Synchronous Outputs
    Out_Level <= r.RdLevel;
    In_Level  <= r.WrLevel;

    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: In_Valid, Out_Ready, Rst, r
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Write side
        v.RdUp := '0'
- RamWr  <= '0'
- if unsigned(r.WrLevel) /= Depth_g and In_Valid = '1' then
            if unsigned(r.WrAddr) /= Depth_g - 1 then
                v.WrAddr := std_logic_vector(unsigned(r.WrAddr) + 1)
- else
                v.WrAddr := (others => '0')

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst, reset, ReadyRstState_g
- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 204
- Process count: 4
- Signal count: 5

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_fifo_sync.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_fifo_sync is
    generic (
        Width_g         : positive;
        Depth_g         : positive;
        AlmFullOn_g     : boolean   := false;
        AlmFullLevel_g  : natural   := 0;
        AlmEmptyOn_g    : boolean   := false;
        AlmEmptyLevel_g : natural   := 0;
        RamStyle_g      : string    := ""auto"";
        RamBehavior_g   : string    := ""RBW"";
        ReadyRstState_g : std_logic := '1'
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        In_Data       : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid      : in    std_logic := '1';
        In_Ready      : out   std_logic;
        In_Level      : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Out_Data      : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid     : out   std_logic;
        Out_Ready     : in    std_logic := '1';
        Out_Level     : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Full          : out   std_logic;
        AlmFull       : out   std_logic;
        Empty         : out   std_logic;
        AlmEmpty      : out   std_logic
    );
end entity;

architecture rtl of olo_base_fifo_sync is

    type TwoProcess_r is record
        WrLevel : std_logic_vector(In_Level'range);
        RdLevel : std_logic_vector(Out_Level'range);
        RdUp    : std_logic;
        WrDown  : std_logic;
        WrAddr  : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        RdAddr  : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

    signal RamWr     : std_logic;
    signal RamRdAddr : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);

begin

    p_comb : process (In_Valid, Out_Ready, Rst, r) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.RdUp := '0';
        RamWr  <= '0';
        if unsigned(r.WrLevel) /= Depth_g and In_Valid = '1' then
            if unsigned(r.WrAddr) /= Depth_g - 1 then
                v.WrAddr := std_logic_vector(unsigned(r.WrAddr) + 1);
            else
                v.WrAddr := (others => '0');
            end if;
            RamWr  <= '1';
            v.RdUp := '1';
            if r.WrDown = '0' then
                v.WrLevel := std_logic_vector(unsigned(r.WrLevel) + 1);
            end if;
        elsif r.WrDown = '1' then
            v.WrLevel := std_logic_vector(unsigned(r.WrLevel) - 1);
        end if;

        if unsigned(r.WrLevel) = Depth_g then
            In_Ready <= '0';
            Full     <= '1';
        else
            In_Ready <= '1';
            Full     <= '0';
        end if;
        if (ReadyRstState_g = '0') and (Rst = '1') then
            In_Ready <= '0';
        end if;

        if AlmFullOn_g and unsigned(r.WrLevel) >= AlmFullLevel_g then
            AlmFull <= '1';
        else
            AlmFull <= '0';
        end if;

        v.WrDown := '0';
        if unsigned(r.RdLevel) /= 0 and Out_Ready = '1' then
            if unsigned(r.RdAddr) /= Depth_g - 1 then
                v.RdAddr := std_logic_vector(unsigned(r.RdAddr) + 1);
            else
                v.RdAddr := (others => '0');
            end if;
            v.WrDown := '1';
            if r.RdUp = '0' then
                v.RdLevel := std_logic_vector(unsigned(r.RdLevel) - 1);
            end if;
        elsif r.RdUp = '1' then
            v.RdLevel := std_logic_vector(unsigned(r.RdLevel) + 1);
        end if;
        RamRdAddr <= v.RdAddr;

        if unsigned(r.RdLevel) > 0 then
            Out_Valid <= '1';
            Empty     <= '0';
        else
            Out_Valid <= '0';
            Empty     <= '1';
        end if;

        if AlmEmptyOn_g and unsigned(r.RdLevel) <= AlmEmptyLevel_g then
            AlmEmpty <= '1';
        else
            AlmEmpty <= '0';
        end if;

        r_next <= v;

    end process;

    Out_Level <= r.RdLevel;
    In_Level  <= r.WrLevel;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.WrLevel <= (others => '0');
                r.RdLevel <= (others => '0');
                r.RdUp    <= '0';
                r.WrDown  <= '0';
                r.WrAddr  <= (others => '0');
                r.RdAddr  <= (others => '0');
            end if;
        end if;
    end process;

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk         => Clk,
            Wr_Addr     => r.WrAddr,
            Wr_Ena      => RamWr,
            Wr_Data     => In_Data,
            Rd_Addr     => RamRdAddr,
            Rd_Data     => Out_Data
        );

end architecture;"
"This component implements full flow-control (including Ready/back-pressure) around processing entities that do not support Ready/back-pressure natively. The usage is depicted below: The _olo_base_flowctrl_handler_ includes a small FIFO buffer and ensures to de-assert _In_Ready_ in a way that remaining output samples from processing can be absorbed without data-loss when _Out_Ready_ is de-asserted. The FIFO buffer is chosen large enough to provide full throughput (i.e. not add any needless stall-cycles). For processing entities that do not even provide the handling of the _Valid_ flag, the _Valid_ flag handling can easily be implemented by adding an [olo_base_delay](*./olo_base_delay.md) component with the same delay as the processingitself:

# VHDL Analysis for 'olo_base_flowctrl_handler.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Implements full flow-control handling (including Ready/backpressure) for
- processing entities that do not support flow-control natively.
- Plus 24 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: olo_base_flowctrl_handler

## Architecture: rtl of olo_base_flowctrl_handler

### Signals
- Fifo_InReady: std_logic
- Fifo_HalfEmpty: std_logic

### Component Instantiations
- Instance 'i_fifo' of component 'olo_base_fifo_sync'

### Processes
- Process 'p_assert :' (Clocked) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_assert :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst
- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 110
- Process count: 2
- Signal count: 2

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_flowctrl_handler.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_flowctrl_handler is
    generic (
        InWidth_g           : positive;
        OutWidth_g          : positive;
        SamplesToAbsorb_g   : positive;
        RamStyle_g          : string := ""auto"";
        RamBehavior_g       : string := ""RBW""
    );
    port (
        Clk            : in    std_logic;
        Rst            : in    std_logic;
        In_Data        : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Valid       : in    std_logic := '1';
        In_Ready       : out   std_logic;
        Out_Data       : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Valid      : out   std_logic;
        Out_Ready      : in    std_logic := '1';
        ToProc_Data    : out   std_logic_vector(InWidth_g - 1 downto 0);
        ToProc_Valid   : out   std_logic;
        FromProc_Data  : in    std_logic_vector(OutWidth_g - 1 downto 0);
        FromProc_Valid : in    std_logic
    );
end entity;

architecture rtl of olo_base_flowctrl_handler is

    constant FifoDepth_c  : positive := 2*(SamplesToAbsorb_g+2);
    signal Fifo_InReady   : std_logic;
    signal Fifo_HalfEmpty : std_logic;

begin

    In_Ready     <= Fifo_HalfEmpty;
    ToProc_Data  <= In_Data;
    ToProc_Valid <= In_Valid and Fifo_HalfEmpty; -- Only forward data when FIFO is guaranteed to accept result

    i_fifo : entity work.olo_base_fifo_sync
        generic map (
            Width_g         => OutWidth_g,
            Depth_g         => FifoDepth_c,
            AlmEmptyOn_g    => true,
            AlmEmptyLevel_g => FifoDepth_c/2,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk           => Clk,
            Rst           => Rst,
            In_Data       => FromProc_Data,
            In_Valid      => FromProc_Valid,
            In_Ready      => Fifo_InReady,
            Out_Data      => Out_Data,
            Out_Valid     => Out_Valid,
            Out_Ready     => Out_Ready,
            AlmEmpty      => Fifo_HalfEmpty

        );

    p_assert : process (Clk) is
    begin
        if rising_edge(Clk) then
            assert (Fifo_InReady = '1' or FromProc_Valid /= '1')
                report ""olo_base_flowctrl_handler: FIFO is full upon FromProc_Valid = '1'""
                severity error;
        end if;
    end process;

end architecture;"
"This package contains different array types which are used in _Open Logic_ internally but also on its interfaces to the user (e.g. for generics). The package is written mainly for these purposes and does not aim for completeness - nevertheless as a user you are free to use it for your code of course.

# VHDL Analysis for 'olo_base_pkg_array.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Waldemar Koprek, Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing commonly used array types
- Plus 16 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all

## Functional Analysis

- Defines custom functions: arrayInteger2Real, arrayStdl2Bool, arrayBool2Stdl, arrayInteger2Real, arrayStdl2Bool, arrayBool2Stdl

## Code Metrics
- Line count: 120
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_array.vhd' plays a specific role in the overall CPU architecture.
","
library ieee;
    use ieee.std_logic_1164.all;

package olo_base_pkg_array is

    type StlvArray2_t   is array (natural range <>) of std_logic_vector( 1 downto 0);
    type StlvArray3_t   is array (natural range <>) of std_logic_vector( 2 downto 0);
    type StlvArray4_t   is array (natural range <>) of std_logic_vector( 3 downto 0);
    type StlvArray5_t   is array (natural range <>) of std_logic_vector( 4 downto 0);
    type StlvArray6_t   is array (natural range <>) of std_logic_vector( 5 downto 0);
    type StlvArray7_t   is array (natural range <>) of std_logic_vector( 6 downto 0);
    type StlvArray8_t   is array (natural range <>) of std_logic_vector( 7 downto 0);
    type StlvArray9_t   is array (natural range <>) of std_logic_vector( 8 downto 0);
    type StlvArray10_t  is array (natural range <>) of std_logic_vector( 9 downto 0);
    type StlvArray11_t  is array (natural range <>) of std_logic_vector(10 downto 0);
    type StlvArray12_t  is array (natural range <>) of std_logic_vector(11 downto 0);
    type StlvArray13_t  is array (natural range <>) of std_logic_vector(12 downto 0);
    type StlvArray14_t  is array (natural range <>) of std_logic_vector(13 downto 0);
    type StlvArray15_t  is array (natural range <>) of std_logic_vector(14 downto 0);
    type StlvArray16_t  is array (natural range <>) of std_logic_vector(15 downto 0);
    type StlvArray17_t  is array (natural range <>) of std_logic_vector(16 downto 0);
    type StlvArray18_t  is array (natural range <>) of std_logic_vector(17 downto 0);
    type StlvArray19_t  is array (natural range <>) of std_logic_vector(18 downto 0);
    type StlvArray20_t  is array (natural range <>) of std_logic_vector(19 downto 0);
    type StlvArray21_t  is array (natural range <>) of std_logic_vector(20 downto 0);
    type StlvArray22_t  is array (natural range <>) of std_logic_vector(21 downto 0);
    type StlvArray23_t  is array (natural range <>) of std_logic_vector(22 downto 0);
    type StlvArray24_t  is array (natural range <>) of std_logic_vector(23 downto 0);
    type StlvArray25_t  is array (natural range <>) of std_logic_vector(24 downto 0);
    type StlvArray26_t  is array (natural range <>) of std_logic_vector(25 downto 0);
    type StlvArray27_t  is array (natural range <>) of std_logic_vector(26 downto 0);
    type StlvArray28_t  is array (natural range <>) of std_logic_vector(27 downto 0);
    type StlvArray29_t  is array (natural range <>) of std_logic_vector(28 downto 0);
    type StlvArray30_t  is array (natural range <>) of std_logic_vector(29 downto 0);
    type StlvArray32_t  is array (natural range <>) of std_logic_vector(31 downto 0);
    type StlvArray36_t  is array (natural range <>) of std_logic_vector(35 downto 0);
    type StlvArray48_t  is array (natural range <>) of std_logic_vector(47 downto 0);
    type StlvArray64_t  is array (natural range <>) of std_logic_vector(63 downto 0);
    type StlvArray512_t is array (natural range <>) of std_logic_vector(511 downto 0);

    type IntegerArray_t is array (natural range <>) of integer;
    type RealArray_t is array (natural range <>) of real;
    type BoolArray_t is array (natural range <>) of boolean;

    function arrayInteger2Real (a : in IntegerArray_t) return RealArray_t;
    function arrayStdl2Bool (a : in std_logic_vector) return BoolArray_t;
    function arrayBool2Stdl (a : in BoolArray_t) return std_logic_vector;

end package;

package body olo_base_pkg_array is

    function arrayInteger2Real (a : in IntegerArray_t) return RealArray_t is
        variable Array_v : RealArray_t(a'range);
    begin

        for i in a'low to a'high loop
            Array_v(i) := real(a(i));
        end loop;

        return Array_v;
    end function;

    function arrayStdl2Bool (a : in std_logic_vector) return BoolArray_t is
        variable Array_v : BoolArray_t(a'range);
    begin

        for i in a'low to a'high loop
            Array_v(i) := (a(i) = '1');
        end loop;

        return Array_v;
    end function;

    function arrayBool2Stdl (a : in BoolArray_t) return std_logic_vector is
        variable Array_v : std_logic_vector(a'range);
    begin

        for i in a'low to a'high loop
            if a(i) then
                Array_v(i) := '1';
            else
                Array_v(i) := '0';
            end if;
        end loop;

        return Array_v;
    end function;

end package body;"
"This package contains synthesis attributes for various vendors. The usage is non-straightforward because different attributes must be added due to restrictions of VHDL. Also does the package only contain attributes used in Open Logic internally. As a result, **this package is meant for internal use** mainly and it is **undocumented**. Users are still free to use the package but no support will be given. If you decide to do so, orient yourself on code samples (e.g. in [olo_base_cc_bits](./olo_base_cc_bits.md) or [olo_base_ram_sdp](./olo_base_ram_sdp.md)) and on the comments within the source code of the package. Currently only one version of the package is provided. In case of unresolvable name clashes between attributes expected by different tools, the package might be provided in different versions for different tools in future.

# VHDL Analysis for 'olo_base_pkg_attribute.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler, Benoit Stef
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing attribute definitions that work for all target vendors. The package is meant
- for Open Logic internal use and hence not deocumented in detail.
- Plus 58 more comments

## Libraries and Packages
- Library: ieee
- Use: and hence not deocumented in detail.
--
-- Documentation:
-- https://github.com/open-logic/open-logic/blob/main/doc/base/olo_base_pkg_attribute.md
--
-- Note: The link points to the documentation of the latest release. If you
--       use an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: LUT as shift register

    -- Tools:
    -- - Efinity (Efinix)
    -- - GowinEDA (Gowin)
    attribute syn_srlstyle : string
- Use: Gowin only accepts integer.
    attribute syn_keep : integer
- Use: Gowin only accepts integer.
    attribute syn_preserve : integer

## Functional Analysis

- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 126
- Process count: N/A
- Signal count: N/A

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_attribute.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

package olo_base_pkg_attribute is


    attribute shreg_extract : string;
    constant ShregExtract_SuppressExtraction_c : string := ""no"";
    constant ShregExtract_AllowExtraction_c    : string := ""yes"";


    attribute srl_style : string;
    constant SrlStyle_FlipFlops_c : string := ""registers"";
    constant SrlStyle_Srl_c       : string := ""srl""; -- Use LUT as shift register

    attribute syn_srlstyle : string;
    constant SynSrlstyle_FlipFlops_c : string := ""registers"";


    attribute async_reg : boolean;
    constant AsyncReg_TreatAsync_c : boolean := true;


    attribute dont_merge : boolean;
    constant DontMerge_SuppressChanges_c : boolean := true;

    attribute preserve : boolean;
    constant Preserve_SuppressChanges_c : boolean := true;

    attribute syn_keep : integer;
    constant SynKeep_SuppressChanges_c : integer := 1;

    attribute syn_preserve : integer;
    constant SynPreserve_SuppressChanges_c : integer := 1;

    attribute dont_touch : boolean;
    constant DontTouch_SuppressChanges_c : boolean := true;

    attribute keep : string;
    constant Keep_SuppressChanges_c : string := ""yes"";


    attribute ram_style : string;

    attribute ramstyle : string;

    attribute syn_ramstyle : string;

end package;

package body olo_base_pkg_attribute is

end package body;"
"This package contains different logic functions not defined in IEEE packages but used by _Open Logic_ internally or on its interfaces to the user (e.g. for port-widths depending on generics). The package is written mainly for these purposes and does not aim for completeness - nevertheless as a user you are free to use it for your code of course.

# VHDL Analysis for 'olo_base_pkg_logic.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing logic functions.
- Plus 41 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Functional Analysis

- May be part of a pipeline architecture
- Defines custom functions: zerosVector, onesVector, shiftLeft, shiftRight, binaryToGray, grayToBinary, ppcOr, to01X, to01X, to01, to01, invertBitOrder, invertByteOrder, zerosVector, onesVector, shiftLeft, shiftRight, binaryToGray, grayToBinary, ppcOr, to01X, to01X, to01, to01, invertBitOrder, invertByteOrder

## Code Metrics
- Line count: 302
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_logic.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

package olo_base_pkg_logic is

    function zerosVector (size : in natural) return std_logic_vector;

    function onesVector (size : in natural) return std_logic_vector;

    function shiftLeft (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector;

    function shiftRight (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector;

    function binaryToGray (binary : in std_logic_vector) return std_logic_vector;

    function grayToBinary (gray : in std_logic_vector) return std_logic_vector;

    function ppcOr (inp : in std_logic_vector) return std_logic_vector;

    function to01X (inp : in std_logic) return std_logic;

    function to01X (inp : in std_logic_vector) return std_logic_vector;

    function to01 (inp : in std_logic) return std_logic;

    function to01 (inp : in std_logic_vector) return std_logic_vector;

    function invertBitOrder (inp : in std_logic_vector) return std_logic_vector;

    function invertByteOrder (inp : in std_logic_vector) return std_logic_vector;

    constant Polynomial_Prbs2_c  : std_logic_vector( 1 downto 0) := ""11"";
    constant Polynomial_Prbs3_c  : std_logic_vector( 2 downto 0) := ""110"";
    constant Polynomial_Prbs4_c  : std_logic_vector( 3 downto 0) := ""1100"";
    constant Polynomial_Prbs5_c  : std_logic_vector( 4 downto 0) := ""10100"";
    constant Polynomial_Prbs6_c  : std_logic_vector( 5 downto 0) := ""110000"";
    constant Polynomial_Prbs7_c  : std_logic_vector( 6 downto 0) := ""1100000"";
    constant Polynomial_Prbs8_c  : std_logic_vector( 7 downto 0) := ""10111000"";
    constant Polynomial_Prbs9_c  : std_logic_vector( 8 downto 0) := ""100010000"";
    constant Polynomial_Prbs10_c : std_logic_vector( 9 downto 0) := ""1001000000"";
    constant Polynomial_Prbs11_c : std_logic_vector(10 downto 0) := ""10100000000"";
    constant Polynomial_Prbs12_c : std_logic_vector(11 downto 0) := ""100000101001"";
    constant Polynomial_Prbs13_c : std_logic_vector(12 downto 0) := ""1000000001101"";
    constant Polynomial_Prbs14_c : std_logic_vector(13 downto 0) := ""10000000010101"";
    constant Polynomial_Prbs15_c : std_logic_vector(14 downto 0) := ""110000000000000"";
    constant Polynomial_Prbs16_c : std_logic_vector(15 downto 0) := ""1101000000001000"";
    constant Polynomial_Prbs17_c : std_logic_vector(16 downto 0) := ""10010000000000000"";
    constant Polynomial_Prbs18_c : std_logic_vector(17 downto 0) := ""100000010000000000"";
    constant Polynomial_Prbs19_c : std_logic_vector(18 downto 0) := ""1000000000000100011"";
    constant Polynomial_Prbs20_c : std_logic_vector(19 downto 0) := ""10010000000000000000"";
    constant Polynomial_Prbs21_c : std_logic_vector(20 downto 0) := ""101000000000000000000"";
    constant Polynomial_Prbs22_c : std_logic_vector(21 downto 0) := ""1100000000000000000000"";
    constant Polynomial_Prbs23_c : std_logic_vector(22 downto 0) := ""10000100000000000000000"";
    constant Polynomial_Prbs24_c : std_logic_vector(23 downto 0) := ""111000010000000000000000"";
    constant Polynomial_Prbs25_c : std_logic_vector(24 downto 0) := ""1001000000000000000000000"";
    constant Polynomial_Prbs26_c : std_logic_vector(25 downto 0) := ""10000000000000000000100011"";
    constant Polynomial_Prbs27_c : std_logic_vector(26 downto 0) := ""100000000000000000000010011"";
    constant Polynomial_Prbs28_c : std_logic_vector(27 downto 0) := ""1001000000000000000000000000"";
    constant Polynomial_Prbs29_c : std_logic_vector(28 downto 0) := ""10100000000000000000000000000"";
    constant Polynomial_Prbs30_c : std_logic_vector(29 downto 0) := ""100000000000000000000000101001"";
    constant Polynomial_Prbs31_c : std_logic_vector(30 downto 0) := ""1001000000000000000000000000000"";
    constant Polynomial_Prbs32_c : std_logic_vector(31 downto 0) := ""10000000001000000000000000000011"";

end package;

package body olo_base_pkg_logic is

    function zerosVector (size : in natural) return std_logic_vector is
        constant Vector_c : std_logic_vector(size - 1 downto 0) := (others => '0');
    begin
        return Vector_c;
    end function;

    function onesVector (size : in natural) return std_logic_vector is
        constant Vector_c : std_logic_vector(size - 1 downto 0) := (others => '1');
    begin
        return Vector_c;
    end function;

    function shiftLeft (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector is
        constant ArgDownto_c : std_logic_vector(arg'high downto arg'low) := arg;
        variable Vector_v    : std_logic_vector(ArgDownto_c'range);
    begin
        if bits < 0 then
            return shiftRight(ArgDownto_c, -bits, fill);
        else
            Vector_v(Vector_v'left downto bits)      := ArgDownto_c(ArgDownto_c'left - bits downto ArgDownto_c'right);
            Vector_v(bits - 1 downto Vector_v'right) := (others => fill);
            return Vector_v;
        end if;
    end function;

    function shiftRight (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector is
        constant ArgDownto_c : std_logic_vector(arg'high downto arg'low) := arg;
        variable Vector_v    : std_logic_vector(ArgDownto_c'range);
    begin
        if bits < 0 then
            return shiftLeft(ArgDownto_c, -bits, fill);
        else
            Vector_v(Vector_v'left - bits downto Vector_v'right)    := ArgDownto_c(ArgDownto_c'left downto bits);
            Vector_v(Vector_v'left downto Vector_v'left - bits + 1) := (others => fill);
            return Vector_v;
        end if;
    end function;

    function binaryToGray (binary : in std_logic_vector) return std_logic_vector is
        variable Gray_v : std_logic_vector(binary'range);
    begin
        Gray_v := binary xor ('0' & binary(binary'high downto binary'low + 1));
        return Gray_v;
    end function;

    function grayToBinary (gray : in std_logic_vector) return std_logic_vector is
        variable Binary_v : std_logic_vector(gray'range);
    begin
        Binary_v(Binary_v'high) := gray(gray'high);

        for b in gray'high - 1 downto gray'low loop
            Binary_v(b) := gray(b) xor Binary_v(b + 1);
        end loop;

        return Binary_v;
    end function;

    function ppcOr (inp : in std_logic_vector) return std_logic_vector is
        constant Stages_c    : integer := log2ceil(inp'length);
        constant Pwr2Width_c : integer := 2**Stages_c;

        type StageOut_t is array (natural range <>) of std_logic_vector(Pwr2Width_c - 1 downto 0);

        variable StageOut_v : StageOut_t(0 to Stages_c);
        variable BinCnt_v   : unsigned(Pwr2Width_c - 1 downto 0);
    begin
        StageOut_v(0)                          := (others => '0');
        StageOut_v(0)(inp'length - 1 downto 0) := inp;

        for stage in 0 to Stages_c - 1 loop
            BinCnt_v := (others => '0');

            for idx in 0 to Pwr2Width_c - 1 loop
                if BinCnt_v(stage) = '0' then
                    StageOut_v(stage + 1)(idx) := StageOut_v(stage)(idx) or StageOut_v(stage)((idx / (2**stage) + 1) * 2**stage);
                else
                    StageOut_v(stage + 1)(idx) := StageOut_v(stage)(idx);
                end if;
                BinCnt_v := BinCnt_v + 1;
            end loop;

        end loop;

        return StageOut_v(Stages_c)(inp'length - 1 downto 0);
    end function;

    function to01X (inp : in std_logic) return std_logic is
    begin

        case inp is
            when '0' | 'L' => return '0';
            when '1' | 'H' => return '1';
            when others => return 'X';
        end case;

    end function;

    function to01X (inp : in std_logic_vector) return std_logic_vector is
        variable Result_v : std_logic_vector(inp'range);
    begin

        for i in inp'low to inp'high loop
            Result_v(i) := to01X(inp(i));
        end loop;

        return Result_v;
    end function;

    function to01 (inp : in std_logic) return std_logic is
    begin

        case inp is
            when '0' | 'L' => return '0';
            when '1' | 'H' => return '1';
            when others => return '0';
        end case;

    end function;

    function to01 (inp : in std_logic_vector) return std_logic_vector is
        variable Result_v : std_logic_vector(inp'range);
    begin

        for i in inp'low to inp'high loop
            Result_v(i) := to01(inp(i));
        end loop;

        return Result_v;
    end function;

    function invertBitOrder (inp : in std_logic_vector) return std_logic_vector is
        variable Inp_v    : std_logic_vector(inp'length-1 downto 0);
        variable Result_v : std_logic_vector(Inp_v'range);
    begin
        Inp_v := inp;

        for i in 0 to Inp_v'high loop
            Result_v(Result_v'high - i) := Inp_v(i);
        end loop;

        return Result_v;
    end function;

    function invertByteOrder (inp : in std_logic_vector) return std_logic_vector is
        constant Inp_c    : std_logic_vector(inp'length-1 downto 0) := inp;
        constant Bytes_c  : natural                                 := inp'length/8;
        variable Result_v : std_logic_vector(Inp_c'range);
        variable InByte_v : natural;
    begin

        assert inp'length mod 8 = 0
            report ""invertByteOrder(): Number of bits must be a multiple of 8""
            severity error;

        for byte in 0 to Bytes_c-1 loop
            InByte_v                         := Bytes_c - 1 - byte;
            Result_v(byte*8+7 downto byte*8) := Inp_c(InByte_v*8+7 downto InByte_v*8);
        end loop;

        return Result_v;
    end function;

end package body;"
"This package contains different mathematics functions not defined in IEEE packages but used by _Open Logic_ internally or on its interfaces to the user (e.g. for port-widths depending on generics). The package is written mainly for these purposes and does not aim for completeness - nevertheless as a user you are free to use it for your code of course. The package uses array-types (e.g. t_abool or t_areal) defined in [olo_base_pkg_array](./olo_base_pkg_array.md).

# VHDL Analysis for 'olo_base_pkg_math.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler, Benoit Stef
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing mathematchis functions
- Plus 78 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_array.all

## Functional Analysis

- Defines custom functions: log2, log2ceil, isPower2, greatestCommonFactor, leastCommonMultiple, max, min, max, min, choose, choose, choose, choose, choose, choose, choose, choose, count, count, count, int, toUslv, toSslv, toStdl, slv, fromUslv, fromSslv, fromStdl, fromString, fromString, maxArray, maxArray, minArray, minArray, countCommaSepElems, log2, log2ceil, isPower2, greatestCommonFactor, leastCommonMultiple, max, max, min, min, choose, choose, choose, choose, choose, choose, choose, choose, count, count, count, toUslv, toSslv, toStdl, fromUslv, fromSslv, fromStdl, fromString, fromString, maxArray, maxArray, minArray, minArray

## Code Metrics
- Line count: 660
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_math.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_array.all;

package olo_base_pkg_math is

    function log2 (arg : in natural) return natural;

    function log2ceil (arg : in natural) return natural;

    function isPower2 (arg : in natural) return boolean;

    function greatestCommonFactor (
        a : in positive;
        b : in positive) return positive;

    function leastCommonMultiple (
        a : in positive;
        b : in positive) return positive;

    function max (
        a : in integer;
        b : in integer) return integer;

    function min (
        a : in integer;
        b : in integer) return integer;

    function max (
        a : in real;
        b : in real) return real;

    function min (
        a : in real;
        b : in real) return real;

    function choose (
        s : in boolean;
        t : in std_logic;
        f : in std_logic) return std_logic;

    function choose (
        s : in boolean;
        t : in std_logic_vector;
        f : in std_logic_vector) return std_logic_vector;

    function choose (
        s : in boolean;
        t : in integer;
        f : in integer) return integer;

    function choose (
        s : in boolean;
        t : in string;
        f : in string) return string;

    function choose (
        s : in boolean;
        t : in real;
        f : in real) return real;

    function choose (
        s : in boolean;
        t : in unsigned;
        f : in unsigned) return unsigned;

    function choose (
        s : in boolean;
        t : in boolean;
        f : in boolean) return boolean;

    function choose (
        s : in boolean;
        t : in RealArray_t;
        f : in RealArray_t) return RealArray_t;

    function count (
        a : in IntegerArray_t;
        v : in integer) return integer;

    function count (
        a : in BoolArray_t;
        v : in boolean) return integer;

    function count (
        a : in std_logic_vector;
        v : in std_logic) return integer;

    function toUslv (
        input : integer;
        len   : integer) return std_logic_vector;

    function toSslv (
        input : integer;
        len   : integer) return std_logic_vector;

    function toStdl (input : integer range 0 to 1) return std_logic;

    function fromUslv (input : std_logic_vector) return integer;

    function fromSslv (input : std_logic_vector) return integer;

    function fromStdl (input : std_logic) return integer;

    function fromString (input : string) return real;

    function fromString (input : string) return RealArray_t;

    function maxArray (a : in IntegerArray_t) return integer;

    function maxArray (a : in RealArray_t) return real;

    function minArray (a : in IntegerArray_t) return integer;

    function minArray (a : in RealArray_t) return real;

end package;

package body olo_base_pkg_math is

    function countCommaSepElems (input : string) return natural is
        variable Count_v : natural := 1;
        variable Idx_v   : integer := input'low;
    begin

        while Idx_v <= input'high loop
            if input(Idx_v) = ',' then
                Count_v := Count_v + 1;
            end if;
            Idx_v := Idx_v + 1;
        end loop;

        return Count_v;
    end function;


    function log2 (arg : in natural) return natural is
        variable ArgShift_v : natural := arg;
        variable Log2_v     : natural := 0;
    begin

        while ArgShift_v > 1 loop
            ArgShift_v := ArgShift_v / 2;
            Log2_v     := Log2_v + 1;
        end loop;

        return Log2_v;
    end function;

    function log2ceil (arg : in natural) return natural is
    begin
        if arg = 0 then
            return 0;
        end if;
        return log2(arg * 2 - 1);
    end function;

    function isPower2 (arg : in natural) return boolean is
    begin
        if log2(arg) = log2ceil(arg) then
            return true;
        else
            return false;
        end if;
    end function;

    function greatestCommonFactor (
        a : in positive;
        b : in positive) return positive is
        variable Gcd_v : positive := min(a, b);
    begin

        while Gcd_v > 1 loop
            if a mod Gcd_v = 0 and b mod Gcd_v = 0 then
                return Gcd_v;
            end if;
            Gcd_v := Gcd_v - 1;
        end loop;

        return Gcd_v;
    end function;

    function leastCommonMultiple (
        a : in positive;
        b : in positive) return positive is
    begin
        return a * b / greatestCommonFactor(a, b);
    end function;

    function max (
        a : in integer;
        b : in integer) return integer is
    begin
        if a > b then
            return a;
        else
            return b;
        end if;
    end function;

    function max (
        a : in real;
        b : in real) return real is
    begin
        if a > b then
            return a;
        else
            return b;
        end if;
    end function;

    function min (
        a : in integer;
        b : in integer) return integer is
    begin
        if a > b then
            return b;
        else
            return a;
        end if;
    end function;

    function min (
        a : in real;
        b : in real) return real is
    begin
        if a > b then
            return b;
        else
            return a;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in std_logic;
        f : in std_logic) return std_logic is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in std_logic_vector;
        f : in std_logic_vector) return std_logic_vector is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in integer;
        f : in integer) return integer is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in string;
        f : in string) return string is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in real;
        f : in real) return real is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in unsigned;
        f : in unsigned) return unsigned is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in boolean;
        f : in boolean) return boolean is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in RealArray_t;
        f : in RealArray_t) return RealArray_t is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function count (
        a : in IntegerArray_t;
        v : in integer) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function count (
        a : in BoolArray_t;
        v : in boolean) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function count (
        a : in std_logic_vector;
        v : in std_logic) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function toUslv (
        input : integer;
        len   : integer) return std_logic_vector is
    begin
        return std_logic_vector(to_unsigned(input, len));
    end function;

    function toSslv (
        input : integer;
        len   : integer) return std_logic_vector is
    begin
        return std_logic_vector(to_signed(input, len));
    end function;

    function toStdl (input : integer range 0 to 1) return std_logic is
    begin
        if input = 1 then
            return '1';
        else
            return '0';
        end if;
    end function;

    function fromUslv (input : std_logic_vector) return integer is
    begin
        return to_integer(unsigned(input));
    end function;

    function fromSslv (input : std_logic_vector) return integer is
    begin
        return to_integer(signed(input));
    end function;

    function fromStdl (input : std_logic) return integer is
    begin
        assert input = '0' or input = '1'
            report ""fromStdl(): Illegal argument""
            severity error;
        if input = '0' then
            return 0;
        else
            return 1;
        end if;
    end function;

    function fromString (input : string) return real is
        constant Nbsp_c       : character := character'val(160);
        variable Idx_v        : integer   := input'low;
        variable IsNeg_v      : boolean   := false;
        variable ValInt_v     : integer   := 0;
        variable ValFrac_v    : real      := 0.0;
        variable FracDigits_v : integer   := 0;
        variable Exp_v        : integer   := 0;
        variable ExpNeg_v     : boolean   := false;
        variable ValAbs_v     : real      := 0.0;
    begin

        while (Idx_v <= input'high) and (input(Idx_v) = ' ' or input(Idx_v) = Nbsp_c or input(Idx_v) = HT) loop
            Idx_v := Idx_v + 1;
        end loop;

        if (Idx_v <= input'high) and ((input(Idx_v) = '-') or (input(Idx_v) = '+')) then
            IsNeg_v := (input(Idx_v) = '-');
            Idx_v   := Idx_v + 1;
        end if;

        while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
            ValInt_v := ValInt_v * 10 + (character'pos(input(Idx_v)) - character'pos('0'));
            Idx_v    := Idx_v + 1;
        end loop;

        if (Idx_v <= input'high) then
            if input(Idx_v) = '.' then
                Idx_v := Idx_v + 1;

                while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
                    ValFrac_v    := ValFrac_v * 10.0 + real((character'pos(input(Idx_v)) - character'pos('0')));
                    FracDigits_v := FracDigits_v + 1;
                    Idx_v        := Idx_v + 1;
                end loop;

            end if;
        end if;

        if (Idx_v <= input'high) then
            if (input(Idx_v) = 'E') or (input(Idx_v) = 'e') then
                Idx_v := Idx_v + 1;
                if (Idx_v <= input'high) and ((input(Idx_v) = '-') or (input(Idx_v) = '+')) then
                    ExpNeg_v := (input(Idx_v) = '-');
                    Idx_v    := Idx_v + 1;
                end if;

                while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
                    Exp_v := Exp_v * 10 + (character'pos(input(Idx_v)) - character'pos('0'));
                    Idx_v := Idx_v + 1;
                end loop;

                if ExpNeg_v then
                    Exp_v := -Exp_v;
                end if;
            end if;
        end if;

        ValAbs_v := (real(ValInt_v) + ValFrac_v / 10.0**real(FracDigits_v)) * 10.0**real(Exp_v);
        if IsNeg_v then
            return -ValAbs_v;
        else
            return ValAbs_v;
        end if;
    end function;

    function fromString (input : string) return RealArray_t is
        variable Array_v    : RealArray_t(0 to countCommaSepElems(input) - 1) := (others => 0.0);
        variable ArrayIdx_v : natural                                         := 0;
        variable StartIdx_v : natural                                         := 1;
        variable EndIdx_v   : natural                                         := 1;
        variable CharIdx_v  : natural                                         := input'low;
    begin

        while CharIdx_v <= input'high loop
            if input(CharIdx_v) = ',' then
                EndIdx_v            := CharIdx_v - 1;
                Array_v(ArrayIdx_v) := fromString(input(StartIdx_v to EndIdx_v));
                ArrayIdx_v          := ArrayIdx_v + 1;
                StartIdx_v          := CharIdx_v + 1;
            end if;
            CharIdx_v := CharIdx_v + 1;
        end loop;

        if StartIdx_v <= input'high then
            Array_v(ArrayIdx_v) := fromString(input(StartIdx_v to input'high));
        end if;

        return Array_v;
    end function;

    function maxArray (a : in IntegerArray_t) return integer is
        variable Max_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if max(Max_v, a(idx)) > Max_v then
                Max_v := a(idx);
            end if;
        end loop;

        return Max_v;
    end function;

    function maxArray (a : in RealArray_t) return real is
        variable Max_v : real := 0.0;
    begin

        for idx in a'low to a'high loop
            if max(Max_v, a(idx)) > Max_v then
                Max_v := a(idx);
            end if;
        end loop;

        return Max_v;
    end function;

    function minArray (a : in IntegerArray_t) return integer is
        variable Min_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if min(Min_v, a(idx)) < Min_v then
                Min_v := a(idx);
            end if;
        end loop;

        return Min_v;
    end function;

    function minArray (a : in RealArray_t) return real is
        variable Min_v : real := 0.0;
    begin

        for idx in a'low to a'high loop
            if min(Min_v, a(idx)) < Min_v then
                Min_v := a(idx);
            end if;
        end loop;

        return Min_v;
    end function;

end package body;"
"This package contains useful string-related functions.

# VHDL Analysis for 'olo_base_pkg_string.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing commonly used string manipulation functionality.
- Documentation:
- Plus 38 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: work.olo_base_pkg_math.all

## Functional Analysis

- Uses reset signal(s): first
- Implements arithmetic/computational functionality
- Defines custom functions: toUpper, toLower, trim, hex2StdLogicVector, countOccurence, toUpper, toLower, trim, hex2StdLogicVector, countOccurence

## Code Metrics
- Line count: 202
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_string.vhd' plays a specific role in the overall CPU architecture.
","
library ieee;
    use ieee.std_logic_1164.all;

library work;
    use work.olo_base_pkg_math.all;

package olo_base_pkg_string is

    function toUpper (a : in string) return string;
    function toLower (a : in string) return string;

    function trim (a : in string) return string;

    function hex2StdLogicVector (
        a         : in string;
        bits      : in natural;
        hasPrefix : in boolean := false) return std_logic_vector;

    function countOccurence (
        a : in string;
        c : in character) return natural;

end package;

package body olo_base_pkg_string is

    function toUpper (a : in string) return string is
        variable Res_v        : string(a'range);
        variable CharIdx_v    : natural;
        constant LowerUpper_c : natural := character'pos('a') - character'pos('A');
    begin

        for i in a'range loop
            CharIdx_v := character'pos(a(i));
            if CharIdx_v >= character'pos('a') and CharIdx_v <= character'pos('z') then
                CharIdx_v := CharIdx_v - LowerUpper_c;
            end if;
            Res_v(i) := character'val(CharIdx_v);
        end loop;

        return Res_v;
    end function;

    function toLower (a : in string) return string is
        variable Res_v        : string(a'range);
        variable CharIdx_v    : natural;
        constant LowerUpper_c : natural := character'pos('a') - character'pos('A');
    begin

        for i in a'range loop
            CharIdx_v := character'pos(a(i));
            if CharIdx_v >= character'pos('A') and CharIdx_v <= character'pos('Z') then
                CharIdx_v := CharIdx_v + LowerUpper_c;
            end if;
            Res_v(i) := character'val(CharIdx_v);
        end loop;

        return Res_v;
    end function;

    function trim (a : in string) return string is
        variable StartIdx_v : natural := a'left;
        variable EndIdx_v   : natural := a'right;
    begin

        while StartIdx_v < a'right and a(StartIdx_v) = ' ' loop
            StartIdx_v := StartIdx_v + 1;
        end loop;

        while EndIdx_v > a'left and a(EndIdx_v) = ' ' loop
            EndIdx_v := EndIdx_v - 1;
        end loop;

        return a(StartIdx_v to EndIdx_v);
    end function;

    function hex2StdLogicVector (
        a         : in string;
        bits      : in natural;
        hasPrefix : in boolean := false) return std_logic_vector is
        constant Trimmed_c   : string                                   := trim(toLower(a));
        constant MaxBits_c   : natural                                  := max(choose(hasPrefix, (Trimmed_c'length-2) * 4, Trimmed_c'length * 4), 0);
        variable StdlvFull_v : std_logic_vector(MaxBits_c - 1 downto 0) := (others => '0');
        variable Result_v    : std_logic_vector(bits - 1 downto 0)      := (others => '0');
        variable LowIdx_v    : natural                                  := 0;
        variable Nibble_v    : std_logic_vector(3 downto 0);
    begin
        if Trimmed_c'length = 0 then
            return Result_v;
        end if;

        if hasPrefix then
            assert Trimmed_c(Trimmed_c'left to Trimmed_c'left+1) = ""0x""
                report ""Invalid prefix in hex2StdLogicVector() - expected prefix is 0x - string: "" & a
                severity error;
            LowIdx_v := LowIdx_v + 2;
        end if;

        for i in Trimmed_c'left+LowIdx_v to Trimmed_c'right loop

            case Trimmed_c(i) is
                when '0' => Nibble_v := x""0"";
                when '1' => Nibble_v := x""1"";
                when '2' => Nibble_v := x""2"";
                when '3' => Nibble_v := x""3"";
                when '4' => Nibble_v := x""4"";
                when '5' => Nibble_v := x""5"";
                when '6' => Nibble_v := x""6"";
                when '7' => Nibble_v := x""7"";
                when '8' => Nibble_v := x""8"";
                when '9' => Nibble_v := x""9"";
                when 'a' => Nibble_v := x""A"";
                when 'b' => Nibble_v := x""B"";
                when 'c' => Nibble_v := x""C"";
                when 'd' => Nibble_v := x""D"";
                when 'e' => Nibble_v := x""E"";
                when 'f' => Nibble_v := x""F"";
                when others =>
                    report ""Invalid character in hex2StdLogicVector() - only 0-9, a-f, A-F are allowed - string: "" & a
                        severity error;
                    return Result_v;
            end case;

            StdlvFull_v := StdlvFull_v(StdlvFull_v'left - 4 downto 0) & Nibble_v;
        end loop;

        if bits > MaxBits_c then
            Result_v(MaxBits_c - 1 downto 0) := StdlvFull_v;
        else
            Result_v := StdlvFull_v(bits-1 downto 0);
        end if;
        return Result_v;
    end function;

    function countOccurence (
        a : in string;
        c : in character) return natural is
        variable Count_v : natural := 0;
    begin

        for i in a'range loop
            if a(i) = c then
                Count_v := Count_v + 1;
            end if;
        end loop;

        return Count_v;
    end function;

end package body;"
"This entity implements multiple pipeline stages with handshaking (AXI-S Ready/Valid). The pipeline stage ensures all signals are registered in both directions (including Ready). This is important to break long logic chains that can occur in the Ready  paths because Ready is often forwarded asynchronously. _olo_base_pl_stage_ is used for two main cases: - Breaking long logic paths into several sections, each one having a propagation time shorter than the clock period. In this case _olo_base_pl_stage_ usually is configured for _Stages_g_=1. - Adding multiple register stages for long routing paths. In this case _olo_base_pl_stage_ usually is configured for _Stages_g_>1.

# VHDL Analysis for 'olo_base_pl_stage.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2023-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a pipelinestage with handshaking (AXI-S Ready/Valild). The
- Plus 51 more comments

## Libraries and Packages
- Library: ieee
- Library: ieee
- Library: work
- Use: Rdy is often forwarded asynchronously.
--
-- Documentation:
-- https://github.com/open-logic/open-logic/blob/main/doc/base/olo_base_pl_stage.md
--
-- Note: The link points to the documentation of the latest release. If you
--       use an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------

library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_attribute.all
- Use: ready is deasserted only after one clock cycle
                if IsStuck_v then
                    v.DataShadVld := '1'

## Entity: olo_base_pl_stage

## Architecture: rtl of olo_base_pl_stage

### Signals
- Data: Data_t(0 to Stages_g)
- Valid: std_logic_vector(0 to Stages_g)
- Ready: std_logic_vector(0 to Stages_g)

### Component Declarations
- olo_private_pl_stage_single

## Functional Analysis

- Contains 2 clock domain(s): Clk, clock
- Uses reset signal(s): Rst
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 289
- Process count: 0
- Signal count: 3

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pl_stage.vhd' plays a specific role in the overall CPU architecture.
","


library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_pl_stage is
    generic (
        Width_g     : positive;
        UseReady_g  : boolean := true;
        Stages_g    : natural := 1
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_pl_stage is

    component olo_private_pl_stage_single is
        generic (
            Width_g     : positive;
            UseReady_g  : boolean   := true
        );
        port (
            Clk         : in    std_logic;
            Rst         : in    std_logic;
            In_Valid    : in    std_logic;
            In_Ready    : out   std_logic;
            In_Data     : in    std_logic_vector(Width_g-1 downto 0);
            Out_Valid   : out   std_logic;
            Out_Ready   : in    std_logic := '1';
            Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
        );
    end component;

    type Data_t is array (natural range <>) of std_logic_vector(Width_g - 1 downto 0);

    signal Data  : Data_t(0 to Stages_g);
    signal Valid : std_logic_vector(0 to Stages_g);
    signal Ready : std_logic_vector(0 to Stages_g);

begin

    g_nonzero : if Stages_g > 0 generate
        Valid(0) <= In_Valid;
        In_Ready <= Ready(0);
        Data(0)  <= In_Data;

        g_stages : for i in 0 to Stages_g - 1 generate

            i_stg : component olo_private_pl_stage_single
                generic map (
                    Width_g    => Width_g,
                    UseReady_g => UseReady_g
                )
                port map (
                    Clk       => Clk,
                    Rst       => Rst,
                    In_Valid  => Valid(i),
                    In_Ready  => Ready(i),
                    In_Data   => Data(i),
                    Out_Valid => Valid(i + 1),
                    Out_Ready => Ready(i + 1),
                    Out_Data  => Data(i + 1)
                );

        end generate;

        Out_Valid       <= Valid(Stages_g);
        Ready(Stages_g) <= Out_Ready;
        Out_Data        <= Data(Stages_g);
    end generate;

    g_zero : if Stages_g = 0 generate
        Out_Valid <= In_Valid;
        Out_Data  <= In_Data;
        In_Ready  <= Out_Ready;
    end generate;

end architecture;


library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_private_pl_stage_single is
    generic (
        Width_g     : positive;
        UseReady_g  : boolean := true
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_private_pl_stage_single is

    type TwoProcess_r is record
        DataMain    : std_logic_vector(Width_g - 1 downto 0);
        DataMainVld : std_logic;
        DataShad    : std_logic_vector(Width_g - 1 downto 0);
        DataShadVld : std_logic;
        In_Ready    : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    g_rdy : if UseReady_g generate

        p_comb : process (In_Valid, In_Data, Out_Ready, r) is
            variable v         : TwoProcess_r;
            variable IsStuck_v : boolean;
        begin
            v := r;

            IsStuck_v := (r.DataMainVld = '1' and Out_Ready = '0' and (In_Valid = '1' or r.DataShadVld = '1'));

            if r.DataMainVld = '1' and Out_Ready = '1' then
                v.DataMainVld := r.DataShadVld;
                v.DataMain    := r.DataShad;
                v.DataShadVld := '0';
            end if;

            if r.In_Ready = '1' and In_Valid = '1' then
                if IsStuck_v then
                    v.DataShadVld := '1';
                    v.DataShad    := In_Data;
                else
                    v.DataMainVld := '1';
                    v.DataMain    := In_Data;
                end if;
            end if;

            if IsStuck_v then
                v.In_Ready := '0';
            else
                v.In_Ready := '1';
            end if;

            r_next <= v;
        end process;

        In_Ready  <= r.In_Ready;
        Out_Valid <= r.DataMainVld;
        Out_Data  <= r.DataMain;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.DataMainVld <= '0';
                    r.DataShadVld <= '0';
                    r.In_Ready    <= '1';
                end if;
            end if;
        end process;

    end generate;

    g_nrdy : if not UseReady_g generate
        signal VldReg  : std_logic;
        signal DataReg : std_logic_vector(Width_g-1 downto 0);

        attribute shreg_extract of VldReg  : signal is ShregExtract_SuppressExtraction_c;
        attribute shreg_extract of DataReg : signal is ShregExtract_SuppressExtraction_c;

        attribute syn_srlstyle of VldReg  : signal is SynSrlstyle_FlipFlops_c;
        attribute syn_srlstyle of DataReg : signal is SynSrlstyle_FlipFlops_c;

        attribute dont_merge of VldReg  : signal is DontMerge_SuppressChanges_c;
        attribute dont_merge of DataReg : signal is DontMerge_SuppressChanges_c;

        attribute preserve of VldReg  : signal is Preserve_SuppressChanges_c;
        attribute preserve of DataReg : signal is Preserve_SuppressChanges_c;

        attribute syn_keep of VldReg  : signal is SynKeep_SuppressChanges_c;
        attribute syn_keep of DataReg : signal is SynKeep_SuppressChanges_c;

        attribute syn_preserve of VldReg  : signal is SynPreserve_SuppressChanges_c;
        attribute syn_preserve of DataReg : signal is SynPreserve_SuppressChanges_c;

    begin

        p_stg : process (Clk) is
        begin
            if rising_edge(Clk) then
                DataReg <= In_Data;
                VldReg  <= In_Valid;
                if Rst = '1' then
                    VldReg <= '0';
                end if;
            end if;
        end process;

        In_Ready  <= '1'; -- Not used!
        Out_Data  <= DataReg;
        Out_Valid <= VldReg;

    end generate;

end architecture;"
"This component generates a pseudorandom binary sequence based (PRBS) on a logic feed-back shift register (LFSR) method. A set of common polynomials (aiming the maximum cycle possible) is available in [olo_base_pkg_logic](./olo_base_pkg_logic.md) and can be passed to _olo_base_prbs_ through the generic _Polynomial_g_. The number of bits per symbol which is presented at the output is configurable. Polynomials are passed as _std_logic_vector_ where a one denotes every position where x^n is used: ""100010000"" means ""x⁹ +x⁵ + 1"". The initial state of the LFSR can be configured throuh _Seed_g_ at compile time or through _State_New_ at the moment where _State_Set='1'_ is asserted at runtime. Note that the state of an LFSR never should be zero - otherwise the LFSR will stay zero forever. Note that for the case of _BitsPerSymbol_g_ > _width(Polynomial_g)_ the LFSR is shifted _before_ the first symbol is produced. Hence _Seed_g_ (after reset) resp. _State_New_ (after setting the state) is ocurring in the highest bits of the first _Out_Data_ word - and the lower bits are the first results of the LFSR calculation.

# VHDL Analysis for 'olo_base_prbs.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Rafael Basso, Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description:
- -------------------------------------------------------------------------------------------------
- A generic pseudo random binary sequence based on a linear-feedback shifter
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.std_logic_misc.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_logic.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_prbs

## Architecture: rtl of olo_base_prbs

### Signals
- LfsrReg: std_logic_vector(LfsrLenght_c-1 downto 0)

### Processes
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- NextBit_v    := xor_reduce(LfsrMasked_v)
- Lfsr_v       := Lfsr_v(Lfsr_v'high-1 downto 0) & NextBit_v

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst
- Implements control logic
- Defines custom functions: function, lfsrInitValue

## Code Metrics
- Line count: 154
- Process count: 2
- Signal count: 1

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_prbs.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_math.all;

entity olo_base_prbs is
    generic (
        Polynomial_g    : std_logic_vector;
        Seed_g          : std_logic_vector;
        BitsPerSymbol_g : positive := 1;
        LfsrWidth_g     : natural  := 0 -- Deprecated, not used
    );
    port (
        Clk              : in    std_logic;
        Rst              : in    std_logic;
        Out_Data         : out   std_logic_vector(BitsPerSymbol_g-1 downto 0);
        Out_Ready        : in    std_logic                                        := '1';
        Out_Valid        : out   std_logic;
        State_Current    : out   std_logic_vector(Polynomial_g'length-1 downto 0);
        State_New        : in    std_logic_vector(Polynomial_g'length-1 downto 0) := (others => '0');
        State_Set        : in    std_logic                                        := '0'
    );
end entity;


architecture rtl of olo_base_prbs is

    constant LfsrLenght_c : natural := max(BitsPerSymbol_g, Polynomial_g'length);

    signal LfsrReg : std_logic_vector(LfsrLenght_c-1 downto 0);

    function lfsrUpdate (
        lfsrReg : std_logic_vector(LfsrLenght_c-1 downto 0);
        bits    : positive) return std_logic_vector is
        variable Lfsr_v       : std_logic_vector(LfsrLenght_c-1 downto 0) := lfsrReg;
        variable LfsrMasked_v : std_logic_vector(Polynomial_g'length-1 downto 0);
        variable NextBit_v    : std_logic;
    begin

        for bit in 0 to bits - 1 loop
            LfsrMasked_v := Lfsr_v(Polynomial_g'length-1 downto 0) and Polynomial_g;
            NextBit_v    := xor_reduce(LfsrMasked_v);
            Lfsr_v       := Lfsr_v(Lfsr_v'high-1 downto 0) & NextBit_v;
        end loop;

        return Lfsr_v;
    end function;

    function lfsrInitValue return std_logic_vector is
        variable Lfsr_v : std_logic_vector(LfsrLenght_c-1 downto 0) := (others => '0');
    begin
        Lfsr_v(Polynomial_g'length-1 downto 0) := Seed_g;

        if LfsrLenght_c > Polynomial_g'length then
            Lfsr_v := lfsrUpdate(Lfsr_v, LfsrLenght_c - Polynomial_g'length);
        end if;

        return Lfsr_v;

    end function;

begin

    assert Polynomial_g'length >= 2
        report ""###ERROR###: olo_base_prbs - Polynomial_g width must be at least 2""
        severity error;
    assert Seed_g'length = Polynomial_g'length
        report ""###ERROR###: olo_base_prbs - Seed_g width must match Polynomial_g width""
        severity error;
    assert fromUslv(Seed_g) /= 0
        report ""###ERROR###: olo_base_prbs - Seed_g MUST NOT be zero""
        severity error;
    assert BitsPerSymbol_g >= 1
        report ""###ERROR###: olo_base_prbs - BitsPerSymbol_g width must be larger or equal to 1""
        severity error;

    Out_Valid     <= '1';
    Out_Data      <= invertBitOrder(LfsrReg(LfsrReg'high downto LfsrReg'length-BitsPerSymbol_g));
    State_Current <= LfsrReg(State_Current'high downto 0);

    p_lfsr : process (Clk) is
        variable Lfsr_v : std_logic_vector(LfsrReg'range);
    begin
        if rising_edge(Clk) then
            if Out_Ready = '1' then
                LfsrReg <= lfsrUpdate(LfsrReg, BitsPerSymbol_g);
            end if;

            if State_Set = '1' then
                Lfsr_v                                 := (others => '0');
                Lfsr_v(Polynomial_g'length-1 downto 0) := State_New;
                if LfsrLenght_c > Polynomial_g'length then
                    Lfsr_v := lfsrUpdate(Lfsr_v, LfsrLenght_c - Polynomial_g'length);
                end if;
                LfsrReg <= Lfsr_v;
            end if;

            if Rst = '1' then
                LfsrReg <= lfsrInitValue;
            end if;

        end if;

    end process;

end architecture;"
"This component implements a **simple dual-port** RAM. It offers separate read and write ports. By default read and write port both run on the same clock but optionally the implementation with separate read/write clocks is supported. The RAM is implemented in pure VHDL but in a way that allows tools to implement it in block-RAMs.

# VHDL Analysis for 'olo_base_ram_sdp.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a pure VHDL and vendor indpendent simple dual port RAM with
- Plus 46 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: VHDL93 (supported by all tools) does not allow
    -- ... unconstrainted arrays as return types.
    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'))

## Entity: olo_base_ram_sdp

## Architecture: rtl of olo_base_ram_sdp

### Signals
- Wr_Ena_Byte: std_logic

### Component Declarations
- olo_private_ram_sdp_nobe

### Concurrent Statements
- i_ram : component olo_private_ram_sdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    IsAsync_g       => IsAsync_g,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk         => Clk,
                    Wr_Addr     => Wr_Addr,
                    Wr_Ena      => Wr_Ena_Byte,
                    Wr_Data     => Wr_Data(byte*8+7 downto byte*8),
                    Rd_Clk      => Rd_Clk,
                    Rd_Addr     => Rd_Addr,
                    Rd_Ena      => Rd_Ena,
                    Rd_Data     => Rd_Data(byte*8+7 downto byte*8)
                )

## Functional Analysis

- Contains 2 clock domain(s): Clk, Rd_Clk
- Implements memory functionality
- Implements control logic
- May be part of a pipeline architecture
- Defines custom functions: getInitContent

## Code Metrics
- Line count: 337
- Process count: 0
- Signal count: 1

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_ram_sdp.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_sdp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        IsAsync_g       : boolean  := false;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );
    port (
        Clk         : in    std_logic;
        Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Wr_Ena      : in    std_logic                                  := '1';
        Wr_Be       : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Rd_Clk      : in    std_logic                                  := '0';
        Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Rd_Ena      : in    std_logic                                  := '1';
        Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_sdp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_sdp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            IsAsync_g       : boolean  := false;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            Clk         : in    std_logic;
            Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            Wr_Ena      : in    std_logic                                  := '1';
            Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
            Rd_Clk      : in    std_logic                                  := '0';
            Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            Rd_Ena      : in    std_logic                                  := '1';
            Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_sdp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_sdp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                IsAsync_g       => IsAsync_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                Clk         => Clk,
                Wr_Addr     => Wr_Addr,
                Wr_Ena      => Wr_Ena,
                Wr_Data     => Wr_Data,
                Rd_Clk      => Rd_Clk,
                Rd_Addr     => Rd_Addr,
                Rd_Ena      => Rd_Ena,
                Rd_Data     => Rd_Data
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal Wr_Ena_Byte : std_logic;
        begin
            Wr_Ena_Byte <= Wr_Ena and Wr_Be(byte);

            i_ram : component olo_private_ram_sdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    IsAsync_g       => IsAsync_g,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk         => Clk,
                    Wr_Addr     => Wr_Addr,
                    Wr_Ena      => Wr_Ena_Byte,
                    Wr_Data     => Wr_Data(byte*8+7 downto byte*8),
                    Rd_Clk      => Rd_Clk,
                    Rd_Addr     => Rd_Addr,
                    Rd_Ena      => Rd_Ena,
                    Rd_Data     => Rd_Data(byte*8+7 downto byte*8)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_sdp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        IsAsync_g       : boolean  := false;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        Clk         : in    std_logic;
        Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Wr_Ena      : in    std_logic := '1';
        Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Rd_Clk      : in    std_logic := '0';
        Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Rd_Ena      : in    std_logic := '1';
        Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_sdp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipe : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipe : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_sdp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_sdp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    g_sync : if not IsAsync_g generate

        p_ram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if RamBehavior_g = ""RBW"" then
                    if Rd_Ena = '1' then
                        RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                    end if;
                end if;
                if Wr_Ena = '1' then
                    Mem_v(to_integer(unsigned(Wr_Addr))) := Wr_Data;
                end if;
                if RamBehavior_g = ""WBR"" then
                    if Rd_Ena = '1' then
                        RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                    end if;
                end if;

                RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    g_async : if IsAsync_g generate

        p_write : process (Clk) is
        begin
            if rising_edge(Clk) then
                if Wr_Ena = '1' then
                    Mem_v(to_integer(unsigned(Wr_Addr))) := Wr_Data;
                end if;
            end if;
        end process;

        p_read : process (Rd_Clk) is
        begin
            if rising_edge(Rd_Clk) then
                if Rd_Ena = '1' then
                    RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                end if;

                RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    Rd_Data <= RdPipe(RdLatency_g);

end architecture;"
"This component implements a **single-port** RAM. The RAM is implemented in pure VHDL but in a way that allows tools to implement it in block-RAMs.

# VHDL Analysis for 'olo_base_ram_sp.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a pure VHDL and vendor indpendent true single-port RAM with
- Plus 42 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: VHDL93 (supported by all tools) does not allow
    -- ... unconstrainted arrays as return types.
    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'))

## Entity: olo_base_ram_sp

## Architecture: rtl of olo_base_ram_sp

### Signals
- WrEna_Byte: std_logic

### Component Declarations
- olo_private_ram_sp_nobe

### Concurrent Statements
- i_ram : component olo_private_ram_sp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk             => Clk,
                    Addr            => Addr,
                    WrEna           => WrEna_Byte,
                    WrData          => WrData(byte*8+7 downto byte*8),
                    RdData          => RdData(byte*8+7 downto byte*8)
                )

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Implements memory functionality
- May be part of a pipeline architecture
- Defines custom functions: getInitContent

## Code Metrics
- Line count: 281
- Process count: 0
- Signal count: 1

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_ram_sp.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_sp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );
    port (
        Clk             : in    std_logic;
        Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
        Be              : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        WrEna           : in    std_logic                                  := '1';
        WrData          : in    std_logic_vector(Width_g - 1 downto 0);
        RdData          : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_sp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_sp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            Clk             : in    std_logic;
            Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
            WrEna           : in    std_logic := '1';
            WrData          : in    std_logic_vector(Width_g - 1 downto 0);
            RdData          : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_sp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_sp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                Clk             => Clk,
                Addr            => Addr,
                WrEna           => WrEna,
                WrData          => WrData,
                RdData          => RdData
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal WrEna_Byte : std_logic;
        begin
            WrEna_Byte <= WrEna and Be(byte);

            i_ram : component olo_private_ram_sp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk             => Clk,
                    Addr            => Addr,
                    WrEna           => WrEna_Byte,
                    WrData          => WrData(byte*8+7 downto byte*8),
                    RdData          => RdData(byte*8+7 downto byte*8)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_sp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        Clk             : in    std_logic;
        Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
        WrEna           : in    std_logic := '1';
        WrData          : in    std_logic_vector(Width_g - 1 downto 0);
        RdData          : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_sp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipe : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipe : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_sp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_sp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    p_ram : process (Clk) is
    begin
        if rising_edge(Clk) then
            if RamBehavior_g = ""RBW"" then
                RdPipe(1) <= Mem_v(to_integer(unsigned(Addr)));
            end if;
            if WrEna = '1' then
                Mem_v(to_integer(unsigned(Addr))) := WrData;
            end if;
            if RamBehavior_g = ""WBR"" then
                RdPipe(1) <= Mem_v(to_integer(unsigned(Addr)));
            end if;

            RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
        end if;
    end process;

    RdData <= RdPipe(RdLatency_g);

end architecture;"
"This component implements a **true dual-port** RAM. It offers two ports, which both allow reading and writing. The two ports run on separate clocks - although connecting the same clock to both ports is allowed. The RAM is implemented in pure VHDL but in a way that allows tools to implement it in block-RAMs.

# VHDL Analysis for 'olo_base_ram_tdp.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a pure VHDL and vendor indpendent true dual port RAM with optional
- Plus 55 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: VHDL93 (supported by all tools) does not allow
    -- ... unconstrainted arrays as return types.
    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'))

## Entity: olo_base_ram_tdp

## Architecture: rtl of olo_base_ram_tdp

### Signals
- A_WrEna_Byte: std_logic
- B_WrEna_Byte: std_logic

### Component Declarations
- olo_private_ram_tdp_nobe

### Concurrent Statements
- B_WrEna_Byte <= B_WrEna and B_Be(byte)
- i_ram : component olo_private_ram_tdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => 8*byte
                )
                port map (
                    A_Clk     => A_Clk,
                    A_Addr    => A_Addr,
                    A_WrEna   => A_WrEna_Byte,
                    A_WrData  => A_WrData(8*(byte+1)-1 downto 8*byte),
                    A_RdData  => A_RdData(8*(byte+1)-1 downto 8*byte),
                    B_Clk     => B_Clk,
                    B_Addr    => B_Addr,
                    B_WrEna   => B_WrEna_Byte,
                    B_WrData  => B_WrData(8*(byte+1)-1 downto 8*byte),
                    B_RdData  => B_RdData(8*(byte+1)-1 downto 8*byte)
                )

## Functional Analysis

- Contains 2 clock domain(s): A_Clk, B_Clk
- Implements memory functionality
- May be part of a pipeline architecture
- Defines custom functions: getInitContent

## Code Metrics
- Line count: 362
- Process count: 0
- Signal count: 2

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_ram_tdp.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_tdp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );                                                      -- ""RBW"" = read-before-write, ""WBR"" = write-before-read
    port (
        A_Clk     : in    std_logic;
        A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        A_Be      : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        A_WrEna   : in    std_logic                                  := '0';
        A_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
        A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
        B_Clk     : in    std_logic;
        B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        B_Be      : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        B_WrEna   : in    std_logic                                  := '0';
        B_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
        B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_tdp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_tdp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            A_Clk     : in    std_logic;
            A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            A_WrEna   : in    std_logic                                  := '0';
            A_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
            A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
            B_Clk     : in    std_logic;
            B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            B_WrEna   : in    std_logic                                  := '0';
            B_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
            B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_tdp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_tdp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                A_Clk     => A_Clk,
                A_Addr    => A_Addr,
                A_WrEna   => A_WrEna,
                A_WrData  => A_WrData,
                A_RdData  => A_RdData,
                B_Clk     => B_Clk,
                B_Addr    => B_Addr,
                B_WrEna   => B_WrEna,
                B_WrData  => B_WrData,
                B_RdData  => B_RdData
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal A_WrEna_Byte : std_logic;
            signal B_WrEna_Byte : std_logic;
        begin
            A_WrEna_Byte <= A_WrEna and A_Be(byte);
            B_WrEna_Byte <= B_WrEna and B_Be(byte);

            i_ram : component olo_private_ram_tdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => 8*byte
                )
                port map (
                    A_Clk     => A_Clk,
                    A_Addr    => A_Addr,
                    A_WrEna   => A_WrEna_Byte,
                    A_WrData  => A_WrData(8*(byte+1)-1 downto 8*byte),
                    A_RdData  => A_RdData(8*(byte+1)-1 downto 8*byte),
                    B_Clk     => B_Clk,
                    B_Addr    => B_Addr,
                    B_WrEna   => B_WrEna_Byte,
                    B_WrData  => B_WrData(8*(byte+1)-1 downto 8*byte),
                    B_RdData  => B_RdData(8*(byte+1)-1 downto 8*byte)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_tdp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        A_Clk     : in    std_logic;
        A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        A_WrEna   : in    std_logic                              := '0';
        A_WrData  : in    std_logic_vector(Width_g - 1 downto 0) := (others => '0');
        A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
        B_Clk     : in    std_logic;
        B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        B_WrEna   : in    std_logic                              := '0';
        B_WrData  : in    std_logic_vector(Width_g - 1 downto 0) := (others => '0');
        B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_tdp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipeA, RdPipeB : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipeA : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RdPipeB : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_tdp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_tdp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    g_wbr : if RamBehavior_g = ""WBR"" generate

        p_porta : process (A_Clk) is
        begin
            if rising_edge(A_Clk) then
                if A_WrEna = '1' then
                    Mem_v(to_integer(unsigned(A_Addr))) := A_WrData;
                end if;
                RdPipeA(1) <= Mem_v(to_integer(unsigned(A_Addr)));

                RdPipeA(2 to RdLatency_g) <= RdPipeA(1 to RdLatency_g-1);
            end if;
        end process;

        p_portb : process (B_Clk) is
        begin
            if rising_edge(B_Clk) then
                if B_WrEna = '1' then
                    Mem_v(to_integer(unsigned(B_Addr))) := B_WrData;
                end if;
                RdPipeB(1) <= Mem_v(to_integer(unsigned(B_Addr)));

                RdPipeB(2 to RdLatency_g) <= RdPipeB(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    g_rbw : if RamBehavior_g = ""RBW"" generate

        p_porta : process (A_Clk) is
        begin
            if rising_edge(A_Clk) then
                RdPipeA(1) <= Mem_v(to_integer(unsigned(A_Addr)));
                if A_WrEna = '1' then
                    Mem_v(to_integer(unsigned(A_Addr))) := A_WrData;
                end if;

                RdPipeA(2 to RdLatency_g) <= RdPipeA(1 to RdLatency_g-1);
            end if;
        end process;

        p_portb : process (B_Clk) is
        begin
            if rising_edge(B_Clk) then
                RdPipeB(1) <= Mem_v(to_integer(unsigned(B_Addr)));
                if B_WrEna = '1' then
                    Mem_v(to_integer(unsigned(B_Addr))) := B_WrData;
                end if;

                RdPipeB(2 to RdLatency_g) <= RdPipeB(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    A_RdData <= RdPipeA(RdLatency_g);
    B_RdData <= RdPipeB(RdLatency_g);

end architecture;"
"This component generates reset pulses of a specified minimum duration after FPGA configuration and optionally upon request (reset input). The component does guarantee synchronous de-assertion of the reset. Assertion is asynchronous or synchronous, depending on the users choice. **Note:** Because the reset input is detected asynchronously, it is important that this input is glitch-free. The block comes with automatic constraints. For manual constraining, a  or a constraint is required for the _RstIn_ input (if it is used). **Note:** Automatic constraining currently only works for _AMD_ tools (_Vivado_) and the usage in VHDL. Manual constraints are required for Verilog or other tools. **WARNING:** Reset assertion upon FPGA configuration relies on the **target technology supporting specific FF initialization state**. For the most common target technologies (namely AMD and altera) this is given. However, for technologies which do not support specifying FF initialization state (e.g. Microchip devices) an external reset signal must be connected to _RstIn_ - _RstOut_ will not be asserted upon FPGA configuration. If in doubt, refer to the the documentation of your target technology or play it safe and connect _RstIn_.

# VHDL Analysis for 'olo_base_reset_gen.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a reset generator. It generates a pulse of the specified duration
- after FPGA configuration. The reset output is High-Active according to the
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_reset_gen

## Architecture: struct of olo_base_reset_gen

### Signals
- RstSyncChain: std_logic_vector(2 downto 0)              := ""111""
- RstSync: std_logic
- DsSync: std_logic_vector(SyncStages_g-1 downto 0) := (others => '1')
- PulseCnt: integer range 0 to PulseCntMax_c := 0
- RstPulse: std_logic                        := '1'
- is ShregExtract_SuppressExtraction_c;
    attribute syn_srlstyle of DsSync: signal is SynSrlstyle_FlipFlops_c
- is DontMerge_SuppressChanges_c;
    attribute preserve of DsSync: signal is Preserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_keep of DsSync: signal is SynKeep_SuppressChanges_c
- is AsyncReg_TreatAsync_c;

begin

    -- Reset Synchronizer
    p_rstsync: process (Clk, RstIn) is
    begin
        if RstIn = RstInPolarity_g then
            RstSyncChain <= (others => '1')

### Processes
- Process 'p_rstsync :' (Clocked) (Has Reset) with sensitivity list: Clk, RstIn
  - Implements synchronous logic
- Process 'p_sync :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_prolong :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_rstsync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_sync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_prolong :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- elsif rising_edge(Clk) then
            RstSyncChain <= RstSyncChain(RstSyncChain'left - 1 downto 0) & '0'

## Functional Analysis

- Contains 2 clock domain(s): clock, Clk
- Uses reset signal(s): RstPulseCycles_g, olo_base_reset_gen, RstSync, resets, reset, Reset, p_rstsync, RstOut, RstSyncChain, RstIn, RstPulse, RstInPolarity_g, AsyncResetOutput_g

## Code Metrics
- Line count: 150
- Process count: 6
- Signal count: 9

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_reset_gen.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;

entity olo_base_reset_gen is
    generic (
        RstPulseCycles_g    : positive range 3 to positive'high := 3;
        RstInPolarity_g     : std_logic                         := '1';
        AsyncResetOutput_g  : boolean                           := false;
        SyncStages_g        : positive range 2 to 4             := 2
    );
    port (
        Clk         : in    std_logic;
        RstOut      : out   std_logic;
        RstIn       : in    std_logic := not RstInPolarity_g
    );
end entity;

architecture struct of olo_base_reset_gen is

    signal RstSyncChain : std_logic_vector(2 downto 0)              := ""111"";
    signal RstSync      : std_logic;
    signal DsSync       : std_logic_vector(SyncStages_g-1 downto 0) := (others => '1');

    constant PulseCntMax_c : natural                          := max(RstPulseCycles_g-4, 0);
    signal PulseCnt        : integer range 0 to PulseCntMax_c := 0;
    signal RstPulse        : std_logic                        := '1';

    attribute shreg_extract of DsSync : signal is ShregExtract_SuppressExtraction_c;
    attribute syn_srlstyle of DsSync  : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of DsSync   : signal is DontMerge_SuppressChanges_c;
    attribute preserve of DsSync     : signal is Preserve_SuppressChanges_c;
    attribute syn_preserve of DsSync : signal is SynPreserve_SuppressChanges_c;
    attribute syn_keep of DsSync     : signal is SynKeep_SuppressChanges_c;

    attribute async_reg of DsSync : signal is AsyncReg_TreatAsync_c;

begin

    p_rstsync : process (Clk, RstIn) is
    begin
        if RstIn = RstInPolarity_g then
            RstSyncChain <= (others => '1');
        elsif rising_edge(Clk) then
            RstSyncChain <= RstSyncChain(RstSyncChain'left - 1 downto 0) & '0';
        end if;
    end process;

    g_async : if AsyncResetOutput_g generate
        RstSync <= RstSyncChain(RstSyncChain'left);
    end generate;

    g_sync : if not AsyncResetOutput_g generate

        p_sync : process (Clk) is
        begin
            if rising_edge(Clk) then
                DsSync <= DsSync(DsSync'left - 1 downto 0) & RstSyncChain(RstSyncChain'left);
            end if;
        end process;

        RstSync <= DsSync(DsSync'left);
    end generate;

    g_prolong : if RstPulseCycles_g > 3 generate

        p_prolong : process (Clk) is
        begin
            if rising_edge(Clk) then
                if RstSync = '1' then
                    PulseCnt <= 0;
                    RstPulse <= '1';
                else
                    if PulseCnt = PulseCntMax_c then
                        RstPulse <= '0';
                    else
                        PulseCnt <= PulseCnt + 1;
                    end if;
                end if;
            end if;
        end process;

        g_async : if AsyncResetOutput_g generate
            RstOut <= RstPulse or RstSync;

        end generate;

        g_sync : if not AsyncResetOutput_g generate
            RstOut <= RstPulse;
        end generate;

    end generate;

    g_direct : if RstPulseCycles_g <= 3 generate
        RstOut <= RstSync;
    end generate;

end architecture;"
"This component takes single-cycle pulses as inputs and divides the pulse frequency. The ratio can be configured at runtime or at compile-time. To use the compile-time variant, just leave the _In_Ratio_ port unconnected and assign the ratio to _MaxRatio_g_. The latency can be selected to be 0 (combinatorial output) or 1 (registered output) clock cycle through the generic _Latency_g_. Registered output (_Latency_g_=1) is preferred for timing optimization reasons. Below figure shows an example for a ratio of 3. The entity can also be used to convert single cycle pulses into pulses that stay active until acknowledged by _Out_Ready_='1'. For this usage, simply use _MaxRatio_g=1_ and leave _In_Ratio_ unconnected. Note that for runtime configurable ratio, _In_Ratio_ must be set to the **desired ratio minus one**. E.g. to forward every third pulse to the output, _In_Ratio_ must be set to 2.

# VHDL Analysis for 'olo_base_strobe_div.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef, Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic strobe divider. It forwards only every Nth single
- cycle pulse to the output.
- Plus 20 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_strobe_div

## Architecture: rtl of olo_base_strobe_div

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
        r_next <= v;
    end process;

    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' with sensitivity list: r, In_Valid, In_Ratio, Out_Ready
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Ratio Counter
        if In_Valid = '1' then
            if r.Count >= unsigned(In_Ratio) or MaxRatio_g = 1 then
                v.Count    := 0
- v.OutValid := '1'
- else
                v.Count := r.Count + 1

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 110
- Process count: 4
- Signal count: 3

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_strobe_div.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_strobe_div is
    generic (
        MaxRatio_g  : positive;
        Latency_g   : natural range 0 to 1 := 1
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Ratio    : in    std_logic_vector(log2ceil(MaxRatio_g)-1 downto 0) := toUslv(MaxRatio_g-1, log2ceil(MaxRatio_g));
        In_Valid    : in    std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic                                         := '1'
    );
end entity;

architecture rtl of olo_base_strobe_div is

    type TwoProcess_r is record
        Count    : natural range 0 to MaxRatio_g-1;
        OutValid : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    p_comb : process (r, In_Valid, In_Ratio, Out_Ready) is
        variable OutValid_v : std_logic;
        variable v          : TwoProcess_r;
    begin
        v := r;

        if In_Valid = '1' then
            if r.Count >= unsigned(In_Ratio) or MaxRatio_g = 1 then
                v.Count    := 0;
                v.OutValid := '1';
            else
                v.Count := r.Count + 1;
            end if;
        end if;

        if Latency_g = 0 then
            OutValid_v := v.OutValid;
        else
            OutValid_v := r.OutValid;
        end if;

        if OutValid_v = '1' and Out_Ready = '1' then
            v.OutValid := '0';
        end if;

        Out_Valid <= OutValid_v;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Count    <= 0;
                r.OutValid <= '0';
            end if;
        end if;
    end process;

end architecture;"
"This component generates pulse at a fixed frequency. It optionally allows synchronization of those events to an input. In the most simple use-case, single cycle pulses are generated free-running at a fixed frequency. To achieve this, _Out_Ready_ and _In_Sync_ can be left unconnected. Bellow figure depicts this situation for _FreqClkHz_g=5e6_ and _FreqStrobeHz_g=1e6_. Additionally the strobe phase can be synchronized to _In_Sync_. In this case, the event is synchronized to the rising edge of the _In_Sync_ input. If the _Out_Ready_ signal is connected, _Out_Valid_ stays asserted until _Out_Ready_ and _Out_Valid_ are asserted at the same time (AXI4-Stream hanshaking). Note that in this case, the rising edges of _Out_Valid_ occur at _FreqStrobeHz_g_ independently of how long the signal stays asserted. However, _Out_Ready_ and _In_Sync_ are optional signals and can be left unconnected in the standard-case where just a pulse with a known frequency is required. The strobe generator by default works in _aequidistant mode_: It produces _Out_Valid_ pulses that are always the same number of clock-cycles apart from each other. This has the down-side of the output strobe period being off by up to half a clock period - which finally leads to a slightly shifted frequency. Alternatively the strobe generator can be used in _fractional mode_ (by setting _FractionalMode_g=true_). In this mode, the strobe generator does vary the time between _Out_Valid_ pulses by one clock cycle to meet the _FreqStrobeHz_g_ with less than 1% of error _on average_ (over a long time). Use _fractional mode_ if _FreqStrobeHz_g_ is relatively close to _FreqClkHz_g_ and the exact strobe frequency is important. Use _aequidistant mode_ if a constant number of clock cycles between _Out_Valid_ pulses is required.

# VHDL Analysis for 'olo_base_strobe_gen.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef, Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic strobe generator. It produces pulses with a duration
- Plus 22 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_strobe_gen

## Architecture: rtl of olo_base_strobe_gen

### Signals
- Declarations
    signal Count: integer range 0 to PeriodCounts_c-1
- SyncLast: std_logic

### Processes
- Process 'p_strobe :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_strobe :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- Out_Valid <= '1'
- -- Wraparound
            elsif Count >= WrapBorder_c then
                Out_Valid <= '1'
- if FractionalMode_g then
                    Count <= Count - WrapBorder_c
- else
                    Count <= 0

## Functional Analysis

- Contains 2 clock domain(s): clock, Clk
- Uses reset signal(s): Reset, Rst

## Code Metrics
- Line count: 104
- Process count: 2
- Signal count: 2

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_strobe_gen.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_strobe_gen is
    generic (
        FreqClkHz_g      : real;
        FreqStrobeHz_g   : real;
        FractionalMode_g : boolean := false
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Sync     : in    std_logic := '0';
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1'
    );
end entity;

architecture rtl of olo_base_strobe_gen is

    constant PeriodCountsFractional_c : integer := integer(round(FreqClkHz_g*100.0 / FreqStrobeHz_g));
    constant PeriodCountsInteger_c    : integer := integer(round(FreqClkHz_g / FreqStrobeHz_g));
    constant PeriodCounts_c           : integer := choose(FractionalMode_g, PeriodCountsFractional_c, PeriodCountsInteger_c);

    constant Increment_c  : integer := choose(FractionalMode_g, 100, 1);
    constant WrapBorder_c : integer := PeriodCounts_c - Increment_c;

    signal Count    : integer range 0 to PeriodCounts_c-1;
    signal SyncLast : std_logic;

begin

    p_strobe : process (Clk) is
    begin
        if rising_edge(Clk) then
            if (In_Sync = '1') and (SyncLast = '0') then
                Count     <= 0;
                Out_Valid <= '1';
            elsif Count >= WrapBorder_c then
                Out_Valid <= '1';
                if FractionalMode_g then
                    Count <= Count - WrapBorder_c;
                else
                    Count <= 0;
                end if;
            else
                if Out_Ready = '1' then
                    Out_Valid <= '0';
                end if;
                Count <= Count + Increment_c;
            end if;
            SyncLast <= In_Sync;

            if Rst = '1' then
                Count     <= 0;
                Out_Valid <= '0';
                SyncLast  <= '0';
            end if;
        end if;
    end process;

end architecture;"
"This component allows selecting one unique channel over a bunch of ""N"" time division multiplexed (tdm, see [Conventions](../Conventions.md)) data. Note that the number of channels must be compile-time defined (i.e. the entity does not support variable number of channels at run-time). The select signal _In_ChSel_ is sampled when the data of the first channel of a TDM burst arrives. The output _Out_Data_/_Out_Valid_ is asserted after the last channel of a TDM burst was received. The state of the _In_ChSel_ signal in between the _CH0_ inputs (where it is sampled) does not have any effect as depicted by the figure below. The entity does automatically synchronize the channel counter to _In_Last_. However, it can also be used in absence of _In_Last_. In this case the first sample after reset is interpreted as channel 0 and the channel-counter is freerunning. If _In_Last_ is asserted on the last channel in a TDM burst, the corresponding output hast _Out_Last_ asserted (independently of which channel was selected). This behavior allows to signal packet-boundaries throughout the _olo_base_tdm_mux_.

# VHDL Analysis for 'olo_base_tdm_mux.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic mux for Time Division Multiplxed data input
- Plus 23 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_tdm_mux

## Architecture: rtl of olo_base_tdm_mux

### Signals
- Count_0: integer range 0 to Channels_g-1 := 0
- SelLatched_1: std_logic_vector(In_ChSel'range)
- Data_1: std_logic_vector(In_Data'range)
- Count_1: integer range 0 to Channels_g-1
- Vld_1: std_logic
- Last_1: std_logic
- Data_2: std_logic_vector(In_Data'range)
- Vld_2: std_logic
- Last_2: std_logic

### Processes
- Process 'p_decode :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_decode :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst
- May be part of a pipeline architecture

## Code Metrics
- Line count: 118
- Process count: 2
- Signal count: 9

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_tdm_mux.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_tdm_mux is
    generic (
        Channels_g  : natural;
        Width_g     : natural
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_ChSel    : in    std_logic_vector(log2ceil(Channels_g)-1 downto 0);
        In_Valid    : in    std_logic := '1';
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        In_Last     : in    std_logic := '0';
        Out_Valid   : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0);
        Out_Last    : out   std_logic
    );
end entity;

architecture rtl of olo_base_tdm_mux is

    signal Count_0      : integer range 0 to Channels_g-1 := 0;
    signal SelLatched_1 : std_logic_vector(In_ChSel'range);
    signal Data_1       : std_logic_vector(In_Data'range);
    signal Count_1      : integer range 0 to Channels_g-1;
    signal Vld_1        : std_logic;
    signal Last_1       : std_logic;
    signal Data_2       : std_logic_vector(In_Data'range);
    signal Vld_2        : std_logic;
    signal Last_2       : std_logic;

begin

    p_decode : process (Clk) is
    begin
        if rising_edge(Clk) then

            if In_Valid = '1' then
                if Count_0 = 0 then
                    SelLatched_1 <= In_ChSel;
                end if;
                if (Count_0 = Channels_g-1) or (In_Last = '1') then
                    Count_0 <= 0;
                else
                    Count_0 <= Count_0 + 1;
                end if;
            end if;
            Data_1  <= In_Data;
            Vld_1   <= In_Valid;
            Count_1 <= Count_0;
            Last_1  <= In_Last;

            if Count_1 = unsigned(SelLatched_1) then
                Data_2 <= Data_1;
            end if;
            Vld_2 <= '0';
            if Vld_1 = '1' and Count_1 = Channels_g-1 then
                Vld_2 <= '1';
            end if;
            Last_2 <= Last_1;

            if Rst = '1' then
                Count_0 <= 0;
                Vld_2   <= '0';
                Vld_1   <= '0';
            end if;
        end if;
    end process;

    Out_Valid <= Vld_2;
    Out_Data  <= Data_2;
    Out_Last  <= Last_2;

end architecture;"
"This component implements a width conversion between arbitrary word widths. It can handle continuous or packetized data-streams and optionally supports the usage of byte-enable signals (for input and output widths being a multiple of 8-bits only). The width conversion implements AXI-S handshaking signals to handle back-pressure. The with conversion supports back-to-back conversions (_In_Valid_ can stay high all the time). It also handles the last-flag correctly according to AXI-S specification. If _In_Last_ is asserted, all data is flushed out and _Out_Last_ is asserted accordingly. Usage examples: - Conversion from 8-bit (byte oriented) data to 7-bit for the usage with 7-bit LVDS serializers - Conversion from 24-bit to 32-bit in order to write 24-bit video pixel-data efficiently to a 32-bit wide memory Note that for integer ratio width conversions, [olo_base_wconv_n2xn](./olo_base_wconv_n2xn.md) and [olo_base_wconv_xn2n](./olo_base_wconv_xn2n.md) shall be used because they are more resource efficient and timing optimal. The entity does little-endian data alignment as shown in the figures below (the first word received on the input is packet into the output bits with the lowest index). Below example shows a conversion from 16 to 24 bit. Backpressure (_Out_Ready_ going low) is not depicted for simplicity reasons (but fully supported by the implementation). Interesting is the last packet (blue) which contains an all zero word at the end, because without byte enable from the input data 0x**00**66 it cannot be known if the zeros represent a data byte being zero or if it is a padding byte. Similarly in the last output word of the orange packet, two padding bytes are inserted (0x**0000**DD) but to a receiver this might not be clear due to the missing byte enables. Below example is similar but uses byte enables to indicate padding bytes on the input as well as on the output. The blue packet is now also shorter by one cycle because padding bytes at the end of the packet are removed. Byte enables (_UseBe_g=true_) are only supported when both, _InWidth_g_ and _OutWidth_g_, are multiples of 8. For inputs or outputs not being mutiples of bytes, the behavior of _In_Be_ and _Out_Be_ byte-enable signals is undefined. **The usage of byte-enables is limited to indicating that not all bytes are used in the last beat of a packet**. Any _In_Be_ being low in any other word of a packet than the last one (_In_Last='1'_) are not allowed and will lead to error messages in simulations as well as undefined behavior in synthesis. _olo_Base_wconv_n2m_ can be used for non-byte-aligned data as well. In this case byte enables are not supported, otherwise the block behaves the same as for byte-oriented data. Backpressure (_Out_Ready_ going low) is not depicted for simplicity reasons (but fully supported by the implementation). Below example shows a 8-bit to 7-bit conversion, as required for 7-bit LVDS serializers. And of course the conversion into the other direction (7-bit to 8-bit) is possible as well:$

# VHDL Analysis for 'olo_base_wconv_n2m.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple data-width conversion between arbitrary input and output
- widths.
- Plus 35 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: ieee.std_logic_misc.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_wconv_n2m

## Architecture: rtl of olo_base_wconv_n2m

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
            r_next <= v;
        end process;

        p_seq: process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Valid, In_Data, Out_Ready, In_Last, In_Be, Rst
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Output transaction
            Out_Valid_v  := '0'
- IsLastBeat_v := or_reduce(r.LastChunk(OutChunks_c - 1 downto 0))
- if (r.ChunkCnt >= OutChunks_c) or (IsLastBeat_v = '1') then
                Out_Valid_v := '1'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 204
- Process count: 4
- Signal count: 3

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_wconv_n2m.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;
    use ieee.std_logic_misc.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_n2m is
    generic (
        InWidth_g  : positive := 16;
        OutWidth_g : positive := 24;
        UseBe_g    : boolean  := false
    );
    port (
        Clk          : in    std_logic;
        Rst          : in    std_logic;
        In_Valid     : in    std_logic                                    := '1';
        In_Ready     : out   std_logic;
        In_Data      : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Be        : in    std_logic_vector(InWidth_g / 8 - 1 downto 0) := (others => '1');
        In_Last      : in    std_logic                                    := '0';
        Out_Valid    : out   std_logic;
        Out_Ready    : in    std_logic                                    := '1';
        Out_Data     : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Be       : out   std_logic_vector(OutWidth_g / 8 - 1 downto 0);
        Out_Last     : out   std_logic
    );
end entity;

architecture rtl of olo_base_wconv_n2m is

    constant MaxChunkSize_c : positive := greatestCommonFactor(InWidth_g, OutWidth_g);
    constant ChunkSize_c    : positive := choose(UseBe_g, 8, MaxChunkSize_c);
    constant SrWidth_c      : positive := choose(OutWidth_g > InWidth_g, 2*OutWidth_g, OutWidth_g+InWidth_g);
    constant OutChunks_c    : positive := OutWidth_g / ChunkSize_c;
    constant InChunks_c     : positive := InWidth_g / ChunkSize_c;

    type TwoProcess_r is record
        ChunkCnt    : integer range 0 to SrWidth_c / ChunkSize_c - 1;
        ShiftReg    : std_logic_vector(SrWidth_c - 1 downto 0);
        LastChunk   : std_logic_vector(SrWidth_c / ChunkSize_c - 1 downto 0);
        LastPending : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert (UseBe_g = false) or ((InWidth_g mod 8 = 0) and (OutWidth_g mod 8 = 0))
        report ""olo_base_wconv_n2m: Byte Enables are only supported for byte-aligned InWidht_g and OutWidth_g""
        severity failure;

    g_convert : if OutWidth_g /= InWidth_g generate

        p_comb : process (r, In_Valid, In_Data, Out_Ready, In_Last, In_Be, Rst) is
            variable v            : TwoProcess_r;
            variable Out_Valid_v  : std_logic;
            variable Offset_v     : natural range 0 to SrWidth_c - 1;
            variable IsLastBeat_v : std_logic;
        begin
            v := r;

            Out_Valid_v  := '0';
            IsLastBeat_v := or_reduce(r.LastChunk(OutChunks_c - 1 downto 0));
            if (r.ChunkCnt >= OutChunks_c) or (IsLastBeat_v = '1') then
                Out_Valid_v := '1';
            end if;
            if Out_Valid_v = '1' and Out_Ready = '1' then
                if IsLastBeat_v = '1' then
                    v.ChunkCnt    := 0;
                    v.ShiftReg    := (others => '0');
                    v.LastChunk   := (others => '0');
                    v.LastPending := '0';
                else
                    v.ChunkCnt  := r.ChunkCnt - OutChunks_c;
                    v.ShiftReg  := zerosVector(OutWidth_g) & r.ShiftReg(r.ShiftReg'high downto OutWidth_g);
                    v.LastChunk := zerosVector(OutChunks_c) & r.LastChunk(r.LastChunk'high downto OutChunks_c);
                end if;
            end if;
            Out_Valid <= Out_Valid_v;
            Out_Data  <= r.ShiftReg(OutWidth_g - 1 downto 0);
            Out_Last  <= IsLastBeat_v;
            if UseBe_g = true then
                Out_Be <= (others => '0');

                for byte in 0 to OutChunks_c-1 loop
                    Out_Be(byte) <= '1';
                    if r.LastChunk(byte) = '1' then
                        exit;
                    end if;
                end loop;

            else
                Out_Be <= (others => '1');
            end if;

            In_Ready <= '0';
            if (v.ChunkCnt < OutChunks_c) and (v.LastPending = '0') then

                In_Ready <= not Rst;
                if In_Valid = '1' then
                    Offset_v                                             := v.ChunkCnt*ChunkSize_c;
                    v.ShiftReg(Offset_v + InWidth_g - 1 downto Offset_v) := In_Data;

                    if UseBe_g = true then
                        assert (In_Last = '1') or (In_Be = onesVector(In_Be'length))
                            report ""olo_base_wconv_n2m: Incomplete byte enables are only supported for last beat""
                            severity failure;
                        v.LastChunk(v.ChunkCnt + InChunks_c-1) := In_Last;

                        for byte in 0 to InChunks_c-2 loop
                            if In_Be(byte) = '1' and In_Be(byte+1) = '0' then
                                v.LastChunk(v.ChunkCnt + byte)         := In_Last; -- set last chunk
                                v.LastChunk(v.ChunkCnt + InChunks_c-1) := '0'; -- override default
                                exit;
                            end if;
                        end loop;

                    else
                        v.LastChunk(v.ChunkCnt + InChunks_c-1) := In_Last;
                    end if;
                    v.ChunkCnt    := v.ChunkCnt + InChunks_c;
                    v.LastPending := In_Last;
                end if;
            end if;

            r_next <= v;
        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.ShiftReg    <= (others => '0');
                    r.ChunkCnt    <= 0;
                    r.LastChunk   <= (others => '0');
                    r.LastPending <= '0';
                end if;
            end if;
        end process;

    end generate;

    g_equalwidth : if OutWidth_g = InWidth_g generate
        Out_Valid <= In_Valid;
        Out_Data  <= In_Data;
        Out_Last  <= In_Last;
        In_Ready  <= Out_Ready;

    end generate;

end architecture;"
"This component implements a data width conversion from N-bits to a multiple of N-bits. The sample rate (_Valid_ pulse rate) is reduced accordingly. The width conversion implements AXI-S handshaking signals to handle back-pressure. This block can also be used for _TDM to Parallel_ conversion (see [Conventions](../Conventions.md)) The with conversion supports back-to-back conversions (_In_Valid_ can stay high all the time). It also handles the last-flag correctly according to AXI specification. If _In_Last_ is asserted, all data is flushed out and the word enabled (_Out_WordEna_) at the output are set only for words that contain data. _Out_Last_ is asserted accordingly. Note that insteady of byte-enables, a word enable (_Out_WordEna_)  is implemented. It signals the validity of data on the granularity of _In_Data_ words. This concept allows to correctly handle any data-widths, not only multiple of bytes. The entity does little-endian data alignment as shown in the figure below. The figure depicts operation of the block without backpressure (_Out_Ready_ continuously high) and for a width-conversion from 4 to 8 bits. This entity does only do a width conversion but not clock crossing. If a half-clock-double-width conversion is used, [olo_base_cc_xn2n](./olo_base_cc_xn2n.md) component can be used after the width conversion.

# VHDL Analysis for 'olo_base_wconv_n2xn.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple data-width conversion. The output width
- Plus 24 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_wconv_n2xn

## Architecture: rtl of olo_base_wconv_n2xn

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
            r_next <= v;
        end process;

        p_seq: process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Valid, In_Data, Out_Ready, In_Last
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Halt detection
            ShiftDone_v := (r.DataVld(r.DataVld'high) = '1') or (r.DataLast = '1')
- if ShiftDone_v and (r.Out_Valid = '1') and (Out_Ready = '0') then
                IsStuck_v := '1'
- else
                IsStuck_v := '0'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst

## Code Metrics
- Line count: 170
- Process count: 4
- Signal count: 3

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_wconv_n2xn.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_n2xn is
    generic (
        InWidth_g  : positive;
        OutWidth_g : positive
    );
    port (
        Clk          : in    std_logic;
        Rst          : in    std_logic;
        In_Valid     : in    std_logic := '1';
        In_Ready     : out   std_logic;
        In_Data      : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Last      : in    std_logic := '0';
        Out_Valid    : out   std_logic;
        Out_Ready    : in    std_logic := '1';
        Out_Data     : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last     : out   std_logic;
        Out_WordEna  : out   std_logic_vector(OutWidth_g / InWidth_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_wconv_n2xn is

    constant RatioReal_c : real    := real(OutWidth_g) / real(InWidth_g);
    constant RatioInt_c  : integer := integer(RatioReal_c);

    type TwoProcess_r is record
        DataVld     : std_logic_vector(RatioInt_c - 1 downto 0);
        Data        : std_logic_vector(OutWidth_g - 1 downto 0);
        DataLast    : std_logic;
        Out_Valid   : std_logic;
        Out_Data    : std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last    : std_logic;
        Out_WordEna : std_logic_vector(RatioInt_c - 1 downto 0);
        Cnt         : integer range 0 to RatioInt_c;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert floor(RatioReal_c) = ceil(RatioReal_c)
        report ""olo_base_wconv_n2xn: Ratio OutWidth_g/InWidth_g must be an integer number""
        severity error;
    assert OutWidth_g >= InWidth_g
        report ""olo_base_wconv_n2xn: OutWidth_g must be bigger or equal than InWidth_g""
        severity error;

    g_convert : if OutWidth_g > InWidth_g generate

        p_comb : process (r, In_Valid, In_Data, Out_Ready, In_Last) is
            variable v           : TwoProcess_r;
            variable IsStuck_v   : std_logic;
            variable ShiftDone_v : boolean;
        begin
            v := r;

            ShiftDone_v := (r.DataVld(r.DataVld'high) = '1') or (r.DataLast = '1');
            if ShiftDone_v and (r.Out_Valid = '1') and (Out_Ready = '0') then
                IsStuck_v := '1';
            else
                IsStuck_v := '0';
            end if;

            if (r.Out_Valid = '1') and (Out_Ready = '1') then
                v.Out_Valid := '0';
            end if;

            if ShiftDone_v and ((r.Out_Valid = '0') or (Out_Ready = '1')) then
                v.Out_Valid   := '1';
                v.Out_Data    := r.Data;
                v.Out_Last    := r.DataLast;
                v.Out_WordEna := r.DataVld;
                v.DataVld     := (others => '0');
                v.DataLast    := '0';
            end if;
            if In_Valid = '1' and IsStuck_v = '0' then
                v.Data((r.Cnt + 1) * InWidth_g - 1 downto r.Cnt * InWidth_g) := In_Data;
                v.DataVld(r.Cnt)                                             := '1';
                if In_Last = '1' then
                    v.DataLast := '1';
                end if;
                if (r.Cnt = RatioInt_c - 1) or (In_Last = '1') then
                    v.Cnt := 0;
                else
                    v.Cnt := r.Cnt + 1;
                end if;
            end if;

            In_Ready    <= not IsStuck_v;
            Out_Valid   <= r.Out_Valid;
            Out_Data    <= r.Out_Data;
            Out_Last    <= r.Out_Last;
            Out_WordEna <= r.Out_WordEna;

            r_next <= v;
        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.DataVld   <= (others => '0');
                    r.Out_Valid <= '0';
                    r.Cnt       <= 0;
                    r.DataLast  <= '0';
                end if;
            end if;
        end process;

    end generate;

    g_equalwidth : if OutWidth_g = InWidth_g generate
        Out_Valid   <= In_Valid;
        Out_Data    <= In_Data;
        Out_Last    <= In_Last;
        Out_WordEna <= (others => '1');
        In_Ready    <= Out_Ready;

    end generate;

end architecture;"
"This component implements a data width conversion from a multiple N-bits to a N-bits. The sample rate (_Valid_ pulse rate) is increased accordingly. The width conversion implements AXI-S handshaking signals to handle back-pressure. The width conversion does support back-to-back conversions (_Out_Valid/In_ready_ can stay high all the time). This block can also be used for _Parallel to TDM_ conversion (see [Conventions](../Conventions.md)) The entity does little-endian data alignment as shown in the figure below. The with conversion does also handle the last-flag according to AXI specification and it can do alignment. To do so, an input word-enable signal _In_WordEna_ exists (one bit per _OutWidth_g_ bits). Words that are not enabled are not sent to the output. If the input is marked with the _In_Last_ flag, the last enabled word is marked with _Out_Last_ at the output. Note that with the assertion of _In_Last_ at least one byte of the data must be valid (_In_WordEna_ high). Otherwise it would be unclear when _Out_Last_ shall be assigned. This entity does only do a width conversion but not clock crossing. If a double-clock-half-width conversion is required, [olo_base_cc_n2xn](./olo_base_cc_n2xn)  component can be used in front of the width conversion.

# VHDL Analysis for 'olo_base_wconv_xn2n.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple data-width conversion. The input width
- Plus 20 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_wconv_xn2n

## Architecture: rtl of olo_base_wconv_xn2n

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
        r_next <= v;
    end process;

    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' with sensitivity list: r, In_Valid, In_Data, Out_Ready, In_WordEna, In_Last
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Halt detection
        IsReady_v := '1'
- if unsigned(r.DataVld(r.DataVld'high downto 1)) /= 0 then
            IsReady_v := '0'
- elsif r.DataVld(0) = '1' and Out_Ready = '0' then
            IsReady_v := '0'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 136
- Process count: 4
- Signal count: 3

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_wconv_xn2n.vhd' plays a specific role in the overall CPU architecture.
","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_xn2n is
    generic (
        InWidth_g  : positive;
        OutWidth_g : positive
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Last     : in    std_logic                                             := '0';
        In_WordEna  : in    std_logic_vector(InWidth_g / OutWidth_g - 1 downto 0) := (others => '1');
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic                                             := '1';
        Out_Data    : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last    : out   std_logic
    );
end entity;

architecture rtl of olo_base_wconv_xn2n is

    constant RatioReal_c : real    := real(InWidth_g) / real(OutWidth_g);
    constant RatioInt_c  : integer := integer(RatioReal_c);

    type TwoProcess_r is record
        Data     : std_logic_vector(InWidth_g - 1 downto 0);
        DataVld  : std_logic_vector(RatioInt_c - 1 downto 0);
        DataLast : std_logic_vector(RatioInt_c - 1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert floor(RatioReal_c) = ceil(RatioReal_c)
        report ""olo_base_wconv_xn2n: Ratio OutWidth_g/InWidth_g must be an integer number""
        severity error;
    assert OutWidth_g < InWidth_g
        report ""olo_base_wconv_n2xn: OutWidth_g must be smaller than InWidth_g""
        severity error;

    p_comb : process (r, In_Valid, In_Data, Out_Ready, In_WordEna, In_Last) is
        variable v         : TwoProcess_r;
        variable IsReady_v : std_logic;
    begin
        v := r;

        IsReady_v := '1';
        if unsigned(r.DataVld(r.DataVld'high downto 1)) /= 0 then
            IsReady_v := '0';
        elsif r.DataVld(0) = '1' and Out_Ready = '0' then
            IsReady_v := '0';
        end if;

        if IsReady_v = '1' and In_Valid = '1' then
            v.Data    := In_Data;
            v.DataVld := In_WordEna;
            v.DataLast := (others => '0');

            for i in RatioInt_c-1 downto 0 loop
                if In_WordEna(i) = '1' and In_Last = '1' then
                    v.DataLast(i) := '1';
                    exit;
                end if;
            end loop;

        elsif (Out_Ready = '1') and (unsigned(r.DataVld) /= 0) then
            v.Data     := zerosVector(OutWidth_g) & r.Data(r.Data'left downto OutWidth_g);
            v.DataVld  := '0' & r.DataVld(r.DataVld'left downto 1);
            v.DataLast := '0' & r.DataLast(r.DataLast'left downto 1);
        end if;

        Out_Data  <= r.Data(OutWidth_g - 1 downto 0);
        In_Ready  <= IsReady_v;
        Out_Valid <= r.DataVld(0);
        Out_Last  <= r.DataLast(0);

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.DataVld <= (others => '0');
            end if;
        end if;
    end process;

end architecture;"
