original_input,new_input,output,index
"This entity measures the frequency of a clock under the assumption that the frequency of the main-clock is exactly correct. Generally the system clock comes from PS, the block is useful to verify if other clocks are set to the correct frequency. This block contains _Open Logic_ clock crossings, refer to [clock crossing principles](../base/clock_crossing_principles.md) regarding timing constraints.

# VHDL Analysis for 'olo_intf_clk_meas.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity measures the frequency of a clock under the assumption that
- Plus 47 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_intf_clk_meas

## Architecture: rtl of olo_intf_clk_meas

### Signals
- AwaitResult_M: std_logic
- SecPulse_M: std_logic
- ResultValid_M: std_logic
- Result_M: std_logic_vector(ResultWidth_c-1 downto 0)
- CntrTest_T: integer range 0 to MaxClkTestFrequencyInt_c
- Rst_T: std_logic
- SecPulse_T: std_logic
- Result_T: std_logic_vector(ResultWidth_c-1 downto 0)
- ResultValid_T: std_logic

### Component Instantiations
- Instance 'i_sec_pulse' of component 'olo_base_strobe_gen'
- Instance 'i_sec_pulse_cc' of component 'olo_base_cc_pulse'
- Instance 'i_result_cc' of component 'olo_base_cc_simple'

### Processes
- Process 'p_control :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_meas :' (Clocked) (Has Reset) with sensitivity list: ClkTest
  - Implements synchronous logic with reset
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- -- Request new result
            if SecPulse_M = '1' then
                AwaitResult_M <= '1'
- -- If no new value was detected, the clock is stopped (0 Hz)
                if AwaitResult_M = '1' then
                    Freq_Hz    <= (others => '0')
- Freq_Valid <= '1'

## Functional Analysis

- Contains 5 clock domain(s): Clk, Out_Clk, In_Clk, clock, Clock
- Uses reset signal(s): Reset, reset, first, Rst_T, Out_RstIn, Rst, In_RstIn, Out_RstOut
- Implements control logic

## Code Metrics
- Line count: 195
- Process count: 4
- Signal count: 9

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_intf_clk_meas.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_intf_clk_meas` component measures the frequency of an input clock signal (`ClkTest`) and outputs the measured frequency in Hz as a 32-bit unsigned integer (`Freq_Hz`). The component uses a reference clock (`Clk`) to generate a 1-second strobe signal, which is then used to measure the frequency of the input clock. The measured frequency is output along with a validity signal (`Freq_Valid`).

**Inputs**

* `Clk`: Reference clock signal (input)
* `Rst`: Reset signal (input)
* `ClkTest`: Input clock signal to measure (input)

**Outputs**

* `Freq_Hz`: Measured frequency in Hz (output, 32-bit unsigned integer)
* `Freq_Valid`: Validity signal indicating when the measured frequency is valid (output)

**Generics**

* `ClkFrequency_g`: Frequency of the reference clock (`Clk`) in Hz (generic, real)
* `MaxClkTestFrequency_g`: Maximum frequency of the input clock (`ClkTest`) in Hz (generic, real, default: 1.0e9)

**Functionality**

The component uses the following functionality:

1. Generates a 1-second strobe signal (`SecPulse_M`) using a strobe generator (`olo_base_strobe_gen`) clocked by the reference clock (`Clk`).
2. Measures the frequency of the input clock (`ClkTest`) by counting the number of edges within a 1-second","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_intf_clk_meas is
    generic (
        ClkFrequency_g          : real;
        MaxClkTestFrequency_g   : real := 1.0e9
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        ClkTest       : in    std_logic;
        Freq_Hz       : out   std_logic_vector(31 downto 0);
        Freq_Valid    : out   std_logic
    );
end entity;

architecture rtl of olo_intf_clk_meas is

    constant MaxClkTestFrequencyInt_c : integer := integer(MaxClkTestFrequency_g);
    constant ResultWidth_c            : integer := log2ceil(integer(MaxClkTestFrequencyInt_c)+1);

    signal AwaitResult_M : std_logic;
    signal SecPulse_M    : std_logic;
    signal ResultValid_M : std_logic;
    signal Result_M      : std_logic_vector(ResultWidth_c-1 downto 0);

    signal CntrTest_T    : integer range 0 to MaxClkTestFrequencyInt_c;
    signal Rst_T         : std_logic;
    signal SecPulse_T    : std_logic;
    signal Result_T      : std_logic_vector(ResultWidth_c-1 downto 0);
    signal ResultValid_T : std_logic;

begin

    assert ClkFrequency_g >= 100.0
        report ""olo_intfclk_meas: ClkFrequency_g must >= 100 Hz""
        severity failure;
    assert MaxClkTestFrequency_g >= 100.0
        report ""olo_intfclk_meas: MaxClkTestFrequency_g must be >= 100 Hz""
        severity failure;

    p_control : process (Clk) is
    begin
        if rising_edge(Clk) then

            Freq_Valid <= '0';

            if SecPulse_M = '1' then
                AwaitResult_M <= '1';
                if AwaitResult_M = '1' then
                    Freq_Hz    <= (others => '0');
                    Freq_Valid <= '1';
                end if;
            end if;

            if ResultValid_M = '1' then
                Freq_Hz       <= std_logic_vector(resize(unsigned(Result_M), Freq_Hz'length));
                AwaitResult_M <= '0';
                Freq_Valid    <= '1';
            end if;

            if Rst = '1' then
                AwaitResult_M <= '0';
                Freq_Hz       <= (others => '0');
                Freq_Valid    <= '0';
            end if;

        end if;
    end process;

    p_meas : process (ClkTest) is
    begin
        if rising_edge(ClkTest) then

            ResultValid_T <= '0';

            if SecPulse_T = '1' then
                Result_T      <= toUslv(CntrTest_T, ResultWidth_c);
                CntrTest_T    <= 1;          -- the first edge implicitly arrived
                ResultValid_T <= '1';
            elsif CntrTest_T /= MaxClkTestFrequencyInt_c then
                CntrTest_T <= CntrTest_T + 1;
            end if;

            if Rst_T = '1' then
                CntrTest_T    <= 0;
                ResultValid_T <= '0';
            end if;
        end if;
    end process;

    i_sec_pulse : entity work.olo_base_strobe_gen
        generic map (
            FreqClkHz_g    => ClkFrequency_g,
            FreqStrobeHz_g => 1.0
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            Out_Valid   => SecPulse_M
        );

    i_sec_pulse_cc : entity work.olo_base_cc_pulse
        port map (
            In_Clk        => Clk,
            In_RstIn      => Rst,
            In_Pulse(0)   => SecPulse_M,
            Out_Clk       => ClkTest,
            Out_RstOut    => Rst_T,
            Out_Pulse(0)  => SecPulse_T
        );

    i_result_cc : entity work.olo_base_cc_simple
        generic map (
            Width_g     => ResultWidth_c
        )
        port map (
            In_Clk      => ClkTest,
            In_Data     => Result_T,
            In_Valid    => ResultValid_T,
            Out_Clk     => Clk,
            Out_RstIn   => Rst,
            Out_Data    => Result_M,
            Out_Valid   => ResultValid_M
        );

end architecture;
",0
"This component synchronizes external signals and debounces them. The debouncing is implemented efficiently with a prescaler divider shared between all signals in order to keep resource usage as low as possible. The entity has two modes of operation. - In _LOW_LATENCY_ mode, an incoming edge is forwarded immediately (less than 5 clock cycles of delay). After the edge is forwarded to the output, the next edge can be detected only after the signal was stable for _DebounceTime_g_. - This mode of operation implies that single cycle input pulses are stretched to a pulse-width of _DebounceTime_g_. - In _GLITCH_FILTER_ mode, any signal change is only forwarded to the output after the signal was stable for _DebounceTime_g_ on the new level. - This mode of operation implies that single cycle input pulses are suppressed. Below figure provides an example waveform for both modes of operation.

# VHDL Analysis for 'olo_intf_debounce.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a debouncer for button and switch inputs. It contains a
- double stage synchronizer to synchronize those inputs to the clock.
- Plus 39 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_array.all

## Entity: olo_intf_debounce

## Architecture: struct of olo_intf_debounce

### Signals
- DataSync: std_logic_vector(DataAsync'range)
- Tick: std_logic
- r: TwoProcess_r
- r_next: TwoProcess_r
- once stable
                if r.IsStable(i) = '1' then
                    v.DataOut(i): = r.LastState(i)
- is stable (including first edge)
                if r.IsStable(i) = '1' then
                    v.DataOut(i): = DataSync(i)
- r_next <= v;
    end process;

    -- *** Sequential Process ***
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            -- normal operation
            r <= r_next

### Component Instantiations
- Instance 'i_sync' of component 'olo_intf_sync'
- Instance 'i_tickgen' of component 'olo_base_strobe_gen'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, DataSync, Tick
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- for i in 0 to DataAsync'length-1 loop

            -- Counter Update & Stablity Detection
            if Tick = '1' then
                if r.StableCnt(i) = DebounceTicks_c then
                    v.IsStable(i) := '1'
- else
                    v.StableCnt(i) := r.Stablecnt(i) + 1

## Functional Analysis

- Contains 2 clock domain(s): clock, Clk
- Uses reset signal(s): RstLevel_g, Reset, reset, first, Rst
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 200
- Process count: 4
- Signal count: 7

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_intf_debounce.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Debouncer Interface (olo_intf_debounce)**

**Component Description:**
The olo_intf_debounce component is a digital debouncer interface designed to filter out glitches and unstable signals from asynchronous inputs. It provides a stable output signal by monitoring the input signal over a specified debounce time.

**Functional Requirements:**

* Debounce asynchronous input signals to produce stable output signals
* Support two operating modes: Low Latency and Glitch Filter
* Configurable debounce time and clock frequency
* Handle multiple input bits (up to Width_g)

**Inputs:**

* **Clk**: Clock signal (std_logic)
* **Rst**: Reset signal (std_logic)
* **DataAsync**: Asynchronous input signal(s) (std_logic_vector, Width_g bits)

**Outputs:**

* **DataOut**: Debounced output signal(s) (std_logic_vector, Width_g bits)

**Parameters:**

* **ClkFrequency_g**: Clock frequency (real)
* **DebounceTime_g**: Debounce time (real, default: 20.0e-3 seconds)
* **Width_g**: Number of input bits (positive integer, default: 1)
* **IdleLevel_g**: Idle level for output signals (std_logic, default: '0')
* **Mode_g**: Operating mode (string, default: ""LOW_LATENCY""; options: ""LOW_LATENCY"" or ""GLITCH_FILTER"")

**Behavior:**

* The component synchronizes the asynchronous input signals using an internal synchron","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_array.all;


entity olo_intf_debounce is
    generic (
        ClkFrequency_g  : real;
        DebounceTime_g  : real      := 20.0e-3;
        Width_g         : positive  := 1;
        IdleLevel_g     : std_logic := '0';
        Mode_g          : string    := ""LOW_LATENCY""    -- LOW_LATENCY or GLITCH_FILTER
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        DataAsync   : in    std_logic_vector(Width_g - 1 downto 0);
        DataOut     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;


architecture struct of olo_intf_debounce is

    constant TargetTickFrequency_c : real    := 1.0/(DebounceTime_g/31.0);
    constant TickCycles_c          : real    := ceil(ClkFrequency_g/TargetTickFrequency_c);
    constant ActualTickFrequency_c : real    := ClkFrequency_g/TickCycles_c;
    constant DebounceTicks_c       : integer := integer(ceil(DebounceTime_g*ActualTickFrequency_c));
    constant UseStrobeDiv_c        : boolean := integer(TickCycles_c) >= 2;

    constant Bits_c : integer := DataAsync'length;

    signal DataSync : std_logic_vector(DataAsync'range);
    signal Tick     : std_logic;

    subtype Cnt_t is integer range 0 to DebounceTicks_c;
    type Cnt_a is array (0 to Bits_c-1) of Cnt_t;

    type TwoProcess_r is record
        StableCnt : Cnt_a;
        LastState : std_logic_vector(Bits_c-1 downto 0);
        IsStable  : std_logic_vector(Bits_c-1 downto 0);
        DataOut   : std_logic_vector(Bits_c-1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert Mode_g = ""GLITCH_FILTER"" or Mode_g = ""LOW_LATENCY""
        report ""olo_intf_debounce: Illegal Mode_g - "" & Mode_g
        severity failure;

    assert DebounceTicks_c >= 10
        report ""olo_intf_debounce: DebounceTime too short (must be >= 10 clock cycles) - "" &
               ""DebounceTime_g="" & real'image(DebounceTime_g) & "" ClkFrequency_g="" & real'image(ClkFrequency_g)
        severity failure;

    p_comb : process (r, DataSync, Tick) is
        variable v : TwoProcess_r;
    begin
        v := r;

        for i in 0 to DataAsync'length-1 loop

            if Tick = '1' then
                if r.StableCnt(i) = DebounceTicks_c then
                    v.IsStable(i) := '1';
                else
                    v.StableCnt(i) := r.Stablecnt(i) + 1;
                end if;
            end if;

            if DataSync(i) /= r.LastState(i) then
                v.StableCnt(i) := 0;
                v.IsStable(i)  := '0';
            end if;

            if Mode_g = ""GLITCH_FILTER"" then
                if r.IsStable(i) = '1' then
                    v.DataOut(i) := r.LastState(i);
                end if;
            end if;

            if Mode_g = ""LOW_LATENCY"" then
                if r.IsStable(i) = '1' then
                    v.DataOut(i) := DataSync(i);
                end if;
            end if;
        end loop;

        v.LastState := DataSync;

        DataOut <= r.DataOut;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.StableCnt <= (others => DebounceTicks_c);
                r.LastState <= (others => IdleLevel_g);
                r.IsStable  <= (others => '1');
                r.DataOut   <= (others => IdleLevel_g);
            end if;
        end if;
    end process;

    i_sync : entity work.olo_intf_sync
        generic map (
            Width_g     => Width_g,
            RstLevel_g  => IdleLevel_g
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            DataAsync   => DataAsync,
            DataSync    => DataSync
        );

    g_use_strobe : if UseStrobeDiv_c generate

        i_tickgen : entity work.olo_base_strobe_gen
            generic map (
                FreqClkHz_g    => ClkFrequency_g,
                FreqStrobeHz_g => ActualTickFrequency_c
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                Out_Valid   => Tick
            );

    end generate;

    g_no_strobe : if not UseStrobeDiv_c generate
        Tick <= '1';
    end generate;

end architecture;",1
"This entity implements an I2C master that is multi-master capable (i.e. supports arbitration). The _olo_intf_i2c_master_ allows generating start, stop and repeated start conditions as well as transferring bytes in both directions. This entity also supports slaves that do clock-stretching. Addressing is not handled separately. To send the byte containing the address and the R/W bit, the normal byte transfer is used. The user is responsible for filling the address into bits 7:1 and the R/W flag into bit 0 of the data. The same applies for 10-bit addressing. The user is responsible to send the 10-bit addressing pattern using two byte transfers. The bus state (busy or free) is tracked based on start- and stop-conditions. However, if no transactions are ongoing (i.e. SCL = '1' and SDA = '1') for a configurable timeout, the bus is always regarded as free. This helps handling the case where a master starts a transaction and then (e.g. due to reset) aborts the transaction without sending a stop-condition. The user has three main interfaces: - The command interface (_Cmd_..._) allows  to select the next bus action to execute. Commands are: - _START_ Send a start condition (only allowed if bus is idle) - _STOP_ Send a stop condition (only allowed if bus is not idle) - _REPSTART_ Send a repeated start condition (only allowed if the bus is not idle) - _SEND_ Send a data byte (only allowed if the bus is not idle). The data to send is provided along with the command. - _RECEIVE_ Receive a data byte (only allowed if the bus is not idle). The ACK to send is provided along with the command. - On the response interface (_Resp_..._), the user receives one response per command as soon as the command is completed. More information like the received ACK bit, whether the command was aborted due to a lost arbitration, the received data or whether the command sequence was illegal is sent along with the response. - On the status interface (_Status_..._) the user can see if the I2C bus is currently busy or free and if a command timed out (i.e. the user failed to provide the next command within time, and hence the bus was released). For constants containing the command codes, a package _olo_intf_i2c_master_pkg_ is defined in the same VHDL file. **Note:** The I2C ports must be constrained manually. No solution was found for scoped timing constraints for inferred tristate buffers.

# VHDL Analysis for 'olo_intf_i2c_master.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple I2C-master (multi master capable)
- Plus 138 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Package for Interface Simplification
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_intf_i2c_master_pkg.all

## Entity: olo_intf_i2c_master

## Architecture: rtl of olo_intf_i2c_master

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- is DontTouch_SuppressChanges_c;

    -- Tri-state buffer muxing
    signal I2cScl_Input: std_logic
- I2cSda_Input: std_logic
- I2cScl_Sync: std_logic
- I2cSda_Sync: std_logic
- ***
        r_next <= v;
    end process;

    -----------------------------------------------------------------------------------------------
    -- Outputs
    -----------------------------------------------------------------------------------------------
    Status_BusBusy <= r.Status_BusBusy;
    Cmd_Ready      <= r.Cmd_Ready;
    Resp_Valid     <= r.Resp_Valid;
    Resp_Command   <= r.CmdTypeLatch;
    Resp_ArbLost   <= r.Resp_ArbLost;
    Resp_Ack       <= r.Resp_Ack;
    Resp_Data      <= r.Resp_Data;
    Resp_SeqErr    <= r.Resp_SeqErr;
    Status_CmdTo   <= r.Status_CmdTo;

    -- Internal Tri-State buffers
    g_int_tristate: if InternalTriState_g generate
        I2c_Scl   <= 'Z' when r.SclOut = '1' else '0'

### Component Instantiations
- Instance 'i_sync' of component 'olo_intf_sync'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, I2cScl_Sync, I2cSda_Sync, Cmd_Valid, Cmd_Command, Cmd_Data, Cmd_Ack
  - Implements case-based selection logic
  - Contains wait statements: for user command (in first half of SCL low phase)

            when WaitCmd_s =>
                -- Default Outputs
                v.Cmd_Ready := '1', for center of SCL low phase (after user command arrived)
            when WaitLowCenter_s =>
                -- State Handling
                v.SclOut := '0'
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
  - Contains wait statements: for user command (in first half of SCL low phase)

            when WaitCmd_s =>
                -- Default Outputs
                v.Cmd_Ready := '1', for center of SCL low phase (after user command arrived)
            when WaitLowCenter_s =>
                -- State Handling
                v.SclOut := '0'
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Edge Detection ***
        -- SclRe_v   := not r.SclLast and I2cScl_Sync
- -- SclFe_v   := r.SclLast and not I2cScl_Sync
- SdaRe_v   := not r.SdaLast and I2cSda_Sync
- SdaFe_v   := r.SdaLast and not I2cSda_Sync
- v.SclLast := I2cScl_Sync
- Plus 8 more statements

## Functional Analysis

- Contains 4 clock domain(s): Clk, CLK, clock, Clock
- Uses reset signal(s): first, Rst, reset
- Implements control logic
- Implements interface or communication protocol

## Code Metrics
- Line count: 622
- Process count: 4
- Signal count: 7

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_intf_i2c_master.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: I2C Master Interface**

**Overview**

The I2C Master Interface is a digital component designed to implement the I2C (Inter-Integrated Circuit) master protocol. It enables communication between a microcontroller or other digital system and I2C slave devices.

**Functionality**

The I2C Master Interface component performs the following functions:

* Generates I2C clock (SCL) and data (SDA) signals to communicate with I2C slave devices
* Supports I2C commands: Start, Stop, Repeated Start, Send, and Receive
* Handles arbitration and bus busy conditions
* Provides status and response signals to indicate command completion and errors

**Inputs**

* **Clk**: Clock input signal
* **Rst**: Reset input signal
* **Cmd_Valid**: Command valid input signal
* **Cmd_Command**: Command input signal (3 bits)
* **Cmd_Data**: Command data input signal (8 bits)
* **Cmd_Ack**: Command acknowledge input signal
* **I2c_Scl**: I2C clock input signal (inout)
* **I2c_Sda**: I2C data input signal (inout)
* **I2c_Scl_i**: I2C clock input signal (for external tristate)
* **I2c_Sda_i**: I2C data input signal (for external tristate)

**Outputs**

* **Cmd_Ready**: Command ready output signal
* **Resp","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

package olo_intf_i2c_master_pkg is

    constant I2cCmd_Start_c    : std_logic_vector(2 downto 0) := ""000"";
    constant I2cCmd_Stop_c     : std_logic_vector(2 downto 0) := ""001"";
    constant I2cCmd_RepStart_c : std_logic_vector(2 downto 0) := ""010"";
    constant I2cCmd_Send_c     : std_logic_vector(2 downto 0) := ""011"";
    constant I2cCmd_Receive_c  : std_logic_vector(2 downto 0) := ""100"";

end package;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_intf_i2c_master_pkg.all;

entity olo_intf_i2c_master is
    generic (
        ClkFrequency_g      : real;
        I2cFrequency_g      : real    := 100.0e3;
        BusBusyTimeout_g    : real    := 1.0e-3;
        CmdTimeout_g        : real    := 1.0e-3;
        InternalTriState_g  : boolean := true;
        DisableAsserts_g    : boolean := false
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Cmd_Ready       : out   std_logic;
        Cmd_Valid       : in    std_logic;
        Cmd_Command     : in    std_logic_vector(2 downto 0);
        Cmd_Data        : in    std_logic_vector(7 downto 0);
        Cmd_Ack         : in    std_logic;
        Resp_Valid      : out   std_logic;
        Resp_Command    : out   std_logic_vector(2 downto 0);
        Resp_Data       : out   std_logic_vector(7 downto 0);
        Resp_Ack        : out   std_logic;
        Resp_ArbLost    : out   std_logic;
        Resp_SeqErr     : out   std_logic;
        Status_BusBusy  : out   std_logic;
        Status_CmdTo    : out   std_logic;
        I2c_Scl         : inout std_logic := 'Z';
        I2c_Sda         : inout std_logic := 'Z';
        I2c_Scl_i       : in    std_logic := '0';
        I2c_Scl_o       : out   std_logic;
        I2c_Scl_t       : out   std_logic;
        I2c_Sda_i       : in    std_logic := '0';
        I2c_Sda_o       : out   std_logic;
        I2c_Sda_t       : out   std_logic
    );
end entity;

architecture rtl of olo_intf_i2c_master is

    constant BusyTimoutLimit_c    : integer := integer(ClkFrequency_g * BusBusyTimeout_g) - 1;
    constant QuarterPeriodLimit_c : integer := integer(ceil(ClkFrequency_g / I2cFrequency_g / 4.0)) - 1;
    constant CmdTimeoutLimit_c    : integer := integer(ClkFrequency_g * CmdTimeout_g) - 1;

    type Fsm_t is (
        BusIdle_s, BusBusy_s, MinIdle_s, Start1_s, Start2_s, WaitCmd_s, WaitLowCenter_s,
        Stop1_s, Stop2_s, Stop3_s, RepStart1_s, DataBit1_s, DataBit2_s, DataBit3_s, DataBit4_s, ArbitLost_s
    );

    type TwoProcess_r is record
        Status_BusBusy : std_logic;
        Cmd_Ready      : std_logic;
        SclLast        : std_logic;
        SdaLast        : std_logic;
        BusBusyToCnt   : unsigned(log2ceil(BusyTimoutLimit_c + 1) - 1 downto 0);
        TimeoutCmdCnt  : unsigned(log2ceil(CmdTimeoutLimit_c + 1) - 1 downto 0);
        QuartPeriodCnt : unsigned(log2ceil(QuarterPeriodLimit_c + 1) - 1 downto 0);
        QPeriodTick    : std_logic;
        CmdTypeLatch   : std_logic_vector(Cmd_Command'range);
        CmdAckLatch    : std_logic;
        Fsm            : Fsm_t;
        SclOut         : std_logic;
        SdaOut         : std_logic;
        Resp_Valid     : std_logic;
        Resp_Ack       : std_logic;
        Resp_SeqErr    : std_logic;
        Resp_Data      : std_logic_vector(7 downto 0);
        Resp_ArbLost   : std_logic;
        BitCnt         : unsigned(3 downto 0); -- 8 Data + 1 Ack = 9 = 4 bits
        ShReg          : std_logic_vector(8 downto 0);
        CmdTimeout     : std_logic;
        Status_CmdTo   : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    attribute dont_touch of r : signal is DontTouch_SuppressChanges_c;

    signal I2cScl_Input : std_logic;
    signal I2cSda_Input : std_logic;
    signal I2cScl_Sync  : std_logic;
    signal I2cSda_Sync  : std_logic;

begin

    p_comb : process (r, I2cScl_Sync, I2cSda_Sync, Cmd_Valid, Cmd_Command, Cmd_Data, Cmd_Ack) is
        variable v                     : TwoProcess_r;
        variable SdaRe_v, SdaFe_v      : std_logic;
        variable I2cStart_v, I2cStop_v : std_logic;
    begin
        v := r;

        SdaRe_v   := not r.SdaLast and I2cSda_Sync;
        SdaFe_v   := r.SdaLast and not I2cSda_Sync;
        v.SclLast := I2cScl_Sync;
        v.SdaLast := I2cSda_Sync;

        I2cStart_v := r.SclLast and I2cScl_Sync and SdaFe_v;
        I2cStop_v  := r.SclLast and I2cScl_Sync and SdaRe_v;

        v.QPeriodTick := '0';
        if (r.Fsm = BusIdle_s) or (r.Fsm = BusBusy_s) then
            v.QuartPeriodCnt := (others => '0');
        elsif r.QuartPeriodCnt = QuarterPeriodLimit_c then
            v.QuartPeriodCnt := (others => '0');
            v.QPeriodTick    := '1';
        else
            v.QuartPeriodCnt := r.QuartPeriodCnt + 1;
        end if;

        if r.Fsm = WaitCmd_s then
            if r.TimeoutCmdCnt = CmdTimeoutLimit_c then
                v.CmdTimeout := '1';
            else
                v.TimeoutCmdCnt := r.TimeoutCmdCnt + 1;
            end if;
        else
            v.TimeoutCmdCnt := (others => '0');
        end if;

        if (r.Cmd_Ready = '1') and (Cmd_Valid = '1') then
            v.CmdTypeLatch := Cmd_Command;
            v.CmdAckLatch  := Cmd_Ack;
        end if;

        v.Resp_Valid   := '0';
        v.Resp_Ack     := not r.ShReg(0);
        v.Resp_Data    := r.ShReg(8 downto 1);
        v.Resp_SeqErr  := '0';
        v.Resp_ArbLost := '0';
        v.Status_CmdTo := '0';
        v.Cmd_Ready    := '0';

        case r.Fsm is

            when BusIdle_s =>
                v.Cmd_Ready    := '1';
                v.BusBusyToCnt := (others => '0');
                v.SclOut       := '1';
                v.SdaOut       := '1';
                v.CmdTimeout   := '0';

                if (r.Cmd_Ready = '1') and (Cmd_Valid = '1') then
                    assert (Cmd_Command = I2cCmd_Start_c) or DisableAsserts_g
                        report ""###ERROR###: olo_intf_i2c_master: In idle state, only I2cCmd_Start_c commands are allowed!""
                        severity error;
                    v.CmdTypeLatch := Cmd_Command;
                    if Cmd_Command = I2cCmd_Start_c then
                        v.Fsm       := Start1_s;
                        v.Cmd_Ready := '0';
                    else
                        v.Resp_Valid  := '1';
                        v.Resp_SeqErr := '1';
                    end if;
                elsif (I2cScl_Sync = '0') or (I2cStart_v = '1') then
                    v.Fsm       := BusBusy_s;
                    v.Cmd_Ready := '0';
                end if;

            when BusBusy_s =>
                if I2cStop_v = '1' then
                    v.Fsm := MinIdle_s;
                end if;
                if I2cScl_Sync = '0' then
                    v.BusBusyToCnt := (others => '0');
                elsif r.BusBusyToCnt = BusyTimoutLimit_c then
                    v.Fsm := BusIdle_s;
                else
                    v.BusBusyToCnt := r.BusBusyToCnt + 1;
                end if;

                v.SclOut := '1';
                v.SdaOut := '1';

            when MinIdle_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := BusIdle_s;
                end if;

                v.SclOut := '1';
                v.SdaOut := '1';

            when Start1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Start2_s;
                end if;

                if I2cScl_Sync = '0' and r.CmdTypeLatch = I2cCmd_RepStart_c then
                    v.QuartPeriodCnt := (others => '0');
                end if;

                if I2cSda_Sync = '0' then
                    v.Fsm := ArbitLost_s;
                end if;

                v.SclOut := '1';
                v.SdaOut := '1';

            when Start2_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm        := WaitCmd_s;
                    v.Resp_Valid := '1';
                end if;
                v.SclOut := '1';
                v.SdaOut := '0';


            when WaitCmd_s =>
                v.Cmd_Ready := '1';
                v.SclOut    := '0';

                if (r.Cmd_Ready = '1') and (Cmd_Valid = '1') then
                    assert (Cmd_Command = I2cCmd_Stop_c) or (Cmd_Command = I2cCmd_RepStart_c) or
                           (Cmd_Command = I2cCmd_Send_c) or (Cmd_Command = I2cCmd_Receive_c) or DisableAsserts_g
                        report ""###ERROR###: olo_intf_i2c_master: In WaitCmd_s state, I2cCmd_Start_c commands are not allowed!""
                        severity error;
                    if (Cmd_Command = I2cCmd_Stop_c) or (Cmd_Command = I2cCmd_RepStart_c) or
                       (Cmd_Command = I2cCmd_Send_c) or (Cmd_Command = I2cCmd_Receive_c) then
                        v.Fsm       := WaitLowCenter_s;
                        v.Cmd_Ready := '0';
                    else
                        v.Resp_Valid  := '1';
                        v.Resp_SeqErr := '1';
                    end if;
                    v.ShReg := Cmd_Data & '0';
                elsif r.CmdTimeout = '1' then
                    v.Fsm          := WaitLowCenter_s;
                    v.Cmd_Ready    := '0';
                    v.Status_CmdTo := '1';
                end if;

            when WaitLowCenter_s =>
                v.SclOut := '0';
                v.BitCnt := (others => '0');

                if r.QPeriodTick = '1' then
                    if r.CmdTimeout = '1' then
                        v.Fsm := Stop1_s;
                    else

                        case r.CmdTypeLatch is
                            when I2cCmd_Stop_c => v.Fsm := Stop1_s;
                            when I2cCmd_RepStart_c => v.Fsm := RepStart1_s;
                            when I2cCmd_Send_c => v.Fsm := DataBit1_s;
                            when I2cCmd_Receive_c => v.Fsm := DataBit1_s;
                            when others => null; -- unreacable code
                        end case;

                    end if;
                end if;


            when RepStart1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Start1_s;

                    if I2cSda_Sync = '0' then
                        v.Fsm := ArbitLost_s;
                    end if;
                end if;
                v.SclOut := '0';
                v.SdaOut := '1';


            when DataBit1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := DataBit2_s;
                end if;
                v.SclOut := '0';

                if r.CmdTypeLatch = I2cCmd_Send_c then
                    if r.BitCnt = 8 then
                        v.SdaOut := '1';
                    else
                        v.SdaOut := r.ShReg(8);
                    end if;
                else
                    if r.BitCnt = 8 then
                        if r.CmdAckLatch = '1' then
                            v.SdaOut := '0';
                        else
                            v.SdaOut := '1';
                        end if;
                    else
                        v.SdaOut := '1';
                    end if;
                end if;

            when DataBit2_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := DataBit3_s;
                    v.ShReg := r.ShReg(7 downto 0) & I2cSda_Sync;
                end if;
                v.SclOut := '1';

                if I2cScl_Sync = '0' then
                    v.QuartPeriodCnt := (others => '0');
                end if;

                if (r.CmdTypeLatch = I2cCmd_Send_c) and (r.BitCnt /= 8) then
                    if I2cSda_Sync /= r.SdaOut then
                        v.Fsm := ArbitLost_s;
                    end if;
                end if;

            when DataBit3_s =>
                if r.QPeriodTick = '1' then
                    if r.BitCnt = 8 then
                        v.Fsm        := WaitCmd_s;
                        v.Resp_Valid := '1';
                    else
                        v.Fsm := DataBit4_s;
                    end if;
                end if;
                v.SclOut := '1';

                if (r.CmdTypeLatch = I2cCmd_Send_c) and (r.BitCnt /= 8) then
                    if I2cSda_Sync /= r.SdaOut then
                        v.Fsm := ArbitLost_s;
                    end if;
                end if;

            when DataBit4_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm    := DataBit1_s;
                    v.BitCnt := r.BitCnt + 1;
                end if;
                v.SclOut := '0';


            when Stop1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Stop2_s;
                end if;
                v.SclOut := '0';
                v.SdaOut := '0';

            when Stop2_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Stop3_s;
                end if;
                v.SclOut := '1';
                v.SdaOut := '0';

                if I2cScl_Sync = '0' then
                    v.QuartPeriodCnt := (others => '0');
                end if;

            when Stop3_s =>
                if r.QPeriodTick = '1' then
                    if I2cSda_Sync = '0' then
                        v.Fsm := ArbitLost_s;
                    else
                        v.Fsm := BusIdle_s;
                        if r.CmdTimeout = '0' then
                            v.Resp_Valid := '1';
                        end if;
                    end if;
                end if;
                v.SclOut := '1';
                v.SdaOut := '1';

            when ArbitLost_s =>
                v.Fsm          := BusBusy_s;
                v.Resp_Valid   := '1';
                v.Resp_Ack     := '0';
                v.Resp_ArbLost := '1';
                v.SclOut       := '1';
                v.SdaOut       := '1';

            when others => null; -- unreacable code
        end case;

        if r.Fsm = BusIdle_s then
            v.Status_BusBusy := '0';
        else
            v.Status_BusBusy := '1';
        end if;

        r_next <= v;
    end process;

    Status_BusBusy <= r.Status_BusBusy;
    Cmd_Ready      <= r.Cmd_Ready;
    Resp_Valid     <= r.Resp_Valid;
    Resp_Command   <= r.CmdTypeLatch;
    Resp_ArbLost   <= r.Resp_ArbLost;
    Resp_Ack       <= r.Resp_Ack;
    Resp_Data      <= r.Resp_Data;
    Resp_SeqErr    <= r.Resp_SeqErr;
    Status_CmdTo   <= r.Status_CmdTo;

    g_int_tristate : if InternalTriState_g generate
        I2c_Scl   <= 'Z' when r.SclOut = '1' else '0';
        I2c_Sda   <= 'Z' when r.SdaOut = '1' else '0';
        I2c_Scl_o <= '0';
        I2c_Sda_o <= '0';
        I2c_Scl_t <= '1';
        I2c_Sda_t <= '1';
    end generate;

    g_ext_tristatte : if not InternalTriState_g generate
        I2c_Scl_o <= r.SclOut;
        I2c_Sda_o <= r.SdaOut;
        I2c_Scl_t <= r.SclOut;
        I2c_Sda_t <= r.SdaOut;
        I2c_Scl   <= 'Z';
        I2c_Sda   <= 'Z';
    end generate;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Status_BusBusy <= '0';
                r.Cmd_Ready      <= '0';
                r.SclLast        <= '1';
                r.SdaLast        <= '1';
                r.BusBusyToCnt   <= (others => '0');
                r.Fsm            <= BusIdle_s;
                r.SclOut         <= '1';
                r.SdaOut         <= '1';
                r.Resp_Valid     <= '0';
            end if;
        end if;
    end process;

    I2cScl_Input <= to01X(I2c_Scl) when InternalTriState_g else I2c_Scl_i;
    I2cSda_Input <= to01X(I2c_Sda) when InternalTriState_g else I2c_Sda_i;

    i_sync : entity work.olo_intf_sync
        generic map (
            Width_g     => 2
        )
        port map (
            Clk             => Clk,
            DataAsync(0)    => I2cScl_Input,
            DataAsync(1)    => I2cSda_Input,
            DataSync(0)     => I2cScl_Sync,
            DataSync(1)     => I2cSda_Sync
        );

end architecture;",2
"This entity implements a simple SPI master. All common SPI settings are configurable to ensure the master can be configured for different applications. The clock and data phase is configurable according to the SPI standard terminology described in the picture below: <p align=""center""><img src=""spi/spi_clk_data_phases.png"" alt=""CPHA/CPOL""> </p> <p align=""center""> CPOL and CPHA meaning </p> For CPHA = 1, the sampling happens on the second edge (blue) and data is applied on the first edge (red). For CPHA = 0 it is the opposite way. The number of bits to transfer can be chosen per transaction. Alternatively, the related port _Cmd_TransWidth_ can be left unconnected - in this case, all transactions are _MaxTransWidth_g_ bits. Similarly the slave to communicate with can be selected through _Cmd_Slave_ for every transaction ot the signal can be left unconnected when only one slave is used - in this case all transactions implicitly are for communicating with slave 0. The user interface (FPGA side) is split into a command interface (_Cmd_..._) and a response interface (_Resp_..._). Below figure summarizes how they behave timing-wise.

# VHDL Analysis for 'olo_intf_spi_master.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler, Switzerland
- All rights reserved.
- Authors: Oliver Bruendler, Franz Herzog
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple SPI-master
- Plus 50 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_intf_spi_master

## Architecture: rtl of olo_intf_spi_master

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- required for automatic constraining
    signal SpiMiso_i: std_logic
- is DontMerge_SuppressChanges_c;
    attribute preserve of SpiMiso_i: signal is Preserve_SuppressChanges_c
- is Keep_SuppressChanges_c;
    attribute dont_touch of SpiMiso_i: signal is DontTouch_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_preserve of SpiMiso_i: signal is SynPreserve_SuppressChanges_c
- BeforeShift: in std_logic_vector(MaxTransWidth_g-1 downto 0)
- InputBit: in std_logic
- ***
        r_next <= v;
    end process;

    -----------------------------------------------------------------------------------------------
    -- Outputs
    -----------------------------------------------------------------------------------------------
    Cmd_Ready  <= not r.Busy;
    Resp_Valid <= r.Done;
    Resp_Data  <= r.RdData;
    Spi_Sclk   <= r.Spi_Sclk;
    Spi_Cs_n   <= r.Spi_Cs_n;
    Spi_Mosi   <= r.Spi_Mosi;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' with sensitivity list: r, Cmd_Valid, Cmd_Data, SpiMiso_i, Cmd_Slave, Cmd_TransWidth
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- else
                return '0'

## Functional Analysis

- This appears to be a Finite State Machine implementation
- Contains 4 clock domain(s): Clk, Clock, Spi_Sclk, Sclk
- Uses reset signal(s): Rst, LsbFirst_g
- Implements control logic
- Implements interface or communication protocol
- Defines custom functions: getClockLevel
- Defines custom procedures: shiftReg

## Code Metrics
- Line count: 287
- Process count: 4
- Signal count: 9

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_intf_spi_master.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: SPI Master Interface**

**Overview**

The SPI Master Interface (OLO_INTFSPI_MASTER) is a digital component designed to facilitate communication between a system-on-chip (SoC) and external devices via the Serial Peripheral Interface (SPI) protocol. This component acts as a master, initiating transactions with one or more slave devices.

**Functionality**

The OLO_INTFSPI_MASTER component performs the following functions:

1. **SPI Master**: Initiates SPI transactions with external slave devices.
2. **Command Handling**: Accepts command inputs, including slave selection, data to transmit, and transaction width.
3. **Data Shifting**: Shifts data in and out of the component according to the SPI protocol.
4. **Clock Generation**: Generates the SPI clock (SCLK) signal based on a programmable frequency.

**Inputs**

The following inputs are accepted by the OLO_INTFSPI_MASTER component:

* **Clk**: System clock input.
* **Rst**: Asynchronous reset input.
* **Cmd_Valid**: Command valid input, indicating that a new command is available.
* **Cmd_Slave**: Slave selection input, specifying the target slave device.
* **Cmd_Data**: Data to transmit to the slave device.
* **Cmd_TransWidth**: Transaction width input, specifying the number of bits to transfer.
* **Spi_Miso**: SPI master-in-slave-out (MISO) input from the slave device.

**Outputs**

The OLO_INTFSPI_MASTER component produces","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_attribute.all;

entity olo_intf_spi_master is
    generic (
        ClkFreq_g       : real;
        SclkFreq_g      : real                 := 1.0e6;
        MaxTransWidth_g : positive             := 32;
        CsHighTime_g    : real                 := 20.0e-9;
        SpiCpol_g       : natural range 0 to 1 := 1;
        SpiCpha_g       : natural range 0 to 1 := 1;
        SlaveCnt_g      : positive             := 1;
        LsbFirst_g      : boolean              := false;
        MosiIdleState_g : std_logic            := '0'
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Cmd_Valid       : in    std_logic;
        Cmd_Ready       : out   std_logic;
        Cmd_Slave       : in    std_logic_vector(log2ceil(SlaveCnt_g) - 1 downto 0)      := (others => '0');
        Cmd_Data        : in    std_logic_vector(MaxTransWidth_g - 1 downto 0)           := (others => '0');
        Cmd_TransWidth  : in    std_logic_vector(log2ceil(MaxTransWidth_g+1)-1 downto 0) := toUslv(MaxTransWidth_g, log2ceil(MaxTransWidth_g+1));
        Resp_Valid      : out   std_logic;
        Resp_Data       : out   std_logic_vector(MaxTransWidth_g - 1 downto 0);
        Spi_Sclk        : out   std_logic;
        Spi_Mosi        : out   std_logic;
        Spi_Miso        : in    std_logic                                                := '0';
        Spi_Cs_n        : out   std_logic_vector(SlaveCnt_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_intf_spi_master is

    type State_t is (Idle_s, SftComp_s, ClkInact_s, ClkAct_s, CsHigh_s);

    constant ClkDiv_c         : natural := integer(round(ClkFreq_g/SclkFreq_g));
    constant ClkDivThres_c    : natural := ClkDiv_c / 2 - 1;
    constant CsHighCycles_c   : natural := integer(ceil(ClkFreq_g*CsHighTime_g));
    constant SclkFreqResult_c : real    := ClkFreq_g/(2.0*real(ClkDivThres_c+1));

    type TwoProcess_r is record
        State      : State_t;
        StateLast  : State_t;
        shiftReg   : std_logic_vector(MaxTransWidth_g - 1 downto 0);
        RdData     : std_logic_vector(MaxTransWidth_g - 1 downto 0);
        Spi_Cs_n   : std_logic_vector(SlaveCnt_g - 1 downto 0);
        Spi_Sclk   : std_logic;
        Spi_Mosi   : std_logic;
        ClkDivCnt  : integer range 0 to ClkDivThres_c;
        BitCnt     : integer range 0 to MaxTransWidth_g;
        CsHighCnt  : integer range 0 to CsHighCycles_c - 1;
        Busy       : std_logic;
        Done       : std_logic;
        MosiNext   : std_logic;
        TransWidth : integer range 0 to MaxTransWidth_g;
    end record;

    signal r, r_next : TwoProcess_r;

    signal SpiMiso_i : std_logic;

    attribute dont_merge of SpiMiso_i   : signal is DontMerge_SuppressChanges_c;
    attribute preserve of SpiMiso_i     : signal is Preserve_SuppressChanges_c;
    attribute keep of SpiMiso_i         : signal is Keep_SuppressChanges_c;
    attribute dont_touch of SpiMiso_i   : signal is DontTouch_SuppressChanges_c;
    attribute syn_keep of SpiMiso_i     : signal is SynKeep_SuppressChanges_c;
    attribute syn_preserve of SpiMiso_i : signal is SynPreserve_SuppressChanges_c;

    function getClockLevel (ClkActive : boolean) return std_logic is
    begin
        if SpiCpol_g = 0 then
            if ClkActive then
                return '1';
            else
                return '0';
            end if;
        else
            if ClkActive then
                return '0';
            else
                return '1';
            end if;
        end if;
    end function;

    procedure shiftReg (
        signal BeforeShift  : in std_logic_vector(MaxTransWidth_g-1 downto 0);
        variable AfterShift : out std_logic_vector(MaxTransWidth_g-1 downto 0);
        signal InputBit     : in std_logic;
        variable OutputBit  : out std_logic;
        TransWidth          : in integer range 0 to MaxTransWidth_g) is
    begin
        if LsbFirst_g then
            OutputBit                := BeforeShift(0);
            AfterShift               := '0' & BeforeShift(BeforeShift'high downto 1);
            AfterShift(TransWidth-1) := InputBit;
        else
            OutputBit  := BeforeShift(TransWidth-1);
            AfterShift := BeforeShift(BeforeShift'high - 1 downto 0) & InputBit;
        end if;
    end procedure;

begin

    assert abs(SclkFreqResult_c/SclkFreq_g - 1.0) < 0.1
        report ""###ERROR###: olo_intf_spi_master - SclkFreq_g is not within 10% of the actual Sclk frequency""
        severity error;

    SpiMiso_i <= Spi_Miso;

    p_comb : process (r, Cmd_Valid, Cmd_Data, SpiMiso_i, Cmd_Slave, Cmd_TransWidth) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.Done := '0';

        case r.State is
            when Idle_s =>
                if Cmd_Valid = '1' then
                    v.shiftReg                                  := Cmd_Data;
                    v.Spi_Cs_n(to_integer(unsigned(Cmd_Slave))) := '0';
                    v.State                                     := SftComp_s;
                    v.Busy                                      := '1';
                    v.TransWidth                                := fromUslv(Cmd_TransWidth);
                end if;
                v.CsHighCnt := 0;
                v.ClkDivCnt := 0;
                v.BitCnt    := 0;

            when SftComp_s =>
                v.State := ClkInact_s;
                if SpiCpha_g = 0 then
                    shiftReg(r.shiftReg, v.shiftReg, SpiMiso_i, v.MosiNext, r.TransWidth);
                end if;

            when ClkInact_s =>
                v.Spi_Sclk := getClockLevel(false);
                if r.ClkDivCnt = 0 then
                    if SpiCpha_g = 0 then
                        v.Spi_Mosi := r.MosiNext;
                    else
                        shiftReg(r.shiftReg, v.shiftReg, SpiMiso_i, v.MosiNext, r.TransWidth);
                    end if;
                end if;
                if r.ClkDivCnt = ClkDivThres_c then
                    if r.BitCnt = r.TransWidth then
                        v.Spi_Mosi := MosiIdleState_g;
                        v.State    := CsHigh_s;
                    else
                        v.State := ClkAct_s;
                    end if;
                    v.ClkDivCnt := 0;
                else
                    v.ClkDivCnt := r.ClkDivCnt + 1;
                end if;

            when ClkAct_s =>
                v.Spi_Sclk := getClockLevel(true);
                if r.ClkDivCnt = 0 then
                    if SpiCpha_g = 1 then
                        v.Spi_Mosi := r.MosiNext;
                    else
                        shiftReg(r.shiftReg, v.shiftReg, SpiMiso_i, v.MosiNext, r.TransWidth);
                    end if;
                end if;
                if r.ClkDivCnt = ClkDivThres_c then
                    v.State     := ClkInact_s;
                    v.ClkDivCnt := 0;
                    v.BitCnt    := r.BitCnt + 1;
                else
                    v.ClkDivCnt := r.ClkDivCnt + 1;
                end if;

            when CsHigh_s =>
                v.Spi_Cs_n := (others => '1');
                if r.CsHighCnt = CsHighCycles_c - 1 then
                    v.State  := Idle_s;
                    v.Busy   := '0';
                    v.Done   := '1';
                    v.RdData := r.shiftReg;
                else
                    v.CsHighCnt := r.CsHighCnt + 1;
                end if;

            when others => null; -- unreachable code
        end case;

        r_next <= v;
    end process;

    Cmd_Ready  <= not r.Busy;
    Resp_Valid <= r.Done;
    Resp_Data  <= r.RdData;
    Spi_Sclk   <= r.Spi_Sclk;
    Spi_Cs_n   <= r.Spi_Cs_n;
    Spi_Mosi   <= r.Spi_Mosi;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.State    <= Idle_s;
                r.Spi_Cs_n <= (others => '1');
                r.Spi_Sclk <= getClockLevel(false);
                r.Busy     <= '0';
                r.Done     <= '0';
                r.Spi_Mosi <= MosiIdleState_g;
            end if;
        end if;
    end process;

end architecture;",3
"This entity implements a simple SPI slave. All common SPI settings are configurable to ensure the master can be configured for different applications. The clock and data phase is configurable according to the SPI standard terminology (CPHA/CPOL). See [Details](#details) for more information. The component allows single transactions (where _CS_n_ goes high after every transaction) and consecutive transactions (where _CS_n_ does not go high between transactions), which makes it flexible to implement various protocols. See [Details](#details) for more information. On the user-side there are 3 AXI4-Stream interfaces: - TX data (data transmitted from the slave - through MISO) - RX data (data received from the master - through MOSI) - Response - informing the user whether TX data was transmitted or if the master aborted the transaction by pulling _CS_n_ high. - The Response interface is optional and in most cases can be omitted. The all SPI signals are properly synchronized to _Clk_ using [olo_intf_sync](./olo_intf_sync.md) within _olo_intf_spi_slave_. The maximum supported _Spi_Sclk_ frequency is 10x less than the _Clk_ frequency (with some tricks up to 8x less).

# VHDL Analysis for 'olo_intf_spi_slave.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler, Switzerland
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple SPI-slave
- Documentation:
- Plus 76 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_intf_spi_slave

## Architecture: rtl of olo_intf_spi_slave

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- SpiMosi_i: std_logic
- SpiSclk_i: std_logic
- SpiCsn_i: std_logic
- ***
        r_next <= v;
    end process;

    -----------------------------------------------------------------------------------------------
    -- Outputs
    -----------------------------------------------------------------------------------------------
    Rx_Valid      <= r.Rx_Valid;
    Rx_Data       <= r.Rx_Data;
    Tx_Ready      <= r.Tx_Ready;
    Resp_Valid    <= r.Resp_Valid;
    Resp_Sent     <= r.Resp_Sent;
    Resp_Aborted  <= r.Resp_Aborted;
    Resp_CleanEnd <= r.Resp_CleanEnd;

    -- Inernal Tri-State Buffers
    g_int_tristate: if InternalTriState_g generate
        Spi_Miso <= r.SpiMisoData when r.SpiMisoTristate = '0' else 'Z'
- SyncIn: std_logic_vector(2 downto 0)
- SyncOut: std_logic_vector(2 downto 0)

### Component Instantiations
- Instance 'i_sync' of component 'olo_intf_sync'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, Tx_Data, Tx_Valid, SpiSclk_i, SpiMosi_i, SpiCsn_i
  - Implements case-based selection logic
  - Contains wait statements: shift register update
                        -- Transaction completed successfully
                        v.Resp_Valid := '1', for CS to go high
                        else
                            v.State := WaitCsHigh_s
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
  - Contains wait statements: shift register update
                        -- Transaction completed successfully
                        v.Resp_Valid := '1', for CS to go high
                        else
                            v.State := WaitCsHigh_s
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Default Values ***
        CsnRe_v         := '0'
- CsnFe_v         := '0'
- SclkRe_v        := '0'
- SclkFe_v        := '0'
- LeaveState_v    := false
- Plus 8 more statements

## Functional Analysis

- This appears to be a Finite State Machine implementation
- Contains 4 clock domain(s): Clk, SCLK, Clock, Spi_Sclk
- Uses reset signal(s): RstLevel_g, first, LsbFirst_g, Rst, First
- Implements control logic
- Implements interface or communication protocol

## Code Metrics
- Line count: 350
- Process count: 4
- Signal count: 8

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_intf_spi_slave.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: SPI Slave Interface**

**Overview**

The SPI Slave Interface (OLO_INTFSPI_SLAVE) is a digital component designed to facilitate communication between a master device and a slave device over a Serial Peripheral Interface (SPI) bus. The component acts as a slave device, receiving data from the master and transmitting data back to the master.

**Functionality**

The OLO_INTFSPI_SLAVE component performs the following functions:

* Receives data from the master device over the SPI bus
* Transmits data back to the master device over the SPI bus
* Provides status signals to indicate the validity of received data and the readiness of transmitted data
* Supports configurable SPI modes (CPOL and CPHA)
* Supports configurable data transmission width (up to 32 bits)
* Supports consecutive transactions

**Inputs**

* `Clk`: Clock signal (input)
* `Rst`: Reset signal (input)
* `Tx_Valid`: Transmit data validity signal (input)
* `Tx_Data`: Transmit data (input)
* `Spi_Sclk`: SPI clock signal (input)
* `Spi_Mosi`: SPI master out slave in signal (input)
* `Spi_Cs_n`: SPI chip select signal (input)

**Outputs**

* `Rx_Valid`: Received data validity signal (output)
* `Rx_Data`: Received data (output)
* `Tx_Ready`: Transmit data readiness signal (output)
* `Resp_Valid`: Response validity","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_intf_spi_slave is
    generic (
        TransWidth_g                : positive             := 32;
        SpiCpol_g                   : natural range 0 to 1 := 0;
        SpiCpha_g                   : natural range 0 to 1 := 0;
        LsbFirst_g                  : boolean              := false;
        ConsecutiveTransactions_g   : boolean              := false;
        InternalTriState_g          : boolean              := true
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Rx_Valid        : out   std_logic;
        Rx_Data         : out   std_logic_vector(TransWidth_g - 1 downto 0);
        Tx_Valid        : in    std_logic                                   := '1';
        Tx_Ready        : out   std_logic;
        Tx_Data         : in    std_logic_vector(TransWidth_g - 1 downto 0) := (others => '0');
        Resp_Valid      : out   std_logic;
        Resp_Sent       : out   std_logic;
        Resp_Aborted    : out   std_logic;
        Resp_CleanEnd   : out   std_logic;
        Spi_Sclk        : in    std_logic;
        Spi_Mosi        : in    std_logic                                   := '0';
        Spi_Cs_n        : in    std_logic;
        Spi_Miso        : out   std_logic;
        Spi_Miso_o      : out   std_logic;
        Spi_Miso_t      : out   std_logic
    );
end entity;

architecture rtl of olo_intf_spi_slave is

    type State_t is (Idle_s, LatchTx_s, WaitSampleEdge_s, WaitInactiveEdge_s, WaitCsHigh_s);

    type TwoProcess_r is record
        SpiCsnLast      : std_logic;
        SpiSclkLast     : std_logic;
        State           : State_t;
        Tx_Ready        : std_logic;
        SpiMisoData     : std_logic;
        SpiMisoTristate : std_logic;
        BitCnt          : integer range 0 to TransWidth_g;
        ShiftReg        : std_logic_vector(TransWidth_g - 1 downto 0);
        IsConsecutive   : boolean;
        Rx_Valid        : std_logic;
        Rx_Data         : std_logic_vector(TransWidth_g - 1 downto 0);
        Resp_Sent       : std_logic;
        Resp_Aborted    : std_logic;
        Resp_Valid      : std_logic;
        Resp_CleanEnd   : std_logic;
        RxOutput        : std_logic;
        DataLatched     : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal SpiMosi_i : std_logic;
    signal SpiSclk_i : std_logic;
    signal SpiCsn_i  : std_logic;

    constant TxIdx_c : integer := choose(LsbFirst_g, 0, TransWidth_g - 1);

begin

    p_comb : process (r, Tx_Data, Tx_Valid, SpiSclk_i, SpiMosi_i, SpiCsn_i) is
        variable v                  : TwoProcess_r;
        variable CsnRe_v, CsnFe_v   : std_logic;
        variable SclkRe_v, SclkFe_v : std_logic;
        variable SampleEdge_v       : std_logic;
        variable TrasmitEdge_v      : std_logic;
        variable LeaveState_v       : boolean;
    begin
        v := r;

        CsnRe_v         := '0';
        CsnFe_v         := '0';
        SclkRe_v        := '0';
        SclkFe_v        := '0';
        LeaveState_v    := false;
        v.Rx_Valid      := '0';
        v.Resp_Sent     := '0';
        v.Resp_Aborted  := '0';
        v.Resp_Valid    := '0';
        v.RxOutput      := '0';
        v.Resp_CleanEnd := '0';

        if SpiCsn_i /= to01(r.SpiCsnLast) then
            CsnRe_v := SpiCsn_i;
            CsnFe_v := not SpiCsn_i;
        end if;
        v.SpiCsnLast := SpiCsn_i;
        if SpiSclk_i /= to01(r.SpiSclkLast) then
            SclkRe_v := SpiSclk_i;
            SclkFe_v := not SpiSclk_i;
        end if;
        v.SpiSclkLast := SpiSclk_i;
        if SpiCpol_g = SpiCpha_g then
            SampleEdge_v  := SclkRe_v;
            TrasmitEdge_v := SclkFe_v;
        else
            SampleEdge_v  := SclkFe_v;
            TrasmitEdge_v := SclkRe_v;
        end if;

        case r.State is
            when Idle_s =>
                v.SpiMisoTristate := '1';
                if CsnFe_v = '1' then
                    v.State       := LatchTx_s;
                    v.DataLatched := '0';
                    v.Tx_Ready    := '1';
                end if;
                v.IsConsecutive := false;

            when LatchTx_s =>
                v.BitCnt := 0;
                if Tx_Valid = '1' then
                    v.ShiftReg    := Tx_Data;
                    v.Tx_Ready    := '0';
                    v.DataLatched := '1';
                    v.SpiMisoData := Tx_Data(TxIdx_c);
                end if;
                if SpiCpha_g = 0 and not r.IsConsecutive then
                    LeaveState_v := true;
                else
                    if TrasmitEdge_v = '1' then
                        LeaveState_v := true;
                    end if;
                end if;
                if LeaveState_v then
                    v.State := WaitSampleEdge_s;
                    if r.DataLatched = '0' and Tx_Valid = '0' then
                        v.ShiftReg := (others => '0');
                    end if;
                    v.Tx_Ready := '0';
                    v.SpiMisoData     := v.ShiftReg(TxIdx_c);
                    v.SpiMisoTristate := '0';
                end if;

            when WaitSampleEdge_s =>
                if SampleEdge_v = '1' then
                    if LsbFirst_g = false then
                        v.ShiftReg    := r.ShiftReg(r.ShiftReg'high - 1 downto 0) & SpiMosi_i;
                        v.SpiMisoData := r.ShiftReg(r.ShiftReg'high-1);
                    else
                        v.ShiftReg    := SpiMosi_i & r.ShiftReg(r.ShiftReg'high downto 1);
                        v.SpiMisoData := r.ShiftReg(1);
                    end if;
                    if r.BitCnt = TransWidth_g - 1 then
                        v.SpiMisoData := r.SpiMisoData;
                        v.RxOutput := '1'; -- Done in next cycle to await shift register update
                        v.Resp_Valid := '1';
                        v.Resp_Sent  := '1';
                        if ConsecutiveTransactions_g then
                            v.State       := LatchTx_s;
                            v.DataLatched := '0';
                            v.Tx_Ready    := '1';
                        else
                            v.State := WaitCsHigh_s;
                        end if;
                    else
                        v.State := WaitInactiveEdge_s;
                    end if;
                end if;
                v.IsConsecutive := true;

            when WaitInactiveEdge_s =>
                if TrasmitEdge_v = '1' then
                    v.State  := WaitSampleEdge_s;
                    v.BitCnt := r.BitCnt + 1;
                end if;

            when WaitCsHigh_s => null;  -- Return to idle is handled after FSM

            when others => null; -- unreachable code
        end case;

        if r.RxOutput = '1' then
            v.Rx_Valid := '1';
            v.Rx_Data  := r.ShiftReg;
        end if;

        if SpiCsn_i = '1' then
            v.State           := Idle_s;
            v.SpiMisoTristate := '1';
            if r.State /= WaitCsHigh_s and r.State /= Idle_s and r.DataLatched = '1' then
                v.Resp_Valid   := '1';
                v.Resp_Aborted := '1';
            elsif r.State /= Idle_s then
                v.Resp_Valid    := '1';
                v.Resp_CleanEnd := '1';
            end if;
        end if;

        r_next <= v;
    end process;

    Rx_Valid      <= r.Rx_Valid;
    Rx_Data       <= r.Rx_Data;
    Tx_Ready      <= r.Tx_Ready;
    Resp_Valid    <= r.Resp_Valid;
    Resp_Sent     <= r.Resp_Sent;
    Resp_Aborted  <= r.Resp_Aborted;
    Resp_CleanEnd <= r.Resp_CleanEnd;

    g_int_tristate : if InternalTriState_g generate
        Spi_Miso <= r.SpiMisoData when r.SpiMisoTristate = '0' else 'Z';
    end generate;

    g_ext_tristate : if not InternalTriState_g generate
        Spi_Miso_o <= r.SpiMisoData;
        Spi_Miso_t <= r.SpiMisoTristate;
    end generate;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.SpiCsnLast      <= '1';
                r.State           <= Idle_s;
                r.Tx_Ready        <= '0';
                r.SpiMisoTristate <= '1';
                r.RxOutput        <= '0';
            end if;
        end if;
    end process;

    b_sync : block is
        signal SyncIn, SyncOut : std_logic_vector(2 downto 0);
    begin
        SyncIn(0) <= Spi_Sclk;
        SyncIn(1) <= Spi_Mosi;
        SyncIn(2) <= Spi_Cs_n;

        i_sync : entity work.olo_intf_sync
            generic map (
                Width_g     => 3,
                RstLevel_g  => '1'
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                DataAsync   => SyncIn,
                DataSync    => SyncOut
            );

        SpiSclk_i <= SyncOut(0);
        SpiMosi_i <= SyncOut(1);
        SpiCsn_i  <= SyncOut(2);
    end block;

end architecture;",4
"This component implements a N-stage synchronizer for synchronizing external signals to the internal clock. It also sets all the attributes required for proper synthesis. Note that this synchronizer does not guarantee that all bits arrive in the same clock cycle at the destination clock domain, therefore it can only be used for independent single-bit signals. Do not use it to transfer multi-bit signals (e.g. numbers) where it is important that all the bits are updated in the same clock cycle. It is suggested to use this entity only for synchronizing external signals. For synchronizing FPGA internal signals between clocks, the clock crossings in _base_ shall be used (_olo_base_cc_..._). For _AMD_ tools (_Vivado_) an automatic constraint file exists, which automatically identifies all _olo_intf_sync_ instances and constrains them correctly. To use the automatic constraints file, follow the steps described in [clock crossing principles](../base/clock_crossing_principles.md) but use the constraints file **Note:** Automatic constraining currently only works for _AMD_ tools (_Vivado_) and the usage in VHDL. Manual constraints are required for Verilog or other tools.

# VHDL Analysis for 'olo_intf_sync.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a simple double-stage synchronizer for synchronizing external
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_intf_sync

## Architecture: struct of olo_intf_sync

### Signals
- Reg0: std_logic_vector(Width_g - 1 downto 0) := (others => RstLevel_g)
- RegN: SyncStages_t                           := (others => (others => RstLevel_g))
- is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN: signal is ShregExtract_SuppressExtraction_c
- is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegN: signal is SynSrlstyle_FlipFlops_c
- is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN: signal is DontMerge_SuppressChanges_c
- is Preserve_SuppressChanges_c;
    attribute preserve of RegN: signal is Preserve_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegN: signal is SynKeep_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN: signal is SynPreserve_SuppressChanges_c
- is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN: signal is AsyncReg_TreatAsync_c

### Processes
- Process 'p_outff :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- RegN(0) <= Reg0
- -- Loop through aremaining stages
            for i in 1 to RegN'high loop
                RegN(i) <= RegN(i - 1)

## Functional Analysis

- Contains 2 clock domain(s): clock, Clk
- Uses reset signal(s): Reset, Rst, RstLevel_g, First
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 119
- Process count: 2
- Signal count: 9

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_intf_sync.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: olo_intf_sync**

**Component Description:**
The olo_intf_sync component is a generic, synchronous data synchronizer that takes an asynchronous input data signal and produces a synchronized output data signal. It is designed to interface with asynchronous data sources and provide a reliable, clock-domain crossing solution.

**Functional Description:**

* The component takes in an asynchronous data signal (`DataAsync`) and synchronizes it to the input clock (`Clk`) using a configurable number of synchronization stages (`SyncStages_g`).
* The synchronized data signal is then output as (`DataSync`).
* The component includes a reset input (`Rst`) that, when asserted, resets the internal registers to a specified reset level (`RstLevel_g`).

**Inputs:**

* `Clk`: Input clock signal
* `Rst`: Reset signal (active high)
* `DataAsync`: Asynchronous input data signal (Width_g bits)

**Outputs:**

* `DataSync`: Synchronized output data signal (Width_g bits)

**Parameters:**

* `Width_g`: The width of the input and output data signals (default: 1)
* `RstLevel_g`: The reset level of the internal registers (default: '0')
* `SyncStages_g`: The number of synchronization stages (default: 2, range: 2 to 4)

**Attributes:**

* The component includes various attributes to control synthesis and optimization:
	+ `shreg_extract`, `syn_srlstyle`,","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;


entity olo_intf_sync is
    generic (
        Width_g      : positive              := 1;
        RstLevel_g   : std_logic             := '0';
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic := '0';
        DataAsync   : in    std_logic_vector(Width_g - 1 downto 0);
        DataSync    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;


architecture struct of olo_intf_sync is

    type SyncStages_t is array(0 to SyncStages_g - 2) of std_logic_vector(Width_g - 1 downto 0);

    signal Reg0 : std_logic_vector(Width_g - 1 downto 0) := (others => RstLevel_g);
    signal RegN : SyncStages_t                           := (others => (others => RstLevel_g));

    attribute shreg_extract of Reg0 : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of Reg0 : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegN : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of Reg0 : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN : signal is DontMerge_SuppressChanges_c;

    attribute preserve of Reg0 : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegN : signal is Preserve_SuppressChanges_c;

    attribute syn_keep of Reg0 : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegN : signal is SynKeep_SuppressChanges_c;

    attribute syn_preserve of Reg0 : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN : signal is SynPreserve_SuppressChanges_c;

    attribute async_reg of Reg0 : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN : signal is AsyncReg_TreatAsync_c;

begin

    p_outff : process (Clk) is
    begin
        if rising_edge(Clk) then
            Reg0    <= DataAsync;
            RegN(0) <= Reg0;

            for i in 1 to RegN'high loop
                RegN(i) <= RegN(i - 1);
            end loop;

            if Rst = '1' then
                Reg0 <= (others => RstLevel_g);
                RegN <= (others => (others => RstLevel_g));
            end if;
        end if;
    end process;

    DataSync <= RegN(RegN'high);

end architecture;
",5
"This entity implements an UART. It is designed to run high baud-rates (up to 10% of the clock frequency). Parity checking for RX and parity calculation for TX is done internally in _olo_intf_uart_. The _Uart_Rx_ line is synchronized internally inside _olo_intf_uart_. The UART protocol is commonly known and hence not described here. A good and concise description of the protocol can be found [here](https://ece353.engr.wisc.edu/serial-interfaces/uart-basics/).

# VHDL Analysis for 'olo_intf_uart.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler, Switzerland
- All rights reserved.
- Authors: Oliver Bruendler, Franz Herzog
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple UART.
- Documentation:
- Plus 72 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_intf_uart

## Architecture: rtl of olo_intf_uart

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- TxStrobe: std_logic
- RxStrobe: std_logic
- UartRxInt: std_logic
- ***
        r_next <= v;
    end process;

    -----------------------------------------------------------------------------------------------
    -- Outputs
    -----------------------------------------------------------------------------------------------
    Tx_Ready       <= r.Tx_Ready;
    Uart_Tx        <= r.Uart_Tx;
    Rx_ParityError <= r.Rx_ParityError;
    Rx_Data        <= r.RxShiftReg;
    Rx_Valid       <= r.Rx_Valid;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Component Instantiations
- Instance 'i_strb_tx' of component 'olo_base_strobe_gen'
- Instance 'i_strb_rx' of component 'olo_base_strobe_gen'
- Instance 'i_sync' of component 'olo_intf_sync'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, Tx_Valid, Tx_Data, UartRxInt, TxStrobe, RxStrobe
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst, Reset_s
- Implements control logic
- Implements interface or communication protocol
- Defines custom functions: parityBit, stopStrobeCount, transmitBits

## Code Metrics
- Line count: 372
- Process count: 4
- Signal count: 6

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_intf_uart.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Universal Asynchronous Receiver-Transmitter (UART) Interface**

**Overview**

The UART interface component is a digital circuit designed to facilitate serial communication between a system-on-chip (SoC) and external devices using the Universal Asynchronous Receiver-Transmitter (UART) protocol. This component enables the transmission and reception of data through a single serial communication line.

**Functional Description**

The UART interface component performs the following functions:

* **Transmission**: The component takes in parallel data, converts it into a serial bit stream, and transmits it through the `Uart_Tx` output line. The transmission process includes optional parity bit generation and stop bit insertion.
* **Reception**: The component receives a serial bit stream through the `Uart_Rx` input line, converts it into parallel data, and outputs it through the `Rx_Data` output line. The reception process includes optional parity bit checking and error detection.

**Inputs**

* `Clk`: Clock input signal
* `Rst`: Reset input signal
* `Tx_Valid`: Transmission valid input signal (active high)
* `Tx_Data`: Transmission data input signal (parallel)
* `Uart_Rx`: Received serial data input signal

**Outputs**

* `Tx_Ready`: Transmission ready output signal (active high)
* `Uart_Tx`: Transmitted serial data output signal
* `Rx_Valid`: Received data valid output signal (active high)
* `Rx_Data`: Received data output signal (parallel","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_intf_uart is
    generic (
        ClkFreq_g       : real;
        BaudRate_g      : real                  := 115.2e3;
        DataBits_g      : positive range 7 to 9 := 8;
        StopBits_g      : string                := ""1"";
        Parity_g        : string                := ""none""
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Tx_Valid        : in    std_logic                                 := '0';
        Tx_Ready        : out   std_logic;
        Tx_Data         : in    std_logic_vector(DataBits_g - 1 downto 0) := (others => '0');
        Rx_Valid        : out   std_logic;
        Rx_Data         : out   std_logic_vector(DataBits_g - 1 downto 0);
        Rx_ParityError  : out   std_logic;
        Uart_Tx         : out   std_logic;
        Uart_Rx         : in    std_logic                                 := '1'
    );
end entity;

architecture rtl of olo_intf_uart is

    type StateTx_t is (Reset_s, Idle_s, Data_s, Stop_s);
    type StateRx_t is (Idle_s, Start_s, Data_s, Parity_s, Stop_s);

    function parityBit (Data : std_logic_vector) return std_logic is
        variable Parity_v : std_logic := '0';
    begin
        if Parity_g = ""none"" then
            return '0';
        end if;

        for i in Data'range loop
            Parity_v := Parity_v xor Data(i);
        end loop;

        if Parity_g = ""even"" then
            return Parity_v;
        else
            return not Parity_v;
        end if;
    end function;

    function stopStrobeCount return natural is
    begin
        if StopBits_g = ""1"" then
            return 2;
        elsif StopBits_g = ""1.5"" then
            return 3;
        else
            return 4;
        end if;
    end function;

    function transmitBits return natural is
        variable Bits_v : natural := DataBits_g;
    begin
        Bits_v := Bits_v + 1;
        if Parity_g /= ""none"" then
            Bits_v := Bits_v + 1;
        end if;
        return Bits_v;
    end function;

    type TwoProcess_r is record
        StateTx        : StateTx_t;
        TxCount        : natural range 0 to transmitBits*2 - 1;
        Tx_Ready       : std_logic;
        TxSync         : std_logic;
        TxShiftReg     : std_logic_vector(DataBits_g+1 downto 0);
        Uart_Tx        : std_logic;
        StateRx        : StateRx_t;
        RxCount        : natural range 0 to DataBits_g*2 - 1;
        RxSync         : std_logic;
        RxShiftReg     : std_logic_vector(DataBits_g-1 downto 0);
        Rx_ParityError : std_logic;
        Rx_Valid       : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal TxStrobe  : std_logic;
    signal RxStrobe  : std_logic;
    signal UartRxInt : std_logic;

begin

    assert BaudRate_g > 0.0
        report ""olo_intf_uart - BaudRate_g must be greater than 0""
        severity error;

    assert StopBits_g = ""1"" or StopBits_g = ""1.5"" or StopBits_g = ""2""
        report ""olo_intf_uart - StopBits_g must be 1, 1.5 or 2""
        severity error;

    assert Parity_g = ""none"" or Parity_g = ""even"" or Parity_g = ""odd""
        report ""olo_intf_uart - Parity_g must be none, even or odd""
        severity error;

    assert BaudRate_g <= ClkFreq_g / 10.0
        report ""olo_intf_uart - BaudRate_g must be <= ClkFreq_g / 10.0""
        severity error;

    p_comb : process (r, Tx_Valid, Tx_Data, UartRxInt, TxStrobe, RxStrobe) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.TxSync  := '0';
        v.Uart_Tx := '1';

        case r.StateTx is
            when Reset_s =>
                v.Tx_Ready := '1';
                v.StateTx  := Idle_s;

            when Idle_s =>
                if r.Tx_Ready = '0' and TxStrobe = '1' then
                    v.StateTx := Data_s;
                    v.TxCount := 0;
                elsif Tx_Valid = '1' and r.Tx_Ready = '1' then
                    v.Tx_Ready   := '0';
                    v.TxSync     := '1';
                    v.TxShiftReg := parityBit(Tx_Data) & Tx_Data & '0';
                end if;

            when Data_s =>
                v.Uart_Tx := r.TxShiftReg(0);
                if TxStrobe = '1' then
                    if r.TxCount = transmitBits*2 - 1 then
                        v.TxCount := 0;
                        v.StateTx := Stop_s;
                    else
                        if r.TxCount mod 2 = 1 then
                            v.TxShiftReg := '0' & r.TxShiftReg(r.TxShiftReg'high downto 1);
                        end if;
                        v.TxCount := r.TxCount + 1;
                    end if;
                end if;

            when Stop_s =>
                v.Uart_Tx := '1';
                if TxStrobe = '1' then
                    if r.TxCount = stopStrobeCount-1 then
                        v.StateTx  := Idle_s;
                        v.Tx_Ready := '1';
                    else
                        v.TxCount := r.TxCount + 1;
                    end if;
                end if;

            when others =>
                null; -- unreachable code

        end case;

        v.RxSync   := '0';
        v.Rx_Valid := '0';

        case r.StateRx is
            when Idle_s =>
                v.Rx_ParityError := '0';
                if UartRxInt = '0' then
                    v.RxSync  := '1';
                    v.StateRx := Start_s;
                    v.RxCount := 0;
                end if;

            when Start_s =>
                if RxStrobe = '1' then
                    if r.RxCount = 2 then
                        v.StateRx := Data_s;
                        v.RxCount := 0;
                    else
                        if UartRxInt = '1' then
                            v.StateRx := Idle_s;
                        end if;
                        v.RxCount := r.RxCount + 1;
                    end if;
                end if;

            when Data_s =>
                if RxStrobe = '1' then
                    if r.RxCount mod 2 = 0 then
                        v.RxShiftReg := UartRxInt & r.RxShiftReg(DataBits_g-1 downto 1);
                    end if;
                    if r.RxCount = DataBits_g*2 - 1 then
                        if Parity_g = ""none"" then
                            v.StateRx := Stop_s;
                        else
                            v.StateRx := Parity_s;
                        end if;
                        v.RxCount := 0;
                    else
                        v.RxCount := r.RxCount + 1;
                    end if;
                end if;

            when Parity_s =>
                if RxStrobe = '1' then
                    if r.RxCount = 1 then
                        v.StateRx := Stop_s;
                    else
                        v.RxCount := r.RxCount + 1;
                        if UartRxInt /= parityBit(r.RxShiftReg) then
                            v.Rx_ParityError := '1';
                        end if;
                    end if;
                end if;

            when Stop_s =>
                if RxStrobe = '1' then
                    v.StateRx  := Idle_s;
                    v.Rx_Valid := '1';
                end if;

            when others =>
                null; -- unreachable code

        end case;

        r_next <= v;
    end process;

    Tx_Ready       <= r.Tx_Ready;
    Uart_Tx        <= r.Uart_Tx;
    Rx_ParityError <= r.Rx_ParityError;
    Rx_Data        <= r.RxShiftReg;
    Rx_Valid       <= r.Rx_Valid;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.StateTx  <= Reset_s;
                r.Tx_Ready <= '0';
                r.StateRx <= Idle_s;
            end if;
        end if;
    end process;

    i_strb_tx : entity work.olo_base_strobe_gen
        generic map (
            FreqClkHz_g      => ClkFreq_g,
            FractionalMode_g => true,
            FreqStrobeHz_g   => BaudRate_g*2.0 -- 2x baud rate
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            In_Sync     => r.TxSync,
            Out_Valid   => TxStrobe
        );

    i_strb_rx : entity work.olo_base_strobe_gen
        generic map (
            FreqClkHz_g      => ClkFreq_g,
            FractionalMode_g => true,
            FreqStrobeHz_g   => BaudRate_g*2.0 -- 2x baud rate
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            In_Sync     => r.RxSync,
            Out_Valid   => RxStrobe
        );

    i_sync : entity work.olo_intf_sync
        port map (
            Clk             => Clk,
            Rst             => Rst,
            DataAsync(0)    => Uart_Rx,
            DataSync(0)     => UartRxInt
        );

end architecture;",6
"This entity implements a priority arbiter. The left-most bit (highest bit) of the request vector that was asserted is granted (i.e. asserted in the grant  vector). The arbiter is implemented using the very logic-and timing-efficient parallel prefix computation approach. The arbiter can be implemented with or without an output registers. The waveform below shows its implementation with andwithout output register (_Latency_g = 0_ resp. 1).

# VHDL Analysis for 'olo_base_arb_prio.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements an efficient priority arbiter. The highest index of
- Plus 21 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_arb_prio

## Architecture: rtl of olo_base_arb_prio

### Signals
- Grant_I: std_logic_vector(Out_Grant'range)
- RdPipe: Data_t(1 to Latency_g)

### Processes
- Process 'p_comb :' with sensitivity list: In_Req
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_comb :' with sensitivity list: None (uses wait statements)
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Calculate Grant with Edge Detection
            Grant_I <= OredRequest_v and not ('0' & OredRequest_v(OredRequest_v'high downto 1))

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 101
- Process count: 4
- Signal count: 2

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_arb_prio.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_arb_prio` component is a priority-based arbiter that resolves competing requests from multiple sources. It accepts a vector of request signals (`In_Req`) and generates a corresponding vector of grant signals (`Out_Grant`), prioritizing the first asserted request in a one-hot encoded manner. The component introduces a configurable latency (`Latency_g`) between request and grant signals.

**Component Specification**

* **Component Name:** `olo_base_arb_prio`
* **Functionality:** Priority-based arbiter with optional latency
* **Inputs:**
	+ `Clk`: Clock signal (std_logic)
	+ `Rst`: Reset signal (std_logic)
	+ `In_Req`: Vector of request signals (std_logic_vector, Width_g bits)
* **Outputs:**
	+ `Out_Grant`: Vector of grant signals (std_logic_vector, Width_g bits)
* **Generics:**
	+ `Width_g`: Width of the request and grant vectors (positive integer)
	+ `Latency_g`: Latency between request and grant signals (natural integer, default: 1)
* **Behavior:**
	1. The component accepts a vector of request signals (`In_Req`) and generates a corresponding vector of grant signals (`Out_Grant`).
	2. The grant signals are prioritized such that the first asserted request in the vector is granted.
	3. The component introduces a latency (`Latency_g`) between the request and grant signals.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_arb_prio is
    generic (
        Width_g    : positive;
        Latency_g  : natural := 1
    );
    port (
        Clk        : in    std_logic;
        Rst        : in    std_logic;
        In_Req     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Grant  : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_arb_prio is

    type Data_t is array (natural range<>) of std_logic_vector(Out_Grant'range);

    signal Grant_I : std_logic_vector(Out_Grant'range);
    signal RdPipe  : Data_t(1 to Latency_g);

begin

    g_non_zero : if Width_g > 0 generate

        p_comb : process (In_Req) is
            variable OredRequest_v : std_logic_vector(In_Req'range);
        begin
            OredRequest_v := ppcOr(In_Req);

            Grant_I <= OredRequest_v and not ('0' & OredRequest_v(OredRequest_v'high downto 1));
        end process;

        g_reg : if Latency_g > 0 generate

            p_outreg : process (Clk) is
            begin
                if rising_edge(Clk) then
                    if Rst = '1' then
                        RdPipe <= (others => (others => '0'));
                    else
                        RdPipe(1)              <= Grant_I;
                        RdPipe(2 to Latency_g) <= RdPipe(1 to Latency_g-1);
                    end if;
                end if;
            end process;

            Out_Grant <= RdPipe(Latency_g);
        end generate;

        g_nreg : if Latency_g = 0 generate
            Out_Grant <= Grant_I;
        end generate;

    end generate;

end architecture;",7
"This entity implements a round-robin arbiter. If multiple bits are asserted in the _In_Req_ vector, the left-most bit is forwarded to the grant vector first. Next, the second left-most bit that is set is forwarded etc. Whenever at least one bit in the _Out_Grant_ vector is asserted, the _Out_Valid_ handshaking signal is asserted to signal that a request was granted. The consumer of the _Out_Grant_ vector signalizes that the granted access was executed by pulling _Out_Ready_ high. Note that the round-robin arbiter is implemented without an output register. Therefore combinatorial paths between input and output exist and it is recommended to add a register-stage to the output as early as possible. Especially interesting is the part in orange. At this point the arbiter does not grant access to bit 3 because it already granted this request in the clock cycle before. However, it continues to grant access to the highest-priority (i.e. left-most) bit of the request vector that is still left of the bit set in the last _Out_Grant_ output. If the _In_Req_ vector asserts a higher priority this change is directly forwarded to the output. This is shown in the orange section of the waveform.

# VHDL Analysis for 'olo_base_arb_rr.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements an efficient round-robin arbiter.
- Plus 22 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_arb_rr

## Architecture: rtl of olo_base_arb_rr

### Signals
- r: TwoProcess_t
- r_next: TwoProcess_t
- RequestMasked: std_logic_vector(In_Req'range)
- GrantMasked: std_logic_vector(Out_Grant'range)
- GrantUnmasked: std_logic_vector(Out_Grant'range)

### Component Instantiations
- Instance 'i_prio_masked' of component 'olo_base_arb_prio'
- Instance 'i_prio_unmasked' of component 'olo_base_arb_prio'

### Processes
- Process 'p_comb :' with sensitivity list: r, In_Req, Out_Ready, GrantMasked, GrantUnmasked
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Round Robing Logic
            RequestMasked <= In_Req and r.Mask
- -- Generate Grant
            if unsigned(GrantMasked) = 0 then
                Grant_v := GrantUnmasked
- else
                Grant_v := GrantMasked

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 143
- Process count: 4
- Signal count: 5

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_arb_rr.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_arb_rr` component is a Round-Robin (RR) arbiter that resolves concurrent requests from multiple sources. It takes in a vector of request signals (`In_Req`), a clock signal (`Clk`), and a reset signal (`Rst`), and produces a grant signal (`Out_Grant`) indicating which request is accepted, along with a validity signal (`Out_Valid`) and readiness input (`Out_Ready`).

**Component Specification**

**Component Name:** Round-Robin Arbiter (`olo_base_arb_rr`)

**Functionality:**

* Resolves concurrent requests from multiple sources using a Round-Robin arbitration scheme
* Generates a grant signal indicating which request is accepted
* Produces a validity signal indicating whether a grant is valid

**Inputs:**

* `Clk`: Clock signal (1-bit)
* `Rst`: Reset signal (1-bit)
* `In_Req`: Request signal vector (Width_g bits)
* `Out_Ready`: Readiness signal (1-bit)

**Outputs:**

* `Out_Grant`: Grant signal vector (Width_g bits)
* `Out_Valid`: Validity signal (1-bit)

**Parameters:**

* `Width_g`: Positive integer specifying the width of the request and grant signal vectors

**Behavior:**

* On reset, the arbiter clears its internal state and masks all requests
* When a request is made, the arbiter generates a grant signal based on the Round-Robin scheme
*","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_arb_rr is
    generic (
        Width_g    : positive
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Req      : in    std_logic_vector(Width_g-1 downto 0);
        Out_Grant   : out   std_logic_vector(Width_g-1 downto 0);
        Out_Ready   : in    std_logic;
        Out_Valid   : out   std_logic
    );
end entity;

architecture rtl of olo_base_arb_rr is

    type TwoProcess_t is record
        Mask : std_logic_vector(In_Req'range);
    end record;

    signal r, r_next : TwoProcess_t;

    signal RequestMasked : std_logic_vector(In_Req'range);
    signal GrantMasked   : std_logic_vector(Out_Grant'range);
    signal GrantUnmasked : std_logic_vector(Out_Grant'range);

begin

    g_non_zero : if Width_g > 0 generate

        p_comb : process (r, In_Req, Out_Ready, GrantMasked, GrantUnmasked) is
            variable v       : TwoProcess_t;
            variable Grant_v : std_logic_vector(Out_Grant'range);
        begin
            v := r;

            RequestMasked <= In_Req and r.Mask;

            if unsigned(GrantMasked) = 0 then
                Grant_v := GrantUnmasked;
            else
                Grant_v := GrantMasked;
            end if;

            if (unsigned(Grant_v) /= 0) and (Out_Ready = '1') then
                v.Mask := '0' & ppcOr(Grant_v(Grant_v'high downto 1));
            end if;

            if unsigned(Grant_v) /= 0 then
                Out_Valid <= '1';
            else
                Out_Valid <= '0';
            end if;

            Out_Grant <= Grant_v;

            r_next <= v;

        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.Mask <= (others => '0');
                end if;
            end if;
        end process;

        i_prio_masked : entity work.olo_base_arb_prio
            generic map (
                Width_g   => Width_g,
                Latency_g => 0
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Req      => RequestMasked,
                Out_Grant   => GrantMasked
            );

        i_prio_unmasked : entity work.olo_base_arb_prio
            generic map (
                Width_g   => Width_g,
                Latency_g => 0
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Req      => In_Req,
                Out_Grant   => GrantUnmasked
            );

    end generate;

end architecture;",8
"This component implements a content addressable memory. Content addressable memories are usually used for fast-lookups in caches, routing tables and other similar scenarios. The concept of mapping a CAM into block and/or distributed RAM described in the [AMD application not XAPP 1151](https://docs.amd.com/v/u/en-US/xapp1151_Param_CAM) is applied. However, _olo_base_cam_ has a very different and much easier to understand user interface than the component described in the application note. The _olo_base_cam_ does allow to write address/content pairs and to find out in which address a queried content is stored. Reads take one clock cycle, writes take two clock cycles and the two things cannot happen at the same time. Below example assumes a _olo_base_cam_ with 4 addresses and 16 bit content. The CAM has logically separated read and write interfaces. They share some resources internally but from a users perspective they are independent. Every read-request issues through _Rd_..._ is followed by one output on both read-response streams: - _OneHot_..._ provides a match response - A vector with one entry per address, indicating if the requested _Rd_Content_ was stored in this address or not - _Addr_..._ provides the binary encoded address where _Rd_Content_ is stored - The first (lowest) matching address is returned - If _Rd_Content_ is not found, _Addr_Found='0'_ is returned. **Note:** By default the content of the CAM is cleared after reset. During the _RamBlockDepth_g_ clock cycles this takes, it is not ready to accept any requests and holds _Rd/Wr_Ready_ low. This behavior can be changed through generics if needed. **Warning:** The user must ensure that an address is NOT occupied when new content is written to this address. Failure to adhere to this rule may lead to undefined behavior.

# VHDL Analysis for 'olo_base_cam.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- --------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This components implements a content addressable memory.
- Documentation:
- Plus 75 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: WrReady is low)
                InRdReady_v := '1'

## Entity: olo_base_cam

## Architecture: rtl of olo_base_cam

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- Types ***
    type RamData_t is array (natural range <>) of std_logic_vector(Addresses_g-1 downto 0);

    -- *** Instantiation Signals ***
    signal ReadContent_0: std_logic_vector(ContentWidth_g-1 downto 0)
- RamRead_1: RamData_t(0 to BlocksParallel_c-1)
- RamWrite_1: RamData_t(0 to BlocksParallel_c-1)
- WrMem_1: std_logic
- MatchInt: std_logic_vector(Addresses_g-1 downto 0)
- MatchValid: std_logic
- if r.RstClearDone = '0' then
                -- Deasserting ready signals is done further up where the ready signals are assigned
                -- Clear CAM
                v.RstClearWr: = '1'
- ***
        r_next <= v;
    end process;

    -- Output signals
    Match_Valid <= MatchValid;
    Match_Match <= MatchInt;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next
- ContentExtended_0: std_logic_vector(TotalAddrBits_c-1 downto 0) := (others => '0')
- RdAddr_0: std_logic_vector(BlockAddrBits_c-1 downto 0)
- WrAddr_1: std_logic_vector(BlockAddrBits_c-1 downto 0)

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_cob :' (Has Reset) with sensitivity list: Rd_Valid, Rd_Content, Wr_Valid, Wr_Content, Wr_Addr, Wr_Write, Wr_Clear,
                     RamRead_1, Rst, r
  - Implements conditional logic
  - Contains wait statements: until write is done
        if r.Write_0 = '1' or r.Clear_0 = '1' or r.ClearAll_0 = '1' then
            InWrReady_v := '0', for RAM to respond
            v.ContentExtended_1                            := (others => '0')
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
  - Contains wait statements: until write is done
        if r.Write_0 = '1' or r.Clear_0 = '1' or r.ClearAll_0 = '1' then
            InWrReady_v := '0', for RAM to respond
            v.ContentExtended_1                            := (others => '0')
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Input Ready Handling ***
        if ReadPriority_g then
            InRdReady_v := '1'
- InWrReady_v := not Rd_Valid
- else
            InWrReady_v := '1'
- InRdReady_v := not Wr_Valid

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): RstClearWr, FirstBitDecLatency_g, Reset, reset, Rst, olo_base_decode_firstbit, First, RstClearDone, Out_FirstBit, RstClearCounter, ClearAfterReset_g
- Implements memory functionality
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 390
- Process count: 4
- Signal count: 13

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cam.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Content-Addressable Memory (CAM)**

### Overview

The `olo_base_cam` component is a Content-Addressable Memory (CAM) module designed to store and retrieve data based on its content. It provides a flexible and efficient way to perform content-based searches, writes, and clears.

### Functionality

The CAM module performs the following functions:

* **Content-based search**: The module searches for a given content in the CAM and returns a match signal indicating whether the content is found.
* **Write**: The module writes a new content to the CAM at a specified address.
* **Clear**: The module clears a specific content or all contents in the CAM.
* **Read**: The module reads the content at a specified address.

### Inputs

The CAM module has the following inputs:

* **Clk**: Clock signal
* **Rst**: Reset signal
* **Rd_Valid**: Read valid signal
* **Rd_Content**: Read content signal
* **Wr_Valid**: Write valid signal
* **Wr_Content**: Write content signal
* **Wr_Addr**: Write address signal
* **Wr_Write**: Write signal
* **Wr_Clear**: Clear signal
* **Wr_ClearAll**: Clear all signal

### Outputs

The CAM module has the following outputs:

* **Rd_Ready**: Read ready signal
* **Wr_Ready**: Write ready signal
* **Match_Valid**: Match valid signal
* **Match_Match**:","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_cam is
    generic (
        Addresses_g          : positive;
        ContentWidth_g       : positive;
        RamStyle_g           : string   := ""auto"";
        RamBehavior_g        : string   := ""RBW"";
        RamBlockWidth_g      : positive := 32;
        RamBlockDepth_g      : positive := 512;
        ClearAfterReset_g    : boolean  := true;
        ReadPriority_g       : boolean  := true;
        StrictOrdering_g     : boolean  := false;
        UseAddrOut_g         : boolean  := true;
        RegisterInput_g      : boolean  := true;
        RegisterMatch_g      : boolean  := true;
        FirstBitDecLatency_g : natural  := 1
    );
    port (
        Clk                     : in    std_logic;
        Rst                     : in    std_logic;

        Rd_Valid                : in    std_logic;
        Rd_Ready                : out   std_logic;
        Rd_Content              : in    std_logic_vector(ContentWidth_g-1 downto 0);

        Wr_Valid                : in    std_logic;
        Wr_Ready                : out   std_logic;
        Wr_Content              : in    std_logic_vector(ContentWidth_g-1 downto 0);
        Wr_Addr                 : in    std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Wr_Write                : in    std_logic;
        Wr_Clear                : in    std_logic := '0';
        Wr_ClearAll             : in    std_logic := '0';

        Match_Valid             : out   std_logic;
        Match_Match             : out   std_logic_vector(Addresses_g-1 downto 0);

        Addr_Valid              : out   std_logic;
        Addr_Found              : out   std_logic;
        Addr_Addr               : out   std_logic_vector(log2ceil(Addresses_g)-1 downto 0)
    );
end entity;

architecture rtl of olo_base_cam is

    constant BlockAddrBits_c  : positive := log2ceil(RamBlockDepth_g);
    constant BlocksParallel_c : positive := integer(ceil(real(ContentWidth_g) / real(BlockAddrBits_c)));
    constant TotalAddrBits_c  : positive := BlocksParallel_c * BlockAddrBits_c;

    type TwoProcess_r is record
        Content_0         : std_logic_vector(ContentWidth_g - 1 downto 0);
        Addr_0            : std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Write_0           : std_logic;
        Clear_0           : std_logic;
        ClearAll_0        : std_logic;
        Read_0            : std_logic;
        ContentExtended_1 : std_logic_vector(TotalAddrBits_c - 1 downto 0);
        Addr_1            : std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Write_1           : std_logic;
        Clear_1           : std_logic;
        ClearAll_1        : std_logic;
        Read_1            : std_logic;
        Match_2           : std_logic_vector(Addresses_g-1 downto 0);
        Read_2            : std_logic;
        RstClearDone      : std_logic;
        RstClearCounter   : unsigned(BlockAddrBits_c-1 downto 0);
        RstClearWr        : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    type RamData_t is array (natural range <>) of std_logic_vector(Addresses_g-1 downto 0);

    signal ReadContent_0 : std_logic_vector(ContentWidth_g-1 downto 0);
    signal RamRead_1     : RamData_t(0 to BlocksParallel_c-1);
    signal RamWrite_1    : RamData_t(0 to BlocksParallel_c-1);
    signal WrMem_1       : std_logic;
    signal MatchInt      : std_logic_vector(Addresses_g-1 downto 0);
    signal MatchValid    : std_logic;

begin

    assert isPower2(RamBlockDepth_g)
        report ""olo_base_cam - RamBlockDepth_g must be a power of 2""
        severity error;

    p_cob : process (Rd_Valid, Rd_Content, Wr_Valid, Wr_Content, Wr_Addr, Wr_Write, Wr_Clear,
                     RamRead_1, Rst, r) is
        variable v                        : TwoProcess_r;
        variable ClearMask_v, SetMask_v   : std_logic_vector(Addresses_g-1 downto 0);
        variable InRdReady_v, InWrReady_v : std_logic;
    begin
        v := r;

        if ReadPriority_g then
            InRdReady_v := '1';
            InWrReady_v := not Rd_Valid;
        else
            InWrReady_v := '1';
            InRdReady_v := not Wr_Valid;
        end if;
        if r.Write_0 = '1' or r.Clear_0 = '1' or r.ClearAll_0 = '1' then
            InWrReady_v := '0';
            if StrictOrdering_g and RamBehavior_g = ""RBW"" then
                InRdReady_v := '0';
            else
                InRdReady_v := '1';
            end if;
        end if;
        if Rst = '1' or (ClearAfterReset_g and r.RstClearDone = '0') then
            InRdReady_v := '0';
            InWrReady_v := '0';
        end if;
        Rd_Ready <= InRdReady_v;
        Wr_Ready <= InWrReady_v;

        v.Addr_0     := Wr_Addr;
        v.Write_0    := '0';
        v.Clear_0    := '0';
        v.Read_0     := '0';
        v.ClearAll_0 := '0';
        if InWrReady_v = '1' and Wr_Valid = '1' then
            v.Content_0  := Wr_Content;
            v.Write_0    := Wr_Write;
            v.Clear_0    := Wr_Clear;
            v.ClearAll_0 := Wr_ClearAll;
        elsif InRdReady_v = '1' and Rd_Valid = '1' then
            v.Content_0 := Rd_Content;
            v.Read_0    := '1';
        end if;
        if RegisterInput_g then
            ReadContent_0 <= r.Content_0;
        else
            ReadContent_0 <= v.Content_0;
        end if;

        if RegisterInput_g then
            v.ContentExtended_1                            := (others => '0');
            v.ContentExtended_1(ContentWidth_g-1 downto 0) := r.Content_0;
            v.Addr_1                                       := r.Addr_0;
            v.Write_1                                      := r.Write_0;
            v.Clear_1                                      := r.Clear_0;
            v.Read_1                                       := r.Read_0;
            v.ClearAll_1                                   := r.ClearAll_0;
        else
            v.ContentExtended_1                            := (others => '0');
            v.ContentExtended_1(ContentWidth_g-1 downto 0) := v.Content_0;
            v.Addr_1                                       := v.Addr_0;
            v.Write_1                                      := v.Write_0;
            v.Clear_1                                      := v.Clear_0;
            v.Read_1                                       := v.Read_0;
            v.ClearAll_1                                   := v.ClearAll_0;
        end if;

        v.Read_2 := r.Read_1;
        v.Match_2 := RamRead_1(0);

        for i in 1 to BlocksParallel_c-1 loop
            v.Match_2 := v.Match_2 and RamRead_1(i);
        end loop;

        ClearMask_v := (others => '1');
        SetMask_v   := (others => '0');
        if r.Write_1 = '1' then
            SetMask_v(fromUslv(to01(r.Addr_1))) := '1';
        end if;
        if r.Clear_1 = '1' then
            ClearMask_v(fromUslv(to01(r.Addr_1))) := '0';
        end if;
        if r.ClearAll_1 = '1' then
            ClearMask_v := not v.Match_2;
        end if;

        for i in 0 to BlocksParallel_c-1 loop
            RamWrite_1(i) <= (RamRead_1(i) and ClearMask_v) or SetMask_v;
        end loop;

        WrMem_1 <= r.Write_1 or r.Clear_1 or r.ClearAll_1 or r.RstClearWr;
        if RegisterMatch_g then
            MatchValid <= r.Read_2;
            MatchInt   <= r.Match_2;
        else
            MatchValid <= v.Read_2;
            MatchInt   <= v.Match_2;
        end if;

        v.RstClearWr := '0';
        if ClearAfterReset_g then
            if r.RstClearDone = '0' then
                if r.RstClearCounter = 2**BlockAddrBits_c-1 then
                    v.RstClearDone := '1';
                else
                    v.RstClearCounter := r.RstClearCounter + 1;
                end if;
            else
                v.RstClearDone := '1';
            end if;
            if r.RstClearDone = '0' then
                v.RstClearWr := '1'; -- Assignment to memory write done further up in code

                for i in 0 to BlocksParallel_c-1 loop
                    v.ContentExtended_1((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c) := std_logic_vector(r.RstClearCounter);
                end loop;

            end if;
            if r.RstClearWr = '1' then
                RamWrite_1 <= (others => (others => '0'));
            end if;
        end if;

        r_next <= v;
    end process;

    Match_Valid <= MatchValid;
    Match_Match <= MatchInt;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Write_0         <= '0';
                r.Clear_0         <= '0';
                r.ClearAll_0      <= '0';
                r.Read_0          <= '0';
                r.Write_1         <= '0';
                r.Clear_1         <= '0';
                r.ClearAll_1      <= '0';
                r.Read_1          <= '0';
                r.Read_2          <= '0';
                r.RstClearDone    <= '0';
                r.RstClearCounter <= (others => '0');
            end if;
        end if;
    end process;

    g_addr : for i in 0 to BlocksParallel_c-1 generate
        signal ContentExtended_0 : std_logic_vector(TotalAddrBits_c-1 downto 0) := (others => '0');
        signal RdAddr_0          : std_logic_vector(BlockAddrBits_c-1 downto 0);
        signal WrAddr_1          : std_logic_vector(BlockAddrBits_c-1 downto 0);
    begin
        ContentExtended_0(ContentWidth_g-1 downto 0) <= ReadContent_0;

        RdAddr_0 <= to01(ContentExtended_0((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c));
        WrAddr_1 <= to01(r.ContentExtended_1((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c));

        i_ram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => RamBlockDepth_g,
                Width_g         => Addresses_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Wr_Addr     => WrAddr_1,
                Wr_Ena      => WrMem_1,
                Wr_Data     => RamWrite_1(i),
                Rd_Addr     => RdAddr_0,
                Rd_Data     => RamRead_1(i)
            );

    end generate;

    g_addrout : if UseAddrOut_g generate

        i_addrout : entity work.olo_base_decode_firstbit
            generic map (
                InWidth_g       => Addresses_g,
                InReg_g         => false,   -- Regiser is in r
                OutReg_g        => choose(FirstBitDecLatency_g = 0, false, true),
                PlRegs_g        => choose(FirstBitDecLatency_g = 0, 0, FirstBitDecLatency_g-1)
            )
            port map (
                Clk          => Clk,
                Rst          => Rst,
                In_Data      => MatchInt,
                In_Valid     => MatchValid,
                Out_FirstBit => Addr_Addr,
                Out_Found    => Addr_Found,
                Out_Valid    => Addr_Valid
            );

    end generate;

    g_naddrout : if not UseAddrOut_g generate

        Addr_Valid <= '0';
        Addr_Found <= '0';
        Addr_Addr  <= (others => '0');

    end generate;

end architecture;",9
"This component implements a clock crossing for multiple independent single-bit signals. It contains double-stage synchronizers and sets all the attributes required for proper synthesis. Note that this clock crossing does not guarantee that all bits arrive in the same clock cycle at the destination clock domain, therefore it can only be used for independent single-bit signals. Do not use it to transfer multi-bit signals (e.g. numbers) where it is important that all the bits are updated in the same clock cycle. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_bits.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing multple independent
- Plus 35 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_cc_bits

## Architecture: struct of olo_base_cc_bits

### Signals
- RegIn: std_logic_vector(Width_g - 1 downto 0) := (others => '0')
- Reg0: std_logic_vector(Width_g - 1 downto 0) := (others => '0')
- RegN: SyncStages_t                           := (others => (others => '0'))
- is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN: signal is ShregExtract_SuppressExtraction_c
- is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of Reg0: signal is SynSrlstyle_FlipFlops_c
- is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegIn: signal is SynSrlstyle_FlipFlops_c
- is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN: signal is DontMerge_SuppressChanges_c
- is DontMerge_SuppressChanges_c;

    attribute preserve of Reg0: signal is Preserve_SuppressChanges_c
- is Preserve_SuppressChanges_c;
    attribute preserve of RegIn: signal is Preserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN: signal is SynPreserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;

    attribute syn_keep of Reg0: signal is SynKeep_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegIn: signal is SynKeep_SuppressChanges_c
- is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN: signal is AsyncReg_TreatAsync_c
- is AsyncReg_TreatAsync_c;

    -- Input clock (required for automatic constraining in vivado)
    signal In_Clk_Sig: std_logic
- is DontTouch_SuppressChanges_c;
    attribute keep of In_Clk_Sig: signal is Keep_SuppressChanges_c

### Processes
- Process 'p_inff :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_outff :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_inff :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- if In_Rst = '1' then
                RegIn <= (others => '0')

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): Reset, Out_Rst, In_Rst, First
- May be part of a pipeline architecture

## Code Metrics
- Line count: 150
- Process count: 4
- Signal count: 15

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_bits.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_cc_bits` component is a clock domain crossing (CDC) synchronizer that transfers data from an input clock domain (`In_Clk`) to an output clock domain (`Out_Clk`). It synchronizes the input data (`In_Data`) across the clock domains and provides the synchronized data (`Out_Data`) in the output clock domain.

**Component Specification**

### Overview

The `olo_base_cc_bits` component is a generic, parameterizable CDC synchronizer designed to transfer data between two asynchronous clock domains. It ensures reliable data transfer by synchronizing the input data with the output clock domain.

### Parameters

* **Width_g**: The width of the input and output data buses (default: 1).
* **SyncStages_g**: The number of synchronization stages (default: 2, range: 2 to 4).

### Inputs

* **In_Clk**: The input clock signal.
* **In_Rst**: The input reset signal (active high, default: '0').
* **In_Data**: The input data bus (Width_g bits).

### Outputs

* **Out_Data**: The synchronized output data bus (Width_g bits).

### Clock and Reset Requirements

* **Out_Clk**: The output clock signal.
* **Out_Rst**: The output reset signal (active high, default: '0').

### Functionality

1. The component synchronizes the input data (`In_Data`) with the input clock (`In_Clk","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;


entity olo_base_cc_bits is
    generic (
        Width_g      : positive              := 1;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk   : in    std_logic;
        In_Rst   : in    std_logic := '0';
        In_Data  : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk  : in    std_logic;
        Out_Rst  : in    std_logic := '0';
        Out_Data : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;


architecture struct of olo_base_cc_bits is

    type SyncStages_t is array(0 to SyncStages_g - 2) of std_logic_vector(Width_g - 1 downto 0);

    signal RegIn : std_logic_vector(Width_g - 1 downto 0) := (others => '0');
    signal Reg0  : std_logic_vector(Width_g - 1 downto 0) := (others => '0');
    signal RegN  : SyncStages_t                           := (others => (others => '0'));

    attribute shreg_extract of Reg0  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegIn : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of Reg0  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegN  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegIn : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of Reg0  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegIn : signal is DontMerge_SuppressChanges_c;

    attribute preserve of Reg0  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegN  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegIn : signal is Preserve_SuppressChanges_c;

    attribute syn_preserve of Reg0  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegIn : signal is SynPreserve_SuppressChanges_c;

    attribute syn_keep of Reg0  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegN  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegIn : signal is SynKeep_SuppressChanges_c;

    attribute async_reg of Reg0  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegIn : signal is AsyncReg_TreatAsync_c;

    signal In_Clk_Sig : std_logic;

    attribute dont_touch of In_Clk_Sig : signal is DontTouch_SuppressChanges_c;
    attribute keep of In_Clk_Sig       : signal is Keep_SuppressChanges_c;

begin

    In_Clk_Sig <= In_Clk;

    p_inff : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            RegIn <= In_Data;
            if In_Rst = '1' then
                RegIn <= (others => '0');
            end if;
        end if;
    end process;

    p_outff : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            Reg0    <= RegIn;
            RegN(0) <= Reg0;

            for i in 1 to RegN'high loop
                RegN(i) <= RegN(i - 1);
            end loop;

            if Out_Rst = '1' then
                Reg0 <= (others => '0');
                RegN <= (others => (others => '0'));
            end if;
        end if;
    end process;

    Out_Data <= RegN(RegN'high);

end architecture;
",10
"This component implements a clock crossing with AXI-S handshaking for transferring data from one clock domain to another one that runs at a potentially completely asynchronous clock It can for example be used to transfer data from a 100 MHz clock domain to a 55.32 MHz clock domain. This component implements full AXI-S handshaking but is not made for high performance. It can transfer one data-word every _(2 + SyncStages_g) x InputClockPeriods + (2 + SyncStages_g) x OutputClockPeriods_ . Whenever distributed RAM can be used (i.e. LUTs can be used as small RAMs), [olo_base_fifo_async](./olo_base_fifo_async.md) is to be preferred over this entity. For small FIFO depths, it is more resource efficient. Hence _olo_base_cc_handshake_ shall only be used in cases where distributed RAM is not an option (e.g. because it is in not supported by the target technology or because the design is short the related LUT resources). This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_handshake.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing of data with the
- commonly used Valid/Ready handshake.
- Plus 28 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: may override the clause above
            if In_Valid = '1' and In_ReadyI = '1' then
                InLatched <= '1'

## Entity: olo_base_cc_handshake

## Architecture: rtl of olo_base_cc_handshake

### Signals
- RstInI: std_logic
- In_ReadyI: std_logic
- InLatched: std_logic := '0'
- InTransaction: std_logic
- InAck: std_logic
- RstOutI: std_logic
- OutTransaction: std_logic
- OutLatched: std_logic := '0'
- OutAck: std_logic
- Out_ValidI: std_logic

### Component Instantiations
- Instance 'i_scc' of component 'olo_base_cc_simple'
- Instance 'i_bcc' of component 'olo_base_cc_pulse'

### Processes
- Process 'p_in :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_out :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_in :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_out :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): ReadyRstState_g, Reset, reset, In_RstOut, Out_RstIn, In_RstIn, RstInI, RstOutI, Out_RstOut

## Code Metrics
- Line count: 163
- Process count: 4
- Signal count: 10

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_handshake.vhd' plays a specific role in the overall CPU architecture.
","**Component Description:**
The `olo_base_cc_handshake` component is a clock-domain crossing (CDC) handshake interface that enables safe data transfer between two asynchronous clock domains. It receives input data and validity signals from one clock domain and produces output data and validity signals in another clock domain, ensuring proper synchronization and handshake protocol.

**Inputs:**

* `In_Clk`: Input clock signal
* `In_RstIn`: Input reset signal (optional, default: '0')
* `In_Data`: Input data signal (Width_g bits)
* `In_Valid`: Input validity signal (optional, default: '1')
* `Out_Clk`: Output clock signal
* `Out_RstIn`: Output reset signal (optional, default: '0')
* `Out_Ready`: Output ready signal (optional, default: '1')

**Outputs:**

* `In_RstOut`: Input reset output signal
* `In_Ready`: Input ready signal
* `Out_RstOut`: Output reset output signal
* `Out_Data`: Output data signal (Width_g bits)
* `Out_Valid`: Output validity signal

**Functionality:**

The component performs the following functions:

1. Input handshake:
	* Latches input data and validity signals when `In_Valid` and `In_Ready` are high.
	* Generates `In_Ack` pulse to acknowledge input data.
	* Resets input latch when `In_Ack` is high or reset","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_handshake is
    generic (
        Width_g         : positive;
        ReadyRstState_g : std_logic             := '1';
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1'
    );
end entity;

architecture rtl of olo_base_cc_handshake is

    signal RstInI        : std_logic;
    signal In_ReadyI     : std_logic;
    signal InLatched     : std_logic := '0';
    signal InTransaction : std_logic;
    signal InAck         : std_logic;

    signal RstOutI        : std_logic;
    signal OutTransaction : std_logic;
    signal OutLatched     : std_logic := '0';
    signal OutAck         : std_logic;
    signal Out_ValidI     : std_logic;

begin

    p_in : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then

            if InAck = '1' then
                InLatched <= '0';
            end if;

            if In_Valid = '1' and In_ReadyI = '1' then
                InLatched <= '1';
            end if;

            if RstInI = '1' then
                InLatched <= '0';
            end if;
        end if;
    end process;

    In_ReadyI     <= (not InLatched) or InAck when ReadyRstState_g = '1' else
                     ((not InLatched) or InAck) and (not RstInI); -- Actively pull Ready low during reset if required
    InTransaction <= In_Valid and In_ReadyI;
    In_Ready      <= In_ReadyI;

    i_scc : entity work.olo_base_cc_simple
        generic map (
            Width_g      => Width_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => In_Clk,
            In_RstIn    => In_RstIn,
            In_RstOut   => RstInI,
            In_Data     => In_Data,
            In_Valid    => InTransaction,
            Out_Clk     => Out_Clk,
            Out_RstIn   => Out_RstIn,
            Out_RstOut  => RstOutI,
            Out_Data    => Out_Data,
            Out_Valid   => OutTransaction
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    i_bcc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk          => Out_Clk,
            In_RstIn        => RstOutI,
            In_Pulse(0)     => OutAck,
            Out_Clk         => In_Clk,
            Out_RstIn       => RstInI,
            Out_Pulse(0)    => InAck
        );

    p_out : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then

            if OutTransaction = '1' and Out_Ready = '0' then
                OutLatched <= '1';
            elsif Out_Ready = '1' then
                OutLatched <= '0';
            end if;

            if RstOutI = '1' then
                OutLatched <= '0';
            end if;
        end if;
    end process;

    Out_ValidI <= OutTransaction or OutLatched;
    OutAck     <= Out_ValidI and Out_Ready;
    Out_Valid  <= Out_ValidI;

end architecture;",11
"This component implements a clock crossing with AXI-S handshaking for transferring data from one clock domain to another one that runs at an integer multiple of the frequency of the input clock frequency. It can for example be used to transfer data from a 50 MHz clock domain to a 100 MHz clock domain (both generated by the same PLL). Note that the two clocks must be phase aligned. Note that the clock crossing **does not work if the two clocks have the same frequency**. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_n2xn.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a clock crossing between two synchronous clocks where
- Plus 19 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all

## Entity: olo_base_cc_n2xn

## Architecture: rtl of olo_base_cc_n2xn

### Signals
- InRstInt: std_logic
- InDataReg: std_logic_vector(Width_g - 1 downto 0)
- InToggle: std_logic
- OutRstInt: std_logic
- OutDataReg: std_logic_vector(Width_g - 1 downto 0)
- OutDataVld: std_logic
- OutToggle: std_logic

### Component Instantiations
- Instance 'i_rst_cc' of component 'olo_base_cc_reset'

### Processes
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- InToggle  <= not InToggle

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, i_rst_cc, olo_base_cc_reset, A_RstIn, B_RstOut, Reset, In_RstOut, Out_RstIn, In_RstIn, A_RstOut, Out_RstOut, InRstInt, OutRstInt

## Code Metrics
- Line count: 125
- Process count: 4
- Signal count: 7

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_n2xn.vhd' plays a specific role in the overall CPU architecture.
","**Component Description:**
The `olo_base_cc_n2xn` component is a clock-domain crossing (CDC) bridge that transfers data from an input clock domain to an output clock domain. It receives input data and control signals on the input clock domain and produces output data and control signals on the output clock domain.

**Component Specification:**

**Component Name:** Clock Domain Crossing Bridge (olo_base_cc_n2xn)

**Functionality:**

* Transfers data from an input clock domain to an output clock domain
* Handles asynchronous clock domains with potentially different frequencies
* Provides input and output handshake signals for data transfer

**Inputs:**

* `In_Clk`: Input clock signal
* `In_RstIn`: Input reset signal (optional, default='0')
* `In_Valid`: Input data validity signal (optional, default='1')
* `In_Data`: Input data bus (Width_g bits)

**Outputs:**

* `In_RstOut`: Input reset output signal
* `In_Ready`: Input data ready signal
* `Out_Clk`: Output clock signal
* `Out_RstIn`: Output reset input signal (optional, default='0')
* `Out_RstOut`: Output reset output signal
* `Out_Valid`: Output data validity signal
* `Out_Data`: Output data bus (Width_g bits)

**Parameters:**

* `Width_g`: Data bus width (positive integer, default=8)

**Behavior:**

* The component uses a toggle-based","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_cc_n2xn is
    generic (
        Width_g       : positive := 8
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_n2xn is

    signal InRstInt  : std_logic;
    signal InDataReg : std_logic_vector(Width_g - 1 downto 0);
    signal InToggle  : std_logic;

    signal OutRstInt  : std_logic;
    signal OutDataReg : std_logic_vector(Width_g - 1 downto 0);
    signal OutDataVld : std_logic;
    signal OutToggle  : std_logic;

begin

    In_Ready <= '1' when (InToggle = OutToggle) and (InRstInt = '0') else '0';

    p_input : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' and (InToggle = OutToggle) then
                InDataReg <= In_Data;
                InToggle  <= not InToggle;
            end if;
            if InRstInt = '1' then
                InToggle <= '0';
            end if;
        end if;
    end process;

    p_output : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then

            if (OutDataVld = '1' and Out_Ready = '1') then
                OutDataVld <= '0';
            end if;

            if (InToggle /= OutToggle)  and (OutDataVld = '0' or Out_Ready = '1') then
                OutDataReg <= InDataReg;
                OutDataVld <= '1';
                OutToggle  <= InToggle;
            end if;

            if OutRstInt = '1' then
                OutDataVld <= '0';
                OutToggle  <= '0';
            end if;
        end if;
    end process;

    Out_Data  <= OutDataReg;
    Out_Valid <= OutDataVld;

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_RstIn,
            A_RstOut    => InRstInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_RstIn,
            B_RstOut    => OutRstInt
        );

    In_RstOut  <= InRstInt;
    Out_RstOut <= OutRstInt;

end architecture;",12
"This component implements a clock crossing for transferring single pulses from one clock domain to another (completely asynchronous clocks). The entity shall only be used for single-cycle pulses and the pulse frequency must be lower than twice the frequency of the slower clock for it to work correctly. The entity does only guarantee that all pulses arrive at the destination clock domain. It does not guarantee that pulses that occur in the same clock cycle on the source clock domain, occur on the target clock domain in the same clock cycle. As a result it should only be used to do clock-crossings for individual pulses. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_pulse.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing pulses from one clock
- Plus 27 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: register is in olo_base_cc_bits
    ToggleIn <= ToggleLast xor In_Pulse

## Entity: olo_base_cc_pulse

## Architecture: rtl of olo_base_cc_pulse

### Signals
- RstInI: std_logic
- RstOutI: std_logic
- ToggleIn: std_logic_vector(NumPulses_g - 1 downto 0)
- ToggleLast: std_logic_vector(NumPulses_g - 1 downto 0)
- ToggleOut: std_logic_vector(NumPulses_g - 1 downto 0)
- ToggleOutLast: std_logic_vector(NumPulses_g - 1 downto 0)

### Component Instantiations
- Instance 'i_rst' of component 'olo_base_cc_reset'
- Instance 'i_sync' of component 'olo_base_cc_bits'

### Processes
- Process 'p_reg :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_pulseout :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_reg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_pulseout :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- if RstInI = '1' then
                ToggleLast <= (others => '0')

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, olo_base_cc_reset, A_RstIn, Reset, In_RstOut, Out_RstIn, In_RstIn, RstInI, RstOutI, A_RstOut, i_rst, In_Rst, Out_RstOut, Resets, Out_Rst, B_RstOut
- May be part of a pipeline architecture

## Code Metrics
- Line count: 131
- Process count: 4
- Signal count: 6

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_pulse.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_cc_pulse` component is a clock domain crossing (CDC) pulse synchronizer that transfers pulses from one clock domain (`In_Clk`) to another (`Out_Clk`). It takes in pulses from multiple sources (`In_Pulse`), synchronizes them to the output clock domain, and produces corresponding output pulses (`Out_Pulse`). The component also provides reset signals for both clock domains.

**Component Specification**

**Component Name:** `olo_base_cc_pulse`

**Functionality:** Clock domain crossing pulse synchronizer

**Inputs:**

* `In_Clk`: Input clock signal
* `In_RstIn`: Optional input reset signal (default: '0')
* `In_Pulse`: Input pulse signals (vector of width `NumPulses_g`)
* `Out_Clk`: Output clock signal
* `Out_RstIn`: Optional output reset signal (default: '0')

**Outputs:**

* `In_RstOut`: Reset signal for the input clock domain
* `Out_RstOut`: Reset signal for the output clock domain
* `Out_Pulse`: Output pulse signals (vector of width `NumPulses_g`)

**Generics:**

* `NumPulses_g`: Number of pulse inputs (positive integer, default: 1)
* `SyncStages_g`: Number of synchronization stages (positive integer, range 2 to 4, default: 2)

**Purpose:** The `olo_base_cc","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_pulse is
    generic (
        NumPulses_g     : positive              := 1;
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk          : in    std_logic;
        In_RstIn        : in    std_logic := '0';
        In_RstOut       : out   std_logic;
        In_Pulse        : in    std_logic_vector(NumPulses_g - 1 downto 0);
        Out_Clk         : in    std_logic;
        Out_RstIn       : in    std_logic := '0';
        Out_RstOut      : out   std_logic;
        Out_Pulse       : out   std_logic_vector(NumPulses_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_pulse is

    type Pulse_t is array (natural range <>) of std_logic_vector(NumPulses_g - 1 downto 0);

    signal RstInI  : std_logic;
    signal RstOutI : std_logic;

    signal ToggleIn      : std_logic_vector(NumPulses_g - 1 downto 0);
    signal ToggleLast    : std_logic_vector(NumPulses_g - 1 downto 0);
    signal ToggleOut     : std_logic_vector(NumPulses_g - 1 downto 0);
    signal ToggleOutLast : std_logic_vector(NumPulses_g - 1 downto 0);

begin

    i_rst : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_RstIn,
            A_RstOut    => RstInI,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_RstIn,
            B_RstOut    => RstOutI
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    p_reg : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            ToggleLast <= ToggleIn;
            if RstInI = '1' then
                ToggleLast <= (others => '0');
            end if;
        end if;
    end process;

    ToggleIn <= ToggleLast xor In_Pulse;

    i_sync : entity work.olo_base_cc_bits
        generic map (
            Width_g      => NumPulses_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => In_Clk,
            In_Rst   => RstInI,
            In_Data  => ToggleIn,
            Out_Clk  => Out_Clk,
            Out_Rst  => RstOutI,
            Out_Data => ToggleOut
        );

    Out_Pulse <= ToggleOutLast xor ToggleOut;

    p_pulseout : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            ToggleOutLast <= ToggleOut;

            if RstOutI = '1' then
                ToggleOutLast <= (others => '0');
            end if;
        end if;
    end process;

end architecture;",13
"This component synchronizes reset inputs from two clock domains in both directions. Whenever a reset is received on one clock domain, it produces reset outputs on both clock domains and ensures that both reset outputs are asserted at the same time for at least one clock cycle before they are released again. This type of reset synchronization is required in many clock crossings. Usually both sides of the clock crossing must be reset at the same time to avoid unwanted behavior in corner conditions around resets. When using the block, you should connect any reset request signals to _A/B_RstIn_ and reset your logic with the outputs _A/B_RstOut_. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_reset.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows to clock-cross resets. It
- Plus 32 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_cc_reset

## Architecture: struct of olo_base_cc_reset

### Signals
- RstALatch: std_logic                    := '1'
- RstRqstB2A: std_logic_vector(2 downto 0) := (others => '0')
- RstAckB2A: std_logic
- RstBLatch: std_logic                    := '1'
- RstRqstA2B: std_logic_vector(2 downto 0) := (others => '0')
- RstAckA2B: std_logic
- is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckB2A: signal is ShregExtract_SuppressExtraction_c
- is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckA2B: signal is ShregExtract_SuppressExtraction_c
- is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckB2A: signal is SynSrlstyle_FlipFlops_c
- is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckA2B: signal is SynSrlstyle_FlipFlops_c
- is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckB2A: signal is DontMerge_SuppressChanges_c
- is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckA2B: signal is DontMerge_SuppressChanges_c
- is Preserve_SuppressChanges_c;
    attribute preserve of RstAckB2A: signal is Preserve_SuppressChanges_c
- is Preserve_SuppressChanges_c;
    attribute preserve of RstAckA2B: signal is Preserve_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckB2A: signal is SynKeep_SuppressChanges_c
- is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckA2B: signal is SynKeep_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckB2A: signal is SynPreserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckA2B: signal is SynPreserve_SuppressChanges_c
- is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckB2A: signal is AsyncReg_TreatAsync_c
- is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckA2B: signal is AsyncReg_TreatAsync_c

### Component Instantiations
- Instance 'i_ackb2a' of component 'olo_base_cc_bits'
- Instance 'i_acka2b' of component 'olo_base_cc_bits'

### Processes
- Process 'p_a_rst_sync :' (Clocked) (Has Reset) with sensitivity list: A_Clk, RstBLatch
  - Implements synchronous logic
- Process 'p_a_rst :' (Clocked) (Has Reset) with sensitivity list: A_Clk
  - Implements synchronous logic with reset
- Process 'p_b_rst_sync :' (Clocked) (Has Reset) with sensitivity list: B_Clk, RstALatch
  - Implements synchronous logic
- Process 'p_b_rst :' (Clocked) (Has Reset) with sensitivity list: B_Clk
  - Implements synchronous logic with reset
- Process 'p_a_rst_sync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_a_rst :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_b_rst_sync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_b_rst :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- elsif rising_edge(A_Clk) then
            RstRqstB2A <= RstRqstB2A(RstRqstB2A'left - 1 downto 0) & '0'

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, A_RstIn, RstBLatch, In_Rst, B_RstOut, resets, RstAckB2A, RstRqstB2A, A_RstOut, p_b_rst, p_a_rst, RstALatch, p_a_rst_sync, reset, olo_base_cc_reset, p_b_rst_sync, RstAckA2B, Out_Rst, RstRqstA2B

## Code Metrics
- Line count: 190
- Process count: 8
- Signal count: 20

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_reset.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Cross-Clock Domain Reset Synchronizer**

**Component Name:** OLO Base Cross-Clock Domain Reset (OLO Base CC Reset)

**Functionality:**

The OLO Base CC Reset is a digital component designed to synchronize reset signals across two asynchronous clock domains, A and B. It ensures that both clock domains are properly reset and synchronized, preventing metastability issues and data corruption.

**Inputs:**

* `A_Clk`: Clock signal for clock domain A
* `A_RstIn`: Asynchronous reset input for clock domain A (active high)
* `B_Clk`: Clock signal for clock domain B
* `B_RstIn`: Asynchronous reset input for clock domain B (active high)

**Outputs:**

* `A_RstOut`: Synchronized reset output for clock domain A (active high)
* `B_RstOut`: Synchronized reset output for clock domain B (active high)

**Purpose:**

The OLO Base CC Reset component is used to:

1. Synchronize reset signals across two asynchronous clock domains.
2. Prevent metastability issues and data corruption during reset.
3. Provide a reliable and synchronized reset signal for each clock domain.

**Key Features:**

* Supports two asynchronous clock domains (A and B)
* Synchronizes reset signals using a handshaking mechanism
* Configurable number of synchronization stages (SyncStages_g) for each clock domain
* Uses a latch-based approach to generate reset outputs
* Provides a synchronized reset output for each","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_base_cc_reset is
    generic (
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        A_Clk       : in    std_logic;
        A_RstIn     : in    std_logic := '0';
        A_RstOut    : out   std_logic;
        B_Clk       : in    std_logic;
        B_RstIn     : in    std_logic := '0';
        B_RstOut    : out   std_logic
    );
end entity;

architecture struct of olo_base_cc_reset is

    signal RstALatch  : std_logic                    := '1';
    signal RstRqstB2A : std_logic_vector(2 downto 0) := (others => '0');
    signal RstAckB2A  : std_logic;

    signal RstBLatch  : std_logic                    := '1';
    signal RstRqstA2B : std_logic_vector(2 downto 0) := (others => '0');
    signal RstAckA2B  : std_logic;

    attribute shreg_extract of RstRqstB2A : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckB2A  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstRqstA2B : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckA2B  : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of RstRqstB2A : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckB2A  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstRqstA2B : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckA2B  : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of RstRqstB2A : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckB2A  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstRqstA2B : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckA2B  : signal is DontMerge_SuppressChanges_c;

    attribute preserve of RstRqstB2A : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstAckB2A  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstRqstA2B : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstAckA2B  : signal is Preserve_SuppressChanges_c;

    attribute syn_keep of RstRqstB2A : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckB2A  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstRqstA2B : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckA2B  : signal is SynKeep_SuppressChanges_c;

    attribute syn_preserve of RstRqstB2A : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckB2A  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstRqstA2B : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckA2B  : signal is SynPreserve_SuppressChanges_c;

    attribute async_reg of RstRqstB2A : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckB2A  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstRqstA2B : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckA2B  : signal is AsyncReg_TreatAsync_c;

begin

    p_a_rst_sync : process (A_Clk, RstBLatch) is
    begin
        if RstBLatch = '1' then
            RstRqstB2A <= (others => '1');
        elsif rising_edge(A_Clk) then
            RstRqstB2A <= RstRqstB2A(RstRqstB2A'left - 1 downto 0) & '0';
        end if;
    end process;

    p_a_rst : process (A_Clk) is
    begin
        if rising_edge(A_Clk) then
            if A_RstIn = '1' then
                RstALatch <= '1';
            elsif RstAckB2A = '1' then
                RstALatch <= '0';
            end if;
        end if;
    end process;

    A_RstOut <= RstALatch or RstRqstB2A(RstRqstB2A'left);

    p_b_rst_sync : process (B_Clk, RstALatch) is
    begin
        if RstALatch = '1' then
            RstRqstA2B <= (others => '1');
        elsif rising_edge(B_Clk) then
            RstRqstA2B <= RstRqstA2B(RstRqstA2B'left - 1 downto 0) & '0';
        end if;
    end process;

    p_b_rst : process (B_Clk) is
    begin
        if rising_edge(B_Clk) then
            if B_RstIn = '1' then
                RstBLatch <= '1';
            elsif RstAckA2B = '1' then
                RstBLatch <= '0';
            end if;
        end if;
    end process;

    B_RstOut <= RstBLatch or RstRqstA2B(RstRqstA2B'left);

    i_ackb2a : entity work.olo_base_cc_bits
        generic map (
            Width_g      => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => B_Clk,
            In_Rst      => '0',
            In_Data(0)  => RstRqstA2B(RstRqstA2B'left),
            Out_Clk     => A_Clk,
            Out_Rst     => '0',
            Out_Data(0) => RstAckB2A
        );

    i_acka2b : entity work.olo_base_cc_bits
        generic map (
            Width_g      => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => A_Clk,
            In_Rst      => '0',
            In_Data(0)  => RstRqstB2A(RstRqstA2B'left),
            Out_Clk     => B_Clk,
            Out_Rst     => '0',
            Out_Data(0) => RstAckA2B
        );

end architecture;",14
"This component implements a clock crossing for transferring single values from one clock domain to another (completely asynchronous clocks). In both clock domains the valid samples are marked with a Valid signal according to the AXI-S specification but back-pressure (Ready) is not handled. **For the entity to work correctly, the data-rate must be significantly lower ( (_3+SyncStages_g_ x lower) than the slower clock frequency.** This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_simple.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing single samples of data
- Plus 22 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_cc_simple

## Architecture: struct of olo_base_cc_simple

### Signals
- RstInI: std_logic
- DataLatchIn: std_logic_vector(Width_g - 1 downto 0)
- RstOutI: std_logic
- VldOutI: std_logic
- Out_Data_Sig: std_logic_vector(Width_g - 1 downto 0)
- is DontTouch_SuppressChanges_c;
    attribute keep of Out_Data_Sig: signal is Keep_SuppressChanges_c

### Component Instantiations
- Instance 'i_pulse_cc' of component 'olo_base_cc_pulse'

### Processes
- Process 'p_data_a :' (Clocked) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_data_b :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic with reset
- Process 'p_data_a :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_data_b :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): Reset, In_RstOut, Out_RstIn, In_RstIn, RstInI, RstOutI, Out_RstOut

## Code Metrics
- Line count: 121
- Process count: 4
- Signal count: 6

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_simple.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_cc_simple` component is a clock-domain crossing (CDC) synchronizer that transfers data from an input clock domain (`In_Clk`) to an output clock domain (`Out_Clk`). It synchronizes the input data (`In_Data`) and validity signal (`In_Valid`) while handling reset signals (`In_RstIn` and `Out_RstIn`) and producing output reset (`Out_RstOut`) and validity (`Out_Valid`) signals.

**Component Specification**

**Component Name:** `olo_base_cc_simple`

**Functionality:** Clock-domain crossing (CDC) synchronizer

**Inputs:**

* `In_Clk`: Input clock signal
* `In_RstIn`: Input reset signal (optional, default: '0')
* `In_Data`: Input data signal (Width_g bits)
* `In_Valid`: Input validity signal
* `Out_Clk`: Output clock signal
* `Out_RstIn`: Output reset signal (optional, default: '0')

**Outputs:**

* `In_RstOut`: Output reset signal (mirrored from `RstInI`)
* `Out_RstOut`: Output reset signal
* `Out_Data`: Output data signal (Width_g bits)
* `Out_Valid`: Output validity signal

**Parameters:**

* `Width_g`: Width of input and output data signals (positive integer, default: 1)
* `SyncStages_g`: Number of synchronization stages","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_base_cc_simple is
    generic (
        Width_g      : positive              := 1;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid    : in    std_logic;
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic
    );
end entity;

architecture struct of olo_base_cc_simple is

    signal RstInI      : std_logic;
    signal DataLatchIn : std_logic_vector(Width_g - 1 downto 0);
    signal RstOutI     : std_logic;
    signal VldOutI     : std_logic;

    signal Out_Data_Sig : std_logic_vector(Width_g - 1 downto 0);

    attribute dont_touch of Out_Data_Sig : signal is DontTouch_SuppressChanges_c;
    attribute keep of Out_Data_Sig       : signal is Keep_SuppressChanges_c;

begin

    i_pulse_cc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk       => In_Clk,
            In_RstIn     => In_RstIn,
            In_RstOut    => RstInI,
            In_Pulse(0)  => In_Valid,
            Out_Clk      => Out_Clk,
            Out_RstIn    => Out_RstIn,
            Out_RstOut   => RstOutI,
            Out_Pulse(0) => VldOutI
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    p_data_a : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' then
                DataLatchIn <= In_Data;
            end if;
        end if;
    end process;

    p_data_b : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            Out_Valid <= VldOutI;
            if VldOutI = '1' then
                Out_Data_Sig <= DataLatchIn;
            end if;
            if RstOutI = '1' then
                Out_Valid <= '0';
            end if;
        end if;
    end process;

    Out_Data <= Out_Data_Sig;

end architecture;",15
"This component implements a clock crossing for slowly changing status information that does not have exact sample rates. It can for example be used to  transfer a buffer fill level from one clock domain to another with minimal effort and without knowing anything about the frequencies of the two clocks (e.g. without knowing which one runs faster). The entity ensures that data from the source clock domain is correctly transferred to the destination clock domain. The value at the destination clock domain is always correct in terms of ""the exact same value was present on the input clock domain in one clock-cycle"". The exact timing of the sampling points at which the data is transferred is generated by the entity itself, so it is unknown to the user. As a result, the entity does not guarantee to show transient states of the data signal in the source clock domain to the destination clock domain in cases of fast changing signals. For the entity to work correctly, the data-rate must be significantly lower (_6 + 2 * SyncStages_g_ x lower) than the slower clock frequency. Of course the signal can change more quickly but the clock crossing will skip some values in this case. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_status.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic clock crossing that allows passing of static-data
- Plus 26 more comments

## Libraries and Packages
- Library: ieee
- Use: cause of this entity is to pass status information or configuration
-- register values between clock domains.
--
-- Documentation:
-- https://github.com/open-logic/open-logic/blob/main/doc/base/olo_base_cc_status.md
--
-- Note: The link points to the documentation of the latest release. If you
--       use an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: olo_base_cc_status

## Architecture: rtl of olo_base_cc_status

### Signals
- RstInI: std_logic
- Started: std_logic := '0'
- RstOutI_Sync: std_logic_vector(1 downto 0)
- VldIn: std_logic
- VldFb: std_logic
- RstOutI: std_logic
- VldOut: std_logic

### Component Instantiations
- Instance 'i_scc' of component 'olo_base_cc_simple'
- Instance 'i_bcc' of component 'olo_base_cc_pulse'

### Processes
- Process 'p_vldgen :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_vldgen :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 3 clock domain(s): clock, Out_Clk, In_Clk
- Uses reset signal(s): first, Reset, In_RstOut, RstOutI_Sync, Out_RstIn, In_RstIn, RstInI, RstOutI, Out_RstOut

## Code Metrics
- Line count: 129
- Process count: 2
- Signal count: 7

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_status.vhd' plays a specific role in the overall CPU architecture.
","**Component Description:**
The `olo_base_cc_status` component is a clock domain crossing (CDC) status controller that facilitates the transfer of data and reset signals between two asynchronous clock domains. It takes in data and reset signals from the input clock domain and outputs them to the output clock domain, while also generating valid signals to indicate the validity of the transferred data. The component ensures that the output reset signal is properly synchronized with the output clock domain.

**Component Specification:**

**Name:** olo_base_cc_status

**Functionality:**

* Clock domain crossing (CDC) of data and reset signals between two asynchronous clock domains
* Generation of valid signals to indicate the validity of transferred data

**Inputs:**

* `In_Clk`: Input clock signal
* `In_RstIn`: Input reset signal (optional, default='0')
* `In_Data`: Input data signal (Width_g bits)
* `Out_Clk`: Output clock signal
* `Out_RstIn`: Output reset signal

**Outputs:**

* `In_RstOut`: Output reset signal (input clock domain)
* `Out_RstOut`: Output reset signal (output clock domain, default='0')
* `Out_Data`: Output data signal (Width_g bits)

**Parameters:**

* `Width_g`: Width of the input and output data signals (positive integer)
* `SyncStages_g`: Number of synchronization stages for the CDC (positive integer, range 2 to 4, default=2)

**","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_status is
    generic (
        Width_g      : positive;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic;
        Out_RstOut  : out   std_logic := '0';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_status is

    signal RstInI       : std_logic;
    signal Started      : std_logic := '0';
    signal RstOutI_Sync : std_logic_vector(1 downto 0);
    signal VldIn        : std_logic;
    signal VldFb        : std_logic;

    signal RstOutI : std_logic;
    signal VldOut  : std_logic;

begin

    p_vldgen : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            VldIn <= VldFb;

            if (Started = '0') then
                VldIn   <= '1';
                Started <= '1';
            end if;

            if RstInI = '1' then
                RstOutI_Sync <= (others => '1');
                Started      <= '0';
                VldIn        <= '0';
            end if;
        end if;
    end process;

    i_scc : entity work.olo_base_cc_simple
        generic map (
            Width_g      => Width_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => In_Clk,
            In_RstIn    => In_RstIn,
            In_RstOut   => RstInI,
            In_Data     => In_Data,
            In_Valid    => VldIn,
            Out_Clk     => Out_Clk,
            Out_RstIn   => Out_RstIn,
            Out_RstOut  => RstOutI,
            Out_Data    => Out_Data,
            Out_Valid   => VldOut
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    i_bcc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk          => Out_Clk,
            In_RstIn        => RstOutI,
            In_Pulse(0)     => VldOut,
            Out_Clk         => In_Clk,
            Out_RstIn       => RstInI,
            Out_Pulse(0)    => VldFb
        );

end architecture;",16
"This component implements a clock crossing with AXI-S handshaking for transferring data from one clock domain to another one that runs at an integer fraction of the frequency of the input clock frequency. It can for example be used to transfer data from a 100 MHz clock domain to a 50 MHz clock domain (both generated by the same PLL). Note that the two clocks must be phase aligned. Note that the clock crossing **does not work if the two clocks have the same frequency**. This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_cc_xn2n.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a clock crossing between two synchronous clocks where
- Plus 18 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all

## Entity: olo_base_cc_xn2n

## Architecture: rtl of olo_base_cc_xn2n

### Signals
- InCnt: unsigned(1 downto 0)
- InRstInt: std_logic
- InDataReg: std_logic_vector(Width_g - 1 downto 0)
- InDataRegLast: std_logic_vector(Width_g - 1 downto 0)
- OutCnt: unsigned(1 downto 0)
- OutRstInt: std_logic
- OutIn_Valid: std_logic

### Component Instantiations
- Instance 'i_rst_cc' of component 'olo_base_cc_reset'

### Processes
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic
- Process 'p_input :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_output :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- InDataReg     <= In_Data
- InDataRegLast <= InDataReg

## Functional Analysis

- Contains 5 clock domain(s): Out_Clk, B_Clk, In_Clk, clock, A_Clk
- Uses reset signal(s): B_RstIn, i_rst_cc, olo_base_cc_reset, A_RstIn, B_RstOut, Reset, In_RstOut, Out_RstIn, In_RstIn, A_RstOut, Out_RstOut, InRstInt, OutRstInt

## Code Metrics
- Line count: 125
- Process count: 4
- Signal count: 7

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_cc_xn2n.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_cc_xn2n` component is a clock-domain crossing (CDC) FIFO buffer that transfers data from an input clock domain to an output clock domain. It receives input data and validity signals in the input clock domain and produces output data and validity signals in the output clock domain, ensuring safe and reliable data transfer between the two domains.

**Inputs and Outputs**

* Inputs:
	+ `In_Clk`: Input clock signal
	+ `In_RstIn`: Input reset signal
	+ `In_Valid`: Input data validity signal
	+ `In_Data`: Input data signal (Width_g bits wide)
	+ `Out_Clk`: Output clock signal
	+ `Out_RstIn`: Output reset signal (optional, default='0')
	+ `Out_Ready`: Output readiness signal (optional, default='1')
* Outputs:
	+ `In_RstOut`: Input reset output signal
	+ `In_Ready`: Input readiness signal
	+ `Out_RstOut`: Output reset output signal
	+ `Out_Valid`: Output data validity signal
	+ `Out_Data`: Output data signal (Width_g bits wide)

**Functionality**

The component has the following functionality:

1. **Input Side**: The input side of the FIFO buffer is controlled by the `In_Clk` signal. When `In_Valid` is high and there is space in the buffer (i.e.,","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_cc_xn2n is
    generic (
        Width_g       : positive
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic;
        In_RstOut   : out   std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_xn2n is

    signal InCnt         : unsigned(1 downto 0);
    signal InRstInt      : std_logic;
    signal InDataReg     : std_logic_vector(Width_g - 1 downto 0);
    signal InDataRegLast : std_logic_vector(Width_g - 1 downto 0);

    signal OutCnt      : unsigned(1 downto 0);
    signal OutRstInt   : std_logic;
    signal OutIn_Valid : std_logic;

begin

    In_Ready <= '1' when (InCnt - OutCnt /= 2) and (InRstInt = '0') else '0';

    p_input : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' and InCnt - OutCnt /= 2 then
                InCnt         <= InCnt + 1;
                InDataReg     <= In_Data;
                InDataRegLast <= InDataReg;
            end if;
            if InRstInt = '1' then
                InCnt <= (others => '0');
            end if;
        end if;
    end process;

    p_output : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            if OutIn_Valid = '1' and Out_Ready = '1' then
                OutIn_Valid <= '0';
            end if;
            if InCnt /= OutCnt and (OutIn_Valid = '0' or Out_Ready = '1') then
                if InCnt - OutCnt = 1 then
                    Out_Data <= InDataReg;
                else
                    Out_Data <= InDataRegLast;
                end if;
                OutIn_Valid <= '1';
                OutCnt      <= OutCnt + 1;
            end if;
            if OutRstInt = '1' then
                OutCnt      <= (others => '0');
                OutIn_Valid <= '0';
            end if;
        end if;
    end process;

    Out_Valid <= OutIn_Valid;

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_RstIn,
            A_RstOut    => InRstInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_RstIn,
            B_RstOut    => OutRstInt
        );

    In_RstOut  <= InRstInt;
    Out_RstOut <= OutRstInt;

end architecture;",17
"This component is a CRC checksum generator. It can be used to generate CRC checksums to send together with data (TX side) or to calculate the CRC checksum of received data and compare it to the CRC received (RX side). _olo_base_crc_ can take one input data word per clock cycle. One CRC is produced per packet - the _Out_Valid_ signal is presented to the output after _In_Last_ was received. Although _Out_Valid_ is asserted only upon the _In_Last_ being received, the output _Out_Crc_ is updated exactly one clock cycle after an input word being received. This allows for special applications where the CRC has to be checked after every data-word. The component is highly configurable in order to allow calculating CRC checksums for all known standard protocols without any external logic. Regarding the notation of parametrization, the website [crccalc.com](https://crccalc.com) is taken as reference. On this website many commonly used CRCs are listed.

# VHDL Analysis for 'olo_base_crc.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description:
- -------------------------------------------------------------------------------------------------
- A CRC generator based on a linear-feedback shifter register. Can be used to generate CRCs to add
- on TX side or to calculate CRCs to compare to received CRC on RX side.
- Plus 33 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.std_logic_misc.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_logic.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_crc

## Architecture: rtl of olo_base_crc

### Signals
- LfsrReg: std_logic_vector(CrcWidth_g-1 downto 0)
- Out_Valid_I: std_logic
- In_Ready_I: std_logic

### Processes
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- if BitOrder_g = ""MSB_FIRST"" then
                if ByteOrder_g = ""LSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v)

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): In_First, MSB_FIRST, first, Reset, Rst, First, LSB_FIRST
- Implements arithmetic/computational functionality
- Implements control logic

## Code Metrics
- Line count: 171
- Process count: 2
- Signal count: 3

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_crc.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_crc` component is a configurable Cyclic Redundancy Check (CRC) generator that calculates a CRC value for a given input data stream. It supports various CRC parameters, such as polynomial, width, and bit order, to accommodate different CRC standards.

**Functionality**

The component takes in a data stream (`In_Data`) and generates a CRC value (`Out_Crc`) based on the configured polynomial and other parameters. It provides flow control signals (`In_Ready`, `Out_Valid`, and `Out_Ready`) to manage the data processing.

**Inputs**

* `Clk`: Clock signal
* `Rst`: Reset signal
* `In_Data`: Input data stream (width: `DataWidth_g`)
* `In_Valid`: Input data validity signal (default: '1')
* `In_Last`: Input data last signal (default: '0')
* `In_First`: Input data first signal (default: '0')
* `Out_Ready`: Output ready signal (default: '1')

**Outputs**

* `Out_Crc`: Calculated CRC value (width: `CrcWidth_g`)
* `Out_Valid`: Output validity signal
* `In_Ready`: Input ready signal

**Configuration Parameters**

* `CrcWidth_g`: CRC width (range: 2 to `natural'high`)
* `DataWidth_g`: Input data width
* `Polynomial_g`: CRC polynomial value
* `","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_math.all;

entity olo_base_crc is
    generic (
        CrcWidth_g      : positive range 2 to natural'high;
        DataWidth_g     : positive;
        Polynomial_g    : natural;  -- according to https://crccalc.com/?crc=01&method=CRC-8&datatype=hex&outtype=bin
        InitialValue_g  : natural := 0;
        BitOrder_g      : string  := ""MSB_FIRST""; -- ""MSB_FIRST"" or ""LSB_FIRST""
        ByteOrder_g     : string  := ""NONE"";      -- ""NONE"", ""MSB_FIRST"" or ""LSB_FIRST""
        BitflipOutput_g : boolean := false;
        XorOutput_g     : natural := 0
    );
    port (
        Clk              : in    std_logic;
        Rst              : in    std_logic;
        In_Data          : in    std_logic_vector(DataWidth_g-1 downto 0);
        In_Valid         : in    std_logic := '1';
        In_Ready         : out   std_logic;
        In_Last          : in    std_logic := '0';
        In_First         : in    std_logic := '0';
        Out_Crc          : out   std_logic_vector(CrcWidth_g-1 downto 0);
        Out_Valid        : out   std_logic;
        Out_Ready        : in    std_logic := '1'
    );
end entity;


architecture rtl of olo_base_crc is

    constant Polynomial_c   : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(Polynomial_g, CrcWidth_g);
    constant InitialValue_c : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(InitialValue_g, CrcWidth_g);
    constant XorOutput_c    : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(XorOutput_g, CrcWidth_g);

    signal LfsrReg     : std_logic_vector(CrcWidth_g-1 downto 0);
    signal Out_Valid_I : std_logic;
    signal In_Ready_I  : std_logic;

begin

    assert BitOrder_g = ""MSB_FIRST"" or BitOrder_g = ""LSB_FIRST""
        report ""###ERROR###: olo_base_crc - Illegal value for BitOrder_g""
        severity error;
    assert ByteOrder_g = ""NONE"" or ByteOrder_g = ""LSB_FIRST"" or ByteOrder_g = ""MSB_FIRST""
        report ""###ERROR###: olo_base_crc - Illegal value for ByteOrder_g""
        severity error;
    assert ByteOrder_g = ""NONE"" or DataWidth_g mod 8 = 0
        report ""###ERROR###: olo_base_crc - For DataWidth_g not being a multiple of 8, only ByteOrder_g=NONE is allowed""
        severity error;

    p_lfsr : process (Clk) is
        variable Input_v : std_logic_vector(In_Data'range);
        variable Lfsr_v  : std_logic_vector(LfsrReg'range);
        variable InBit_v : std_logic;
        variable Out_v   : std_logic_vector(CrcWidth_g-1 downto 0);
    begin
        if rising_edge(Clk) then
            Input_v := In_Data;
            if BitOrder_g = ""MSB_FIRST"" then
                if ByteOrder_g = ""LSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v);
                end if;
            else
                if ByteOrder_g = ""MSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v);
                end if;
                Input_v := invertBitOrder(Input_v);
            end if;

            if Out_Valid_I = '1' and Out_Ready = '1' then
                Out_Valid_I <= '0';
            end if;

            if In_Valid = '1' and In_Ready_I = '1' then
                if In_First = '1' then
                    Lfsr_v := InitialValue_c;
                else
                    Lfsr_v := LfsrReg;
                end if;

                for bit in DataWidth_g-1 downto 0 loop

                    InBit_v := Input_v(bit) xor Lfsr_v(Lfsr_v'high);

                    Lfsr_v := Lfsr_v(Lfsr_v'high-1 downto 0) & '0';
                    if InBit_v = '1' then
                        Lfsr_v := Lfsr_v xor Polynomial_c;
                    end if;

                end loop;

                Out_v := Lfsr_v;
                if BitflipOutput_g then
                    Out_v := invertBitOrder(Out_v);
                end if;
                Out_Crc <= Out_v xor XorOutput_c;

                if In_Last = '1' then
                    Lfsr_v      := InitialValue_c;
                    Out_Valid_I <= '1';
                end if;
                LfsrReg <= Lfsr_v;
            end if;

            if Rst = '1' then
                LfsrReg     <= InitialValue_c;
                Out_Crc     <= (others => '0');
                Out_Valid_I <= '0';
            end if;

        end if;
    end process;

    In_Ready_I <= Out_Ready or not Out_Valid_I;

    Out_Valid <= Out_Valid_I;
    In_Ready  <= In_Ready_I;

end architecture;",18
"This entity implements a first-bit decoder. It does return the index of the lowest bit set in a vector. First bit decoding can be done in only a few lines of code if all the decoding is done in one clock cycles. However, for doing first-bit decoding on very wide vectors this leads to poor timing performance. In this case using _olo_base_decode_firstbit_ makes sense - because it allows pipelining the operation. The figure below assumes _InReg_g=false_, _OutReg_g=false_ and _PlRegs_g=2_.

# VHDL Analysis for 'olo_base_decode_firstbit.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a pipelined first bit decoder. It finds out which
- is the lowest index of a bit set in the input vecotr.
- Plus 50 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_decode_firstbit

## Architecture: rtl of olo_base_decode_firstbit

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
        r_next <= v;
    end process;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Data, In_Valid
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Optional Input Register ***
        DataIn_v := (others => '0')
- if InReg_g then
            v.DataIn                       := In_Data
- v.ValidIn                      := In_Valid
- InValid_v                      := r.ValidIn
- DataIn_v(InWidth_g-1 downto 0) := r.DataIn
- Plus 2 more statements

## Functional Analysis

- Contains 2 clock domain(s): Clk, Clock
- Uses reset signal(s): FirstBit, first, Reset, Rst, lowerst, First, Out_FirstBit, olo_base_decode_firstbit
- May be part of a pipeline architecture

## Code Metrics
- Line count: 243
- Process count: 4
- Signal count: 3

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_decode_firstbit.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: First Bit Decoder**

**Component Name:** olo_base_decode_firstbit

**Functionality:** The olo_base_decode_firstbit component is a digital circuit that decodes the first bit set to '1' in a binary input vector. It is designed to efficiently find the position of the first '1' in a large binary vector.

**Inputs:**

* **Clk**: Clock signal (std_logic)
* **Rst**: Reset signal (std_logic)
* **In_Data**: Binary input vector (std_logic_vector, width: InWidth_g)
* **In_Valid**: Input validity signal (std_logic, default: '1')

**Outputs:**

* **Out_FirstBit**: Position of the first '1' in the input vector (std_logic_vector, width: log2ceil(InWidth_g))
* **Out_Found**: Flag indicating whether a '1' was found in the input vector (std_logic)
* **Out_Valid**: Output validity signal (std_logic)

**Parameters:**

* **InWidth_g**: Width of the input binary vector (positive integer)
* **InReg_g**: Input register enable (boolean, default: true)
* **OutReg_g**: Output register enable (boolean, default: true)
* **PlRegs_g**: Number of pipeline stages (natural, default: 1)

**Description:** The component uses a pipelined architecture to efficiently find the position of the first '1' in the input vector.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_decode_firstbit is
    generic (
        InWidth_g       : positive;
        InReg_g         : boolean := true;
        OutReg_g        : boolean := true;
        PlRegs_g        : natural := 1
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;

        In_Data         : in    std_logic_vector(InWidth_g-1 downto 0);
        In_Valid        : in    std_logic := '1';

        Out_FirstBit    : out   std_logic_vector(log2ceil(InWidth_g)-1 downto 0);
        Out_Found       : out   std_logic;
        Out_Valid       : out   std_logic
    );
end entity;

architecture rtl of olo_base_decode_firstbit is

    constant Stages_c         : natural := PlRegs_g+1;
    constant BinBits_c        : natural := log2ceil(InWidth_g);
    constant InWidthPow2_c    : natural := 2**BinBits_c;
    constant AddrBitsStageN_c : natural := BinBits_c/Stages_c;
    constant AddrBitsStage1_c : natural := BinBits_c - AddrBitsStageN_c*(Stages_c-1);
    constant ParallelStage1_c : natural := InWidthPow2_c/2**AddrBitsStage1_c;

    type BinStage_t is array (0 to ParallelStage1_c-1) of std_logic_vector(BinBits_c-1 downto 0);
    type BinAll_t is array(0 to Stages_c-1) of BinStage_t;
    type Found_t is array(0 to Stages_c-1) of std_logic_vector(ParallelStage1_c-1 downto 0);

    type TwoProcess_r is record
        DataIn   : std_logic_vector(In_Data'range);
        ValidIn  : std_logic;
        Addr     : BinAll_t;
        Found    : Found_t;
        Valid    : std_logic_vector(Stages_c-1 downto 0);
        FirstBit : std_logic_vector(Out_FirstBit'range);
        FoundOut : std_logic;
        ValidOut : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert PlRegs_g < BinBits_c/2
        report ""olo_base_decode_firstbit - PlRegs_g must be smaller than ceil(log2(InWidth_g))/2""
        severity error;

    p_comb : process (r, In_Data, In_Valid) is
        variable v                : TwoProcess_r;
        variable DataIn_v         : std_logic_vector(2**BinBits_c-1 downto 0);
        variable InValid_v        : std_logic;
        variable AddrBits_v       : natural;
        variable AddrLowIdx_v     : natural;
        variable AddrHighIdx_v    : natural;
        variable Parallelism_v    : natural;
        variable AddrBitsRemain_v : natural;
        variable StartIdx_v       : natural;
        variable InBitsPerInst_v  : natural;
    begin
        v := r;

        DataIn_v := (others => '0');
        if InReg_g then
            v.DataIn                       := In_Data;
            v.ValidIn                      := In_Valid;
            InValid_v                      := r.ValidIn;
            DataIn_v(InWidth_g-1 downto 0) := r.DataIn;
        else
            DataIn_v(InWidth_g-1 downto 0) := In_Data;
            InValid_v                      := In_Valid;
        end if;

        AddrLowIdx_v     := 0;
        AddrBitsRemain_v := BinBits_c;

        for stg in 0 to Stages_c-1 loop
            if stg = 0 then
                v.Valid(stg) := InValid_v;
            else
                v.Valid(stg) := r.Valid(stg-1);
            end if;

            if stg = 0 then
                AddrBits_v := AddrBitsStage1_c;
            else
                AddrBits_v := AddrBitsStageN_c;
            end if;
            AddrHighIdx_v    := AddrLowIdx_v + AddrBits_v - 1;
            AddrBitsRemain_v := AddrBitsRemain_v - AddrBits_v;
            Parallelism_v    := 2**AddrBitsRemain_v;

            InBitsPerInst_v := 2**AddrBits_v;
            StartIdx_v      := 0;

            if stg = 0 then

                for inst in 0 to Parallelism_v-1 loop
                    v.Found(0)(inst) := '0';

                    for bit in 0 to InBitsPerInst_v-1 loop
                        if DataIn_v(StartIdx_v+bit) = '1' then
                            v.Addr(0)(inst)  := toUslv(bit, BinBits_c);
                            v.Found(0)(inst) := '1';
                            exit;
                        end if;
                    end loop;

                    StartIdx_v := StartIdx_v + InBitsPerInst_v;
                end loop;

            else

                for inst in 0 to Parallelism_v-1 loop
                    v.Found(stg)(inst) := '0';

                    for bit in 0 to InBitsPerInst_v-1 loop
                        if r.Found(stg-1)(StartIdx_v+bit) = '1' then
                            v.Addr(stg)(inst)                                    := r.Addr(stg-1)(StartIdx_v+bit);
                            v.Addr(stg)(inst)(AddrHighIdx_v downto AddrLowIdx_v) := toUslv(bit, AddrBits_v);
                            v.Found(stg)(inst)                                   := '1';
                            exit;
                        end if;
                    end loop;

                    StartIdx_v := StartIdx_v + InBitsPerInst_v;
                end loop;

            end if;

            AddrLowIdx_v := AddrLowIdx_v + AddrBits_v;

        end loop;

        v.FoundOut := r.Found(Stages_c-1)(0);
        if v.FoundOUt = '1' then
            v.FirstBit := r.Addr(Stages_c-1)(0);
        else
            v.FirstBit := (others => '0'); -- Output zero if not found, simplifies testing in many cases
        end if;
        v.ValidOut := r.Valid(Stages_c-1);
        if OutReg_g then
            Out_FirstBit <= r.FirstBit;
            Out_Found    <= r.FoundOut;
            Out_Valid    <= r.ValidOut;
        else
            Out_FirstBit <= v.FirstBit;
            Out_Found    <= v.FoundOut;
            Out_Valid    <= v.ValidOut;
        end if;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.ValidIn  <= '0';
                r.Valid    <= (others => '0');
                r.ValidOut <= '0';
            end if;
        end if;
    end process;

end architecture;",19
"This component is an efficient implementation for delay chains. It uses FPGA memory resources (Block-RAM and distributed RAM resp. SRLs) for implementing the delays (instead of many FFs). The last delay stage is always implemented in FFs to ensure good timing (RAM outputs are usually slow). The delay is specified as a number of data-beats (samples). For a delay in clock-cycles, simply connect _In_Valid_='1' - or lave _In_Valid_ unconnected to rely on its default value. One Problem with using RAM resources to implement delays is that they don't have a reset, so the content of the RAM persists after resetting the logic. The _olo_base_delay_ entity works around this issue by some logic that ensures that any persisting data is replaced by zeros after a reset. The replacement is done at the output of the _olo_base_delay_, so no time to overwrite memory cells after a reset is required and the entity is ready to operate on the first clock cycle after the reset. If the delay is implemented using a RAM, the behavior of the RAM (read-before-write or write-before-read) can be selected to allow efficient implementation independently of the target technology. Note that output data is valid together with Input data (when _In_Valid_ is high). Below figure shows the behavior for _Delay_g_=3 with both possible settings for _RstState_g_: In cases a delayed version of an AXI4-Stream with back-pressure (_Ready_ signal) is required, the ANDed _Ready_ and _Valid_ signals shall be connected to the _In_Valid_ input of _olo_base_delay_.

# VHDL Analysis for 'olo_base_delay.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a delay element. It is either emplemented in BRAM or SRL. The output
- Plus 32 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_delay

## Architecture: rtl of olo_base_delay

### Signals
- MemOut: std_logic_vector(Width_g - 1 downto 0)
- SrlSig: Srl_t := (others => (others => '0'))
- is ShregExtract_AllowExtraction_c;
        attribute srl_style of SrlSig: signal is SrlStyle_Srl_c
- RdAddr: std_logic_vector(log2ceil(MemTaps_c) - 1 downto 0) := (others => '0')
- WrAddr: std_logic_vector(log2ceil(MemTaps_c) - 1 downto 0) := (others => '0')
- RstStateCnt: integer range 0 to Delay_g - 1

### Component Instantiations
- Instance 'i_bram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_srl :' (Clocked) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_bram :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_srl :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- SrlSig(1 to SrlSig'high) <= SrlSig(0 to SrlSig'high - 1)

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst, RstState_g, RstStateCnt
- Implements memory functionality
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 192
- Process count: 6
- Signal count: 6

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_delay.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Generic Delay Component**

**Component Name:** Generic Delay Component (`olo_base_delay`)

**Functionality:** The Generic Delay Component is a parameterized digital circuit that introduces a specified delay between its input and output signals. It can be configured to utilize either Shift Register Logic (SRL) or Block RAM (BRAM) resources, depending on the desired delay length and resource availability.

**Inputs:**

* `Clk`: Clock input (1-bit)
* `Rst`: Asynchronous reset input (1-bit)
* `In_Data`: Input data bus (Width_g bits)
* `In_Valid`: Input data validity signal (1-bit, default: '1')

**Outputs:**

* `Out_Data`: Output data bus (Width_g bits)

**Parameters:**

* `Width_g`: Input/output data bus width (positive integer)
* `Delay_g`: Desired delay length (natural number)
* `Resource_g`: Resource selection (string, default: ""AUTO""; options: ""AUTO"", ""SRL"", ""BRAM"")
* `BramThreshold_g`: Threshold for BRAM usage (positive integer, default: 128; range: 3 to positive'high)
* `RstState_g`: Reset state behavior (boolean, default: True)
* `RamBehavior_g`: RAM behavior (string, default: ""RBW"")

**Behavior:**

1. The component introduces a delay of `Delay_g` clock cycles between the `In_Data` input and `Out_Data","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;

entity olo_base_delay is
    generic (
        Width_g         : positive;
        Delay_g         : natural;
        Resource_g      : string                            := ""AUTO"";
        BramThreshold_g : positive range 3 to positive'high := 128;
        RstState_g      : boolean                           := True;
        RamBehavior_g   : string                            := ""RBW""
    );
    port (
        Clk      : in    std_logic;
        Rst      : in    std_logic;
        In_Data  : in    std_logic_vector(Width_g-1 downto 0);
        In_Valid : in    std_logic := '1';
        Out_Data : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_delay is

    signal MemOut      : std_logic_vector(Width_g - 1 downto 0);
    constant MemTaps_c : natural := work.olo_base_pkg_math.max(Delay_g - 1, 0);

begin

    assert Resource_g = ""AUTO"" or Resource_g = ""SRL"" or Resource_g = ""BRAM""
        report ""###ERROR###: olo_base_delay: Unknown Resource_g - "" & Resource_g
        severity error;
    assert Resource_g /= ""BRAM"" or Delay_g >= 3
        report ""###ERROR###: olo_base_delay: Delay_g >= 3 required for Resource_g=BRAM""
        severity error;
    assert BramThreshold_g > 3
        report ""###ERROR###: olo_base_delay: BramThreshold_g must be > 3""
        severity error;

    g_srl : if (Delay_g > 1) and ((Resource_g = ""SRL"") or ((Resource_g = ""AUTO"") and (Delay_g < BramThreshold_g))) generate
        type Srl_t is array (0 to MemTaps_c - 1) of std_logic_vector(Width_g - 1 downto 0);

        signal SrlSig : Srl_t := (others => (others => '0'));

        attribute shreg_extract of SrlSig : signal is ShregExtract_AllowExtraction_c;
        attribute srl_style of SrlSig     : signal is SrlStyle_Srl_c;
    begin

        p_srl : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    SrlSig(0)                <= In_Data;
                    SrlSig(1 to SrlSig'high) <= SrlSig(0 to SrlSig'high - 1);
                end if;
            end if;
        end process;

        MemOut <= SrlSig(SrlSig'high);
    end generate;

    g_bram : if (Delay_g > 1) and ((Resource_g = ""BRAM"") or ((Resource_g = ""AUTO"") and (Delay_g >= BramThreshold_g))) generate
        signal RdAddr, WrAddr : std_logic_vector(log2ceil(MemTaps_c) - 1 downto 0) := (others => '0');
    begin

        p_bram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    if unsigned(WrAddr) = MemTaps_c - 1 then
                        WrAddr <= (others => '0');
                    else
                        WrAddr <= std_logic_vector(unsigned(WrAddr) + 1);
                    end if;
                    if unsigned(RdAddr) = MemTaps_c - 1 then
                        RdAddr <= (others => '0');
                    else
                        RdAddr <= std_logic_vector(unsigned(RdAddr) + 1);
                    end if;
                end if;

                if Rst = '1' then
                    WrAddr <= std_logic_vector(to_unsigned(MemTaps_c - 1, WrAddr'length));
                    RdAddr <= (others => '0');
                end if;
            end if;
        end process;

        i_bram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => MemTaps_c,
                Width_g         => Width_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk     => Clk,
                Wr_Addr => WrAddr,
                Wr_Ena  => In_Valid,
                Wr_Data => In_Data,
                Rd_Addr => RdAddr,
                Rd_Ena  => In_Valid,
                Rd_Data => MemOut
            );

    end generate;

    g_single : if Delay_g = 1 generate
        MemOut <= In_Data;
    end generate;

    g_zero : if Delay_g = 0 generate
        Out_Data <= In_Data;
    end generate;

    g_nonzero : if Delay_g > 0 generate
        signal RstStateCnt : integer range 0 to Delay_g - 1;
    begin

        p_outreg : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    if RstState_g = false or RstStateCnt = Delay_g - 1 then
                        Out_Data <= MemOut;
                    else
                        Out_Data    <= (others => '0');
                        RstStateCnt <= RstStateCnt + 1;
                    end if;
                end if;

                if Rst = '1' then
                    Out_Data    <= (others => '0');
                    RstStateCnt <= 0;
                end if;
            end if;
        end process;

    end generate;

end architecture;",20
"This component is an efficient implementation for runtime configurable delay chains. It uses FPGA memory resources (Block-RAM) for implementing the delays (instead of many FFs). The last delay stage is always implemented in FFs to ensure good timing (RAM outputs are usually slow). For general usage of the _olo_base_delay_cfg_ entity, the same considerations as for [olo_base_delay](./olo_base_delay.md) apply. Refer to this documentation for details on the input and output signaling. Note that any changes of the delay are reflected at the output (_Out_Data_) within less than 5 samples / data-beats. During those 5 samples, the content of (_Out_Data_) is undefined. This is illustrated in the figure below.

# VHDL Analysis for 'olo_base_delay_cfg.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef & Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a delay element. It is either implemented in BRAM & SRL. The output
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_delay_cfg

## Architecture: rtl of olo_base_delay_cfg

### Signals
- SrlSig: Srl_t                                  := (others => (others => '0'))
- OutNonzero: std_logic_vector(Width_g - 1 downto 0)
- MemOut: std_logic_vector(Width_g - 1 downto 0) := (others => '0')
- RdAddr: std_logic_vector(log2ceil(MaxDelay_g) - 1 downto 0) := (others => '0')
- WrAddr: std_logic_vector(log2ceil(MaxDelay_g) - 1 downto 0) := (others => '0')

### Processes
- Process 'p_bram :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_srl :' (Clocked) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset
- Process 'p_srl :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_outreg :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- RdAddr <= std_logic_vector(unsigned(WrAddr) - unsigned(Delay) + 3)

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst
- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 157
- Process count: 6
- Signal count: 5

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_delay_cfg.vhd' plays a specific role in the overall CPU architecture.
","**Component Description:**
The `olo_base_delay_cfg` component is a configurable delay element that introduces a variable delay to the input data stream. It accepts input data, a delay value, and a validity signal, and produces output data with the specified delay. The component supports both RAM-based and shift-register-based delay implementations.

**Component Specification:**

* **Component Name:** Configurable Delay Element (`olo_base_delay_cfg`)
* **Functionality:** Introduces a variable delay to the input data stream based on the provided delay value
* **Inputs:**
	+ `Clk`: Clock signal
	+ `Rst`: Reset signal
	+ `Delay`: Delay value (unsigned integer, width determined by `MaxDelay_g`)
	+ `In_Data`: Input data ( Width_g bits)
	+ `In_Valid`: Input validity signal (1-bit)
* **Outputs:**
	+ `Out_Data`: Output data ( Width_g bits)
* **Parameters:**
	+ `Width_g`: Input/output data width (positive integer)
	+ `MaxDelay_g`: Maximum delay value (positive integer, default: 256)
	+ `SupportZero_g`: Support for zero delay (boolean, default: false)
	+ `RamBehavior_g`: RAM behavior (string, default: ""RBW"")

**Detailed Specification:**

* The component has two implementation options:
	+ For small delay values (<= 3), a shift-register-based implementation is used
	+ For larger delay values,","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_delay_cfg is
    generic (
        Width_g         : positive;
        MaxDelay_g      : positive := 256;
        SupportZero_g   : boolean  := false;
        RamBehavior_g   : string   := ""RBW""
    );
    port (
        Clk      : in    std_logic;
        Rst      : in    std_logic;
        Delay    : in    std_logic_vector(log2ceil(MaxDelay_g+1)-1 downto 0);
        In_Data  : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid : in    std_logic;
        Out_Data : out   std_logic_vector((Width_g - 1) downto 0)
    );
end entity;

architecture rtl of olo_base_delay_cfg is

    type Srl_t is array (0 to 1) of std_logic_vector(Width_g - 1 downto 0);

    signal SrlSig     : Srl_t                                  := (others => (others => '0'));
    signal OutNonzero : std_logic_vector(Width_g - 1 downto 0);
    signal MemOut     : std_logic_vector(Width_g - 1 downto 0) := (others => '0');

begin

    g_ram : if MaxDelay_g > 3 generate
        signal RdAddr, WrAddr : std_logic_vector(log2ceil(MaxDelay_g) - 1 downto 0) := (others => '0');
    begin

        p_bram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    WrAddr <= std_logic_vector(unsigned(WrAddr) + 1);
                    RdAddr <= std_logic_vector(unsigned(WrAddr) - unsigned(Delay) + 3);
                end if;

                if Rst = '1' then
                    WrAddr <= (others => '0');
                    RdAddr <= (others => '0');
                end if;
            end if;
        end process;

        i_bram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => 2**log2ceil(MaxDelay_g),
                Width_g         => Width_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk     => Clk,
                Wr_Addr => WrAddr,
                Wr_Ena  => In_Valid,
                Wr_Data => In_Data,
                Rd_Addr => RdAddr,
                Rd_Ena  => In_Valid,
                Rd_Data => MemOut
            );

    end generate;

    p_srl : process (Clk) is
    begin
        if rising_edge(Clk) then
            if In_Valid = '1' then
                SrlSig(0) <= In_Data;
                SrlSig(1) <= SrlSig(0);
            end if;
        end if;
    end process;

    p_outreg : process (Clk) is
        variable DelayInt_v : natural range 0 to MaxDelay_g;
    begin
        if rising_edge(Clk) then
            DelayInt_v := fromUslv(Delay);
            if In_Valid = '1' then

                case DelayInt_v is
                    when 1 =>  OutNonzero <= In_Data;
                    when 2 =>  OutNonzero <= SrlSig(0);
                    when 3 =>  OutNonzero <= SrlSig(1);
                    when others => OutNonzero <= MemOut;
                end case;

            end if;

            if Rst = '1' then
                OutNonzero <= (others => '0');
            end if;
        end if;
    end process;

    g_supportzero : if SupportZero_g generate
        Out_Data <= OutNonzero when fromUslv(Delay) /= 0 else In_Data;
    end generate;

    g_nozero : if not SupportZero_g generate
        Out_Data <= OutNonzero;
    end generate;

end architecture;",21
"This entity implements a dynamic shift (barrel shift) implemented in multiple stages in order to achieve good timing. The number of bits to shift can be selected at runtime for each data-sample.

# VHDL Analysis for 'olo_base_dyn_sft.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2020 by Oliver Bruendler
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a dynamic shift implemented in multiple stages in
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: this line can't be reached in valid configurations
            -- coverage off
            else
                report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT, is '"" & Direction_g & ""'"" severity error

## Entity: olo_base_dyn_sft

## Architecture: rtl of olo_base_dyn_sft

### Signals
- r: TwoProcess_t
- r_next: TwoProcess_t

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Valid, In_Data, In_Shift
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Input stages
        v.Data(0)  := In_Data
- v.Shift(0) := In_Shift
- v.Vld(0)   := In_Valid
- -- Shift stages
        for stg in 0 to Stages_c - 1 loop
            -- Stage constants calculation
            StepSize_v := 2**(stg * SelBitsPerStageLimited_c)
- -- Shift implementation
            Select_v := to_integer(unsigned(r.Shift(stg)(SelBitsPerStageLimited_c - 1 downto 0)))
- Plus 2 more statements

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst, SelBitsPerStageLimited_c, SelBitsPerStage_g
- May be part of a pipeline architecture

## Code Metrics
- Line count: 151
- Process count: 4
- Signal count: 2

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_dyn_sft.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Dynamic Shift Operator**

**Component Name:** olo_base_dyn_sft

**Functionality:** The olo_base_dyn_sft component performs a dynamic shift operation on the input data based on the provided shift amount. The shift can be either to the left or right, and the component supports sign extension for right shifts.

**Inputs:**

* **Clk:** Clock input (std_logic)
* **Rst:** Asynchronous reset input (std_logic)
* **In_Valid:** Input validity signal (std_logic, default='1')
* **In_Shift:** Shift amount input (std_logic_vector, log2ceil(MaxShift_g+1)-1 downto 0)
* **In_Data:** Input data to be shifted (std_logic_vector, Width_g -1 downto 0)

**Outputs:**

* **Out_Valid:** Output validity signal (std_logic)
* **Out_Data:** Shifted output data (std_logic_vector, Width_g -1 downto 0)

**Parameters:**

* **Direction_g:** Shift direction (string, ""LEFT"" or ""RIGHT"")
* **SelBitsPerStage_g:** Number of bits used for selection per stage (positive, default=4)
* **MaxShift_g:** Maximum shift amount (positive)
* **Width_g:** Input data width (positive)
* **SignExtend_g:** Sign extension enable for right shifts (boolean, default=false)

**Description:** The component takes in input data, a shift amount, and a validity","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_dyn_sft is
    generic (
        Direction_g         : string;
        SelBitsPerStage_g   : positive := 4;
        MaxShift_g          : positive;
        Width_g             : positive;
        SignExtend_g        : boolean  := false
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic := '1';
        In_Shift    : in    std_logic_vector(log2ceil(MaxShift_g+1)- 1 downto 0);
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_dyn_sft is

    constant Stages_c                 : integer := integer(ceil(real(In_Shift'length) / real(SelBitsPerStage_g)));
    constant SelBitsPerStageLimited_c : integer := work.olo_base_pkg_math.min(SelBitsPerStage_g, In_Shift'length);

    type Data_t is array (natural range <>) of std_logic_vector(In_Data'range);
    type Shift_t is array (natural range <>) of std_logic_vector(In_Shift'range);

    type TwoProcess_t is record
        Vld   : std_logic_vector(0 to Stages_c);
        Data  : Data_t(0 to Stages_c);
        Shift : Shift_t(0 to Stages_c);
    end record;

    signal r, r_next : TwoProcess_t;

begin

    assert Direction_g = ""LEFT"" or Direction_g = ""RIGHT""
        report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT""
        severity error;
    assert MaxShift_g <= Width_g
        report ""###ERROR###: olo_base_dyn_sft - MaxShift_g must be smaller or equal to Width_g""
        severity error;

    p_comb : process (r, In_Valid, In_Data, In_Shift) is
        variable v          : TwoProcess_t;
        variable StepSize_v : natural;
        variable Select_v   : natural range 0 to 2**SelBitsPerStage_g - 1;
        variable TempData_v : std_logic_vector(Width_g * 2 - 1 downto 0);
    begin
        v := r;

        v.Data(0)  := In_Data;
        v.Shift(0) := In_Shift;
        v.Vld(0)   := In_Valid;

        for stg in 0 to Stages_c - 1 loop
            StepSize_v := 2**(stg * SelBitsPerStageLimited_c);

            Select_v := to_integer(unsigned(r.Shift(stg)(SelBitsPerStageLimited_c - 1 downto 0)));
            if Direction_g = ""RIGHT"" then
                if SignExtend_g then
                    TempData_v := (others => r.Data(stg)(Width_g - 1));
                else
                    TempData_v := (others => '0');
                end if;
                TempData_v(2 * Width_g - 1 - Select_v * StepSize_v downto Width_g - Select_v * StepSize_v) := r.Data(stg);
                v.Data(stg + 1)                                                                            := TempData_v(2 * Width_g - 1 downto Width_g);
            elsif Direction_g = ""LEFT"" then
                TempData_v                                                                   := (others => '0');
                TempData_v(Select_v * StepSize_v + Width_g - 1 downto Select_v * StepSize_v) := r.Data(stg);
                v.Data(stg + 1)                                                              := TempData_v(Width_g - 1 downto 0);
            else
                report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT, is '"" & Direction_g & ""'"" severity error;
            end if;
            v.Shift(stg + 1) := shiftRight(r.Shift(stg), SelBitsPerStageLimited_c, '0');
            v.Vld(stg + 1)   := r.Vld(stg);
        end loop;

        Out_Data  <= r.Data(Stages_c);
        Out_Valid <= r.Vld(Stages_c);

        r_next <= v;

    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Vld <= (others => '0');
            end if;
        end if;
    end process;

end architecture;",22
"This component implements an asynchronous FIFO (different clocks for write and read port). The memory is described in a way that it utilizes RAM resources (Block-RAM or distributed RAM) available in FPGAs with commonly used tools. For this purpose [olo_base_ram_sdp](./olo_base_ram_sdp.md) is used. The FIFO is a fall-through FIFO and has AXI-S interfaces on read and write side. The RAM behavior (read-before-write or write-before-read) can be selected. This allows efficiently implementing FIFOs for different technologies (some technologies implement one, some the other behavior). An asynchronous FIFO is a clock-crossing and hence this block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

# VHDL Analysis for 'olo_base_fifo_async.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic asynchronous FIFO. The clocks can be fully asynchronous
- Plus 51 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: unregistered signal because CC contains register
            Out_Clk  => In_Clk,
            Out_Rst  => RstInInt,
            Out_Data => RdAddrGray
        )

## Entity: olo_base_fifo_async

## Architecture: rtl of olo_base_fifo_async

### Signals
- ri: TwoProcessIn_r := (WrAddr          => (others => '0'),
                                             WrAddrGray     => (others => '0'),
                                             RdAddr         => (others => '0'),
                                             WrAddrReg      => (others => '0'),
                                             RamWr          => '0',
                                            DataReg         => (others => '0'))
- ri_next: TwoProcessIn_r := (WrAddr          => (others => '0'),
                                             WrAddrGray     => (others => '0'),
                                             RdAddr         => (others => '0'),
                                             WrAddrReg      => (others => '0'),
                                             RamWr          => '0',
                                            DataReg         => (others => '0'))
- ro: TwoProcessOut_r := (RdAddr          => (others => '0'),
                                              RdAddrGray     => (others => '0'),
                                              WrAddr         => (others => '0'),
                                              OutLevel       => (others => '0'))
- ro_next: TwoProcessOut_r := (RdAddr          => (others => '0'),
                                              RdAddrGray     => (others => '0'),
                                              WrAddr         => (others => '0'),
                                              OutLevel       => (others => '0'))
- RstInInt: std_logic
- RstOutInt: std_logic
- RamRdAddr: std_logic_vector(RamAddrWidth_c-1 downto 0)
- RamWrAddr: std_logic_vector(RamAddrWidth_c-1 downto 0)
- RamWr: std_logic
- RamWrData: std_logic_vector(Width_g-1 downto 0)
- WrAddrGray: std_logic_vector(AddrWidth_c-1 downto 0)
- RdAddrGray: std_logic_vector(AddrWidth_c-1 downto 0)
- WrAddrGrayIn: std_logic_vector(AddrWidth_c-1 downto 0)
- RdAddrGrayIn: std_logic_vector(AddrWidth_c-1 downto 0)
- ***
        ri_next <= vi;
        ro_next <= vo;

    end process;

    p_seq_in: process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            ri <= ri_next
- because CC contains register
            Out_Clk  => In_Clk: entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        )
- Out_Rst  => RstInInt: entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        )
- Out_Data => RdAddrGray
        );

    -- Reset CC
    i_rst_cc: entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        )

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'
- Instance 'i_cc_wr_rd' of component 'olo_base_cc_bits'
- Instance 'i_cc_rd_wr' of component 'olo_base_cc_bits'
- Instance 'i_rst_cc' of component 'olo_base_cc_reset'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: In_Valid, Out_Ready, ri, ro, RstInInt, WrAddrGray, RdAddrGray, In_Data
  - Implements conditional logic
- Process 'p_seq_in :' (Clocked) (Has Reset) with sensitivity list: In_Clk
  - Implements synchronous logic
- Process 'p_seq_out :' (Clocked) (Has Reset) with sensitivity list: Out_Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq_in :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_seq_out :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- vo := ro
- -- *** Write Side ***
        -- Defaults
        In_Ready    <= '0'
- In_Full     <= '0'
- In_Empty    <= '0'
- In_AlmFull  <= '0'
- Plus 8 more statements

## Functional Analysis

- Contains 7 clock domain(s): Clk, Out_Clk, B_Clk, In_Clk, A_Clk, Rd_Clk, Clock
- Uses reset signal(s): B_RstIn, i_rst_cc, olo_base_cc_reset, A_RstIn, ReadyRstState_g, RstInInt, reset, Reset, In_RstOut, A_RstOut, In_Rst, Out_RstOut, RstOutInt, Out_Rst, B_RstOut
- Implements memory functionality
- Implements interface or communication protocol
- May be part of a pipeline architecture
- This appears to be a CPU component
- Implements instruction execution functionality

## Code Metrics
- Line count: 344
- Process count: 6
- Signal count: 18

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_fifo_async.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Asynchronous FIFO**

**Overview**

The `olo_base_fifo_async` component is an asynchronous First-In-First-Out (FIFO) buffer designed to transfer data between two clock domains. It provides a flexible and efficient way to handle data transfer between systems operating at different clock frequencies.

**Functional Description**

The FIFO component has two main interfaces:

1. **Input Interface** (In_Clk domain):
	* Accepts data from an external source through `In_Data`.
	* Validates data transfer through `In_Valid`.
	* Indicates readiness to accept data through `In_Ready`.
	* Provides FIFO status signals: `In_Full`, `In_Empty`, `In_AlmFull`, and `In_AlmEmpty`.
2. **Output Interface** (Out_Clk domain):
	* Provides data to an external consumer through `Out_Data`.
	* Indicates data validity through `Out_Valid`.
	* Accepts data consumption through `Out_Ready`.
	* Provides FIFO status signals: `Out_Full`, `Out_Empty`, `Out_AlmFull`, and `Out_AlmEmpty`.

**Key Features**

* **Asynchronous operation**: The FIFO operates independently in both clock domains, ensuring data transfer between systems with different clock frequencies.
* **Configurable**: The component allows configuration of various parameters, such as:
	+ `Width_g`: Data width (in bits).
	+ `Depth_g`: FIFO depth (must","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_fifo_async is
    generic (
        Width_g         : positive;
        Depth_g         : positive; -- must be power of two
        AlmFullOn_g     : boolean               := false;
        AlmFullLevel_g  : natural               := 0;
        AlmEmptyOn_g    : boolean               := false;
        AlmEmptyLevel_g : natural               := 0;
        RamStyle_g      : string                := ""auto"";
        RamBehavior_g   : string                := ""RBW"";
        ReadyRstState_g : std_logic             := '1';
        Optimization_g  : string                := ""SPEED""; -- SPEED or LATENCY
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk          : in    std_logic;
        In_Rst          : in    std_logic;
        In_RstOut       : out   std_logic;
        In_Data         : in    std_logic_vector(Width_g-1 downto 0);
        In_Valid        : in    std_logic := '1';
        In_Ready        : out   std_logic;
        In_Full         : out   std_logic;
        In_Empty        : out   std_logic;
        In_AlmFull      : out   std_logic;
        In_AlmEmpty     : out   std_logic;
        In_Level        : out   std_logic_vector(log2ceil(Depth_g+1)-1 downto 0);
        Out_Clk         : in    std_logic;
        Out_Rst         : in    std_logic;
        Out_RstOut      : out   std_logic;
        Out_Data        : out   std_logic_vector(Width_g-1 downto 0);
        Out_Valid       : out   std_logic;
        Out_Ready       : in    std_logic := '1';
        Out_Full        : out   std_logic;
        Out_Empty       : out   std_logic;
        Out_AlmFull     : out   std_logic;
        Out_AlmEmpty    : out   std_logic;
        Out_Level       : out   std_logic_vector(log2ceil(Depth_g+1)-1 downto 0)
    );
end entity;

architecture rtl of olo_base_fifo_async is

    constant AddrWidth_c    : positive := log2ceil(Depth_g)+1;
    constant RamAddrWidth_c : positive := log2ceil(Depth_g);

    type TwoProcessIn_r is record
        WrAddr     : unsigned(AddrWidth_c-1 downto 0); -- One additional bit for full/empty detection
        WrAddrGray : std_logic_vector(AddrWidth_c-1 downto 0);
        RdAddr     : unsigned(AddrWidth_c-1 downto 0);
        WrAddrReg  : unsigned(AddrWidth_c-1 downto 0);
        RamWr      : std_logic;
        DataReg    : std_logic_vector(Width_g-1 downto 0);
    end record;

    type TwoProcessOut_r is record
        RdAddr     : unsigned(AddrWidth_c-1 downto 0); -- One additional bit for full/empty detection
        RdAddrGray : std_logic_vector(AddrWidth_c-1 downto 0);
        WrAddr     : unsigned(AddrWidth_c-1 downto 0);
        OutLevel   : unsigned(AddrWidth_c-1 downto 0);
    end record;

    signal ri, ri_next : TwoProcessIn_r := (WrAddr          => (others => '0'),
                                             WrAddrGray     => (others => '0'),
                                             RdAddr         => (others => '0'),
                                             WrAddrReg      => (others => '0'),
                                             RamWr          => '0',
                                            DataReg         => (others => '0'));

    signal ro, ro_next : TwoProcessOut_r := (RdAddr          => (others => '0'),
                                              RdAddrGray     => (others => '0'),
                                              WrAddr         => (others => '0'),
                                              OutLevel       => (others => '0'));

    signal RstInInt     : std_logic;
    signal RstOutInt    : std_logic;
    signal RamRdAddr    : std_logic_vector(RamAddrWidth_c-1 downto 0);
    signal RamWrAddr    : std_logic_vector(RamAddrWidth_c-1 downto 0);
    signal RamWr        : std_logic;
    signal RamWrData    : std_logic_vector(Width_g-1 downto 0);
    signal WrAddrGray   : std_logic_vector(AddrWidth_c-1 downto 0);
    signal RdAddrGray   : std_logic_vector(AddrWidth_c-1 downto 0);
    signal WrAddrGrayIn : std_logic_vector(AddrWidth_c-1 downto 0);
    signal RdAddrGrayIn : std_logic_vector(AddrWidth_c-1 downto 0);

begin

    assert log2(Depth_g) = log2ceil(Depth_g)
        report ""###ERROR###: olo_base_fifo_async: only power of two Depth_g is allowed""
        severity error;

    p_comb : process (In_Valid, Out_Ready, ri, ro, RstInInt, WrAddrGray, RdAddrGray, In_Data) is
        variable vi        : TwoProcessIn_r;
        variable vo        : TwoProcessOut_r;
        variable InLevel_v : unsigned(log2ceil(Depth_g) downto 0);
    begin
        vi := ri;
        vo := ro;

        In_Ready    <= '0';
        In_Full     <= '0';
        In_Empty    <= '0';
        In_AlmFull  <= '0';
        In_AlmEmpty <= '0';
        vi.RamWr    := '0';

        InLevel_v := ri.WrAddr - ri.RdAddr;
        In_Level  <= std_logic_vector(InLevel_v);

        if (ri.WrAddr(ri.WrAddr'left) /= ri.RdAddr(ri.RdAddr'left)) and
           (ri.WrAddr(ri.WrAddr'left-1 downto 0) = ri.RdAddr(ri.RdAddr'left-1 downto 0)) then
            In_Full <= '1';
        else
            In_Ready <= '1';
            if In_Valid = '1' then
                vi.WrAddr := ri.WrAddr + 1;
                vi.RamWr  := '1';
            end if;
        end if;
        if (ReadyRstState_g = '0') and (RstInInt = '1') then
            In_Ready <= '0';
        end if;

        if InLevel_v = 0 then
            In_Empty <= '1';
        end if;
        if InLevel_v >= AlmFullLevel_g and AlmFullOn_g then
            In_AlmFull <= '1';
        end if;
        if InLevel_v <= AlmEmptyLevel_g and AlmEmptyOn_g then
            In_AlmEmpty <= '1';
        end if;

        vi.WrAddrReg := ri.WrAddr;
        vi.DataReg   := In_Data;

        Out_Valid    <= '0';
        Out_Full     <= '0';
        Out_Empty    <= '0';
        Out_AlmFull  <= '0';
        Out_AlmEmpty <= '0';

        if ro.WrAddr = ro.RdAddr then
            vo.OutLevel := (others => '0');
        else
            vo.OutLevel := ro.WrAddr - ro.RdAddr;
            if (Out_Ready = '1') and (ro.OutLevel /= 0) then
                vo.OutLevel := vo.OutLevel - 1;
            end if;
        end if;
        Out_Level <= std_logic_vector(ro.OutLevel);

        if ro.OutLevel = 0 then
            Out_Empty <= '1';
        else
            Out_Valid <= '1';
            if Out_Ready = '1' then
                vo.RdAddr := ro.RdAddr + 1;
            end if;
        end if;
        RamRdAddr <= std_logic_vector(vo.RdAddr(log2ceil(Depth_g) - 1 downto 0));

        if ro.OutLevel = Depth_g then
            Out_Full <= '1';
        end if;
        if ro.OutLevel >= AlmFullLevel_g and AlmFullOn_g then
            Out_AlmFull <= '1';
        end if;
        if ro.OutLevel <= AlmEmptyLevel_g and AlmEmptyOn_g then
            Out_AlmEmpty <= '1';
        end if;

        vi.WrAddrGray := binaryToGray(std_logic_vector(vi.WrAddr));
        vo.RdAddrGray := binaryToGray(std_logic_vector(vo.RdAddr));

        vi.RdAddr := unsigned(grayToBinary(RdAddrGray));
        vo.WrAddr := unsigned(grayToBinary(WrAddrGray));

        ri_next <= vi;
        ro_next <= vo;

    end process;

    p_seq_in : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            ri <= ri_next;
            if RstInInt = '1' then
                ri.WrAddr     <= (others => '0');
                ri.WrAddrGray <= (others => '0');
                ri.RdAddr     <= (others => '0');
                ri.RamWr      <= '0';
            end if;
        end if;
    end process;

    p_seq_out : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            ro <= ro_next;
            if RstOutInt = '1' then
                ro.RdAddr     <= (others => '0');
                ro.RdAddrGray <= (others => '0');
                ro.WrAddr     <= (others => '0');
                ro.OutLevel   <= (others => '0');
            end if;
        end if;
    end process;

    RamWrAddr <= std_logic_vector(ri.WrAddr(log2ceil(Depth_g) - 1 downto 0)) when Optimization_g = ""LATENCY"" else
                 std_logic_vector(ri.WrAddrReg(log2ceil(Depth_g) - 1 downto 0));
    RamWr     <= ri_next.RamWr when Optimization_g = ""LATENCY"" else ri.RamWr;
    RamWrData <= In_Data when Optimization_g = ""LATENCY"" else ri.DataReg;

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            IsAsync_g       => true,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk         => In_Clk,
            Wr_Addr     => RamWrAddr,
            Wr_Ena      => RamWr,
            Wr_Data     => RamWrData,
            Rd_Clk      => Out_Clk,
            Rd_Addr     => RamRdAddr,
            Rd_Data     => Out_Data
        );

    WrAddrGrayIn <= ri_next.WrAddrGray when Optimization_g = ""LATENCY"" else ri.WrAddrGray; -- optional register stage

    i_cc_wr_rd : entity work.olo_base_cc_bits
        generic map (
            Width_g      => AddrWidth_c,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => In_Clk,
            In_Rst   => RstInInt,
            In_Data  => WrAddrGrayIn,
            Out_Clk  => Out_Clk,
            Out_Rst  => RstOutInt,
            Out_Data => WrAddrGray
        );

    RdAddrGrayIn <= ro_next.RdAddrGray when Optimization_g = ""LATENCY"" else ro.RdAddrGray; -- optional register stage

    i_cc_rd_wr : entity work.olo_base_cc_bits
        generic map (
            Width_g      => AddrWidth_c,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => Out_Clk,
            In_Rst   => RstOutInt,
            In_Data  => RdAddrGrayIn, -- use unregistered signal because CC contains register
            Out_Clk  => In_Clk,
            Out_Rst  => RstInInt,
            Out_Data => RdAddrGray
        );

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        );

    Out_RstOut <= RstOutInt;
    In_RstOut  <= RstInInt;

end architecture;",23
"This component implements a synchronous packet FIFO. The FIFO works in store and forward mode. This means a packet is only presented to the output after it is written into the FIFO completely. This component offers the following additional features compared to [olo_base_fifo_sync](./olo_base_fifo_sync.md): - Due to the store and forward implementation, packets are compressed. Even if the data is written into the FIFO at low rate, it is guaranteed that the packet can be read in a single short burst once it is presented at the output. - Writing of a packet into a FIFO can be aborted at any time during writing the packet (see [Dropping Packets on Write Side](#dropping-packets-on-write-side)). The write pointer is automatically rewinded in this case. - Example use-case: A CRC error can only be detected at the end of the packet. User logic can still write the packet into the FIFO directly and just asserts _In_Drop_ if a CRC error is detected at the end of the packet. The full packet (including already written data) is ignored. - On the read side, it is possible to skip the remaining data of a packet at any time during reading a packet (see [Skipping Packets on Read Side](#skipping-packets-on-read-side)). - Example use-case: The user logic is interested only in some packet types. If a different packet type is found in the header, _Out_Next_ can be asserted to skip the rest of the packet and directly continue reading the next packet. - On the read side, it is possible to repeat a packet (see [Repeating Packets on Read Side](#repeating-packets-on-read-side)). - Example use-case: A packet is read from the FIFO and transmitted wirelessly. During sending the packet a collision occurs and the transmission is aborted. In this situation the user logic can assert _Out_Repeat_ to read the same packet again and retry the transmission. Below samples assumes _Depth_g_=32. The memory is described in a way that it utilizes RAM resources (Block-RAM or distributed RAM) available in FPGAs with commonly used tools. For this purpose [olo_base_ram_sdp](./olo_base_ram_sdp.md) is used. The FIFO  has AXI-S interfaces on read and write side. The RAM behavior (read-before-write or write-before-read) can be selected. This allows efficiently implementing FIFOs for different technologies (some technologies implement one, some the other behavior). The FIFO contains a large RAM for packet data and a small [olo_base_fifo_sync](./olo_base_fifo_sync.md) for storing the sizes of individual packets. **Note:** Due to implementation reasons the FIFO introduces one stall cycle per packet on the read-side. Hence the FIFO throughput is suboptimal for very small packets. Packets exceeding _Depth_g_ cannot be processed in store and forward mode and are therefore dropped automatically.

# VHDL Analysis for 'olo_base_fifo_packet.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- - This is a synchronous packet FIFO. In contrast to a normal FIFO, it allows
- - dropping and repeating packets as well as detecting how many packets
- Plus 93 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: it does not have any effect on the last word of a packet

                    -- To to idle cycle for fetch after packet completed
                    v.RdValid := '0'

## Entity: olo_base_fifo_packet

## Architecture: rtl of olo_base_fifo_packet

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- RamRdAddr: std_logic_vector(Addr_c)
- FifoInReady: std_logic
- RdPacketEnd: std_logic_vector(Addr_c)
- RdPacketEndValid: std_logic
- RamWrEna: std_logic
- FifoInValid: std_logic
- FifoOutRdy: std_logic
- WrAddrStdlv: std_logic_vector(Addr_c)
- r_next <= v;

    end process;

    -----------------------------------------------------------------------------------------------
    -- Sequential Proccess
    -----------------------------------------------------------------------------------------------
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: In_Valid, In_Data, In_Last, In_Drop, Out_Ready, Out_Next, Out_Repeat, Rst, r,
                      FifoInReady, RdPacketEnd, RdPacketEndValid
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- *** Write side ***

        -- Default Values
        In_Ready_v  := ((not r.Full) and FifoInReady) or r.DropLatch
- InDrop_v    := r.DropLatch
- RamWrEna    <= '0'
- FifoInValid <= '0'
- -- Implement getting free aftter Full
        if r.WrAddr /= r.RdPacketStart then
            v.Full := '0'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst, WrAddrStdlv, ReadyRstState_g
- Implements memory functionality
- Implements control logic
- This appears to be a CPU component
- Implements instruction fetching functionality

## Code Metrics
- Line count: 421
- Process count: 4
- Signal count: 11

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_fifo_packet.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Packet FIFO**

**Overview**

The `olo_base_fifo_packet` component is a parameterized packet FIFO (First-In-First-Out) buffer designed to store and retrieve packets of data. It provides a flexible and efficient way to manage packet data in digital systems.

**Functionality**

The component accepts packet data from an input interface and stores it in a configurable RAM-based buffer. The buffer is divided into packets, and each packet can have a variable length. The component provides a output interface to retrieve packets from the buffer.

**Inputs**

* `Clk`: Clock signal
* `Rst`: Reset signal
* `In_Valid`: Input data valid signal
* `In_Data`: Input data bus (Width_g bits)
* `In_Last`: Input packet last signal
* `In_Drop`: Input packet drop signal
* `Out_Ready`: Output ready signal

**Outputs**

* `In_Ready`: Input ready signal
* `In_IsDropped`: Input packet dropped signal
* `Out_Valid`: Output data valid signal
* `Out_Data`: Output data bus (Width_g bits)
* `Out_Size`: Output packet size bus (log2ceil(Depth_g + 1) bits)
* `Out_Last`: Output packet last signal
* `PacketLevel`: Current packet level bus (log2ceil(MaxPackets_g + 1) bits)
* `FreeWords`: Number of free words in the buffer bus (log2ceil","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_fifo_packet is
    generic (
        Width_g             : positive;
        Depth_g             : positive;
        RamStyle_g          : string                            := ""auto"";
        RamBehavior_g       : string                            := ""RBW"";
        SmallRamStyle_g     : string                            := ""auto"";
        SmallRamBehavior_g  : string                            := ""same"";
        MaxPackets_g        : positive range 2 to positive'high := 17
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        In_Valid      : in    std_logic := '1';
        In_Ready      : out   std_logic;
        In_Data       : in    std_logic_vector(Width_g - 1 downto 0);
        In_Last       : in    std_logic := '1';
        In_Drop       : in    std_logic := '0';
        In_IsDropped  : out   std_logic;
        Out_Valid     : out   std_logic;
        Out_Ready     : in    std_logic := '1';
        Out_Data      : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Size      : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Out_Last      : out   std_logic;
        Out_Next      : in    std_logic := '0';
        Out_Repeat    : in    std_logic := '0';
        PacketLevel   : out   std_logic_vector(log2ceil(MaxPackets_g + 1) - 1 downto 0);
        FreeWords     : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_fifo_packet is

    constant SmallRamStyle_c    : string := choose(SmallRamStyle_g = ""same"", RamStyle_g, SmallRamStyle_g);
    constant SmallRamBehavior_c : string := choose(SmallRamBehavior_g = ""same"", RamBehavior_g, SmallRamBehavior_g);

    subtype Addr_c is integer range log2ceil(Depth_g) downto 0; -- one additional bit to differentiate between full/empty
    subtype AddrApp_c is integer range log2ceil(Depth_g) - 1 downto 0; -- one additional bit to differentiate between full/empty

    type RdFsm_t is (Fetch_s, Data_s, Last_s);

    type TwoProcess_r is record
        WrAddr         : unsigned(Addr_c); -- Shifted by Depth_g to Read pointer
        WrPacketStart  : unsigned(Addr_c); -- Shifted by Depth_g to Read pointer
        WrSize         : unsigned(Addr_c);
        WrPacketActive : std_logic;
        DropLatch      : std_logic;
        Full           : std_logic;
        RdAddr         : unsigned(Addr_c);
        RdPacketStart  : unsigned(Addr_c);
        RdPacketEnd    : unsigned(Addr_c);
        RdValid        : std_logic;
        RdFsm          : RdFsm_t;
        RdRepeat       : std_logic;
        RdSize         : unsigned(log2ceil(Depth_g + 1) - 1 downto 0);
        NextLatch      : std_logic;
        PacketLevel    : unsigned(log2ceil(MaxPackets_g + 1)-1 downto 0);
    end record;


    signal r, r_next : TwoProcess_r;

    signal RamRdAddr        : std_logic_vector(Addr_c);
    signal FifoInReady      : std_logic;
    signal RdPacketEnd      : std_logic_vector(Addr_c);
    signal RdPacketEndValid : std_logic;
    signal RamWrEna         : std_logic;
    signal FifoInValid      : std_logic;
    signal FifoOutRdy       : std_logic;
    signal WrAddrStdlv      : std_logic_vector(Addr_c);

begin

    assert log2(Depth_g) = log2ceil(Depth_g)
        report ""olo_base_fifo_packet: only power of two Depth_g is allowed""
        severity error;

    p_comb : process (In_Valid, In_Data, In_Last, In_Drop, Out_Ready, Out_Next, Out_Repeat, Rst, r,
                      FifoInReady, RdPacketEnd, RdPacketEndValid) is
        variable v          : TwoProcess_r;
        variable In_Ready_v : std_logic;
        variable InDrop_v   : std_logic;
        variable OutLast_v  : std_logic;
    begin
        v := r;


        In_Ready_v  := ((not r.Full) and FifoInReady) or r.DropLatch;
        InDrop_v    := r.DropLatch;
        RamWrEna    <= '0';
        FifoInValid <= '0';

        if r.WrAddr /= r.RdPacketStart then
            v.Full := '0';
        end if;

        if In_Drop = '1' and (r.WrPacketActive = '1' or In_Valid = '1') then
            v.DropLatch := '1';
        end if;

        if In_Valid = '1' and In_Ready_v = '1' then
            v.WrPacketActive := '1';

            if r.WrAddr = r.RdPacketStart-1 then
                v.Full := '1';
            end if;

            if r.WrAddr = Depth_g*2 - 1 then
                v.WrAddr := (others => '0');
            else
                v.WrAddr := r.WrAddr + 1;
            end if;

            if In_Drop = '1' then
                InDrop_v    := '1';
                v.DropLatch := '1';
            end if;

            if r.WrSize = Depth_g then
                v.DropLatch := '1';
            else
                v.WrSize := r.WrSize + 1;
            end if;

            if In_Last = '1' then
                if InDrop_v = '1' then
                    v.WrAddr := r.WrPacketStart;
                else
                    v.WrPacketStart := r.WrAddr + 1;
                    FifoInValid     <= '1';
                end if;
                v.DropLatch      := '0';
                v.WrSize         := to_unsigned(1, r.WrSize'length);
                v.WrPacketActive := '0';
            end if;

            RamWrEna <= '1';

        end if;

        if r.DropLatch = '1' then
            v.WrAddr := r.WrPacketStart;
            v.Full   := '0';
        end if;

        In_IsDropped <= InDrop_v;
        In_Ready     <= In_Ready_v;



        FifoOutRdy <= '0';
        OutLast_v  := '0';

        case r.RdFsm is
            when Fetch_s =>
                v.RdPacketStart := r.RdAddr;

                if r.RdRepeat = '1' then
                    if r.RdPacketEnd = r.RdPacketStart then
                        v.RdFsm := Last_s;
                    else
                        v.RdFsm := Data_s;
                    end if;
                    v.RdRepeat := '0';
                    v.RdAddr   := r.RdPacketStart;
                    v.RdValid  := '1';
                    v.RdPacketStart := r.RdPacketStart;

                elsif RdPacketEndValid = '1' then
                    FifoOutRdy <= '1';
                    v.RdRepeat := '0';
                    if unsigned(RdPacketEnd) = r.RdAddr then
                        v.RdFsm := Last_s;
                    else
                        v.RdFsm := Data_s;
                    end if;
                    v.RdPacketEnd := unsigned(RdPacketEnd);
                    v.RdValid     := '1';
                    v.RdSize      := unsigned(RdPacketEnd) - r.RdAddr + 1;

                end if;

            when Data_s =>
                if Out_Ready = '1' then
                    if v.RdAddr = Depth_g*2 - 1 then
                        v.RdAddr := (others => '0');
                    else
                        v.RdAddr := v.RdAddr + 1;
                    end if;

                    if r.RdAddr = r.RdPacketEnd - 1 then
                        v.RdFsm := Last_s;
                    end if;

                    if Out_Next = '1' or r.NextLatch = '1' then
                        OutLast_v := '1';
                        v.RdValid := '0';
                        v.RdFsm   := Fetch_s;
                        v.RdAddr  := r.RdPacketEnd + 1;
                    end if;

                end if;

            when Last_s =>
                OutLast_v := '1';

                if Out_Ready = '1' then
                    if v.RdAddr = Depth_g*2 - 1 then
                        v.RdAddr := (others => '0');
                    else
                        v.RdAddr := v.RdAddr + 1;
                    end if;


                    v.RdValid := '0';
                    v.RdFsm   := Fetch_s;
                end if;

            when others => null; -- unreacable code

        end case;

        RamRdAddr <= std_logic_vector(v.RdAddr);
        Out_Valid <= r.RdValid;
        Out_Last  <= OutLast_v;
        Out_Size  <= std_logic_vector(r.RdSize);

        if r.RdValid = '1' and Out_Ready = '1' and OutLast_v = '1' then
            v.NextLatch := '0';
        elsif r.RdValid = '1' and Out_Next = '1' then
            v.NextLatch := '1';
        end if;

        if In_Valid = '1' and In_Ready_v = '1' and In_Last = '1' and InDrop_v = '0' then
            v.PacketLevel := r.PacketLevel + 1;
        end if;
        if r.RdValid = '1' and Out_Ready = '1' and OutLast_v = '1' and r.RdRepeat = '0' and Out_Repeat = '0' then
            v.PacketLevel := v.PacketLevel - 1;
        end if;
        PacketLevel <= std_logic_vector(r.PacketLevel);

        FreeWords <= std_logic_vector(r.RdPacketStart(FreeWords'range) - r.WrAddr(FreeWords'range));

        if Out_Repeat = '1' and r.RdValid = '1' then
            v.RdRepeat := '1';
        end if;

        r_next <= v;

    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.WrAddr         <= to_unsigned(Depth_g, r.WrAddr'length);
                r.WrPacketStart  <= to_unsigned(Depth_g, r.WrPacketStart'length);
                r.WrSize         <= to_unsigned(1, r.WrSize'length);
                r.WrPacketActive <= '0';
                r.DropLatch      <= '0';
                r.Full           <= '0';
                r.RdAddr         <= (others => '0');
                r.RdPacketStart  <= (others => '0');
                r.RdFsm          <= Fetch_s;
                r.RdRepeat       <= '0';
                r.RdValid        <= '0';
                r.NextLatch      <= '0';
                r.PacketLevel    <= (others => '0');
            end if;
        end if;
    end process;


    WrAddrStdlv(AddrApp_c)        <= std_logic_vector(r.WrAddr(AddrApp_c));
    WrAddrStdlv(WrAddrStdlv'high) <= not r.WrAddr(r.WrAddr'high);

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk     => Clk,
            Wr_Addr => WrAddrStdlv(AddrApp_c), -- Additional bit for full/empty differentiation is stripped
            Wr_Ena  => RamWrEna,
            Wr_Data => In_Data,
            Rd_Addr => RamRdAddr(AddrApp_c),   -- Additional bit for full/empty differentiation is stripped
            Rd_Data => Out_Data
        );

    i_pktend_fifo : entity work.olo_base_fifo_sync
        generic map (
            Width_g         => log2ceil(Depth_g)+1,
            Depth_g         => MaxPackets_g-1,     -- One packet is currently read out (not in the FIFO anymore)
            RamStyle_g      => SmallRamStyle_c,
            RamBehavior_g   => SmallRamBehavior_c,
            ReadyRstState_g => '0'
        )
        port map (
            Clk           => Clk,
            Rst           => Rst,
            In_Data       => WrAddrStdlv,
            In_Valid      => FifoInValid,
            In_Ready      => FifoInReady,
            Out_Data      => RdPacketEnd,
            Out_Valid     => RdPacketEndValid,
            Out_Ready     => FifoOutRdy
        );

end architecture;",24
"This component implements a synchronous FIFO (same clock for write and read port). The memory is described in a way that it utilizes RAM resources (Block-RAM or distributed RAM) available in FPGAs with commonly used tools. For this purpose [olo_base_ram_sdp](./olo_base_ram_sdp.md) is used. The FIFO is a fall-through FIFO and has AXI-S interfaces on read and write side. The RAM behavior (read-before-write or write-before-read) can be selected. This allows efficiently implementing FIFOs for different technologies (some technologies implement one, some the other behavior).

# VHDL Analysis for 'olo_base_fifo_sync.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic synchronous FIFO. It  has optional level- and
- Plus 26 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_fifo_sync

## Architecture: rtl of olo_base_fifo_sync

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- RamWr: std_logic
- RamRdAddr: std_logic_vector(log2ceil(Depth_g) - 1 downto 0)
- r_next <= v;

    end process;

    -- Synchronous Outputs
    Out_Level <= r.RdLevel;
    In_Level  <= r.WrLevel;

    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Component Instantiations
- Instance 'i_ram' of component 'olo_base_ram_sdp'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: In_Valid, Out_Ready, Rst, r
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Write side
        v.RdUp := '0'
- RamWr  <= '0'
- if unsigned(r.WrLevel) /= Depth_g and In_Valid = '1' then
            if unsigned(r.WrAddr) /= Depth_g - 1 then
                v.WrAddr := std_logic_vector(unsigned(r.WrAddr) + 1)
- else
                v.WrAddr := (others => '0')

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst, reset, ReadyRstState_g
- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 204
- Process count: 4
- Signal count: 5

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_fifo_sync.vhd' plays a specific role in the overall CPU architecture.
","**Component Description:**
The `olo_base_fifo_sync` component is a synchronous First-In-First-Out (FIFO) buffer that provides a flexible and configurable data storage and retrieval mechanism. It accepts input data and validity signals, and produces output data and validity signals, while also providing flags for full, almost full, empty, and almost empty conditions.

**Component Specification:**

### Overview

* **Component Name:** `olo_base_fifo_sync`
* **Functionality:** Synchronous FIFO buffer with configurable width, depth, and behavior
* **Inputs:**
	+ `Clk`: Clock signal
	+ `Rst`: Reset signal
	+ `In_Data`: Input data (Width_g bits)
	+ `In_Valid`: Input data validity signal (default: '1')
	+ `Out_Ready`: Output data readiness signal (default: '1')
* **Outputs:**
	+ `Out_Data`: Output data (Width_g bits)
	+ `Out_Valid`: Output data validity signal
	+ `In_Ready`: Input data readiness signal
	+ `In_Level`: Current input level (log2ceil(Depth_g +1) bits)
	+ `Out_Level`: Current output level (log2ceil(Depth_g +1) bits)
	+ `Full`: FIFO full flag
	+ `AlmFull`: Almost full flag (configurable)
	+ `Empty`: FIFO empty flag
	+ `AlmEmpty`: Almost empty flag (configurable","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_fifo_sync is
    generic (
        Width_g         : positive;
        Depth_g         : positive;
        AlmFullOn_g     : boolean   := false;
        AlmFullLevel_g  : natural   := 0;
        AlmEmptyOn_g    : boolean   := false;
        AlmEmptyLevel_g : natural   := 0;
        RamStyle_g      : string    := ""auto"";
        RamBehavior_g   : string    := ""RBW"";
        ReadyRstState_g : std_logic := '1'
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        In_Data       : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid      : in    std_logic := '1';
        In_Ready      : out   std_logic;
        In_Level      : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Out_Data      : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid     : out   std_logic;
        Out_Ready     : in    std_logic := '1';
        Out_Level     : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Full          : out   std_logic;
        AlmFull       : out   std_logic;
        Empty         : out   std_logic;
        AlmEmpty      : out   std_logic
    );
end entity;

architecture rtl of olo_base_fifo_sync is

    type TwoProcess_r is record
        WrLevel : std_logic_vector(In_Level'range);
        RdLevel : std_logic_vector(Out_Level'range);
        RdUp    : std_logic;
        WrDown  : std_logic;
        WrAddr  : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        RdAddr  : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

    signal RamWr     : std_logic;
    signal RamRdAddr : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);

begin

    p_comb : process (In_Valid, Out_Ready, Rst, r) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.RdUp := '0';
        RamWr  <= '0';
        if unsigned(r.WrLevel) /= Depth_g and In_Valid = '1' then
            if unsigned(r.WrAddr) /= Depth_g - 1 then
                v.WrAddr := std_logic_vector(unsigned(r.WrAddr) + 1);
            else
                v.WrAddr := (others => '0');
            end if;
            RamWr  <= '1';
            v.RdUp := '1';
            if r.WrDown = '0' then
                v.WrLevel := std_logic_vector(unsigned(r.WrLevel) + 1);
            end if;
        elsif r.WrDown = '1' then
            v.WrLevel := std_logic_vector(unsigned(r.WrLevel) - 1);
        end if;

        if unsigned(r.WrLevel) = Depth_g then
            In_Ready <= '0';
            Full     <= '1';
        else
            In_Ready <= '1';
            Full     <= '0';
        end if;
        if (ReadyRstState_g = '0') and (Rst = '1') then
            In_Ready <= '0';
        end if;

        if AlmFullOn_g and unsigned(r.WrLevel) >= AlmFullLevel_g then
            AlmFull <= '1';
        else
            AlmFull <= '0';
        end if;

        v.WrDown := '0';
        if unsigned(r.RdLevel) /= 0 and Out_Ready = '1' then
            if unsigned(r.RdAddr) /= Depth_g - 1 then
                v.RdAddr := std_logic_vector(unsigned(r.RdAddr) + 1);
            else
                v.RdAddr := (others => '0');
            end if;
            v.WrDown := '1';
            if r.RdUp = '0' then
                v.RdLevel := std_logic_vector(unsigned(r.RdLevel) - 1);
            end if;
        elsif r.RdUp = '1' then
            v.RdLevel := std_logic_vector(unsigned(r.RdLevel) + 1);
        end if;
        RamRdAddr <= v.RdAddr;

        if unsigned(r.RdLevel) > 0 then
            Out_Valid <= '1';
            Empty     <= '0';
        else
            Out_Valid <= '0';
            Empty     <= '1';
        end if;

        if AlmEmptyOn_g and unsigned(r.RdLevel) <= AlmEmptyLevel_g then
            AlmEmpty <= '1';
        else
            AlmEmpty <= '0';
        end if;

        r_next <= v;

    end process;

    Out_Level <= r.RdLevel;
    In_Level  <= r.WrLevel;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.WrLevel <= (others => '0');
                r.RdLevel <= (others => '0');
                r.RdUp    <= '0';
                r.WrDown  <= '0';
                r.WrAddr  <= (others => '0');
                r.RdAddr  <= (others => '0');
            end if;
        end if;
    end process;

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk         => Clk,
            Wr_Addr     => r.WrAddr,
            Wr_Ena      => RamWr,
            Wr_Data     => In_Data,
            Rd_Addr     => RamRdAddr,
            Rd_Data     => Out_Data
        );

end architecture;",25
"This component implements full flow-control (including Ready/back-pressure) around processing entities that do not support Ready/back-pressure natively. The usage is depicted below: The _olo_base_flowctrl_handler_ includes a small FIFO buffer and ensures to de-assert _In_Ready_ in a way that remaining output samples from processing can be absorbed without data-loss when _Out_Ready_ is de-asserted. The FIFO buffer is chosen large enough to provide full throughput (i.e. not add any needless stall-cycles). For processing entities that do not even provide the handling of the _Valid_ flag, the _Valid_ flag handling can easily be implemented by adding an [olo_base_delay](*./olo_base_delay.md) component with the same delay as the processingitself:

# VHDL Analysis for 'olo_base_flowctrl_handler.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Implements full flow-control handling (including Ready/backpressure) for
- processing entities that do not support flow-control natively.
- Plus 24 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: olo_base_flowctrl_handler

## Architecture: rtl of olo_base_flowctrl_handler

### Signals
- Fifo_InReady: std_logic
- Fifo_HalfEmpty: std_logic

### Component Instantiations
- Instance 'i_fifo' of component 'olo_base_fifo_sync'

### Processes
- Process 'p_assert :' (Clocked) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_assert :' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst
- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 110
- Process count: 2
- Signal count: 2

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_flowctrl_handler.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_flowctrl_handler` component is a flow control handler that manages data transfer between two processing stages. It acts as a bridge between the input and output data streams, providing buffering and flow control to ensure smooth data processing. The component absorbs a specified number of samples to handle temporary backpressure from the processing stage.

**Inputs and Outputs**

* **Inputs:**
	+ `Clk`: Clock signal
	+ `Rst`: Reset signal
	+ `In_Data`: Input data stream (width: `InWidth_g` bits)
	+ `In_Valid`: Input data validity signal (default: '1')
	+ `Out_Ready`: Output data readiness signal (default: '1')
	+ `FromProc_Data`: Processed data stream (width: `OutWidth_g` bits)
	+ `FromProc_Valid`: Processed data validity signal
* **Outputs:**
	+ `In_Ready`: Input data readiness signal
	+ `Out_Data`: Output data stream (width: `OutWidth_g` bits)
	+ `Out_Valid`: Output data validity signal
	+ `ToProc_Data`: Data stream to processing stage (width: `InWidth_g` bits)
	+ `ToProc_Valid`: Data validity signal to processing stage

**Component Parameters**

* **Generics:**
	+ `InWidth_g`: Input data width (positive integer)
	+ `OutWidth_g`: Output data width","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_flowctrl_handler is
    generic (
        InWidth_g           : positive;
        OutWidth_g          : positive;
        SamplesToAbsorb_g   : positive;
        RamStyle_g          : string := ""auto"";
        RamBehavior_g       : string := ""RBW""
    );
    port (
        Clk            : in    std_logic;
        Rst            : in    std_logic;
        In_Data        : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Valid       : in    std_logic := '1';
        In_Ready       : out   std_logic;
        Out_Data       : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Valid      : out   std_logic;
        Out_Ready      : in    std_logic := '1';
        ToProc_Data    : out   std_logic_vector(InWidth_g - 1 downto 0);
        ToProc_Valid   : out   std_logic;
        FromProc_Data  : in    std_logic_vector(OutWidth_g - 1 downto 0);
        FromProc_Valid : in    std_logic
    );
end entity;

architecture rtl of olo_base_flowctrl_handler is

    constant FifoDepth_c  : positive := 2*(SamplesToAbsorb_g+2);
    signal Fifo_InReady   : std_logic;
    signal Fifo_HalfEmpty : std_logic;

begin

    In_Ready     <= Fifo_HalfEmpty;
    ToProc_Data  <= In_Data;
    ToProc_Valid <= In_Valid and Fifo_HalfEmpty; -- Only forward data when FIFO is guaranteed to accept result

    i_fifo : entity work.olo_base_fifo_sync
        generic map (
            Width_g         => OutWidth_g,
            Depth_g         => FifoDepth_c,
            AlmEmptyOn_g    => true,
            AlmEmptyLevel_g => FifoDepth_c/2,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk           => Clk,
            Rst           => Rst,
            In_Data       => FromProc_Data,
            In_Valid      => FromProc_Valid,
            In_Ready      => Fifo_InReady,
            Out_Data      => Out_Data,
            Out_Valid     => Out_Valid,
            Out_Ready     => Out_Ready,
            AlmEmpty      => Fifo_HalfEmpty

        );

    p_assert : process (Clk) is
    begin
        if rising_edge(Clk) then
            assert (Fifo_InReady = '1' or FromProc_Valid /= '1')
                report ""olo_base_flowctrl_handler: FIFO is full upon FromProc_Valid = '1'""
                severity error;
        end if;
    end process;

end architecture;",26
"This package contains different array types which are used in _Open Logic_ internally but also on its interfaces to the user (e.g. for generics). The package is written mainly for these purposes and does not aim for completeness - nevertheless as a user you are free to use it for your code of course.

# VHDL Analysis for 'olo_base_pkg_array.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Waldemar Koprek, Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing commonly used array types
- Plus 16 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all

## Functional Analysis

- Defines custom functions: arrayInteger2Real, arrayStdl2Bool, arrayBool2Stdl, arrayInteger2Real, arrayStdl2Bool, arrayBool2Stdl

## Code Metrics
- Line count: 120
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_array.vhd' plays a specific role in the overall CPU architecture.
","**Component Functionality Description**

The provided VHDL code defines a package named `olo_base_pkg_array` that provides various array types and functions for converting between integer, real, boolean, and standard logic vector data types. The package enables the creation of arrays with varying element types and sizes, facilitating data manipulation and type conversions in digital design.

**Inputs and Outputs**

The package does not describe a specific component with inputs and outputs. Instead, it provides a set of reusable types and functions that can be utilized in various digital design components.

**Purpose**

The primary purpose of this package is to offer a collection of commonly used array types and type conversion functions, making it easier to work with different data types in VHDL designs. The provided functions enable conversions between:

* Integer arrays and real arrays
* Standard logic vectors and boolean arrays

**Detailed Component Specification**

Based on the provided VHDL code, the following detailed component specification can be derived:

### Array Types

The package defines the following array types:

* `StlvArray2_t` to `StlvArray32_t`: Arrays of standard logic vectors with varying widths (2 to 32 bits)
* `StlvArray36_t`, `StlvArray48_t`, `StlvArray64_t`, and `StlvArray512_t`: Arrays of standard logic vectors with specific widths (36, 48, 64, and 512 bits)
* `IntegerArray_t`: Arrays of integers
* `RealArray_t`: Arrays of real","
library ieee;
    use ieee.std_logic_1164.all;

package olo_base_pkg_array is

    type StlvArray2_t   is array (natural range <>) of std_logic_vector( 1 downto 0);
    type StlvArray3_t   is array (natural range <>) of std_logic_vector( 2 downto 0);
    type StlvArray4_t   is array (natural range <>) of std_logic_vector( 3 downto 0);
    type StlvArray5_t   is array (natural range <>) of std_logic_vector( 4 downto 0);
    type StlvArray6_t   is array (natural range <>) of std_logic_vector( 5 downto 0);
    type StlvArray7_t   is array (natural range <>) of std_logic_vector( 6 downto 0);
    type StlvArray8_t   is array (natural range <>) of std_logic_vector( 7 downto 0);
    type StlvArray9_t   is array (natural range <>) of std_logic_vector( 8 downto 0);
    type StlvArray10_t  is array (natural range <>) of std_logic_vector( 9 downto 0);
    type StlvArray11_t  is array (natural range <>) of std_logic_vector(10 downto 0);
    type StlvArray12_t  is array (natural range <>) of std_logic_vector(11 downto 0);
    type StlvArray13_t  is array (natural range <>) of std_logic_vector(12 downto 0);
    type StlvArray14_t  is array (natural range <>) of std_logic_vector(13 downto 0);
    type StlvArray15_t  is array (natural range <>) of std_logic_vector(14 downto 0);
    type StlvArray16_t  is array (natural range <>) of std_logic_vector(15 downto 0);
    type StlvArray17_t  is array (natural range <>) of std_logic_vector(16 downto 0);
    type StlvArray18_t  is array (natural range <>) of std_logic_vector(17 downto 0);
    type StlvArray19_t  is array (natural range <>) of std_logic_vector(18 downto 0);
    type StlvArray20_t  is array (natural range <>) of std_logic_vector(19 downto 0);
    type StlvArray21_t  is array (natural range <>) of std_logic_vector(20 downto 0);
    type StlvArray22_t  is array (natural range <>) of std_logic_vector(21 downto 0);
    type StlvArray23_t  is array (natural range <>) of std_logic_vector(22 downto 0);
    type StlvArray24_t  is array (natural range <>) of std_logic_vector(23 downto 0);
    type StlvArray25_t  is array (natural range <>) of std_logic_vector(24 downto 0);
    type StlvArray26_t  is array (natural range <>) of std_logic_vector(25 downto 0);
    type StlvArray27_t  is array (natural range <>) of std_logic_vector(26 downto 0);
    type StlvArray28_t  is array (natural range <>) of std_logic_vector(27 downto 0);
    type StlvArray29_t  is array (natural range <>) of std_logic_vector(28 downto 0);
    type StlvArray30_t  is array (natural range <>) of std_logic_vector(29 downto 0);
    type StlvArray32_t  is array (natural range <>) of std_logic_vector(31 downto 0);
    type StlvArray36_t  is array (natural range <>) of std_logic_vector(35 downto 0);
    type StlvArray48_t  is array (natural range <>) of std_logic_vector(47 downto 0);
    type StlvArray64_t  is array (natural range <>) of std_logic_vector(63 downto 0);
    type StlvArray512_t is array (natural range <>) of std_logic_vector(511 downto 0);

    type IntegerArray_t is array (natural range <>) of integer;
    type RealArray_t is array (natural range <>) of real;
    type BoolArray_t is array (natural range <>) of boolean;

    function arrayInteger2Real (a : in IntegerArray_t) return RealArray_t;
    function arrayStdl2Bool (a : in std_logic_vector) return BoolArray_t;
    function arrayBool2Stdl (a : in BoolArray_t) return std_logic_vector;

end package;

package body olo_base_pkg_array is

    function arrayInteger2Real (a : in IntegerArray_t) return RealArray_t is
        variable Array_v : RealArray_t(a'range);
    begin

        for i in a'low to a'high loop
            Array_v(i) := real(a(i));
        end loop;

        return Array_v;
    end function;

    function arrayStdl2Bool (a : in std_logic_vector) return BoolArray_t is
        variable Array_v : BoolArray_t(a'range);
    begin

        for i in a'low to a'high loop
            Array_v(i) := (a(i) = '1');
        end loop;

        return Array_v;
    end function;

    function arrayBool2Stdl (a : in BoolArray_t) return std_logic_vector is
        variable Array_v : std_logic_vector(a'range);
    begin

        for i in a'low to a'high loop
            if a(i) then
                Array_v(i) := '1';
            else
                Array_v(i) := '0';
            end if;
        end loop;

        return Array_v;
    end function;

end package body;",27
"This package contains synthesis attributes for various vendors. The usage is non-straightforward because different attributes must be added due to restrictions of VHDL. Also does the package only contain attributes used in Open Logic internally. As a result, **this package is meant for internal use** mainly and it is **undocumented**. Users are still free to use the package but no support will be given. If you decide to do so, orient yourself on code samples (e.g. in [olo_base_cc_bits](./olo_base_cc_bits.md) or [olo_base_ram_sdp](./olo_base_ram_sdp.md)) and on the comments within the source code of the package. Currently only one version of the package is provided. In case of unresolvable name clashes between attributes expected by different tools, the package might be provided in different versions for different tools in future.

# VHDL Analysis for 'olo_base_pkg_attribute.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler, Benoit Stef
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing attribute definitions that work for all target vendors. The package is meant
- for Open Logic internal use and hence not deocumented in detail.
- Plus 58 more comments

## Libraries and Packages
- Library: ieee
- Use: and hence not deocumented in detail.
--
-- Documentation:
-- https://github.com/open-logic/open-logic/blob/main/doc/base/olo_base_pkg_attribute.md
--
-- Note: The link points to the documentation of the latest release. If you
--       use an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: LUT as shift register

    -- Tools:
    -- - Efinity (Efinix)
    -- - GowinEDA (Gowin)
    attribute syn_srlstyle : string
- Use: Gowin only accepts integer.
    attribute syn_keep : integer
- Use: Gowin only accepts integer.
    attribute syn_preserve : integer

## Functional Analysis

- Implements memory functionality
- Implements control logic

## Code Metrics
- Line count: 126
- Process count: N/A
- Signal count: N/A

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_attribute.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

This VHDL package, `olo_base_pkg_attribute`, defines a set of attributes and constants for controlling the synthesis and optimization of digital circuits. It provides a collection of attributes that can be used to guide the synthesis tool in its optimization decisions, such as extraction, inference, and preservation of specific circuit structures. The package does not describe a specific digital component, but rather provides a set of attributes that can be used to customize the synthesis of components.

**Detailed Component Specification**

* **Purpose:** Provide a set of attributes and constants for controlling the synthesis and optimization of digital circuits.
* **Inputs:** None (this is a package, not a component with inputs).
* **Outputs:** None (this is a package, not a component with outputs).
* **Attributes:**
	+ `shreg_extract`: controls the extraction of shift registers.
	+ `srl_style`: controls the style of shift register implementation (e.g., using flip-flops or LUTs).
	+ `syn_srlstyle`: controls the synthesis style for shift registers.
	+ `async_reg`: controls the treatment of asynchronous registers.
	+ `dont_merge`, `preserve`, `syn_keep`, `syn_preserve`, `dont_touch`, and `keep`: control the optimization and preservation of specific circuit structures.
	+ `ram_style`, `ramstyle`, and `syn_ramstyle`: control the implementation style for RAM structures.
* **Constants:**
	+ `ShregExtract_SuppressExtraction","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

package olo_base_pkg_attribute is


    attribute shreg_extract : string;
    constant ShregExtract_SuppressExtraction_c : string := ""no"";
    constant ShregExtract_AllowExtraction_c    : string := ""yes"";


    attribute srl_style : string;
    constant SrlStyle_FlipFlops_c : string := ""registers"";
    constant SrlStyle_Srl_c       : string := ""srl""; -- Use LUT as shift register

    attribute syn_srlstyle : string;
    constant SynSrlstyle_FlipFlops_c : string := ""registers"";


    attribute async_reg : boolean;
    constant AsyncReg_TreatAsync_c : boolean := true;


    attribute dont_merge : boolean;
    constant DontMerge_SuppressChanges_c : boolean := true;

    attribute preserve : boolean;
    constant Preserve_SuppressChanges_c : boolean := true;

    attribute syn_keep : integer;
    constant SynKeep_SuppressChanges_c : integer := 1;

    attribute syn_preserve : integer;
    constant SynPreserve_SuppressChanges_c : integer := 1;

    attribute dont_touch : boolean;
    constant DontTouch_SuppressChanges_c : boolean := true;

    attribute keep : string;
    constant Keep_SuppressChanges_c : string := ""yes"";


    attribute ram_style : string;

    attribute ramstyle : string;

    attribute syn_ramstyle : string;

end package;

package body olo_base_pkg_attribute is

end package body;",28
"This package contains different logic functions not defined in IEEE packages but used by _Open Logic_ internally or on its interfaces to the user (e.g. for port-widths depending on generics). The package is written mainly for these purposes and does not aim for completeness - nevertheless as a user you are free to use it for your code of course.

# VHDL Analysis for 'olo_base_pkg_logic.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing logic functions.
- Plus 41 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Functional Analysis

- May be part of a pipeline architecture
- Defines custom functions: zerosVector, onesVector, shiftLeft, shiftRight, binaryToGray, grayToBinary, ppcOr, to01X, to01X, to01, to01, invertBitOrder, invertByteOrder, zerosVector, onesVector, shiftLeft, shiftRight, binaryToGray, grayToBinary, ppcOr, to01X, to01X, to01, to01, invertBitOrder, invertByteOrder

## Code Metrics
- Line count: 302
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_logic.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Logic Utilities Package**

**Overview**

The Logic Utilities Package is a collection of reusable functions for performing various logical operations on binary data. This package provides a set of utility functions for bit-level manipulation, conversion, and transformation.

**Functionality**

The package consists of the following functions:

1. **Vector Generation**
	* `zerosVector(size)`: Returns a std_logic_vector of 'size' bits, all initialized to '0'.
	* `onesVector(size)`: Returns a std_logic_vector of 'size' bits, all initialized to '1'.
2. **Shifting and Rotation**
	* `shiftLeft(arg, bits, fill)`: Shifts the input vector 'arg' to the left by 'bits' positions, filling the vacant positions with 'fill' (default='0').
	* `shiftRight(arg, bits, fill)`: Shifts the input vector 'arg' to the right by 'bits' positions, filling the vacant positions with 'fill' (default='0').
3. **Binary-to-Gray and Gray-to-Binary Conversion**
	* `binaryToGray(binary)`: Converts a binary vector to a Gray-coded vector.
	* `grayToBinary(gray)`: Converts a Gray-coded vector to a binary vector.
4. **Parallel Prefix OR (PPC OR)**
	* `ppcOr(inp)`: Performs a parallel prefix OR operation on the input vector 'inp'.
5. **Input Value Conversion**","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

package olo_base_pkg_logic is

    function zerosVector (size : in natural) return std_logic_vector;

    function onesVector (size : in natural) return std_logic_vector;

    function shiftLeft (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector;

    function shiftRight (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector;

    function binaryToGray (binary : in std_logic_vector) return std_logic_vector;

    function grayToBinary (gray : in std_logic_vector) return std_logic_vector;

    function ppcOr (inp : in std_logic_vector) return std_logic_vector;

    function to01X (inp : in std_logic) return std_logic;

    function to01X (inp : in std_logic_vector) return std_logic_vector;

    function to01 (inp : in std_logic) return std_logic;

    function to01 (inp : in std_logic_vector) return std_logic_vector;

    function invertBitOrder (inp : in std_logic_vector) return std_logic_vector;

    function invertByteOrder (inp : in std_logic_vector) return std_logic_vector;

    constant Polynomial_Prbs2_c  : std_logic_vector( 1 downto 0) := ""11"";
    constant Polynomial_Prbs3_c  : std_logic_vector( 2 downto 0) := ""110"";
    constant Polynomial_Prbs4_c  : std_logic_vector( 3 downto 0) := ""1100"";
    constant Polynomial_Prbs5_c  : std_logic_vector( 4 downto 0) := ""10100"";
    constant Polynomial_Prbs6_c  : std_logic_vector( 5 downto 0) := ""110000"";
    constant Polynomial_Prbs7_c  : std_logic_vector( 6 downto 0) := ""1100000"";
    constant Polynomial_Prbs8_c  : std_logic_vector( 7 downto 0) := ""10111000"";
    constant Polynomial_Prbs9_c  : std_logic_vector( 8 downto 0) := ""100010000"";
    constant Polynomial_Prbs10_c : std_logic_vector( 9 downto 0) := ""1001000000"";
    constant Polynomial_Prbs11_c : std_logic_vector(10 downto 0) := ""10100000000"";
    constant Polynomial_Prbs12_c : std_logic_vector(11 downto 0) := ""100000101001"";
    constant Polynomial_Prbs13_c : std_logic_vector(12 downto 0) := ""1000000001101"";
    constant Polynomial_Prbs14_c : std_logic_vector(13 downto 0) := ""10000000010101"";
    constant Polynomial_Prbs15_c : std_logic_vector(14 downto 0) := ""110000000000000"";
    constant Polynomial_Prbs16_c : std_logic_vector(15 downto 0) := ""1101000000001000"";
    constant Polynomial_Prbs17_c : std_logic_vector(16 downto 0) := ""10010000000000000"";
    constant Polynomial_Prbs18_c : std_logic_vector(17 downto 0) := ""100000010000000000"";
    constant Polynomial_Prbs19_c : std_logic_vector(18 downto 0) := ""1000000000000100011"";
    constant Polynomial_Prbs20_c : std_logic_vector(19 downto 0) := ""10010000000000000000"";
    constant Polynomial_Prbs21_c : std_logic_vector(20 downto 0) := ""101000000000000000000"";
    constant Polynomial_Prbs22_c : std_logic_vector(21 downto 0) := ""1100000000000000000000"";
    constant Polynomial_Prbs23_c : std_logic_vector(22 downto 0) := ""10000100000000000000000"";
    constant Polynomial_Prbs24_c : std_logic_vector(23 downto 0) := ""111000010000000000000000"";
    constant Polynomial_Prbs25_c : std_logic_vector(24 downto 0) := ""1001000000000000000000000"";
    constant Polynomial_Prbs26_c : std_logic_vector(25 downto 0) := ""10000000000000000000100011"";
    constant Polynomial_Prbs27_c : std_logic_vector(26 downto 0) := ""100000000000000000000010011"";
    constant Polynomial_Prbs28_c : std_logic_vector(27 downto 0) := ""1001000000000000000000000000"";
    constant Polynomial_Prbs29_c : std_logic_vector(28 downto 0) := ""10100000000000000000000000000"";
    constant Polynomial_Prbs30_c : std_logic_vector(29 downto 0) := ""100000000000000000000000101001"";
    constant Polynomial_Prbs31_c : std_logic_vector(30 downto 0) := ""1001000000000000000000000000000"";
    constant Polynomial_Prbs32_c : std_logic_vector(31 downto 0) := ""10000000001000000000000000000011"";

end package;

package body olo_base_pkg_logic is

    function zerosVector (size : in natural) return std_logic_vector is
        constant Vector_c : std_logic_vector(size - 1 downto 0) := (others => '0');
    begin
        return Vector_c;
    end function;

    function onesVector (size : in natural) return std_logic_vector is
        constant Vector_c : std_logic_vector(size - 1 downto 0) := (others => '1');
    begin
        return Vector_c;
    end function;

    function shiftLeft (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector is
        constant ArgDownto_c : std_logic_vector(arg'high downto arg'low) := arg;
        variable Vector_v    : std_logic_vector(ArgDownto_c'range);
    begin
        if bits < 0 then
            return shiftRight(ArgDownto_c, -bits, fill);
        else
            Vector_v(Vector_v'left downto bits)      := ArgDownto_c(ArgDownto_c'left - bits downto ArgDownto_c'right);
            Vector_v(bits - 1 downto Vector_v'right) := (others => fill);
            return Vector_v;
        end if;
    end function;

    function shiftRight (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector is
        constant ArgDownto_c : std_logic_vector(arg'high downto arg'low) := arg;
        variable Vector_v    : std_logic_vector(ArgDownto_c'range);
    begin
        if bits < 0 then
            return shiftLeft(ArgDownto_c, -bits, fill);
        else
            Vector_v(Vector_v'left - bits downto Vector_v'right)    := ArgDownto_c(ArgDownto_c'left downto bits);
            Vector_v(Vector_v'left downto Vector_v'left - bits + 1) := (others => fill);
            return Vector_v;
        end if;
    end function;

    function binaryToGray (binary : in std_logic_vector) return std_logic_vector is
        variable Gray_v : std_logic_vector(binary'range);
    begin
        Gray_v := binary xor ('0' & binary(binary'high downto binary'low + 1));
        return Gray_v;
    end function;

    function grayToBinary (gray : in std_logic_vector) return std_logic_vector is
        variable Binary_v : std_logic_vector(gray'range);
    begin
        Binary_v(Binary_v'high) := gray(gray'high);

        for b in gray'high - 1 downto gray'low loop
            Binary_v(b) := gray(b) xor Binary_v(b + 1);
        end loop;

        return Binary_v;
    end function;

    function ppcOr (inp : in std_logic_vector) return std_logic_vector is
        constant Stages_c    : integer := log2ceil(inp'length);
        constant Pwr2Width_c : integer := 2**Stages_c;

        type StageOut_t is array (natural range <>) of std_logic_vector(Pwr2Width_c - 1 downto 0);

        variable StageOut_v : StageOut_t(0 to Stages_c);
        variable BinCnt_v   : unsigned(Pwr2Width_c - 1 downto 0);
    begin
        StageOut_v(0)                          := (others => '0');
        StageOut_v(0)(inp'length - 1 downto 0) := inp;

        for stage in 0 to Stages_c - 1 loop
            BinCnt_v := (others => '0');

            for idx in 0 to Pwr2Width_c - 1 loop
                if BinCnt_v(stage) = '0' then
                    StageOut_v(stage + 1)(idx) := StageOut_v(stage)(idx) or StageOut_v(stage)((idx / (2**stage) + 1) * 2**stage);
                else
                    StageOut_v(stage + 1)(idx) := StageOut_v(stage)(idx);
                end if;
                BinCnt_v := BinCnt_v + 1;
            end loop;

        end loop;

        return StageOut_v(Stages_c)(inp'length - 1 downto 0);
    end function;

    function to01X (inp : in std_logic) return std_logic is
    begin

        case inp is
            when '0' | 'L' => return '0';
            when '1' | 'H' => return '1';
            when others => return 'X';
        end case;

    end function;

    function to01X (inp : in std_logic_vector) return std_logic_vector is
        variable Result_v : std_logic_vector(inp'range);
    begin

        for i in inp'low to inp'high loop
            Result_v(i) := to01X(inp(i));
        end loop;

        return Result_v;
    end function;

    function to01 (inp : in std_logic) return std_logic is
    begin

        case inp is
            when '0' | 'L' => return '0';
            when '1' | 'H' => return '1';
            when others => return '0';
        end case;

    end function;

    function to01 (inp : in std_logic_vector) return std_logic_vector is
        variable Result_v : std_logic_vector(inp'range);
    begin

        for i in inp'low to inp'high loop
            Result_v(i) := to01(inp(i));
        end loop;

        return Result_v;
    end function;

    function invertBitOrder (inp : in std_logic_vector) return std_logic_vector is
        variable Inp_v    : std_logic_vector(inp'length-1 downto 0);
        variable Result_v : std_logic_vector(Inp_v'range);
    begin
        Inp_v := inp;

        for i in 0 to Inp_v'high loop
            Result_v(Result_v'high - i) := Inp_v(i);
        end loop;

        return Result_v;
    end function;

    function invertByteOrder (inp : in std_logic_vector) return std_logic_vector is
        constant Inp_c    : std_logic_vector(inp'length-1 downto 0) := inp;
        constant Bytes_c  : natural                                 := inp'length/8;
        variable Result_v : std_logic_vector(Inp_c'range);
        variable InByte_v : natural;
    begin

        assert inp'length mod 8 = 0
            report ""invertByteOrder(): Number of bits must be a multiple of 8""
            severity error;

        for byte in 0 to Bytes_c-1 loop
            InByte_v                         := Bytes_c - 1 - byte;
            Result_v(byte*8+7 downto byte*8) := Inp_c(InByte_v*8+7 downto InByte_v*8);
        end loop;

        return Result_v;
    end function;

end package body;",29
"This package contains different mathematics functions not defined in IEEE packages but used by _Open Logic_ internally or on its interfaces to the user (e.g. for port-widths depending on generics). The package is written mainly for these purposes and does not aim for completeness - nevertheless as a user you are free to use it for your code of course. The package uses array-types (e.g. t_abool or t_areal) defined in [olo_base_pkg_array](./olo_base_pkg_array.md).

# VHDL Analysis for 'olo_base_pkg_math.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler, Benoit Stef
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing mathematchis functions
- Plus 78 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_array.all

## Functional Analysis

- Defines custom functions: log2, log2ceil, isPower2, greatestCommonFactor, leastCommonMultiple, max, min, max, min, choose, choose, choose, choose, choose, choose, choose, choose, count, count, count, int, toUslv, toSslv, toStdl, slv, fromUslv, fromSslv, fromStdl, fromString, fromString, maxArray, maxArray, minArray, minArray, countCommaSepElems, log2, log2ceil, isPower2, greatestCommonFactor, leastCommonMultiple, max, max, min, min, choose, choose, choose, choose, choose, choose, choose, choose, count, count, count, toUslv, toSslv, toStdl, fromUslv, fromSslv, fromStdl, fromString, fromString, maxArray, maxArray, minArray, minArray

## Code Metrics
- Line count: 660
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_math.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Mathematical Utilities Package**

**Overview**

The `olo_base_pkg_math` package provides a collection of mathematical utility functions for use in digital design and verification. This package offers a range of functions for performing common mathematical operations, type conversions, and array manipulations.

**Functionality**

The package provides the following functionality:

* Mathematical operations:
	+ Logarithmic calculations (`log2`, `log2ceil`)
	+ Greatest common factor and least common multiple calculations (`greatestCommonFactor`, `leastCommonMultiple`)
	+ Maximum and minimum value calculations (`max`, `min`)
* Type conversions:
	+ Conversions between integers, real numbers, and standard logic vectors (`toUslv`, `toSslv`, `fromUslv`, `fromSslv`)
	+ Conversions between strings and real numbers or arrays of real numbers (`fromString`)
* Array manipulations:
	+ Counting occurrences of a value in an array (`count`)
	+ Finding maximum and minimum values in an array (`maxArray`, `minArray`)
* Conditional selection:
	+ Choosing between two values based on a boolean condition (`choose`)

**Inputs and Outputs**

The functions in this package take a variety of input types, including:

* Integers (`integer`)
* Real numbers (`real`)
* Standard logic vectors (`std_logic_vector`)
* Boolean values (`boolean`)
* Strings (`string`)
* Arrays of integers or real numbers (`IntegerArray_t`, `RealArray_t`)

The functions return values of corresponding types.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_array.all;

package olo_base_pkg_math is

    function log2 (arg : in natural) return natural;

    function log2ceil (arg : in natural) return natural;

    function isPower2 (arg : in natural) return boolean;

    function greatestCommonFactor (
        a : in positive;
        b : in positive) return positive;

    function leastCommonMultiple (
        a : in positive;
        b : in positive) return positive;

    function max (
        a : in integer;
        b : in integer) return integer;

    function min (
        a : in integer;
        b : in integer) return integer;

    function max (
        a : in real;
        b : in real) return real;

    function min (
        a : in real;
        b : in real) return real;

    function choose (
        s : in boolean;
        t : in std_logic;
        f : in std_logic) return std_logic;

    function choose (
        s : in boolean;
        t : in std_logic_vector;
        f : in std_logic_vector) return std_logic_vector;

    function choose (
        s : in boolean;
        t : in integer;
        f : in integer) return integer;

    function choose (
        s : in boolean;
        t : in string;
        f : in string) return string;

    function choose (
        s : in boolean;
        t : in real;
        f : in real) return real;

    function choose (
        s : in boolean;
        t : in unsigned;
        f : in unsigned) return unsigned;

    function choose (
        s : in boolean;
        t : in boolean;
        f : in boolean) return boolean;

    function choose (
        s : in boolean;
        t : in RealArray_t;
        f : in RealArray_t) return RealArray_t;

    function count (
        a : in IntegerArray_t;
        v : in integer) return integer;

    function count (
        a : in BoolArray_t;
        v : in boolean) return integer;

    function count (
        a : in std_logic_vector;
        v : in std_logic) return integer;

    function toUslv (
        input : integer;
        len   : integer) return std_logic_vector;

    function toSslv (
        input : integer;
        len   : integer) return std_logic_vector;

    function toStdl (input : integer range 0 to 1) return std_logic;

    function fromUslv (input : std_logic_vector) return integer;

    function fromSslv (input : std_logic_vector) return integer;

    function fromStdl (input : std_logic) return integer;

    function fromString (input : string) return real;

    function fromString (input : string) return RealArray_t;

    function maxArray (a : in IntegerArray_t) return integer;

    function maxArray (a : in RealArray_t) return real;

    function minArray (a : in IntegerArray_t) return integer;

    function minArray (a : in RealArray_t) return real;

end package;

package body olo_base_pkg_math is

    function countCommaSepElems (input : string) return natural is
        variable Count_v : natural := 1;
        variable Idx_v   : integer := input'low;
    begin

        while Idx_v <= input'high loop
            if input(Idx_v) = ',' then
                Count_v := Count_v + 1;
            end if;
            Idx_v := Idx_v + 1;
        end loop;

        return Count_v;
    end function;


    function log2 (arg : in natural) return natural is
        variable ArgShift_v : natural := arg;
        variable Log2_v     : natural := 0;
    begin

        while ArgShift_v > 1 loop
            ArgShift_v := ArgShift_v / 2;
            Log2_v     := Log2_v + 1;
        end loop;

        return Log2_v;
    end function;

    function log2ceil (arg : in natural) return natural is
    begin
        if arg = 0 then
            return 0;
        end if;
        return log2(arg * 2 - 1);
    end function;

    function isPower2 (arg : in natural) return boolean is
    begin
        if log2(arg) = log2ceil(arg) then
            return true;
        else
            return false;
        end if;
    end function;

    function greatestCommonFactor (
        a : in positive;
        b : in positive) return positive is
        variable Gcd_v : positive := min(a, b);
    begin

        while Gcd_v > 1 loop
            if a mod Gcd_v = 0 and b mod Gcd_v = 0 then
                return Gcd_v;
            end if;
            Gcd_v := Gcd_v - 1;
        end loop;

        return Gcd_v;
    end function;

    function leastCommonMultiple (
        a : in positive;
        b : in positive) return positive is
    begin
        return a * b / greatestCommonFactor(a, b);
    end function;

    function max (
        a : in integer;
        b : in integer) return integer is
    begin
        if a > b then
            return a;
        else
            return b;
        end if;
    end function;

    function max (
        a : in real;
        b : in real) return real is
    begin
        if a > b then
            return a;
        else
            return b;
        end if;
    end function;

    function min (
        a : in integer;
        b : in integer) return integer is
    begin
        if a > b then
            return b;
        else
            return a;
        end if;
    end function;

    function min (
        a : in real;
        b : in real) return real is
    begin
        if a > b then
            return b;
        else
            return a;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in std_logic;
        f : in std_logic) return std_logic is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in std_logic_vector;
        f : in std_logic_vector) return std_logic_vector is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in integer;
        f : in integer) return integer is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in string;
        f : in string) return string is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in real;
        f : in real) return real is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in unsigned;
        f : in unsigned) return unsigned is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in boolean;
        f : in boolean) return boolean is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in RealArray_t;
        f : in RealArray_t) return RealArray_t is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function count (
        a : in IntegerArray_t;
        v : in integer) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function count (
        a : in BoolArray_t;
        v : in boolean) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function count (
        a : in std_logic_vector;
        v : in std_logic) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function toUslv (
        input : integer;
        len   : integer) return std_logic_vector is
    begin
        return std_logic_vector(to_unsigned(input, len));
    end function;

    function toSslv (
        input : integer;
        len   : integer) return std_logic_vector is
    begin
        return std_logic_vector(to_signed(input, len));
    end function;

    function toStdl (input : integer range 0 to 1) return std_logic is
    begin
        if input = 1 then
            return '1';
        else
            return '0';
        end if;
    end function;

    function fromUslv (input : std_logic_vector) return integer is
    begin
        return to_integer(unsigned(input));
    end function;

    function fromSslv (input : std_logic_vector) return integer is
    begin
        return to_integer(signed(input));
    end function;

    function fromStdl (input : std_logic) return integer is
    begin
        assert input = '0' or input = '1'
            report ""fromStdl(): Illegal argument""
            severity error;
        if input = '0' then
            return 0;
        else
            return 1;
        end if;
    end function;

    function fromString (input : string) return real is
        constant Nbsp_c       : character := character'val(160);
        variable Idx_v        : integer   := input'low;
        variable IsNeg_v      : boolean   := false;
        variable ValInt_v     : integer   := 0;
        variable ValFrac_v    : real      := 0.0;
        variable FracDigits_v : integer   := 0;
        variable Exp_v        : integer   := 0;
        variable ExpNeg_v     : boolean   := false;
        variable ValAbs_v     : real      := 0.0;
    begin

        while (Idx_v <= input'high) and (input(Idx_v) = ' ' or input(Idx_v) = Nbsp_c or input(Idx_v) = HT) loop
            Idx_v := Idx_v + 1;
        end loop;

        if (Idx_v <= input'high) and ((input(Idx_v) = '-') or (input(Idx_v) = '+')) then
            IsNeg_v := (input(Idx_v) = '-');
            Idx_v   := Idx_v + 1;
        end if;

        while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
            ValInt_v := ValInt_v * 10 + (character'pos(input(Idx_v)) - character'pos('0'));
            Idx_v    := Idx_v + 1;
        end loop;

        if (Idx_v <= input'high) then
            if input(Idx_v) = '.' then
                Idx_v := Idx_v + 1;

                while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
                    ValFrac_v    := ValFrac_v * 10.0 + real((character'pos(input(Idx_v)) - character'pos('0')));
                    FracDigits_v := FracDigits_v + 1;
                    Idx_v        := Idx_v + 1;
                end loop;

            end if;
        end if;

        if (Idx_v <= input'high) then
            if (input(Idx_v) = 'E') or (input(Idx_v) = 'e') then
                Idx_v := Idx_v + 1;
                if (Idx_v <= input'high) and ((input(Idx_v) = '-') or (input(Idx_v) = '+')) then
                    ExpNeg_v := (input(Idx_v) = '-');
                    Idx_v    := Idx_v + 1;
                end if;

                while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
                    Exp_v := Exp_v * 10 + (character'pos(input(Idx_v)) - character'pos('0'));
                    Idx_v := Idx_v + 1;
                end loop;

                if ExpNeg_v then
                    Exp_v := -Exp_v;
                end if;
            end if;
        end if;

        ValAbs_v := (real(ValInt_v) + ValFrac_v / 10.0**real(FracDigits_v)) * 10.0**real(Exp_v);
        if IsNeg_v then
            return -ValAbs_v;
        else
            return ValAbs_v;
        end if;
    end function;

    function fromString (input : string) return RealArray_t is
        variable Array_v    : RealArray_t(0 to countCommaSepElems(input) - 1) := (others => 0.0);
        variable ArrayIdx_v : natural                                         := 0;
        variable StartIdx_v : natural                                         := 1;
        variable EndIdx_v   : natural                                         := 1;
        variable CharIdx_v  : natural                                         := input'low;
    begin

        while CharIdx_v <= input'high loop
            if input(CharIdx_v) = ',' then
                EndIdx_v            := CharIdx_v - 1;
                Array_v(ArrayIdx_v) := fromString(input(StartIdx_v to EndIdx_v));
                ArrayIdx_v          := ArrayIdx_v + 1;
                StartIdx_v          := CharIdx_v + 1;
            end if;
            CharIdx_v := CharIdx_v + 1;
        end loop;

        if StartIdx_v <= input'high then
            Array_v(ArrayIdx_v) := fromString(input(StartIdx_v to input'high));
        end if;

        return Array_v;
    end function;

    function maxArray (a : in IntegerArray_t) return integer is
        variable Max_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if max(Max_v, a(idx)) > Max_v then
                Max_v := a(idx);
            end if;
        end loop;

        return Max_v;
    end function;

    function maxArray (a : in RealArray_t) return real is
        variable Max_v : real := 0.0;
    begin

        for idx in a'low to a'high loop
            if max(Max_v, a(idx)) > Max_v then
                Max_v := a(idx);
            end if;
        end loop;

        return Max_v;
    end function;

    function minArray (a : in IntegerArray_t) return integer is
        variable Min_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if min(Min_v, a(idx)) < Min_v then
                Min_v := a(idx);
            end if;
        end loop;

        return Min_v;
    end function;

    function minArray (a : in RealArray_t) return real is
        variable Min_v : real := 0.0;
    begin

        for idx in a'low to a'high loop
            if min(Min_v, a(idx)) < Min_v then
                Min_v := a(idx);
            end if;
        end loop;

        return Min_v;
    end function;

end package body;",30
"This package contains useful string-related functions.

# VHDL Analysis for 'olo_base_pkg_string.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing commonly used string manipulation functionality.
- Documentation:
- Plus 38 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: work.olo_base_pkg_math.all

## Functional Analysis

- Uses reset signal(s): first
- Implements arithmetic/computational functionality
- Defines custom functions: toUpper, toLower, trim, hex2StdLogicVector, countOccurence, toUpper, toLower, trim, hex2StdLogicVector, countOccurence

## Code Metrics
- Line count: 202
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pkg_string.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The VHDL code provided defines a package named `olo_base_pkg_string` which contains a set of string manipulation functions. These functions provide various operations for string processing, including case conversion, trimming, hexadecimal to binary conversion, and character occurrence counting.

**Functionality**

The package provides the following functions:

1. `toUpper(a: in string) return string`: Converts a given string to uppercase.
2. `toLower(a: in string) return string`: Converts a given string to lowercase.
3. `trim(a: in string) return string`: Removes leading and trailing whitespace characters from a given string.
4. `hex2StdLogicVector(a: in string; bits: in natural; hasPrefix: in boolean := false) return std_logic_vector`: Converts a hexadecimal string to a binary `std_logic_vector` with a specified bit width.
5. `countOccurence(a: in string; c: in character) return natural`: Counts the number of occurrences of a given character in a string.

**Inputs and Outputs**

* All functions take in string or character inputs and return string or numerical outputs.
* The `hex2StdLogicVector` function also takes in a `bits` input to specify the desired output width and an optional `hasPrefix` input to indicate if the hexadecimal string has a ""0x"" prefix.

**Purpose**

The purpose of this package is to provide a set of reusable string manipulation functions that can be used in various digital","
library ieee;
    use ieee.std_logic_1164.all;

library work;
    use work.olo_base_pkg_math.all;

package olo_base_pkg_string is

    function toUpper (a : in string) return string;
    function toLower (a : in string) return string;

    function trim (a : in string) return string;

    function hex2StdLogicVector (
        a         : in string;
        bits      : in natural;
        hasPrefix : in boolean := false) return std_logic_vector;

    function countOccurence (
        a : in string;
        c : in character) return natural;

end package;

package body olo_base_pkg_string is

    function toUpper (a : in string) return string is
        variable Res_v        : string(a'range);
        variable CharIdx_v    : natural;
        constant LowerUpper_c : natural := character'pos('a') - character'pos('A');
    begin

        for i in a'range loop
            CharIdx_v := character'pos(a(i));
            if CharIdx_v >= character'pos('a') and CharIdx_v <= character'pos('z') then
                CharIdx_v := CharIdx_v - LowerUpper_c;
            end if;
            Res_v(i) := character'val(CharIdx_v);
        end loop;

        return Res_v;
    end function;

    function toLower (a : in string) return string is
        variable Res_v        : string(a'range);
        variable CharIdx_v    : natural;
        constant LowerUpper_c : natural := character'pos('a') - character'pos('A');
    begin

        for i in a'range loop
            CharIdx_v := character'pos(a(i));
            if CharIdx_v >= character'pos('A') and CharIdx_v <= character'pos('Z') then
                CharIdx_v := CharIdx_v + LowerUpper_c;
            end if;
            Res_v(i) := character'val(CharIdx_v);
        end loop;

        return Res_v;
    end function;

    function trim (a : in string) return string is
        variable StartIdx_v : natural := a'left;
        variable EndIdx_v   : natural := a'right;
    begin

        while StartIdx_v < a'right and a(StartIdx_v) = ' ' loop
            StartIdx_v := StartIdx_v + 1;
        end loop;

        while EndIdx_v > a'left and a(EndIdx_v) = ' ' loop
            EndIdx_v := EndIdx_v - 1;
        end loop;

        return a(StartIdx_v to EndIdx_v);
    end function;

    function hex2StdLogicVector (
        a         : in string;
        bits      : in natural;
        hasPrefix : in boolean := false) return std_logic_vector is
        constant Trimmed_c   : string                                   := trim(toLower(a));
        constant MaxBits_c   : natural                                  := max(choose(hasPrefix, (Trimmed_c'length-2) * 4, Trimmed_c'length * 4), 0);
        variable StdlvFull_v : std_logic_vector(MaxBits_c - 1 downto 0) := (others => '0');
        variable Result_v    : std_logic_vector(bits - 1 downto 0)      := (others => '0');
        variable LowIdx_v    : natural                                  := 0;
        variable Nibble_v    : std_logic_vector(3 downto 0);
    begin
        if Trimmed_c'length = 0 then
            return Result_v;
        end if;

        if hasPrefix then
            assert Trimmed_c(Trimmed_c'left to Trimmed_c'left+1) = ""0x""
                report ""Invalid prefix in hex2StdLogicVector() - expected prefix is 0x - string: "" & a
                severity error;
            LowIdx_v := LowIdx_v + 2;
        end if;

        for i in Trimmed_c'left+LowIdx_v to Trimmed_c'right loop

            case Trimmed_c(i) is
                when '0' => Nibble_v := x""0"";
                when '1' => Nibble_v := x""1"";
                when '2' => Nibble_v := x""2"";
                when '3' => Nibble_v := x""3"";
                when '4' => Nibble_v := x""4"";
                when '5' => Nibble_v := x""5"";
                when '6' => Nibble_v := x""6"";
                when '7' => Nibble_v := x""7"";
                when '8' => Nibble_v := x""8"";
                when '9' => Nibble_v := x""9"";
                when 'a' => Nibble_v := x""A"";
                when 'b' => Nibble_v := x""B"";
                when 'c' => Nibble_v := x""C"";
                when 'd' => Nibble_v := x""D"";
                when 'e' => Nibble_v := x""E"";
                when 'f' => Nibble_v := x""F"";
                when others =>
                    report ""Invalid character in hex2StdLogicVector() - only 0-9, a-f, A-F are allowed - string: "" & a
                        severity error;
                    return Result_v;
            end case;

            StdlvFull_v := StdlvFull_v(StdlvFull_v'left - 4 downto 0) & Nibble_v;
        end loop;

        if bits > MaxBits_c then
            Result_v(MaxBits_c - 1 downto 0) := StdlvFull_v;
        else
            Result_v := StdlvFull_v(bits-1 downto 0);
        end if;
        return Result_v;
    end function;

    function countOccurence (
        a : in string;
        c : in character) return natural is
        variable Count_v : natural := 0;
    begin

        for i in a'range loop
            if a(i) = c then
                Count_v := Count_v + 1;
            end if;
        end loop;

        return Count_v;
    end function;

end package body;",31
"This entity implements multiple pipeline stages with handshaking (AXI-S Ready/Valid). The pipeline stage ensures all signals are registered in both directions (including Ready). This is important to break long logic chains that can occur in the Ready  paths because Ready is often forwarded asynchronously. _olo_base_pl_stage_ is used for two main cases: - Breaking long logic paths into several sections, each one having a propagation time shorter than the clock period. In this case _olo_base_pl_stage_ usually is configured for _Stages_g_=1. - Adding multiple register stages for long routing paths. In this case _olo_base_pl_stage_ usually is configured for _Stages_g_>1.

# VHDL Analysis for 'olo_base_pl_stage.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2023-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a pipelinestage with handshaking (AXI-S Ready/Valild). The
- Plus 51 more comments

## Libraries and Packages
- Library: ieee
- Library: ieee
- Library: work
- Use: Rdy is often forwarded asynchronously.
--
-- Documentation:
-- https://github.com/open-logic/open-logic/blob/main/doc/base/olo_base_pl_stage.md
--
-- Note: The link points to the documentation of the latest release. If you
--       use an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------

library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_attribute.all
- Use: ready is deasserted only after one clock cycle
                if IsStuck_v then
                    v.DataShadVld := '1'

## Entity: olo_base_pl_stage

## Architecture: rtl of olo_base_pl_stage

### Signals
- Data: Data_t(0 to Stages_g)
- Valid: std_logic_vector(0 to Stages_g)
- Ready: std_logic_vector(0 to Stages_g)

### Component Declarations
- olo_private_pl_stage_single

## Functional Analysis

- Contains 2 clock domain(s): Clk, clock
- Uses reset signal(s): Rst
- Implements control logic
- May be part of a pipeline architecture

## Code Metrics
- Line count: 289
- Process count: 0
- Signal count: 3

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_pl_stage.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Pipelined Data Stage (olo_base_pl_stage)**

**Overview**

The olo_base_pl_stage component is a parameterized, pipelined data stage that provides a flexible way to implement a series of data processing stages with optional ready/valid handshaking. The component can be configured to have a variable number of stages, each with a specified width.

**Functional Description**

The olo_base_pl_stage component performs the following functions:

1. **Data Pipelining**: The component pipelines the input data through a series of stages, where each stage can be thought of as a single clock cycle delay.
2. **Ready/Valid Handshaking**: The component supports optional ready/valid handshaking on both the input and output sides. When enabled, the component will only accept new data when the input ready signal is high and will only produce output data when the output ready signal is high.
3. **Data Width and Stage Count**: The component is parameterized to support a variable data width (Width_g) and a variable number of stages (Stages_g).

**Inputs**

* **Clk**: Clock input
* **Rst**: Asynchronous reset input
* **In_Valid**: Input valid signal (default: '1')
* **In_Data**: Input data (Width_g bits)
* **Out_Ready**: Output ready signal (default: '1')

**Outputs**

* **In_Ready**: Input ready signal
* **Out_Valid**: Output valid signal","


library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_pl_stage is
    generic (
        Width_g     : positive;
        UseReady_g  : boolean := true;
        Stages_g    : natural := 1
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_pl_stage is

    component olo_private_pl_stage_single is
        generic (
            Width_g     : positive;
            UseReady_g  : boolean   := true
        );
        port (
            Clk         : in    std_logic;
            Rst         : in    std_logic;
            In_Valid    : in    std_logic;
            In_Ready    : out   std_logic;
            In_Data     : in    std_logic_vector(Width_g-1 downto 0);
            Out_Valid   : out   std_logic;
            Out_Ready   : in    std_logic := '1';
            Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
        );
    end component;

    type Data_t is array (natural range <>) of std_logic_vector(Width_g - 1 downto 0);

    signal Data  : Data_t(0 to Stages_g);
    signal Valid : std_logic_vector(0 to Stages_g);
    signal Ready : std_logic_vector(0 to Stages_g);

begin

    g_nonzero : if Stages_g > 0 generate
        Valid(0) <= In_Valid;
        In_Ready <= Ready(0);
        Data(0)  <= In_Data;

        g_stages : for i in 0 to Stages_g - 1 generate

            i_stg : component olo_private_pl_stage_single
                generic map (
                    Width_g    => Width_g,
                    UseReady_g => UseReady_g
                )
                port map (
                    Clk       => Clk,
                    Rst       => Rst,
                    In_Valid  => Valid(i),
                    In_Ready  => Ready(i),
                    In_Data   => Data(i),
                    Out_Valid => Valid(i + 1),
                    Out_Ready => Ready(i + 1),
                    Out_Data  => Data(i + 1)
                );

        end generate;

        Out_Valid       <= Valid(Stages_g);
        Ready(Stages_g) <= Out_Ready;
        Out_Data        <= Data(Stages_g);
    end generate;

    g_zero : if Stages_g = 0 generate
        Out_Valid <= In_Valid;
        Out_Data  <= In_Data;
        In_Ready  <= Out_Ready;
    end generate;

end architecture;


library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_private_pl_stage_single is
    generic (
        Width_g     : positive;
        UseReady_g  : boolean := true
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_private_pl_stage_single is

    type TwoProcess_r is record
        DataMain    : std_logic_vector(Width_g - 1 downto 0);
        DataMainVld : std_logic;
        DataShad    : std_logic_vector(Width_g - 1 downto 0);
        DataShadVld : std_logic;
        In_Ready    : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    g_rdy : if UseReady_g generate

        p_comb : process (In_Valid, In_Data, Out_Ready, r) is
            variable v         : TwoProcess_r;
            variable IsStuck_v : boolean;
        begin
            v := r;

            IsStuck_v := (r.DataMainVld = '1' and Out_Ready = '0' and (In_Valid = '1' or r.DataShadVld = '1'));

            if r.DataMainVld = '1' and Out_Ready = '1' then
                v.DataMainVld := r.DataShadVld;
                v.DataMain    := r.DataShad;
                v.DataShadVld := '0';
            end if;

            if r.In_Ready = '1' and In_Valid = '1' then
                if IsStuck_v then
                    v.DataShadVld := '1';
                    v.DataShad    := In_Data;
                else
                    v.DataMainVld := '1';
                    v.DataMain    := In_Data;
                end if;
            end if;

            if IsStuck_v then
                v.In_Ready := '0';
            else
                v.In_Ready := '1';
            end if;

            r_next <= v;
        end process;

        In_Ready  <= r.In_Ready;
        Out_Valid <= r.DataMainVld;
        Out_Data  <= r.DataMain;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.DataMainVld <= '0';
                    r.DataShadVld <= '0';
                    r.In_Ready    <= '1';
                end if;
            end if;
        end process;

    end generate;

    g_nrdy : if not UseReady_g generate
        signal VldReg  : std_logic;
        signal DataReg : std_logic_vector(Width_g-1 downto 0);

        attribute shreg_extract of VldReg  : signal is ShregExtract_SuppressExtraction_c;
        attribute shreg_extract of DataReg : signal is ShregExtract_SuppressExtraction_c;

        attribute syn_srlstyle of VldReg  : signal is SynSrlstyle_FlipFlops_c;
        attribute syn_srlstyle of DataReg : signal is SynSrlstyle_FlipFlops_c;

        attribute dont_merge of VldReg  : signal is DontMerge_SuppressChanges_c;
        attribute dont_merge of DataReg : signal is DontMerge_SuppressChanges_c;

        attribute preserve of VldReg  : signal is Preserve_SuppressChanges_c;
        attribute preserve of DataReg : signal is Preserve_SuppressChanges_c;

        attribute syn_keep of VldReg  : signal is SynKeep_SuppressChanges_c;
        attribute syn_keep of DataReg : signal is SynKeep_SuppressChanges_c;

        attribute syn_preserve of VldReg  : signal is SynPreserve_SuppressChanges_c;
        attribute syn_preserve of DataReg : signal is SynPreserve_SuppressChanges_c;

    begin

        p_stg : process (Clk) is
        begin
            if rising_edge(Clk) then
                DataReg <= In_Data;
                VldReg  <= In_Valid;
                if Rst = '1' then
                    VldReg <= '0';
                end if;
            end if;
        end process;

        In_Ready  <= '1'; -- Not used!
        Out_Data  <= DataReg;
        Out_Valid <= VldReg;

    end generate;

end architecture;",32
"This component generates a pseudorandom binary sequence based (PRBS) on a logic feed-back shift register (LFSR) method. A set of common polynomials (aiming the maximum cycle possible) is available in [olo_base_pkg_logic](./olo_base_pkg_logic.md) and can be passed to _olo_base_prbs_ through the generic _Polynomial_g_. The number of bits per symbol which is presented at the output is configurable. Polynomials are passed as _std_logic_vector_ where a one denotes every position where x^n is used: ""100010000"" means ""x⁹ +x⁵ + 1"". The initial state of the LFSR can be configured throuh _Seed_g_ at compile time or through _State_New_ at the moment where _State_Set='1'_ is asserted at runtime. Note that the state of an LFSR never should be zero - otherwise the LFSR will stay zero forever. Note that for the case of _BitsPerSymbol_g_ > _width(Polynomial_g)_ the LFSR is shifted _before_ the first symbol is produced. Hence _Seed_g_ (after reset) resp. _State_New_ (after setting the state) is ocurring in the highest bits of the first _Out_Data_ word - and the lower bits are the first results of the LFSR calculation.

# VHDL Analysis for 'olo_base_prbs.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Rafael Basso, Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description:
- -------------------------------------------------------------------------------------------------
- A generic pseudo random binary sequence based on a linear-feedback shifter
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.std_logic_misc.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_logic.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_prbs

## Architecture: rtl of olo_base_prbs

### Signals
- LfsrReg: std_logic_vector(LfsrLenght_c-1 downto 0)

### Processes
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_lfsr :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- NextBit_v    := xor_reduce(LfsrMasked_v)
- Lfsr_v       := Lfsr_v(Lfsr_v'high-1 downto 0) & NextBit_v

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst
- Implements control logic
- Defines custom functions: function, lfsrInitValue

## Code Metrics
- Line count: 154
- Process count: 2
- Signal count: 1

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_prbs.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Pseudo-Random Bit Sequence (PRBS) Generator**

**Component Description:**
The PRBS Generator is a digital component that produces a pseudo-random bit sequence based on a given polynomial and seed value. It generates a sequence of bits that can be used for testing and verification purposes.

**Inputs:**

* **Clk**: Clock input, rising edge sensitive
* **Rst**: Asynchronous reset input, active high
* **Out_Ready**: Input signal indicating that the output is ready to be consumed, active high (default: '1')
* **State_New**: Optional input to set a new state for the PRBS generator, active high (default: (others => '0'))
* **State_Set**: Optional input to set the new state, active high (default: '0')

**Outputs:**

* **Out_Data**: Output data, a bit sequence of length `BitsPerSymbol_g`
* **Out_Valid**: Output validity signal, active high (always '1' in this implementation)
* **State_Current**: Current state of the PRBS generator, a bit sequence of length equal to the polynomial

**Parameters:**

* **Polynomial_g**: The polynomial used to generate the PRBS, a bit sequence of length >= 2
* **Seed_g**: The initial seed value for the PRBS generator, a bit sequence of length equal to the polynomial
* **BitsPerSymbol_g**: The number of bits to generate per symbol, a positive integer (>= 1","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_math.all;

entity olo_base_prbs is
    generic (
        Polynomial_g    : std_logic_vector;
        Seed_g          : std_logic_vector;
        BitsPerSymbol_g : positive := 1;
        LfsrWidth_g     : natural  := 0 -- Deprecated, not used
    );
    port (
        Clk              : in    std_logic;
        Rst              : in    std_logic;
        Out_Data         : out   std_logic_vector(BitsPerSymbol_g-1 downto 0);
        Out_Ready        : in    std_logic                                        := '1';
        Out_Valid        : out   std_logic;
        State_Current    : out   std_logic_vector(Polynomial_g'length-1 downto 0);
        State_New        : in    std_logic_vector(Polynomial_g'length-1 downto 0) := (others => '0');
        State_Set        : in    std_logic                                        := '0'
    );
end entity;


architecture rtl of olo_base_prbs is

    constant LfsrLenght_c : natural := max(BitsPerSymbol_g, Polynomial_g'length);

    signal LfsrReg : std_logic_vector(LfsrLenght_c-1 downto 0);

    function lfsrUpdate (
        lfsrReg : std_logic_vector(LfsrLenght_c-1 downto 0);
        bits    : positive) return std_logic_vector is
        variable Lfsr_v       : std_logic_vector(LfsrLenght_c-1 downto 0) := lfsrReg;
        variable LfsrMasked_v : std_logic_vector(Polynomial_g'length-1 downto 0);
        variable NextBit_v    : std_logic;
    begin

        for bit in 0 to bits - 1 loop
            LfsrMasked_v := Lfsr_v(Polynomial_g'length-1 downto 0) and Polynomial_g;
            NextBit_v    := xor_reduce(LfsrMasked_v);
            Lfsr_v       := Lfsr_v(Lfsr_v'high-1 downto 0) & NextBit_v;
        end loop;

        return Lfsr_v;
    end function;

    function lfsrInitValue return std_logic_vector is
        variable Lfsr_v : std_logic_vector(LfsrLenght_c-1 downto 0) := (others => '0');
    begin
        Lfsr_v(Polynomial_g'length-1 downto 0) := Seed_g;

        if LfsrLenght_c > Polynomial_g'length then
            Lfsr_v := lfsrUpdate(Lfsr_v, LfsrLenght_c - Polynomial_g'length);
        end if;

        return Lfsr_v;

    end function;

begin

    assert Polynomial_g'length >= 2
        report ""###ERROR###: olo_base_prbs - Polynomial_g width must be at least 2""
        severity error;
    assert Seed_g'length = Polynomial_g'length
        report ""###ERROR###: olo_base_prbs - Seed_g width must match Polynomial_g width""
        severity error;
    assert fromUslv(Seed_g) /= 0
        report ""###ERROR###: olo_base_prbs - Seed_g MUST NOT be zero""
        severity error;
    assert BitsPerSymbol_g >= 1
        report ""###ERROR###: olo_base_prbs - BitsPerSymbol_g width must be larger or equal to 1""
        severity error;

    Out_Valid     <= '1';
    Out_Data      <= invertBitOrder(LfsrReg(LfsrReg'high downto LfsrReg'length-BitsPerSymbol_g));
    State_Current <= LfsrReg(State_Current'high downto 0);

    p_lfsr : process (Clk) is
        variable Lfsr_v : std_logic_vector(LfsrReg'range);
    begin
        if rising_edge(Clk) then
            if Out_Ready = '1' then
                LfsrReg <= lfsrUpdate(LfsrReg, BitsPerSymbol_g);
            end if;

            if State_Set = '1' then
                Lfsr_v                                 := (others => '0');
                Lfsr_v(Polynomial_g'length-1 downto 0) := State_New;
                if LfsrLenght_c > Polynomial_g'length then
                    Lfsr_v := lfsrUpdate(Lfsr_v, LfsrLenght_c - Polynomial_g'length);
                end if;
                LfsrReg <= Lfsr_v;
            end if;

            if Rst = '1' then
                LfsrReg <= lfsrInitValue;
            end if;

        end if;

    end process;

end architecture;",33
"This component implements a **simple dual-port** RAM. It offers separate read and write ports. By default read and write port both run on the same clock but optionally the implementation with separate read/write clocks is supported. The RAM is implemented in pure VHDL but in a way that allows tools to implement it in block-RAMs.

# VHDL Analysis for 'olo_base_ram_sdp.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a pure VHDL and vendor indpendent simple dual port RAM with
- Plus 46 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: VHDL93 (supported by all tools) does not allow
    -- ... unconstrainted arrays as return types.
    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'))

## Entity: olo_base_ram_sdp

## Architecture: rtl of olo_base_ram_sdp

### Signals
- Wr_Ena_Byte: std_logic

### Component Declarations
- olo_private_ram_sdp_nobe

### Concurrent Statements
- i_ram : component olo_private_ram_sdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    IsAsync_g       => IsAsync_g,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk         => Clk,
                    Wr_Addr     => Wr_Addr,
                    Wr_Ena      => Wr_Ena_Byte,
                    Wr_Data     => Wr_Data(byte*8+7 downto byte*8),
                    Rd_Clk      => Rd_Clk,
                    Rd_Addr     => Rd_Addr,
                    Rd_Ena      => Rd_Ena,
                    Rd_Data     => Rd_Data(byte*8+7 downto byte*8)
                )

## Functional Analysis

- Contains 2 clock domain(s): Clk, Rd_Clk
- Implements memory functionality
- Implements control logic
- May be part of a pipeline architecture
- Defines custom functions: getInitContent

## Code Metrics
- Line count: 337
- Process count: 0
- Signal count: 1

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_ram_sdp.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Single-Port RAM with Optional Byte Enables**

**Component Name:** olo_base_ram_sdp

**Description:** A single-port RAM component with optional byte enables, supporting synchronous and asynchronous read/write operations.

**Functional Description:**

The olo_base_ram_sdp component is a configurable single-port RAM with the following features:

* Supports synchronous and asynchronous read/write operations
* Optional byte enables for write operations
* Configurable RAM style, behavior, and initialization

**Inputs:**

* **Clk**: Clock signal for synchronous write operations
* **Wr_Addr**: Write address (log2ceil(Depth_g) bits)
* **Wr_Ena**: Write enable (active high)
* **Wr_Be**: Byte enable (active high) (only used if UseByteEnable_g = true)
* **Wr_Data**: Write data (Width_g bits)
* **Rd_Clk**: Clock signal for asynchronous read operations (only used if IsAsync_g = true)
* **Rd_Addr**: Read address (log2ceil(Depth_g) bits)
* **Rd_Ena**: Read enable (active high)

**Outputs:**

* **Rd_Data**: Read data (Width_g bits)

**Configuration Parameters:**

* **Depth_g**: RAM depth (positive integer)
* **Width_g**: RAM width (positive integer)
* **IsAsync_g**: Asynchronous read/write mode (boolean, default: false)
* **RdLatency_g**: Read latency (positive integer, default: 1","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_sdp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        IsAsync_g       : boolean  := false;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );
    port (
        Clk         : in    std_logic;
        Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Wr_Ena      : in    std_logic                                  := '1';
        Wr_Be       : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Rd_Clk      : in    std_logic                                  := '0';
        Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Rd_Ena      : in    std_logic                                  := '1';
        Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_sdp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_sdp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            IsAsync_g       : boolean  := false;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            Clk         : in    std_logic;
            Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            Wr_Ena      : in    std_logic                                  := '1';
            Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
            Rd_Clk      : in    std_logic                                  := '0';
            Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            Rd_Ena      : in    std_logic                                  := '1';
            Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_sdp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_sdp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                IsAsync_g       => IsAsync_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                Clk         => Clk,
                Wr_Addr     => Wr_Addr,
                Wr_Ena      => Wr_Ena,
                Wr_Data     => Wr_Data,
                Rd_Clk      => Rd_Clk,
                Rd_Addr     => Rd_Addr,
                Rd_Ena      => Rd_Ena,
                Rd_Data     => Rd_Data
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal Wr_Ena_Byte : std_logic;
        begin
            Wr_Ena_Byte <= Wr_Ena and Wr_Be(byte);

            i_ram : component olo_private_ram_sdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    IsAsync_g       => IsAsync_g,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk         => Clk,
                    Wr_Addr     => Wr_Addr,
                    Wr_Ena      => Wr_Ena_Byte,
                    Wr_Data     => Wr_Data(byte*8+7 downto byte*8),
                    Rd_Clk      => Rd_Clk,
                    Rd_Addr     => Rd_Addr,
                    Rd_Ena      => Rd_Ena,
                    Rd_Data     => Rd_Data(byte*8+7 downto byte*8)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_sdp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        IsAsync_g       : boolean  := false;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        Clk         : in    std_logic;
        Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Wr_Ena      : in    std_logic := '1';
        Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Rd_Clk      : in    std_logic := '0';
        Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Rd_Ena      : in    std_logic := '1';
        Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_sdp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipe : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipe : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_sdp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_sdp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    g_sync : if not IsAsync_g generate

        p_ram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if RamBehavior_g = ""RBW"" then
                    if Rd_Ena = '1' then
                        RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                    end if;
                end if;
                if Wr_Ena = '1' then
                    Mem_v(to_integer(unsigned(Wr_Addr))) := Wr_Data;
                end if;
                if RamBehavior_g = ""WBR"" then
                    if Rd_Ena = '1' then
                        RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                    end if;
                end if;

                RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    g_async : if IsAsync_g generate

        p_write : process (Clk) is
        begin
            if rising_edge(Clk) then
                if Wr_Ena = '1' then
                    Mem_v(to_integer(unsigned(Wr_Addr))) := Wr_Data;
                end if;
            end if;
        end process;

        p_read : process (Rd_Clk) is
        begin
            if rising_edge(Rd_Clk) then
                if Rd_Ena = '1' then
                    RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                end if;

                RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    Rd_Data <= RdPipe(RdLatency_g);

end architecture;",34
"This component implements a **single-port** RAM. The RAM is implemented in pure VHDL but in a way that allows tools to implement it in block-RAMs.

# VHDL Analysis for 'olo_base_ram_sp.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a pure VHDL and vendor indpendent true single-port RAM with
- Plus 42 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: VHDL93 (supported by all tools) does not allow
    -- ... unconstrainted arrays as return types.
    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'))

## Entity: olo_base_ram_sp

## Architecture: rtl of olo_base_ram_sp

### Signals
- WrEna_Byte: std_logic

### Component Declarations
- olo_private_ram_sp_nobe

### Concurrent Statements
- i_ram : component olo_private_ram_sp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk             => Clk,
                    Addr            => Addr,
                    WrEna           => WrEna_Byte,
                    WrData          => WrData(byte*8+7 downto byte*8),
                    RdData          => RdData(byte*8+7 downto byte*8)
                )

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Implements memory functionality
- May be part of a pipeline architecture
- Defines custom functions: getInitContent

## Code Metrics
- Line count: 281
- Process count: 0
- Signal count: 1

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_ram_sp.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Single-Port RAM with Optional Byte Enables**

**Overview**

The `olo_base_ram_sp` component is a single-port RAM (Random Access Memory) module with optional byte enables. It provides a flexible and configurable memory solution for digital systems.

**Functional Description**

The component has the following functionality:

* Stores and retrieves data from a memory array of configurable depth and width
* Supports optional byte enables for selective write operations
* Provides a configurable read latency
* Allows for initialization of the memory array with a specified string

**Inputs**

* `Clk`: Clock signal (1-bit)
* `Addr`: Address bus (log2ceil(Depth_g)-1 downto 0)
* `Be`: Byte enables (Width_g / 8 - 1 downto 0) (optional)
* `WrEna`: Write enable signal (1-bit)
* `WrData`: Write data bus (Width_g - 1 downto 0)

**Outputs**

* `RdData`: Read data bus (Width_g - 1 downto 0)

**Configuration Parameters**

* `Depth_g`: Memory depth (positive integer)
* `Width_g`: Memory width (positive integer)
* `RdLatency_g`: Read latency (positive integer, default: 1)
* `RamStyle_g`: RAM style (string, default: ""auto"")
* `RamBehavior_g`: RAM behavior (string, default: ""RBW"")
* `UseByteEnable_g`: Use byte enables (","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_sp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );
    port (
        Clk             : in    std_logic;
        Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
        Be              : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        WrEna           : in    std_logic                                  := '1';
        WrData          : in    std_logic_vector(Width_g - 1 downto 0);
        RdData          : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_sp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_sp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            Clk             : in    std_logic;
            Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
            WrEna           : in    std_logic := '1';
            WrData          : in    std_logic_vector(Width_g - 1 downto 0);
            RdData          : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_sp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_sp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                Clk             => Clk,
                Addr            => Addr,
                WrEna           => WrEna,
                WrData          => WrData,
                RdData          => RdData
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal WrEna_Byte : std_logic;
        begin
            WrEna_Byte <= WrEna and Be(byte);

            i_ram : component olo_private_ram_sp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk             => Clk,
                    Addr            => Addr,
                    WrEna           => WrEna_Byte,
                    WrData          => WrData(byte*8+7 downto byte*8),
                    RdData          => RdData(byte*8+7 downto byte*8)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_sp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        Clk             : in    std_logic;
        Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
        WrEna           : in    std_logic := '1';
        WrData          : in    std_logic_vector(Width_g - 1 downto 0);
        RdData          : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_sp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipe : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipe : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_sp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_sp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    p_ram : process (Clk) is
    begin
        if rising_edge(Clk) then
            if RamBehavior_g = ""RBW"" then
                RdPipe(1) <= Mem_v(to_integer(unsigned(Addr)));
            end if;
            if WrEna = '1' then
                Mem_v(to_integer(unsigned(Addr))) := WrData;
            end if;
            if RamBehavior_g = ""WBR"" then
                RdPipe(1) <= Mem_v(to_integer(unsigned(Addr)));
            end if;

            RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
        end if;
    end process;

    RdData <= RdPipe(RdLatency_g);

end architecture;",35
"This component implements a **true dual-port** RAM. It offers two ports, which both allow reading and writing. The two ports run on separate clocks - although connecting the same clock to both ports is allowed. The RAM is implemented in pure VHDL but in a way that allows tools to implement it in block-RAMs.

# VHDL Analysis for 'olo_base_ram_tdp.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a pure VHDL and vendor indpendent true dual port RAM with optional
- Plus 55 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all
- Use: work.olo_base_pkg_string.all
- Use: VHDL93 (supported by all tools) does not allow
    -- ... unconstrainted arrays as return types.
    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'))

## Entity: olo_base_ram_tdp

## Architecture: rtl of olo_base_ram_tdp

### Signals
- A_WrEna_Byte: std_logic
- B_WrEna_Byte: std_logic

### Component Declarations
- olo_private_ram_tdp_nobe

### Concurrent Statements
- B_WrEna_Byte <= B_WrEna and B_Be(byte)
- i_ram : component olo_private_ram_tdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => 8*byte
                )
                port map (
                    A_Clk     => A_Clk,
                    A_Addr    => A_Addr,
                    A_WrEna   => A_WrEna_Byte,
                    A_WrData  => A_WrData(8*(byte+1)-1 downto 8*byte),
                    A_RdData  => A_RdData(8*(byte+1)-1 downto 8*byte),
                    B_Clk     => B_Clk,
                    B_Addr    => B_Addr,
                    B_WrEna   => B_WrEna_Byte,
                    B_WrData  => B_WrData(8*(byte+1)-1 downto 8*byte),
                    B_RdData  => B_RdData(8*(byte+1)-1 downto 8*byte)
                )

## Functional Analysis

- Contains 2 clock domain(s): A_Clk, B_Clk
- Implements memory functionality
- May be part of a pipeline architecture
- Defines custom functions: getInitContent

## Code Metrics
- Line count: 362
- Process count: 0
- Signal count: 2

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_ram_tdp.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Dual-Port RAM with Optional Byte Enables**

**Component Name:** olo_base_ram_tdp

**Description:** A dual-port RAM component with optional byte enables, configurable read latency, and initialization.

**Functional Description:**

The olo_base_ram_tdp component is a dual-port RAM that allows simultaneous read and write operations on two separate ports, A and B. The component supports optional byte enables, which allow for selective writing of bytes within a word. The RAM can be configured to have a specific read latency, and it supports initialization from a string.

**Inputs:**

* **A_Clk**: Clock signal for port A
* **A_Addr**: Address signal for port A
* **A_Be**: Byte enable signal for port A (optional)
* **A_WrEna**: Write enable signal for port A
* **A_WrData**: Write data signal for port A
* **B_Clk**: Clock signal for port B
* **B_Addr**: Address signal for port B
* **B_Be**: Byte enable signal for port B (optional)
* **B_WrEna**: Write enable signal for port B
* **B_WrData**: Write data signal for port B

**Outputs:**

* **A_RdData**: Read data signal for port A
* **B_RdData**: Read data signal for port B

**Generics:**

* **Depth_g**: Depth of the RAM (number of","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_tdp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );                                                      -- ""RBW"" = read-before-write, ""WBR"" = write-before-read
    port (
        A_Clk     : in    std_logic;
        A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        A_Be      : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        A_WrEna   : in    std_logic                                  := '0';
        A_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
        A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
        B_Clk     : in    std_logic;
        B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        B_Be      : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        B_WrEna   : in    std_logic                                  := '0';
        B_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
        B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_tdp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_tdp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            A_Clk     : in    std_logic;
            A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            A_WrEna   : in    std_logic                                  := '0';
            A_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
            A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
            B_Clk     : in    std_logic;
            B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            B_WrEna   : in    std_logic                                  := '0';
            B_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
            B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_tdp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_tdp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                A_Clk     => A_Clk,
                A_Addr    => A_Addr,
                A_WrEna   => A_WrEna,
                A_WrData  => A_WrData,
                A_RdData  => A_RdData,
                B_Clk     => B_Clk,
                B_Addr    => B_Addr,
                B_WrEna   => B_WrEna,
                B_WrData  => B_WrData,
                B_RdData  => B_RdData
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal A_WrEna_Byte : std_logic;
            signal B_WrEna_Byte : std_logic;
        begin
            A_WrEna_Byte <= A_WrEna and A_Be(byte);
            B_WrEna_Byte <= B_WrEna and B_Be(byte);

            i_ram : component olo_private_ram_tdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => 8*byte
                )
                port map (
                    A_Clk     => A_Clk,
                    A_Addr    => A_Addr,
                    A_WrEna   => A_WrEna_Byte,
                    A_WrData  => A_WrData(8*(byte+1)-1 downto 8*byte),
                    A_RdData  => A_RdData(8*(byte+1)-1 downto 8*byte),
                    B_Clk     => B_Clk,
                    B_Addr    => B_Addr,
                    B_WrEna   => B_WrEna_Byte,
                    B_WrData  => B_WrData(8*(byte+1)-1 downto 8*byte),
                    B_RdData  => B_RdData(8*(byte+1)-1 downto 8*byte)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_tdp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        A_Clk     : in    std_logic;
        A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        A_WrEna   : in    std_logic                              := '0';
        A_WrData  : in    std_logic_vector(Width_g - 1 downto 0) := (others => '0');
        A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
        B_Clk     : in    std_logic;
        B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        B_WrEna   : in    std_logic                              := '0';
        B_WrData  : in    std_logic_vector(Width_g - 1 downto 0) := (others => '0');
        B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_tdp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipeA, RdPipeB : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipeA : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RdPipeB : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_tdp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_tdp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    g_wbr : if RamBehavior_g = ""WBR"" generate

        p_porta : process (A_Clk) is
        begin
            if rising_edge(A_Clk) then
                if A_WrEna = '1' then
                    Mem_v(to_integer(unsigned(A_Addr))) := A_WrData;
                end if;
                RdPipeA(1) <= Mem_v(to_integer(unsigned(A_Addr)));

                RdPipeA(2 to RdLatency_g) <= RdPipeA(1 to RdLatency_g-1);
            end if;
        end process;

        p_portb : process (B_Clk) is
        begin
            if rising_edge(B_Clk) then
                if B_WrEna = '1' then
                    Mem_v(to_integer(unsigned(B_Addr))) := B_WrData;
                end if;
                RdPipeB(1) <= Mem_v(to_integer(unsigned(B_Addr)));

                RdPipeB(2 to RdLatency_g) <= RdPipeB(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    g_rbw : if RamBehavior_g = ""RBW"" generate

        p_porta : process (A_Clk) is
        begin
            if rising_edge(A_Clk) then
                RdPipeA(1) <= Mem_v(to_integer(unsigned(A_Addr)));
                if A_WrEna = '1' then
                    Mem_v(to_integer(unsigned(A_Addr))) := A_WrData;
                end if;

                RdPipeA(2 to RdLatency_g) <= RdPipeA(1 to RdLatency_g-1);
            end if;
        end process;

        p_portb : process (B_Clk) is
        begin
            if rising_edge(B_Clk) then
                RdPipeB(1) <= Mem_v(to_integer(unsigned(B_Addr)));
                if B_WrEna = '1' then
                    Mem_v(to_integer(unsigned(B_Addr))) := B_WrData;
                end if;

                RdPipeB(2 to RdLatency_g) <= RdPipeB(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    A_RdData <= RdPipeA(RdLatency_g);
    B_RdData <= RdPipeB(RdLatency_g);

end architecture;",36
"This component generates reset pulses of a specified minimum duration after FPGA configuration and optionally upon request (reset input). The component does guarantee synchronous de-assertion of the reset. Assertion is asynchronous or synchronous, depending on the users choice. **Note:** Because the reset input is detected asynchronously, it is important that this input is glitch-free. The block comes with automatic constraints. For manual constraining, a  or a constraint is required for the _RstIn_ input (if it is used). **Note:** Automatic constraining currently only works for _AMD_ tools (_Vivado_) and the usage in VHDL. Manual constraints are required for Verilog or other tools. **WARNING:** Reset assertion upon FPGA configuration relies on the **target technology supporting specific FF initialization state**. For the most common target technologies (namely AMD and altera) this is given. However, for technologies which do not support specifying FF initialization state (e.g. Microchip devices) an external reset signal must be connected to _RstIn_ - _RstOut_ will not be asserted upon FPGA configuration. If in doubt, refer to the the documentation of your target technology or play it safe and connect _RstIn_.

# VHDL Analysis for 'olo_base_reset_gen.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024-2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a reset generator. It generates a pulse of the specified duration
- after FPGA configuration. The reset output is High-Active according to the
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_attribute.all

## Entity: olo_base_reset_gen

## Architecture: struct of olo_base_reset_gen

### Signals
- RstSyncChain: std_logic_vector(2 downto 0)              := ""111""
- RstSync: std_logic
- DsSync: std_logic_vector(SyncStages_g-1 downto 0) := (others => '1')
- PulseCnt: integer range 0 to PulseCntMax_c := 0
- RstPulse: std_logic                        := '1'
- is ShregExtract_SuppressExtraction_c;
    attribute syn_srlstyle of DsSync: signal is SynSrlstyle_FlipFlops_c
- is DontMerge_SuppressChanges_c;
    attribute preserve of DsSync: signal is Preserve_SuppressChanges_c
- is SynPreserve_SuppressChanges_c;
    attribute syn_keep of DsSync: signal is SynKeep_SuppressChanges_c
- is AsyncReg_TreatAsync_c;

begin

    -- Reset Synchronizer
    p_rstsync: process (Clk, RstIn) is
    begin
        if RstIn = RstInPolarity_g then
            RstSyncChain <= (others => '1')

### Processes
- Process 'p_rstsync :' (Clocked) (Has Reset) with sensitivity list: Clk, RstIn
  - Implements synchronous logic
- Process 'p_sync :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_prolong :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_rstsync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_sync :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'p_prolong :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- elsif rising_edge(Clk) then
            RstSyncChain <= RstSyncChain(RstSyncChain'left - 1 downto 0) & '0'

## Functional Analysis

- Contains 2 clock domain(s): clock, Clk
- Uses reset signal(s): RstPulseCycles_g, olo_base_reset_gen, RstSync, resets, reset, Reset, p_rstsync, RstOut, RstSyncChain, RstIn, RstPulse, RstInPolarity_g, AsyncResetOutput_g

## Code Metrics
- Line count: 150
- Process count: 6
- Signal count: 9

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_reset_gen.vhd' plays a specific role in the overall CPU architecture.
","**Technical Description:**
The `olo_base_reset_gen` component is a reset generator that produces a synchronized reset output (`RstOut`) based on an asynchronous reset input (`RstIn`) and a clock input (`Clk`). It can generate a reset pulse of programmable duration and provides options for asynchronous or synchronous reset output.

**Component Specification:**

**Component Name:** Reset Generator

**Functionality:**

* Generates a synchronized reset output (`RstOut`) based on an asynchronous reset input (`RstIn`) and a clock input (`Clk`)
* Produces a reset pulse of programmable duration (`RstPulseCycles_g`)
* Supports asynchronous or synchronous reset output (`AsyncResetOutput_g`)

**Inputs:**

* `Clk`: Clock input (std_logic)
* `RstIn`: Asynchronous reset input (std_logic), default polarity is active high (`RstInPolarity_g`)

**Outputs:**

* `RstOut`: Synchronized reset output (std_logic)

**Parameters:**

* `RstPulseCycles_g`: Programmable reset pulse duration (positive integer, range: 3 to infinity), default: 3
* `RstInPolarity_g`: Reset input polarity (std_logic, default: '1' for active high)
* `AsyncResetOutput_g`: Asynchronous reset output flag (boolean, default: false)
* `SyncStages_g`: Number of synchronization stages (positive integer, range: 2 to 4), default: 2

**Behavior:**

* When","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;

entity olo_base_reset_gen is
    generic (
        RstPulseCycles_g    : positive range 3 to positive'high := 3;
        RstInPolarity_g     : std_logic                         := '1';
        AsyncResetOutput_g  : boolean                           := false;
        SyncStages_g        : positive range 2 to 4             := 2
    );
    port (
        Clk         : in    std_logic;
        RstOut      : out   std_logic;
        RstIn       : in    std_logic := not RstInPolarity_g
    );
end entity;

architecture struct of olo_base_reset_gen is

    signal RstSyncChain : std_logic_vector(2 downto 0)              := ""111"";
    signal RstSync      : std_logic;
    signal DsSync       : std_logic_vector(SyncStages_g-1 downto 0) := (others => '1');

    constant PulseCntMax_c : natural                          := max(RstPulseCycles_g-4, 0);
    signal PulseCnt        : integer range 0 to PulseCntMax_c := 0;
    signal RstPulse        : std_logic                        := '1';

    attribute shreg_extract of DsSync : signal is ShregExtract_SuppressExtraction_c;
    attribute syn_srlstyle of DsSync  : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of DsSync   : signal is DontMerge_SuppressChanges_c;
    attribute preserve of DsSync     : signal is Preserve_SuppressChanges_c;
    attribute syn_preserve of DsSync : signal is SynPreserve_SuppressChanges_c;
    attribute syn_keep of DsSync     : signal is SynKeep_SuppressChanges_c;

    attribute async_reg of DsSync : signal is AsyncReg_TreatAsync_c;

begin

    p_rstsync : process (Clk, RstIn) is
    begin
        if RstIn = RstInPolarity_g then
            RstSyncChain <= (others => '1');
        elsif rising_edge(Clk) then
            RstSyncChain <= RstSyncChain(RstSyncChain'left - 1 downto 0) & '0';
        end if;
    end process;

    g_async : if AsyncResetOutput_g generate
        RstSync <= RstSyncChain(RstSyncChain'left);
    end generate;

    g_sync : if not AsyncResetOutput_g generate

        p_sync : process (Clk) is
        begin
            if rising_edge(Clk) then
                DsSync <= DsSync(DsSync'left - 1 downto 0) & RstSyncChain(RstSyncChain'left);
            end if;
        end process;

        RstSync <= DsSync(DsSync'left);
    end generate;

    g_prolong : if RstPulseCycles_g > 3 generate

        p_prolong : process (Clk) is
        begin
            if rising_edge(Clk) then
                if RstSync = '1' then
                    PulseCnt <= 0;
                    RstPulse <= '1';
                else
                    if PulseCnt = PulseCntMax_c then
                        RstPulse <= '0';
                    else
                        PulseCnt <= PulseCnt + 1;
                    end if;
                end if;
            end if;
        end process;

        g_async : if AsyncResetOutput_g generate
            RstOut <= RstPulse or RstSync;

        end generate;

        g_sync : if not AsyncResetOutput_g generate
            RstOut <= RstPulse;
        end generate;

    end generate;

    g_direct : if RstPulseCycles_g <= 3 generate
        RstOut <= RstSync;
    end generate;

end architecture;",37
"This component takes single-cycle pulses as inputs and divides the pulse frequency. The ratio can be configured at runtime or at compile-time. To use the compile-time variant, just leave the _In_Ratio_ port unconnected and assign the ratio to _MaxRatio_g_. The latency can be selected to be 0 (combinatorial output) or 1 (registered output) clock cycle through the generic _Latency_g_. Registered output (_Latency_g_=1) is preferred for timing optimization reasons. Below figure shows an example for a ratio of 3. The entity can also be used to convert single cycle pulses into pulses that stay active until acknowledged by _Out_Ready_='1'. For this usage, simply use _MaxRatio_g=1_ and leave _In_Ratio_ unconnected. Note that for runtime configurable ratio, _In_Ratio_ must be set to the **desired ratio minus one**. E.g. to forward every third pulse to the output, _In_Ratio_ must be set to 2.

# VHDL Analysis for 'olo_base_strobe_div.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef, Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic strobe divider. It forwards only every Nth single
- cycle pulse to the output.
- Plus 20 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_strobe_div

## Architecture: rtl of olo_base_strobe_div

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
        r_next <= v;
    end process;

    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' with sensitivity list: r, In_Valid, In_Ratio, Out_Ready
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Ratio Counter
        if In_Valid = '1' then
            if r.Count >= unsigned(In_Ratio) or MaxRatio_g = 1 then
                v.Count    := 0
- v.OutValid := '1'
- else
                v.Count := r.Count + 1

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 110
- Process count: 4
- Signal count: 3

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_strobe_div.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_strobe_div` component is a digital circuit that generates a strobe signal (`Out_Valid`) based on a input ratio (`In_Ratio`) and a clock signal (`Clk`). It essentially acts as a programmable divider, producing an output strobe at a rate defined by the input ratio. The component also features a configurable latency and a ready input (`Out_Ready`) to control the output strobe.

**Component Specification**

**Component Name:** olo_base_strobe_div

**Functionality:** Programmable strobe divider

**Inputs:**

* `Clk`: Clock signal (std_logic)
* `Rst`: Reset signal (std_logic)
* `In_Ratio`: Input ratio (std_logic_vector, width: log2ceil(MaxRatio_g))
* `In_Valid`: Input valid signal (std_logic)
* `Out_Ready`: Output ready signal (std_logic, default: '1')

**Outputs:**

* `Out_Valid`: Output strobe signal (std_logic)

**Generics:**

* `MaxRatio_g`: Maximum ratio value (positive integer)
* `Latency_g`: Output latency (natural, range: 0 to 1, default: 1)

**Behavior:**

1. The component generates an output strobe (`Out_Valid`) based on the input ratio (`In_Ratio`) and the clock signal (`Clk`).
2. When `In_Valid` is high, the component increments a counter","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_strobe_div is
    generic (
        MaxRatio_g  : positive;
        Latency_g   : natural range 0 to 1 := 1
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Ratio    : in    std_logic_vector(log2ceil(MaxRatio_g)-1 downto 0) := toUslv(MaxRatio_g-1, log2ceil(MaxRatio_g));
        In_Valid    : in    std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic                                         := '1'
    );
end entity;

architecture rtl of olo_base_strobe_div is

    type TwoProcess_r is record
        Count    : natural range 0 to MaxRatio_g-1;
        OutValid : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    p_comb : process (r, In_Valid, In_Ratio, Out_Ready) is
        variable OutValid_v : std_logic;
        variable v          : TwoProcess_r;
    begin
        v := r;

        if In_Valid = '1' then
            if r.Count >= unsigned(In_Ratio) or MaxRatio_g = 1 then
                v.Count    := 0;
                v.OutValid := '1';
            else
                v.Count := r.Count + 1;
            end if;
        end if;

        if Latency_g = 0 then
            OutValid_v := v.OutValid;
        else
            OutValid_v := r.OutValid;
        end if;

        if OutValid_v = '1' and Out_Ready = '1' then
            v.OutValid := '0';
        end if;

        Out_Valid <= OutValid_v;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Count    <= 0;
                r.OutValid <= '0';
            end if;
        end if;
    end process;

end architecture;",38
"This component generates pulse at a fixed frequency. It optionally allows synchronization of those events to an input. In the most simple use-case, single cycle pulses are generated free-running at a fixed frequency. To achieve this, _Out_Ready_ and _In_Sync_ can be left unconnected. Bellow figure depicts this situation for _FreqClkHz_g=5e6_ and _FreqStrobeHz_g=1e6_. Additionally the strobe phase can be synchronized to _In_Sync_. In this case, the event is synchronized to the rising edge of the _In_Sync_ input. If the _Out_Ready_ signal is connected, _Out_Valid_ stays asserted until _Out_Ready_ and _Out_Valid_ are asserted at the same time (AXI4-Stream hanshaking). Note that in this case, the rising edges of _Out_Valid_ occur at _FreqStrobeHz_g_ independently of how long the signal stays asserted. However, _Out_Ready_ and _In_Sync_ are optional signals and can be left unconnected in the standard-case where just a pulse with a known frequency is required. The strobe generator by default works in _aequidistant mode_: It produces _Out_Valid_ pulses that are always the same number of clock-cycles apart from each other. This has the down-side of the output strobe period being off by up to half a clock period - which finally leads to a slightly shifted frequency. Alternatively the strobe generator can be used in _fractional mode_ (by setting _FractionalMode_g=true_). In this mode, the strobe generator does vary the time between _Out_Valid_ pulses by one clock cycle to meet the _FreqStrobeHz_g_ with less than 1% of error _on average_ (over a long time). Use _fractional mode_ if _FreqStrobeHz_g_ is relatively close to _FreqClkHz_g_ and the exact strobe frequency is important. Use _aequidistant mode_ if a constant number of clock cycles between _Out_Valid_ pulses is required.

# VHDL Analysis for 'olo_base_strobe_gen.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef, Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic strobe generator. It produces pulses with a duration
- Plus 22 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_strobe_gen

## Architecture: rtl of olo_base_strobe_gen

### Signals
- Declarations
    signal Count: integer range 0 to PeriodCounts_c-1
- SyncLast: std_logic

### Processes
- Process 'p_strobe :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_strobe :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

### Concurrent Statements
- Out_Valid <= '1'
- -- Wraparound
            elsif Count >= WrapBorder_c then
                Out_Valid <= '1'
- if FractionalMode_g then
                    Count <= Count - WrapBorder_c
- else
                    Count <= 0

## Functional Analysis

- Contains 2 clock domain(s): clock, Clk
- Uses reset signal(s): Reset, Rst

## Code Metrics
- Line count: 104
- Process count: 2
- Signal count: 2

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_strobe_gen.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_strobe_gen` component is a clocked strobe generator that produces a valid output signal (`Out_Valid`) at a specified frequency (`FreqStrobeHz_g`) based on a reference clock frequency (`FreqClkHz_g`). The component has inputs for clock (`Clk`), reset (`Rst`), synchronization (`In_Sync`), and output ready (`Out_Ready`), and outputs a valid signal (`Out_Valid`).

**Component Specification**

**Component Name:** `olo_base_strobe_gen`

**Functionality:** Clocked strobe generator

**Inputs:**

* `Clk`: Clock input (std_logic)
* `Rst`: Reset input (std_logic)
* `In_Sync`: Synchronization input (std_logic, default='0')
* `Out_Ready`: Output ready input (std_logic, default='1')

**Outputs:**

* `Out_Valid`: Valid output signal (std_logic)

**Generics:**

* `FreqClkHz_g`: Reference clock frequency (real)
* `FreqStrobeHz_g`: Desired strobe frequency (real)
* `FractionalMode_g`: Fractional mode enable (boolean, default=false)

**Behavior:**

* The component generates a strobe signal (`Out_Valid`) at a frequency of `FreqStrobeHz_g` based on the reference clock frequency `FreqClkHz_g`.
* The strobe signal is synchronized with the `In_Sync` input.
* The component has a reset","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_strobe_gen is
    generic (
        FreqClkHz_g      : real;
        FreqStrobeHz_g   : real;
        FractionalMode_g : boolean := false
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Sync     : in    std_logic := '0';
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1'
    );
end entity;

architecture rtl of olo_base_strobe_gen is

    constant PeriodCountsFractional_c : integer := integer(round(FreqClkHz_g*100.0 / FreqStrobeHz_g));
    constant PeriodCountsInteger_c    : integer := integer(round(FreqClkHz_g / FreqStrobeHz_g));
    constant PeriodCounts_c           : integer := choose(FractionalMode_g, PeriodCountsFractional_c, PeriodCountsInteger_c);

    constant Increment_c  : integer := choose(FractionalMode_g, 100, 1);
    constant WrapBorder_c : integer := PeriodCounts_c - Increment_c;

    signal Count    : integer range 0 to PeriodCounts_c-1;
    signal SyncLast : std_logic;

begin

    p_strobe : process (Clk) is
    begin
        if rising_edge(Clk) then
            if (In_Sync = '1') and (SyncLast = '0') then
                Count     <= 0;
                Out_Valid <= '1';
            elsif Count >= WrapBorder_c then
                Out_Valid <= '1';
                if FractionalMode_g then
                    Count <= Count - WrapBorder_c;
                else
                    Count <= 0;
                end if;
            else
                if Out_Ready = '1' then
                    Out_Valid <= '0';
                end if;
                Count <= Count + Increment_c;
            end if;
            SyncLast <= In_Sync;

            if Rst = '1' then
                Count     <= 0;
                Out_Valid <= '0';
                SyncLast  <= '0';
            end if;
        end if;
    end process;

end architecture;",39
"This component allows selecting one unique channel over a bunch of ""N"" time division multiplexed (tdm, see [Conventions](../Conventions.md)) data. Note that the number of channels must be compile-time defined (i.e. the entity does not support variable number of channels at run-time). The select signal _In_ChSel_ is sampled when the data of the first channel of a TDM burst arrives. The output _Out_Data_/_Out_Valid_ is asserted after the last channel of a TDM burst was received. The state of the _In_ChSel_ signal in between the _CH0_ inputs (where it is sampled) does not have any effect as depicted by the figure below. The entity does automatically synchronize the channel counter to _In_Last_. However, it can also be used in absence of _In_Last_. In this case the first sample after reset is interpreted as channel 0 and the channel-counter is freerunning. If _In_Last_ is asserted on the last channel in a TDM burst, the corresponding output hast _Out_Last_ asserted (independently of which channel was selected). This behavior allows to signal packet-boundaries throughout the _olo_base_tdm_mux_.

# VHDL Analysis for 'olo_base_tdm_mux.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Benoit Stef
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This is a very basic mux for Time Division Multiplxed data input
- Plus 23 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all

## Entity: olo_base_tdm_mux

## Architecture: rtl of olo_base_tdm_mux

### Signals
- Count_0: integer range 0 to Channels_g-1 := 0
- SelLatched_1: std_logic_vector(In_ChSel'range)
- Data_1: std_logic_vector(In_Data'range)
- Count_1: integer range 0 to Channels_g-1
- Vld_1: std_logic
- Last_1: std_logic
- Data_2: std_logic_vector(In_Data'range)
- Vld_2: std_logic
- Last_2: std_logic

### Processes
- Process 'p_decode :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic with reset
- Process 'p_decode :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic with reset

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst
- May be part of a pipeline architecture

## Code Metrics
- Line count: 118
- Process count: 2
- Signal count: 9

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_tdm_mux.vhd' plays a specific role in the overall CPU architecture.
","**Component Description:**
The `olo_base_tdm_mux` component is a Time Division Multiplexer (TDM) that selects and outputs data from multiple channels based on a channel selection input. It takes in a data stream, channel selection signal, and validity signals, and outputs the selected channel's data, validity, and last data indicators. The component is designed to handle a variable number of channels and data widths.

**Inputs:**

* `Clk`: Clock signal
* `Rst`: Reset signal
* `In_ChSel`: Channel selection signal (log2ceil(Channels_g) bits)
* `In_Valid`: Input data validity signal (default: '1')
* `In_Data`: Input data signal (Width_g bits)
* `In_Last`: Input last data indicator signal (default: '0')

**Outputs:**

* `Out_Valid`: Output data validity signal
* `Out_Data`: Output data signal (Width_g bits)
* `Out_Last`: Output last data indicator signal

**Functionality:**

1. The component receives input data and channel selection signals.
2. It uses a counter to keep track of the current channel being processed.
3. When a new input data is received, it latches the channel selection signal and increments the counter.
4. When the counter matches the channel selection signal, the corresponding input data is selected and output.
5. The component also generates output validity and last data indicator signals based on the input signals.

**Component Specification:**","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_tdm_mux is
    generic (
        Channels_g  : natural;
        Width_g     : natural
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_ChSel    : in    std_logic_vector(log2ceil(Channels_g)-1 downto 0);
        In_Valid    : in    std_logic := '1';
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        In_Last     : in    std_logic := '0';
        Out_Valid   : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0);
        Out_Last    : out   std_logic
    );
end entity;

architecture rtl of olo_base_tdm_mux is

    signal Count_0      : integer range 0 to Channels_g-1 := 0;
    signal SelLatched_1 : std_logic_vector(In_ChSel'range);
    signal Data_1       : std_logic_vector(In_Data'range);
    signal Count_1      : integer range 0 to Channels_g-1;
    signal Vld_1        : std_logic;
    signal Last_1       : std_logic;
    signal Data_2       : std_logic_vector(In_Data'range);
    signal Vld_2        : std_logic;
    signal Last_2       : std_logic;

begin

    p_decode : process (Clk) is
    begin
        if rising_edge(Clk) then

            if In_Valid = '1' then
                if Count_0 = 0 then
                    SelLatched_1 <= In_ChSel;
                end if;
                if (Count_0 = Channels_g-1) or (In_Last = '1') then
                    Count_0 <= 0;
                else
                    Count_0 <= Count_0 + 1;
                end if;
            end if;
            Data_1  <= In_Data;
            Vld_1   <= In_Valid;
            Count_1 <= Count_0;
            Last_1  <= In_Last;

            if Count_1 = unsigned(SelLatched_1) then
                Data_2 <= Data_1;
            end if;
            Vld_2 <= '0';
            if Vld_1 = '1' and Count_1 = Channels_g-1 then
                Vld_2 <= '1';
            end if;
            Last_2 <= Last_1;

            if Rst = '1' then
                Count_0 <= 0;
                Vld_2   <= '0';
                Vld_1   <= '0';
            end if;
        end if;
    end process;

    Out_Valid <= Vld_2;
    Out_Data  <= Data_2;
    Out_Last  <= Last_2;

end architecture;",40
"This component implements a width conversion between arbitrary word widths. It can handle continuous or packetized data-streams and optionally supports the usage of byte-enable signals (for input and output widths being a multiple of 8-bits only). The width conversion implements AXI-S handshaking signals to handle back-pressure. The with conversion supports back-to-back conversions (_In_Valid_ can stay high all the time). It also handles the last-flag correctly according to AXI-S specification. If _In_Last_ is asserted, all data is flushed out and _Out_Last_ is asserted accordingly. Usage examples: - Conversion from 8-bit (byte oriented) data to 7-bit for the usage with 7-bit LVDS serializers - Conversion from 24-bit to 32-bit in order to write 24-bit video pixel-data efficiently to a 32-bit wide memory Note that for integer ratio width conversions, [olo_base_wconv_n2xn](./olo_base_wconv_n2xn.md) and [olo_base_wconv_xn2n](./olo_base_wconv_xn2n.md) shall be used because they are more resource efficient and timing optimal. The entity does little-endian data alignment as shown in the figures below (the first word received on the input is packet into the output bits with the lowest index). Below example shows a conversion from 16 to 24 bit. Backpressure (_Out_Ready_ going low) is not depicted for simplicity reasons (but fully supported by the implementation). Interesting is the last packet (blue) which contains an all zero word at the end, because without byte enable from the input data 0x**00**66 it cannot be known if the zeros represent a data byte being zero or if it is a padding byte. Similarly in the last output word of the orange packet, two padding bytes are inserted (0x**0000**DD) but to a receiver this might not be clear due to the missing byte enables. Below example is similar but uses byte enables to indicate padding bytes on the input as well as on the output. The blue packet is now also shorter by one cycle because padding bytes at the end of the packet are removed. Byte enables (_UseBe_g=true_) are only supported when both, _InWidth_g_ and _OutWidth_g_, are multiples of 8. For inputs or outputs not being mutiples of bytes, the behavior of _In_Be_ and _Out_Be_ byte-enable signals is undefined. **The usage of byte-enables is limited to indicating that not all bytes are used in the last beat of a packet**. Any _In_Be_ being low in any other word of a packet than the last one (_In_Last='1'_) are not allowed and will lead to error messages in simulations as well as undefined behavior in synthesis. _olo_Base_wconv_n2m_ can be used for non-byte-aligned data as well. In this case byte enables are not supported, otherwise the block behaves the same as for byte-oriented data. Backpressure (_Out_Ready_ going low) is not depicted for simplicity reasons (but fully supported by the implementation). Below example shows a 8-bit to 7-bit conversion, as required for 7-bit LVDS serializers. And of course the conversion into the other direction (7-bit to 8-bit) is possible as well:$

# VHDL Analysis for 'olo_base_wconv_n2m.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2025 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple data-width conversion between arbitrary input and output
- widths.
- Plus 35 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: ieee.std_logic_misc.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_wconv_n2m

## Architecture: rtl of olo_base_wconv_n2m

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
            r_next <= v;
        end process;

        p_seq: process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Valid, In_Data, Out_Ready, In_Last, In_Be, Rst
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Output transaction
            Out_Valid_v  := '0'
- IsLastBeat_v := or_reduce(r.LastChunk(OutChunks_c - 1 downto 0))
- if (r.ChunkCnt >= OutChunks_c) or (IsLastBeat_v = '1') then
                Out_Valid_v := '1'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 204
- Process count: 4
- Signal count: 3

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_wconv_n2m.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Width Conversion Module (`olo_base_wconv_n2m`)**

**Overview**

The `olo_base_wconv_n2m` module is a digital design component that performs width conversion on input data streams. It takes in data of a certain width and converts it to a different width, handling data alignment and chunking as necessary.

**Functional Description**

The module operates in two primary modes:

1. **Width Conversion Mode** (`OutWidth_g /= InWidth_g`): In this mode, the module converts input data from a narrower width (`InWidth_g`) to a wider width (`OutWidth_g`). It uses a shift register to store and align data chunks, ensuring proper data formatting and padding.
2. **Pass-Through Mode** (`OutWidth_g = InWidth_g`): When the input and output widths are equal, the module simply passes the input data through to the output without modification.

**Inputs**

* `Clk`: Clock signal
* `Rst`: Reset signal
* `In_Valid`: Input data validity signal (default: '1')
* `In_Data`: Input data (`std_logic_vector(InWidth_g - 1 downto 0)`)
* `In_Be`: Input byte enables (`std_logic_vector(InWidth_g / 8 - 1 downto 0)`, default: all '1's)
* `In_Last`: Input last beat signal (default: '0')

**Outputs**

* `Out_Valid`:","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;
    use ieee.std_logic_misc.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_n2m is
    generic (
        InWidth_g  : positive := 16;
        OutWidth_g : positive := 24;
        UseBe_g    : boolean  := false
    );
    port (
        Clk          : in    std_logic;
        Rst          : in    std_logic;
        In_Valid     : in    std_logic                                    := '1';
        In_Ready     : out   std_logic;
        In_Data      : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Be        : in    std_logic_vector(InWidth_g / 8 - 1 downto 0) := (others => '1');
        In_Last      : in    std_logic                                    := '0';
        Out_Valid    : out   std_logic;
        Out_Ready    : in    std_logic                                    := '1';
        Out_Data     : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Be       : out   std_logic_vector(OutWidth_g / 8 - 1 downto 0);
        Out_Last     : out   std_logic
    );
end entity;

architecture rtl of olo_base_wconv_n2m is

    constant MaxChunkSize_c : positive := greatestCommonFactor(InWidth_g, OutWidth_g);
    constant ChunkSize_c    : positive := choose(UseBe_g, 8, MaxChunkSize_c);
    constant SrWidth_c      : positive := choose(OutWidth_g > InWidth_g, 2*OutWidth_g, OutWidth_g+InWidth_g);
    constant OutChunks_c    : positive := OutWidth_g / ChunkSize_c;
    constant InChunks_c     : positive := InWidth_g / ChunkSize_c;

    type TwoProcess_r is record
        ChunkCnt    : integer range 0 to SrWidth_c / ChunkSize_c - 1;
        ShiftReg    : std_logic_vector(SrWidth_c - 1 downto 0);
        LastChunk   : std_logic_vector(SrWidth_c / ChunkSize_c - 1 downto 0);
        LastPending : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert (UseBe_g = false) or ((InWidth_g mod 8 = 0) and (OutWidth_g mod 8 = 0))
        report ""olo_base_wconv_n2m: Byte Enables are only supported for byte-aligned InWidht_g and OutWidth_g""
        severity failure;

    g_convert : if OutWidth_g /= InWidth_g generate

        p_comb : process (r, In_Valid, In_Data, Out_Ready, In_Last, In_Be, Rst) is
            variable v            : TwoProcess_r;
            variable Out_Valid_v  : std_logic;
            variable Offset_v     : natural range 0 to SrWidth_c - 1;
            variable IsLastBeat_v : std_logic;
        begin
            v := r;

            Out_Valid_v  := '0';
            IsLastBeat_v := or_reduce(r.LastChunk(OutChunks_c - 1 downto 0));
            if (r.ChunkCnt >= OutChunks_c) or (IsLastBeat_v = '1') then
                Out_Valid_v := '1';
            end if;
            if Out_Valid_v = '1' and Out_Ready = '1' then
                if IsLastBeat_v = '1' then
                    v.ChunkCnt    := 0;
                    v.ShiftReg    := (others => '0');
                    v.LastChunk   := (others => '0');
                    v.LastPending := '0';
                else
                    v.ChunkCnt  := r.ChunkCnt - OutChunks_c;
                    v.ShiftReg  := zerosVector(OutWidth_g) & r.ShiftReg(r.ShiftReg'high downto OutWidth_g);
                    v.LastChunk := zerosVector(OutChunks_c) & r.LastChunk(r.LastChunk'high downto OutChunks_c);
                end if;
            end if;
            Out_Valid <= Out_Valid_v;
            Out_Data  <= r.ShiftReg(OutWidth_g - 1 downto 0);
            Out_Last  <= IsLastBeat_v;
            if UseBe_g = true then
                Out_Be <= (others => '0');

                for byte in 0 to OutChunks_c-1 loop
                    Out_Be(byte) <= '1';
                    if r.LastChunk(byte) = '1' then
                        exit;
                    end if;
                end loop;

            else
                Out_Be <= (others => '1');
            end if;

            In_Ready <= '0';
            if (v.ChunkCnt < OutChunks_c) and (v.LastPending = '0') then

                In_Ready <= not Rst;
                if In_Valid = '1' then
                    Offset_v                                             := v.ChunkCnt*ChunkSize_c;
                    v.ShiftReg(Offset_v + InWidth_g - 1 downto Offset_v) := In_Data;

                    if UseBe_g = true then
                        assert (In_Last = '1') or (In_Be = onesVector(In_Be'length))
                            report ""olo_base_wconv_n2m: Incomplete byte enables are only supported for last beat""
                            severity failure;
                        v.LastChunk(v.ChunkCnt + InChunks_c-1) := In_Last;

                        for byte in 0 to InChunks_c-2 loop
                            if In_Be(byte) = '1' and In_Be(byte+1) = '0' then
                                v.LastChunk(v.ChunkCnt + byte)         := In_Last; -- set last chunk
                                v.LastChunk(v.ChunkCnt + InChunks_c-1) := '0'; -- override default
                                exit;
                            end if;
                        end loop;

                    else
                        v.LastChunk(v.ChunkCnt + InChunks_c-1) := In_Last;
                    end if;
                    v.ChunkCnt    := v.ChunkCnt + InChunks_c;
                    v.LastPending := In_Last;
                end if;
            end if;

            r_next <= v;
        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.ShiftReg    <= (others => '0');
                    r.ChunkCnt    <= 0;
                    r.LastChunk   <= (others => '0');
                    r.LastPending <= '0';
                end if;
            end if;
        end process;

    end generate;

    g_equalwidth : if OutWidth_g = InWidth_g generate
        Out_Valid <= In_Valid;
        Out_Data  <= In_Data;
        Out_Last  <= In_Last;
        In_Ready  <= Out_Ready;

    end generate;

end architecture;",41
"This component implements a data width conversion from N-bits to a multiple of N-bits. The sample rate (_Valid_ pulse rate) is reduced accordingly. The width conversion implements AXI-S handshaking signals to handle back-pressure. This block can also be used for _TDM to Parallel_ conversion (see [Conventions](../Conventions.md)) The with conversion supports back-to-back conversions (_In_Valid_ can stay high all the time). It also handles the last-flag correctly according to AXI specification. If _In_Last_ is asserted, all data is flushed out and the word enabled (_Out_WordEna_) at the output are set only for words that contain data. _Out_Last_ is asserted accordingly. Note that insteady of byte-enables, a word enable (_Out_WordEna_)  is implemented. It signals the validity of data on the granularity of _In_Data_ words. This concept allows to correctly handle any data-widths, not only multiple of bytes. The entity does little-endian data alignment as shown in the figure below. The figure depicts operation of the block without backpressure (_Out_Ready_ continuously high) and for a width-conversion from 4 to 8 bits. This entity does only do a width conversion but not clock crossing. If a half-clock-double-width conversion is used, [olo_base_cc_xn2n](./olo_base_cc_xn2n.md) component can be used after the width conversion.

# VHDL Analysis for 'olo_base_wconv_n2xn.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple data-width conversion. The output width
- Plus 24 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_wconv_n2xn

## Architecture: rtl of olo_base_wconv_n2xn

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
            r_next <= v;
        end process;

        p_seq: process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r, In_Valid, In_Data, Out_Ready, In_Last
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Halt detection
            ShiftDone_v := (r.DataVld(r.DataVld'high) = '1') or (r.DataLast = '1')
- if ShiftDone_v and (r.Out_Valid = '1') and (Out_Ready = '0') then
                IsStuck_v := '1'
- else
                IsStuck_v := '0'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Reset, Rst

## Code Metrics
- Line count: 170
- Process count: 4
- Signal count: 3

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_wconv_n2xn.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Word Converter (olo_base_wconv_n2xn)**

**Functionality:**
The olo_base_wconv_n2xn component is a digital circuit that performs a word conversion function, specifically designed to convert a narrow input data bus to a wider output data bus. It receives input data in a sequence of beats, where each beat consists of a fixed-width data word, and outputs a single beat with a wider data word.

**Inputs:**

* **Clk**: Clock signal (std_logic)
* **Rst**: Reset signal (std_logic)
* **In_Valid**: Input data validity signal (std_logic, default='1')
* **In_Data**: Input data bus (std_logic_vector, width=InWidth_g)
* **In_Last**: Input last beat indicator (std_logic, default='0')

**Outputs:**

* **In_Ready**: Input ready signal (std_logic)
* **Out_Valid**: Output data validity signal (std_logic)
* **Out_Data**: Output data bus (std_logic_vector, width=OutWidth_g)
* **Out_Last**: Output last beat indicator (std_logic)
* **Out_WordEna**: Output word enable signal (std_logic_vector, width=OutWidth_g / InWidth_g)

**Parameters:**

* **InWidth_g**: Input data bus width (positive integer)
* **OutWidth_g**: Output data bus width (positive integer)

**Purpose:**
The component's primary purpose is to convert a narrow input","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_n2xn is
    generic (
        InWidth_g  : positive;
        OutWidth_g : positive
    );
    port (
        Clk          : in    std_logic;
        Rst          : in    std_logic;
        In_Valid     : in    std_logic := '1';
        In_Ready     : out   std_logic;
        In_Data      : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Last      : in    std_logic := '0';
        Out_Valid    : out   std_logic;
        Out_Ready    : in    std_logic := '1';
        Out_Data     : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last     : out   std_logic;
        Out_WordEna  : out   std_logic_vector(OutWidth_g / InWidth_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_wconv_n2xn is

    constant RatioReal_c : real    := real(OutWidth_g) / real(InWidth_g);
    constant RatioInt_c  : integer := integer(RatioReal_c);

    type TwoProcess_r is record
        DataVld     : std_logic_vector(RatioInt_c - 1 downto 0);
        Data        : std_logic_vector(OutWidth_g - 1 downto 0);
        DataLast    : std_logic;
        Out_Valid   : std_logic;
        Out_Data    : std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last    : std_logic;
        Out_WordEna : std_logic_vector(RatioInt_c - 1 downto 0);
        Cnt         : integer range 0 to RatioInt_c;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert floor(RatioReal_c) = ceil(RatioReal_c)
        report ""olo_base_wconv_n2xn: Ratio OutWidth_g/InWidth_g must be an integer number""
        severity error;
    assert OutWidth_g >= InWidth_g
        report ""olo_base_wconv_n2xn: OutWidth_g must be bigger or equal than InWidth_g""
        severity error;

    g_convert : if OutWidth_g > InWidth_g generate

        p_comb : process (r, In_Valid, In_Data, Out_Ready, In_Last) is
            variable v           : TwoProcess_r;
            variable IsStuck_v   : std_logic;
            variable ShiftDone_v : boolean;
        begin
            v := r;

            ShiftDone_v := (r.DataVld(r.DataVld'high) = '1') or (r.DataLast = '1');
            if ShiftDone_v and (r.Out_Valid = '1') and (Out_Ready = '0') then
                IsStuck_v := '1';
            else
                IsStuck_v := '0';
            end if;

            if (r.Out_Valid = '1') and (Out_Ready = '1') then
                v.Out_Valid := '0';
            end if;

            if ShiftDone_v and ((r.Out_Valid = '0') or (Out_Ready = '1')) then
                v.Out_Valid   := '1';
                v.Out_Data    := r.Data;
                v.Out_Last    := r.DataLast;
                v.Out_WordEna := r.DataVld;
                v.DataVld     := (others => '0');
                v.DataLast    := '0';
            end if;
            if In_Valid = '1' and IsStuck_v = '0' then
                v.Data((r.Cnt + 1) * InWidth_g - 1 downto r.Cnt * InWidth_g) := In_Data;
                v.DataVld(r.Cnt)                                             := '1';
                if In_Last = '1' then
                    v.DataLast := '1';
                end if;
                if (r.Cnt = RatioInt_c - 1) or (In_Last = '1') then
                    v.Cnt := 0;
                else
                    v.Cnt := r.Cnt + 1;
                end if;
            end if;

            In_Ready    <= not IsStuck_v;
            Out_Valid   <= r.Out_Valid;
            Out_Data    <= r.Out_Data;
            Out_Last    <= r.Out_Last;
            Out_WordEna <= r.Out_WordEna;

            r_next <= v;
        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.DataVld   <= (others => '0');
                    r.Out_Valid <= '0';
                    r.Cnt       <= 0;
                    r.DataLast  <= '0';
                end if;
            end if;
        end process;

    end generate;

    g_equalwidth : if OutWidth_g = InWidth_g generate
        Out_Valid   <= In_Valid;
        Out_Data    <= In_Data;
        Out_Last    <= In_Last;
        Out_WordEna <= (others => '1');
        In_Ready    <= Out_Ready;

    end generate;

end architecture;",42
"This component implements a data width conversion from a multiple N-bits to a N-bits. The sample rate (_Valid_ pulse rate) is increased accordingly. The width conversion implements AXI-S handshaking signals to handle back-pressure. The width conversion does support back-to-back conversions (_Out_Valid/In_ready_ can stay high all the time). This block can also be used for _Parallel to TDM_ conversion (see [Conventions](../Conventions.md)) The entity does little-endian data alignment as shown in the figure below. The with conversion does also handle the last-flag according to AXI specification and it can do alignment. To do so, an input word-enable signal _In_WordEna_ exists (one bit per _OutWidth_g_ bits). Words that are not enabled are not sent to the output. If the input is marked with the _In_Last_ flag, the last enabled word is marked with _Out_Last_ at the output. Note that with the assertion of _In_Last_ at least one byte of the data must be valid (_In_WordEna_ high). Otherwise it would be unclear when _Out_Last_ shall be assigned. This entity does only do a width conversion but not clock crossing. If a double-clock-half-width conversion is required, [olo_base_cc_n2xn](./olo_base_cc_n2xn)  component can be used in front of the width conversion.

# VHDL Analysis for 'olo_base_wconv_xn2n.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2018 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple data-width conversion. The input width
- Plus 20 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.math_real.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_base_wconv_xn2n

## Architecture: rtl of olo_base_wconv_xn2n

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- ***
        r_next <= v;
    end process;

    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' with sensitivity list: r, In_Valid, In_Data, Out_Ready, In_WordEna, In_Last
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' with sensitivity list: None (uses wait statements)
  - Implements conditional logic
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Halt detection
        IsReady_v := '1'
- if unsigned(r.DataVld(r.DataVld'high downto 1)) /= 0 then
            IsReady_v := '0'
- elsif r.DataVld(0) = '1' and Out_Ready = '0' then
            IsReady_v := '0'

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst

## Code Metrics
- Line count: 136
- Process count: 4
- Signal count: 3

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_base_wconv_xn2n.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `olo_base_wconv_xn2n` component is a digital circuit that performs a width conversion on input data, converting a wide input data bus to a narrower output data bus. It takes in a stream of data and outputs a stream of converted data, handling data validity and last-word indication.

**Inputs**

* `Clk`: Clock signal
* `Rst`: Asynchronous reset signal
* `In_Valid`: Input data validity signal
* `In_Data`: Input data bus (width: `InWidth_g` bits)
* `In_Last`: Input last-word indication signal (default: '0')
* `In_WordEna`: Input word enable signal (width: `InWidth_g / OutWidth_g` bits, default: all ones)

**Outputs**

* `In_Ready`: Input ready signal
* `Out_Valid`: Output data validity signal
* `Out_Data`: Output data bus (width: `OutWidth_g` bits)
* `Out_Last`: Output last-word indication signal

**Functionality**

The component performs the following functions:

1. **Width Conversion**: Converts the input data bus from `InWidth_g` bits to `OutWidth_g` bits, where `OutWidth_g` is a divisor of `InWidth_g`.
2. **Data Buffering**: Buffers the input data and control signals to facilitate the width conversion process.
3. **Data Validity Handling**: Handles data validity and last-word","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_xn2n is
    generic (
        InWidth_g  : positive;
        OutWidth_g : positive
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Last     : in    std_logic                                             := '0';
        In_WordEna  : in    std_logic_vector(InWidth_g / OutWidth_g - 1 downto 0) := (others => '1');
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic                                             := '1';
        Out_Data    : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last    : out   std_logic
    );
end entity;

architecture rtl of olo_base_wconv_xn2n is

    constant RatioReal_c : real    := real(InWidth_g) / real(OutWidth_g);
    constant RatioInt_c  : integer := integer(RatioReal_c);

    type TwoProcess_r is record
        Data     : std_logic_vector(InWidth_g - 1 downto 0);
        DataVld  : std_logic_vector(RatioInt_c - 1 downto 0);
        DataLast : std_logic_vector(RatioInt_c - 1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert floor(RatioReal_c) = ceil(RatioReal_c)
        report ""olo_base_wconv_xn2n: Ratio OutWidth_g/InWidth_g must be an integer number""
        severity error;
    assert OutWidth_g < InWidth_g
        report ""olo_base_wconv_n2xn: OutWidth_g must be smaller than InWidth_g""
        severity error;

    p_comb : process (r, In_Valid, In_Data, Out_Ready, In_WordEna, In_Last) is
        variable v         : TwoProcess_r;
        variable IsReady_v : std_logic;
    begin
        v := r;

        IsReady_v := '1';
        if unsigned(r.DataVld(r.DataVld'high downto 1)) /= 0 then
            IsReady_v := '0';
        elsif r.DataVld(0) = '1' and Out_Ready = '0' then
            IsReady_v := '0';
        end if;

        if IsReady_v = '1' and In_Valid = '1' then
            v.Data    := In_Data;
            v.DataVld := In_WordEna;
            v.DataLast := (others => '0');

            for i in RatioInt_c-1 downto 0 loop
                if In_WordEna(i) = '1' and In_Last = '1' then
                    v.DataLast(i) := '1';
                    exit;
                end if;
            end loop;

        elsif (Out_Ready = '1') and (unsigned(r.DataVld) /= 0) then
            v.Data     := zerosVector(OutWidth_g) & r.Data(r.Data'left downto OutWidth_g);
            v.DataVld  := '0' & r.DataVld(r.DataVld'left downto 1);
            v.DataLast := '0' & r.DataLast(r.DataLast'left downto 1);
        end if;

        Out_Data  <= r.Data(OutWidth_g - 1 downto 0);
        In_Ready  <= IsReady_v;
        Out_Valid <= r.DataVld(0);
        Out_Last  <= r.DataLast(0);

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.DataVld <= (others => '0');
            end if;
        end if;
    end process;

end architecture;",43
"This component implements a very simple AXI4-Lite slave. It converts AXI4-Lite accesses to a simple address/read/write interface commonly used for mapping register banks and memory. Below figures shows how write transactions are signaled to user-code. Write transactions do not require an acknowledge. The user code **must** expect them in the speed they arrive. Below figures shows how read transactions are signaled to user-code. The validity of read-data must be acknowledged by _Rb_RdValid_. If this does not happen within _ReadTimeoutClks_g_ an error is signaled to the master who requested the read. Note that the read latency (from _Rb_Rd_ to _Rb_Valid_) does not have to be constant. The _olo_axi_lite_slave_ implements a read-timeout. In case the read data is not returned (_Rb_RdValid_) within the timeout specified, an error is signaled on the AXI bus. This mechanism prevents masters from becoming locked for infinite time if a read fails due to user code connected to the _olo_axi_lite_slave_. The _olo_axi_lite_slave_ does not aim for maximum performance. It requires 4 clock cycles per transaction (plus read-latency for read accesses). This is regarded as acceptable because the AXI4-Lite protocol does not aim for maximum performance anyways.

# VHDL Analysis for 'olo_axi_lite_slave.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements an AXI-Lite Slave Interface, which can be used to
- access registers and memory. On the user-side it provides a simple
- Plus 49 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_axi_pkg_protocol.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_axi_lite_slave

## Architecture: rtl of olo_axi_lite_slave

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- r_next <= v;
    end process;

    -- *** Sequential Process ***
    p_seq: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next

### Processes
- Process 'p_comb :' with sensitivity list: r, S_AxiLite_ArAddr, S_AxiLite_ArValid, S_AxiLite_AwAddr, S_AxiLite_AwValid,
                      S_AxiLite_WData, S_AxiLite_WStrb, S_AxiLite_WValid, S_AxiLite_BReady,
                      S_AxiLite_RReady, Rb_RdData, Rb_RdValid
  - Implements case-based selection logic
  - Contains wait statements: for response transferred
                if S_AxiLite_BReady = '1' then
                    v.State  := Idle, for read data
                if Rb_RdValid = '1' then
                    v.RData  := Rb_RdData, for response transferred
                if S_AxiLite_RReady = '1' then
                    v.State  := Idle
- Process 'p_seq :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
  - Contains wait statements: for response transferred
                if S_AxiLite_BReady = '1' then
                    v.State  := Idle, for read data
                if Rb_RdValid = '1' then
                    v.RData  := Rb_RdData, for response transferred
                if S_AxiLite_RReady = '1' then
                    v.State  := Idle
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- -- Default values
        v.ArReady := '0'
- v.AwReady := '0'
- v.Wr      := '0'
- v.Rd      := '0'
- -- FSM
        case r.State is
            -- Idle
            when Idle =>
                -- Idle
                if S_AxiLite_ArValid = '1' then
                    v.State   := RdCmd
- Plus 3 more statements

## Functional Analysis

- This appears to be a Finite State Machine implementation
- Contains 1 clock domain(s): Clk
- Uses reset signal(s): Rst
- Implements memory functionality
- Implements control logic
- Implements interface or communication protocol

## Code Metrics
- Line count: 251
- Process count: 4
- Signal count: 3

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_axi_lite_slave.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: OLO AXI Lite Slave**

**Overview**

The OLO AXI Lite Slave is a digital component designed to interface with an AXI (Advanced eXtensible Interface) Lite bus, providing a bridge to a register-based interface. This component acts as a slave device on the AXI Lite bus, allowing for read and write transactions to access internal registers.

**Functional Description**

The OLO AXI Lite Slave component performs the following functions:

*   Receives AXI Lite bus transactions (read and write) and decodes the address and data.
*   Generates control signals to access internal registers.
*   Handles read and write data transfer between the AXI Lite bus and internal registers.

**Inputs**

*   **Clk**: Clock signal.
*   **Rst**: Asynchronous reset signal.
*   **S_AxiLite_ArAddr**: Read address.
*   **S_AxiLite_ArValid**: Read address valid signal.
*   **S_AxiLite_AwAddr**: Write address.
*   **S_AxiLite_AwValid**: Write address valid signal.
*   **S_AxiLite_WData**: Write data.
*   **S_AxiLite_WStrb**: Write strobe (byte enable).
*   **S_AxiLite_WValid**: Write data valid signal.
*   **S_AxiLite_BReady**: Write response ready signal.
*   **S_AxiLite_RReady**: Read data ready signal.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_axi_pkg_protocol.all;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_axi_lite_slave is
    generic (
        AxiAddrWidth_g      : positive := 8;
        AxiDataWidth_g      : positive := 32;
        ReadTimeoutClks_g   : positive := 100
    );
    port (
        Clk               : in    std_logic;
        Rst               : in    std_logic;
        S_AxiLite_ArAddr  : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        S_AxiLite_ArValid : in    std_logic;
        S_AxiLite_ArReady : out   std_logic;
        S_AxiLite_AwAddr  : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        S_AxiLite_AwValid : in    std_logic;
        S_AxiLite_AwReady : out   std_logic;
        S_AxiLite_WData   : in    std_logic_vector(AxiDataWidth_g - 1 downto 0);
        S_AxiLite_WStrb   : in    std_logic_vector((AxiDataWidth_g/8) - 1 downto 0);
        S_AxiLite_WValid  : in    std_logic;
        S_AxiLite_WReady  : out   std_logic;
        S_AxiLite_BResp   : out   std_logic_vector(1 downto 0);
        S_AxiLite_BValid  : out   std_logic;
        S_AxiLite_BReady  : in    std_logic;
        S_AxiLite_RData   : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        S_AxiLite_RResp   : out   std_logic_vector(1 downto 0);
        S_AxiLite_RValid  : out   std_logic;
        S_AxiLite_RReady  : in    std_logic;
        Rb_Addr           : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        Rb_Wr             : out   std_logic;
        Rb_ByteEna        : out   std_logic_vector((AxiDataWidth_g/8) - 1 downto 0);
        Rb_WrData         : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        Rb_Rd             : out   std_logic;
        Rb_RdData         : in    std_logic_vector(AxiDataWidth_g - 1 downto 0);
        Rb_RdValid        : in    std_logic
    );
end entity;

architecture rtl of olo_axi_lite_slave is

    type Fsm_t is (Idle, WrCmd, WrData, WrResp, RdCmd, RdData, RdResp);

    type TwoProcess_r is record
        State   : Fsm_t;
        ArReady : std_logic;
        AwReady : std_logic;
        WReady  : std_logic;
        BValid  : std_logic;
        RValid  : std_logic;
        RData   : std_logic_vector(Rb_RdData'range);
        Addr    : std_logic_vector(Rb_Addr'range);
        ByteEna : std_logic_vector(Rb_ByteEna'range);
        WrData  : std_logic_vector(Rb_WrData'range);
        Wr      : std_logic;
        Rd      : std_logic;
        RResp   : Resp_t;
        ToCnt   : natural range 0 to ReadTimeoutClks_g-1;
    end record;

    signal r, r_next : TwoProcess_r;

    constant UnusedBits_c : natural := log2(AxiDataWidth_g/8);

begin

    assert AxiDataWidth_g mod 8 = 0
        report ""###ERROR###: olo_axi_lite_slave AxiDataWidth_g must be a multiple of 8""
        severity failure;
    assert isPower2(AxiDataWidth_g/8)
        report ""###ERROR###: olo_axi_lite_slave AxiDataWidth_g must be 2^X bytes""
        severity failure;

    p_comb : process (r, S_AxiLite_ArAddr, S_AxiLite_ArValid, S_AxiLite_AwAddr, S_AxiLite_AwValid,
                      S_AxiLite_WData, S_AxiLite_WStrb, S_AxiLite_WValid, S_AxiLite_BReady,
                      S_AxiLite_RReady, Rb_RdData, Rb_RdValid) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.ArReady := '0';
        v.AwReady := '0';
        v.Wr      := '0';
        v.Rd      := '0';

        case r.State is
            when Idle =>
                if S_AxiLite_ArValid = '1' then
                    v.State   := RdCmd;
                    v.ArReady := '1';
                elsif S_AxiLite_AwValid = '1' then
                    v.State   := WrCmd;
                    v.AwReady := '1';
                end if;

            when WrCmd =>
                v.Addr := S_AxiLite_AwAddr(S_AxiLite_AwAddr'high downto UnusedBits_c) & zerosVector(UnusedBits_c);
                v.WReady := '1';
                v.State  := WrData;

            when WrData =>
                if S_AxiLite_WValid = '1' then
                    v.State   := WrResp;
                    v.WReady  := '0';
                    v.ByteEna := S_AxiLite_WStrb;
                    v.WrData  := S_AxiLite_WData;
                    v.Wr      := '1';
                    v.BValid  := '1';
                end if;

            when WrResp =>
                if S_AxiLite_BReady = '1' then
                    v.State  := Idle;
                    v.BValid := '0';
                end if;

            when RdCmd =>
                v.Addr  := S_AxiLite_ArAddr;
                v.Rd    := '1';
                v.State := RdData;
                v.ToCnt := ReadTimeoutClks_g-1;

            when RdData =>
                if Rb_RdValid = '1' then
                    v.RData  := Rb_RdData;
                    v.RValid := '1';
                    v.RResp  := AxiResp_Okay_c;
                    v.State  := RdResp;
                end if;
                if v.ToCnt = 0 then
                    v.RValid := '1';
                    v.RResp  := AxiResp_SlvErr_c;
                    v.State  := RdResp;
                else
                    v.ToCnt := v.ToCnt - 1;
                end if;

            when RdResp =>
                if S_AxiLite_RReady = '1' then
                    v.State  := Idle;
                    v.RValid := '0';
                end if;

            when others => null; -- unreachable

        end case;

        S_AxiLite_ArReady <= r.ArReady;
        S_AxiLite_AwReady <= r.AwReady;
        S_AxiLite_WReady  <= r.WReady;
        S_AxiLite_BResp   <= AxiResp_Okay_c; -- Writes can't fail
        S_AxiLite_BValid  <= r.BValid;
        S_AxiLite_RData   <= r.RData;
        S_AxiLite_RResp   <= r.RResp;
        S_AxiLite_RValid  <= r.RValid;

        Rb_Addr    <= r.Addr;
        Rb_ByteEna <= r.ByteEna;
        Rb_WrData  <= r.WrData;
        Rb_Wr      <= r.Wr;
        Rb_Rd      <= r.Rd;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.State   <= Idle;
                r.ArReady <= '0';
                r.AwReady <= '0';
                r.WReady  <= '0';
                r.Wr      <= '0';
                r.BValid  <= '0';
                r.Rd      <= '0';
                r.RValid  <= '0';
            end if;
        end if;
    end process;

end architecture;",44
"This entity is a wrapper around [olo_axi_master_simple](olo_axi_master_simple.md) to allow the following things: - Access to non word-aligned addresses - Arbitrarily sized (not a multiple of AXI data words) transfers - AXI data width can be bigger than the data-width of the user interface Besides the capability for unaligned transfers, the user interface is the same as for [olo_axi_master_simple](olo_axi_master_simple.md) - **please read through the documentation of [olo_axi_master_simple](olo_axi_master_simple.md)**. Important topics covered there are: - Automatic splitting of transfers at 4kB boundaries - Automatic splitting of transfers at the maximum bust-size supported by AXI4 - High Latency vs. Low Latency transactions Important differences between _olo_axi_master_full_ and [olo_axi_master_simple](olo_axi_master_simple.md) are: - Transaction size (_CmdWr_Size_/_CmdRd_Size_) is given in **bytes** not **words** - Write data cannot be provided before the command (due to the required alignment) - No byte enables are provided on the user interface because data is aligned automatically. Note that due to the alignment logic, every command takes at least four clock cycles to process. In most cases there significant bursts are executed this does not matter but for cases where many very small (e.g. single-beat) transactions are required this entity is suboptimal. Most of the logic in this entity is related to unaligned and odd-sized transfers. So if you only require an AXI data width that is larger than the user interface data width, you may consider using [olo_axi_master_simple](olo_axi_master_simple.md) along with [olo_base_wconv_n2xn](../base/olo_base_wconv_n2xn.md)/ [olo_base_wconv_xn2n](../base/olo_base_wconv_xn2n.md) (width conversion) to achieve better performance with less resource utilization. Read and write logic are fully independent. So reads and writes can happen at the same time.

# VHDL Analysis for 'olo_axi_master_full.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a full AXI master. In contrast to olo_axi_master_simple,
- Plus 120 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: ieee.std_logic_misc.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all

## Entity: olo_axi_master_full

## Architecture: rtl of olo_axi_master_full

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- WrPl_Data: std_logic_vector(Wr_Data'range)
- WrPl_Vld: std_logic
- AxiWrCmd_Rdy: std_logic
- AxiWrDat_Rdy: std_logic
- AxiWrDat_Data: std_logic_vector(AxiDataWidth_g - 1 downto 0)
- WrPl_Rdy: std_logic
- AxiWrDat_Be: std_logic_vector(AxiBytes_c - 1 downto 0)
- WrWconvEna: std_logic
- WrWconv_Vld: std_logic
- WrWconv_Rdy: std_logic
- WrWconv_Last: std_logic
- WrData_Vld: std_logic
- WrData_Data: std_logic_vector(AxiDataWidth_g - 1 downto 0)
- WrData_Last: std_logic
- WrData_We: std_logic_vector(AxiBytes_c / DataBytes_c - 1 downto 0)
- WrData_Rdy: std_logic
- WrDataEna: std_logic
- AxiRdCmd_Rdy: std_logic
- AxiRdDat_Rdy: std_logic
- AxiRdDat_Vld: std_logic
- AxiRdDat_Data: std_logic_vector(AxiDataWidth_g - 1 downto 0)
- AxiRdDat_Last: std_logic
- RdPl_Rdy: std_logic
- RdPl_Data: std_logic_vector(UserDataWidth_g - 1 downto 0)
- RdPl_Vld: std_logic
- RdPl_Last: std_logic
- ***
        r_next <= v;
    end process;

    -- *** Registered Process ***
    p_reg: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next
- InData: std_logic_vector(UserDataWidth_g downto 0)
- OutData: std_logic_vector(UserDataWidth_g downto 0)

### Component Instantiations
- Instance 'i_axi' of component 'olo_axi_master_simple'
- Instance 'i_pl_wr_data' of component 'olo_base_pl_stage'
- Instance 'i_wc_wr' of component 'olo_base_wconv_n2xn'
- Instance 'i_pl_rd_data' of component 'olo_base_pl_stage'

### Processes
- Process 'p_comb :' (Has Reset) with sensitivity list: r,
                      CmdWr_Addr, CmdWr_Size, CmdWr_Valid, CmdWr_LowLat, CmdRd_Addr, CmdRd_Size, CmdRd_Valid, CmdRd_LowLat,
                      AxiWrCmd_Rdy, AxiWrDat_Rdy, AxiRdCmd_Rdy, AxiRdDat_Vld, AxiRdDat_Data,
                      WrWconv_Rdy, WrPl_Vld, WrData_Vld, WrData_Data, WrData_Last, WrData_We, RdPl_Rdy
  - Implements case-based selection logic
  - Contains wait statements: for the last beat te be accepted without reading more data from the FIFO
                when Last_s =>
                    v.WrAlignVld := '1', until reception of all data is done
                when Wait_s =>
                    if unsigned(r.RdAlignByteVld) = 0 then
                        v.RdDataFsm := Idle_s
- Process 'p_reg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
  - Contains wait statements: for the last beat te be accepted without reading more data from the FIFO
                when Last_s =>
                    v.WrAlignVld := '1', until reception of all data is done
                when Wait_s =>
                    if unsigned(r.RdAlignByteVld) = 0 then
                        v.RdDataFsm := Idle_s
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- return Addr_v

## Functional Analysis

- Contains 2 clock domain(s): clock, Clk
- Uses reset signal(s): WrStartTf, M_Axi_ArBurst, RdDatFirstBe, first, M_Axi_AwBurst, Rst, RdFirstBe, RdFirstAddrOffs
- Implements memory functionality
- Implements arithmetic/computational functionality
- Implements control logic
- Implements interface or communication protocol
- May be part of a pipeline architecture
- This appears to be a CPU component
- Implements instruction execution functionality
- Defines custom functions: alignedAddr

## Code Metrics
- Line count: 777
- Process count: 4
- Signal count: 31

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_axi_master_full.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: AXI Master Full**

**Overview**

The `olo_axi_master_full` component is a fully-featured AXI master interface designed to facilitate high-speed data transfers between a user logic and an AXI slave device. This component supports both write and read transactions, with configurable parameters for address width, data width, and maximum transaction size.

**Functional Description**

The `olo_axi_master_full` component acts as a bridge between a user interface and an AXI interface. It accepts write and read commands from the user interface, translates them into AXI transactions, and communicates with an AXI slave device. The component supports:

* Write transactions: The component accepts write data from the user interface, aligns and converts it to the AXI data width, and transmits it to the AXI slave device.
* Read transactions: The component sends read requests to the AXI slave device, receives data, and aligns and converts it to the user data width.

**Inputs**

* `Clk`: Clock signal
* `Rst`: Reset signal
* `CmdWr_Addr`, `CmdWr_Size`, `CmdWr_LowLat`, `CmdWr_Valid`: Write command inputs
* `CmdRd_Addr`, `CmdRd_Size`, `CmdRd_LowLat`, `CmdRd_Valid`: Read command inputs
* `Wr_Data`, `Wr_Valid`: Write data inputs
* `Rd_Ready`: Read data ready signal

**Outputs**

* `Cmd","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.std_logic_misc.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_axi_master_full is
    generic (
        AxiAddrWidth_g             : natural range 12 to 64  := 32;
        AxiDataWidth_g             : natural range 8 to 1024 := 32;
        AxiMaxBeats_g              : natural range 1 to 256  := 256;
        AxiMaxOpenTransactions_g   : natural range 1 to 8    := 8;
        UserTransactionSizeBits_g  : natural                 := 32;
        DataFifoDepth_g            : natural                 := 1024;
        UserDataWidth_g            : natural                 := 32;
        ImplRead_g                 : boolean                 := true;
        ImplWrite_g                : boolean                 := true;
        RamBehavior_g              : string                  := ""RBW""
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        CmdWr_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdWr_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdWr_LowLat    : in    std_logic                                                := '0';
        CmdWr_Valid     : in    std_logic                                                := '0';
        CmdWr_Ready     : out   std_logic;
        CmdRd_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdRd_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdRd_LowLat    : in    std_logic                                                := '0';
        CmdRd_Valid     : in    std_logic                                                := '0';
        CmdRd_Ready     : out   std_logic;
        Wr_Data         : in    std_logic_vector(UserDataWidth_g - 1 downto 0)           := (others => '0');
        Wr_Valid        : in    std_logic                                                := '0';
        Wr_Ready        : out   std_logic;
        Rd_Data         : out   std_logic_vector(UserDataWidth_g - 1 downto 0);
        Rd_Last         : out   std_logic;
        Rd_Valid        : out   std_logic;
        Rd_Ready        : in    std_logic                                                := '1';
        Wr_Done         : out   std_logic;
        Wr_Error        : out   std_logic;
        Rd_Done         : out   std_logic;
        Rd_Error        : out   std_logic;
        M_Axi_AwAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_AwLen     : out   std_logic_vector(7 downto 0);
        M_Axi_AwSize    : out   std_logic_vector(2 downto 0);
        M_Axi_AwBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_AwLock    : out   std_logic;
        M_Axi_AwCache   : out   std_logic_vector(3 downto 0);
        M_Axi_AwProt    : out   std_logic_vector(2 downto 0);
        M_Axi_AwValid   : out   std_logic;
        M_Axi_AwReady   : in    std_logic                                                := '0';
        M_Axi_WData     : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        M_Axi_WStrb     : out   std_logic_vector(AxiDataWidth_g / 8 - 1 downto 0);
        M_Axi_WLast     : out   std_logic;
        M_Axi_WValid    : out   std_logic;
        M_Axi_WReady    : in    std_logic                                                := '0';
        M_Axi_BResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_BValid    : in    std_logic                                                := '0';
        M_Axi_BReady    : out   std_logic;
        M_Axi_ArAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_ArLen     : out   std_logic_vector(7 downto 0);
        M_Axi_ArSize    : out   std_logic_vector(2 downto 0);
        M_Axi_ArBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_ArLock    : out   std_logic;
        M_Axi_ArCache   : out   std_logic_vector(3 downto 0);
        M_Axi_ArProt    : out   std_logic_vector(2 downto 0);
        M_Axi_ArValid   : out   std_logic;
        M_Axi_ArReady   : in    std_logic                                                := '0';
        M_Axi_RData     : in    std_logic_vector(AxiDataWidth_g - 1 downto 0)            := (others => '0');
        M_Axi_RResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_RLast     : in    std_logic                                                := '0';
        M_Axi_RValid    : in    std_logic                                                := '0';
        M_Axi_RReady    : out   std_logic
    );
end entity;

architecture rtl of olo_axi_master_full is

    constant AxiBytes_c  : natural := AxiDataWidth_g / 8;
    constant DataBytes_c : natural := UserDataWidth_g / 8;

    type WriteCmdFsm_t is (Idle_s, Apply_s);
    type WriteWconvFsm_t is (Idle_s, Transfer_s);
    type WriteAlignFsm_t is (Idle_s, Transfer_s, Last_s);
    type ReadCmdFsm_t is (Idle_s, Apply_s, WaitDataFsm_s);
    type ReadDataFsm_t is (Idle_s, Transfer_s, Wait_s);

    function alignedAddr (Addr : in unsigned(AxiAddrWidth_g-1 downto 0))
    return unsigned is
        variable Addr_v : unsigned(Addr'range) := (others => '0');
    begin
        Addr_v(Addr'left downto log2(AxiBytes_c)) := Addr(Addr'left downto log2(AxiBytes_c));
        return Addr_v;
    end function;

    type TwoProcess_r is record
        WrCmdFsm        : WriteCmdFsm_t;
        WrLastAddr      : unsigned(AxiAddrWidth_g - 1 downto 0);
        CmdWr_Ready     : std_logic;
        AxiWrCmd_Addr   : std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        AxiWrCmd_Size   : std_logic_vector(UserTransactionSizeBits_g - 1 downto 0);
        WrAlignCmdSize  : std_logic_vector(UserTransactionSizeBits_g - 1 downto 0);
        AxiWrCmd_LowLat : std_logic;
        AxiWrCmd_Vld    : std_logic;
        WrWconvFsm      : WriteWconvFsm_t;
        WrStartTf       : std_logic;
        WrWordsDone     : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrDataWordsCmd  : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrDataWordsWc   : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrAlignFsm      : WriteAlignFsm_t;
        WrAlignReg      : std_logic_vector(AxiDataWidth_g * 2 - 1 downto 0);
        WrAlignBe       : std_logic_vector(AxiBytes_c * 2 - 1 downto 0);
        WrShift         : unsigned(log2(AxiBytes_c) - 1 downto 0);
        WrAlignShift    : unsigned(log2(AxiBytes_c) - 1 downto 0);
        WrAlignVld      : std_logic;
        AxiWordCnt      : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrLastBe        : std_logic_vector(AxiBytes_c - 1 downto 0);
        WrAlignLastBe   : std_logic_vector(AxiBytes_c - 1 downto 0);
        WrAlignLast     : std_logic;

        RdCmdFsm        : ReadCmdFsm_t;
        RdLastAddr      : unsigned(AxiAddrWidth_g - 1 downto 0);
        RdFirstAddrOffs : unsigned(log2(AxiBytes_c) - 1 downto 0);
        CmdRd_Ready     : std_logic;
        AxiRdCmd_Addr   : std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        AxiRdCmd_LowLat : std_logic;
        AxiRdCmd_Vld    : std_logic;
        AxiRdCmd_Size   : std_logic_vector(UserTransactionSizeBits_g - 1 downto 0);
        RdFirstBe       : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdLastBe        : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdDataFsm       : ReadDataFsm_t;
        RdStartTf       : std_logic;
        RdDataEna       : std_logic;
        RdDatFirstBe    : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdDatLastBe     : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdDataWords     : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        RdCurrentWord   : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        RdShift         : unsigned(log2(AxiBytes_c) - 1 downto 0);
        RdLowIdx        : unsigned(log2(AxiBytes_c) downto 0);
        RdAlignShift    : unsigned(log2(AxiBytes_c) - 1 downto 0);
        RdAlignLowIdx   : unsigned(log2(AxiBytes_c) downto 0);
        RdAlignByteVld  : std_logic_vector(AxiBytes_c * 2 - 1 downto 0);
        RdAlignReg      : std_logic_vector(AxiDataWidth_g * 2 - 1 downto 0);
        RdAlignLast     : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal WrPl_Data     : std_logic_vector(Wr_Data'range);
    signal WrPl_Vld      : std_logic;
    signal AxiWrCmd_Rdy  : std_logic;
    signal AxiWrDat_Rdy  : std_logic;
    signal AxiWrDat_Data : std_logic_vector(AxiDataWidth_g - 1 downto 0);
    signal WrPl_Rdy      : std_logic;
    signal AxiWrDat_Be   : std_logic_vector(AxiBytes_c - 1 downto 0);
    signal WrWconvEna    : std_logic;
    signal WrWconv_Vld   : std_logic;
    signal WrWconv_Rdy   : std_logic;
    signal WrWconv_Last  : std_logic;
    signal WrData_Vld    : std_logic;
    signal WrData_Data   : std_logic_vector(AxiDataWidth_g - 1 downto 0);
    signal WrData_Last   : std_logic;
    signal WrData_We     : std_logic_vector(AxiBytes_c / DataBytes_c - 1 downto 0);
    signal WrData_Rdy    : std_logic;
    signal WrDataEna     : std_logic;
    signal AxiRdCmd_Rdy  : std_logic;
    signal AxiRdDat_Rdy  : std_logic;
    signal AxiRdDat_Vld  : std_logic;
    signal AxiRdDat_Data : std_logic_vector(AxiDataWidth_g - 1 downto 0);
    signal AxiRdDat_Last : std_logic;
    signal RdPl_Rdy      : std_logic;
    signal RdPl_Data     : std_logic_vector(UserDataWidth_g - 1 downto 0);
    signal RdPl_Vld      : std_logic;
    signal RdPl_Last     : std_logic;

begin

    assert isPower2(AxiDataWidth_g/8)
        report ""olo_axi_master_full - AxiDataWidth_g must be a power of two of bytes""
        severity failure;
    assert UserDataWidth_g mod 8 = 0
        report ""olo_axi_master_full UserDataWidth_g must be a multiple of 8""
        severity failure;
    assert AxiDataWidth_g mod UserDataWidth_g = 0
        report ""olo_axi_master_full AxiDataWidth_g must be a multiple of UserDataWidth_g""
        severity failure;
    assert UserTransactionSizeBits_g <= AxiAddrWidth_g
        report ""olo_axi_master_full UserTransactionSizeBits_g must be smaller or equal to AxiAddrWidth_g""
        severity failure;

    p_comb : process (r,
                      CmdWr_Addr, CmdWr_Size, CmdWr_Valid, CmdWr_LowLat, CmdRd_Addr, CmdRd_Size, CmdRd_Valid, CmdRd_LowLat,
                      AxiWrCmd_Rdy, AxiWrDat_Rdy, AxiRdCmd_Rdy, AxiRdDat_Vld, AxiRdDat_Data,
                      WrWconv_Rdy, WrPl_Vld, WrData_Vld, WrData_Data, WrData_Last, WrData_We, RdPl_Rdy) is
        variable v              : TwoProcess_r;
        variable WriteBe_v      : std_logic_vector(AxiBytes_c - 1 downto 0);
        variable RdAlignReady_v : std_logic;
        variable RdLowIdxInt_v  : integer range 0 to AxiBytes_c;
        variable RdDatBe_v      : std_logic_vector(AxiBytes_c - 1 downto 0);
    begin
        v := r;

        if ImplWrite_g then

            v.WrStartTf    := '0';
            v.AxiWrCmd_Vld := '0';

            case r.WrCmdFsm is

                when Idle_s =>
                    v.CmdWr_Ready := '1';
                    v.WrLastAddr  := unsigned(CmdWr_Addr) + unsigned(CmdWr_Size) - 1;
                    if unsigned(CmdWr_Size(log2(DataBytes_c) - 1 downto 0)) = 0 then
                        v.WrDataWordsCmd := resize(unsigned(CmdWr_Size(CmdWr_Size'high downto log2(DataBytes_c))), UserTransactionSizeBits_g);
                    else
                        v.WrDataWordsCmd := resize(unsigned(CmdWr_Size(CmdWr_Size'high downto log2(DataBytes_c))) + 1, UserTransactionSizeBits_g);
                    end if;
                    v.AxiWrCmd_Addr   := std_logic_vector(alignedAddr(unsigned(CmdWr_Addr)));
                    v.WrShift         := unsigned(CmdWr_Addr(v.WrShift'range));
                    v.AxiWrCmd_LowLat := CmdWr_LowLat;
                    if CmdWr_Valid = '1' then
                        v.CmdWr_Ready := '0';
                        v.WrCmdFsm    := Apply_s;
                    end if;

                when Apply_s =>
                    if (AxiWrCmd_Rdy = '1') and (r.WrWconvFsm = Idle_s) and (r.WrAlignFsm = Idle_s) then
                        v.AxiWrCmd_Vld  := '1';
                        v.WrStartTf     := '1';
                        v.WrCmdFsm      := Idle_s;
                        v.CmdWr_Ready   := '1';
                        v.AxiWrCmd_Size := std_logic_vector(resize(shift_right(alignedAddr(r.WrLastAddr) - unsigned(r.AxiWrCmd_Addr), log2(AxiBytes_c)) + 1,
                                                                   UserTransactionSizeBits_g));

                        for byte in 0 to AxiBytes_c - 1 loop
                            if r.WrLastAddr(log2(AxiBytes_c) - 1 downto 0) >= byte then
                                v.WrLastBe(byte) := '1';
                            else
                                v.WrLastBe(byte) := '0';
                            end if;
                        end loop;

                    end if;

                when others => null;    -- unreachable code

            end case;

            WrWconvEna   <= '0';
            WrWconv_Last <= '0';

            case r.WrWconvFsm is
                when Idle_s =>
                    v.WrWordsDone   := to_unsigned(1, v.WrWordsDone'length);
                    v.WrDataWordsWc := r.WrDataWordsCmd;
                    if r.WrStartTf = '1' then
                        v.WrWconvFsm := Transfer_s;
                    end if;

                when Transfer_s =>
                    WrWconvEna <= '1';
                    if r.WrWordsDone = r.WrDataWordsWc then
                        WrWconv_Last <= '1';
                    end if;
                    if (WrWconv_Rdy = '1') and (WrPl_Vld = '1') then
                        v.WrWordsDone := r.WrWordsDone + 1;
                        if r.WrWordsDone = r.WrDataWordsWc then
                            v.WrWconvFsm := Idle_s;
                        end if;
                    end if;

                when others => null; -- unreachable code
            end case;

            WrDataEna <= '0';

            for i in 0 to AxiBytes_c - 1 loop
                WriteBe_v(i) := WrData_We(i / UserDataWidth_g);
            end loop;

            case r.WrAlignFsm is
                when Idle_s =>
                    v.WrAlignReg     := (others => '0');
                    v.WrAlignBe      := (others => '0');
                    v.AxiWordCnt     := to_unsigned(1, v.AxiWordCnt'length);
                    v.WrAlignLast    := '0';
                    v.WrAlignShift   := r.WrShift;
                    v.WrAlignCmdSize := r.AxiWrCmd_Size;
                    v.WrAlignLastBe  := r.WrLastBe;
                    v.WrAlignVld     := '0';
                    if r.WrStartTf = '1' then
                        v.WrAlignFsm := Transfer_s;
                    end if;

                when Transfer_s =>
                    WrDataEna <= '1';
                    if (AxiWrDat_Rdy = '1') and ((WrData_Vld = '1') or (r.WrAlignLast = '1')) then
                        if r.WrAlignLast = '1' then
                            WriteBe_v := (others => '0');
                        end if;
                        v.WrAlignReg(AxiDataWidth_g - 1 downto 0) := r.WrAlignReg(r.WrAlignReg'left downto AxiDataWidth_g);
                        v.WrAlignBe(AxiBytes_c - 1 downto 0)      := r.WrAlignBe(r.WrAlignBe'left downto AxiBytes_c);
                        v.WrAlignReg((to_integer(r.WrAlignShift) + AxiBytes_c) * 8 - 1 downto to_integer(r.WrAlignShift) * 8) := WrData_Data;
                        v.WrAlignBe(to_integer(r.WrAlignShift) + AxiBytes_c - 1 downto to_integer(r.WrAlignShift))            := WriteBe_v;
                        v.WrAlignVld := '1';
                        if r.AxiWordCnt = unsigned(r.WrAlignCmdSize) then
                            v.WrAlignFsm                         := Last_s;
                            v.WrAlignBe(AxiBytes_c - 1 downto 0) := v.WrAlignBe(AxiBytes_c - 1 downto 0) and r.WrAlignLastBe;
                        end if;
                        v.AxiWordCnt := r.AxiWordCnt + 1;
                        v.WrAlignLast := WrData_Last;
                    elsif AxiWrDat_Rdy = '1' then
                        v.WrAlignVld := '0';
                    end if;

                when Last_s =>
                    v.WrAlignVld := '1';
                    if AxiWrDat_Rdy = '1' then
                        v.WrAlignVld := '0';
                        v.WrAlignFsm := Idle_s;
                    end if;

                when others => null; -- unreachable code
            end case;

        end if;

        if ImplRead_g then

            RdLowIdxInt_v  := to_integer(r.RdAlignLowIdx);
            RdAlignReady_v := r.RdDataEna;

            for i in 0 to AxiBytes_c loop
                if i = RdLowIdxInt_v then
                    if (DataBytes_c < AxiBytes_c) and (unsigned(r.RdAlignByteVld(r.RdAlignByteVld'high downto i + DataBytes_c)) /= 0) then
                        RdAlignReady_v := '0';
                    elsif unsigned(r.RdAlignByteVld(r.RdAlignByteVld'high downto i)) /= 0 and RdPl_Rdy = '0' then
                        RdAlignReady_v := '0';
                    end if;
                end if;
            end loop;

            v.RdStartTf    := '0';
            v.AxiRdCmd_Vld := '0';

            case r.RdCmdFsm is
                when Idle_s =>
                    v.CmdRd_Ready     := '1';
                    v.RdLastAddr      := unsigned(CmdRd_Addr) + unsigned(CmdRd_Size) - 1;
                    v.RdFirstAddrOffs := unsigned(CmdRd_Addr(v.RdFirstAddrOffs'range));
                    v.AxiRdCmd_Addr   := std_logic_vector(alignedAddr(unsigned(CmdRd_Addr)));
                    v.AxiRdCmd_LowLat := CmdRd_LowLat;
                    v.RdShift         := unsigned(CmdRd_Addr(v.RdShift'range));
                    v.RdLowIdx        := to_unsigned(AxiBytes_c, v.RdLowIdx'length) - unsigned(CmdRd_Addr(v.RdShift'range));
                    if CmdRd_Valid = '1' then
                        v.CmdRd_Ready := '0';
                        v.RdCmdFsm    := Apply_s;
                    end if;

                when Apply_s =>
                    if AxiRdCmd_Rdy = '1' then
                        v.AxiRdCmd_Vld  := '1';
                        v.RdCmdFsm      := WaitDataFsm_s;
                        v.RdStartTf     := '1';
                        v.AxiRdCmd_Size := std_logic_vector(resize(shift_right(alignedAddr(r.RdLastAddr) - unsigned(r.AxiRdCmd_Addr), log2(AxiBytes_c)) + 1,
                                                                   UserTransactionSizeBits_g));

                        for byte in 0 to AxiBytes_c - 1 loop
                            if r.RdLastAddr(log2(AxiBytes_c) - 1 downto 0) >= byte then
                                v.RdLastBe(byte) := '1';
                            else
                                v.RdLastBe(byte) := '0';
                            end if;
                        end loop;

                        for byte in 0 to AxiBytes_c - 1 loop
                            if r.RdFirstAddrOffs <= byte then
                                v.RdFirstBe(byte) := '1';
                            else
                                v.RdFirstBe(byte) := '0';
                            end if;
                        end loop;

                    end if;

                when WaitDataFsm_s =>
                    v.RdStartTf := '1';
                    if r.RdDataFsm = Idle_s then
                        v.RdCmdFsm    := Idle_s;
                        v.CmdRd_Ready := '1';
                        v.RdStartTf   := '0';
                    end if;

                when others => null;    -- unreachable code
            end case;

            v.RdDataEna := '0';
            RdDatBe_v   := (others => '1');

            case r.RdDataFsm is
                when Idle_s =>
                    v.RdDatFirstBe  := r.RdFirstBe;
                    v.RdDatLastBe   := r.RdLastBe;
                    v.RdDataWords   := unsigned(r.AxiRdCmd_Size);
                    v.RdCurrentWord := to_unsigned(1, v.RdCurrentWord'length);
                    v.RdAlignShift  := r.RdShift;
                    v.RdAlignLowIdx := r.RdLowIdx;
                    if r.RdStartTf = '1' then
                        v.RdDataFsm := Transfer_s;
                        v.RdDataEna := '1';
                    end if;

                when Transfer_s =>
                    v.RdDataEna := '1';
                    if r.RdCurrentWord = 1 then
                        RdDatBe_v := RdDatBe_v and r.RdDatFirstBe;
                    end if;
                    if r.RdCurrentWord = r.RdDataWords then
                        RdDatBe_v := RdDatBe_v and r.RdDatLastBe;
                    end if;
                    if (RdAlignReady_v = '1') and (AxiRdDat_Vld = '1') and (r.RdDataEna = '1') then
                        v.RdCurrentWord := r.RdCurrentWord + 1;
                        if r.RdCurrentWord = r.RdDataWords then
                            v.RdDataEna := '0';
                            v.RdDataFsm := Wait_s;
                        end if;
                    end if;

                when Wait_s =>
                    if unsigned(r.RdAlignByteVld) = 0 then
                        v.RdDataFsm := Idle_s;
                    end if;

                when others => null; -- unreachable code
            end case;

            AxiRdDat_Rdy <= RdAlignReady_v;
            RdPl_Vld     <= '0';
            if (RdPl_Rdy = '1') and (RdAlignReady_v = '0' or AxiRdDat_Vld = '1' or r.RdAlignLast = '1') then
                v.RdAlignReg     := zerosVector(UserDataWidth_g) & r.RdAlignReg(r.RdAlignReg'left downto UserDataWidth_g);
                v.RdAlignByteVld := zerosVector(DataBytes_c) & r.RdAlignByteVld(r.RdAlignByteVld'left downto DataBytes_c);
                if r.RdAlignLast = '1' then
                    RdPl_Vld <= or_reduce(r.RdAlignByteVld(DataBytes_c - 1 downto 0));
                else
                    RdPl_Vld <= and_reduce(r.RdAlignByteVld(DataBytes_c - 1 downto 0));
                end if;
            end if;
            if RdAlignReady_v = '1' and AxiRdDat_Vld = '1' then
                v.RdAlignReg(RdLowIdxInt_v * 8 + AxiDataWidth_g - 1 downto RdLowIdxInt_v * 8) := AxiRdDat_Data;
                v.RdAlignByteVld(RdLowIdxInt_v + AxiBytes_c - 1 downto RdLowIdxInt_v)         := RdDatBe_v;
                v.RdAlignLast                                                                 := AxiRdDat_Last;
            end if;

            RdPl_Last <= r.RdAlignLast and not (or_reduce(r.RdAlignByteVld(r.RdAlignByteVld'high downto DataBytes_c)));
            RdPl_Data <= r.RdAlignReg(UserDataWidth_g - 1 downto 0);

        end if;

        r_next <= v;
    end process;

    p_reg : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                if ImplWrite_g then
                    r.WrCmdFsm     <= Idle_s;
                    r.CmdWr_Ready  <= '0';
                    r.AxiWrCmd_Vld <= '0';
                    r.WrWconvFsm   <= Idle_s;
                    r.WrStartTf    <= '0';
                    r.WrAlignFsm   <= Idle_s;
                    r.WrAlignVld   <= '0';
                end if;
                if ImplRead_g then
                    r.RdCmdFsm       <= Idle_s;
                    r.CmdRd_Ready    <= '0';
                    r.AxiRdCmd_Vld   <= '0';
                    r.RdDataFsm      <= Idle_s;
                    r.RdStartTf      <= '0';
                    r.RdDataEna      <= '0';
                    r.RdAlignByteVld <= (others => '0');
                end if;
            end if;
        end if;
    end process;

    CmdWr_Ready <= r.CmdWr_Ready;
    CmdRd_Ready <= r.CmdRd_Ready;

    AxiWrDat_Data <= r.WrAlignReg(AxiWrDat_Data'range);
    AxiWrDat_Be   <= r.WrAlignBe(AxiWrDat_Be'range);

    i_axi : entity work.olo_axi_master_simple
        generic map (
            AxiAddrWidth_g              => AxiAddrWidth_g,
            AxiDataWidth_g              => AxiDataWidth_g,
            AxiMaxBeats_g               => AxiMaxBeats_g,
            AxiMaxOpenTransactions_g    => AxiMaxOpenTransactions_g,
            UserTransactionSizeBits_g   => UserTransactionSizeBits_g,
            DataFifoDepth_g             => DataFifoDepth_g,
            ImplRead_g                  => ImplRead_g,
            ImplWrite_g                 => ImplWrite_g,
            RamBehavior_g               => RamBehavior_g
        )
        port map (
            Clk             => Clk,
            Rst             => Rst,
            CmdWr_Addr      => r.AxiWrCmd_Addr,
            CmdWr_Size      => r.AxiWrCmd_Size,
            CmdWr_LowLat    => r.AxiWrCmd_LowLat,
            CmdWr_Valid     => r.AxiWrCmd_Vld,
            CmdWr_Ready     => AxiWrCmd_Rdy,
            CmdRd_Addr      => r.AxiRdCmd_Addr,
            CmdRd_Size      => r.AxiRdCmd_Size,
            CmdRd_LowLat    => r.AxiRdCmd_LowLat,
            CmdRd_Valid     => r.AxiRdCmd_Vld,
            CmdRd_Ready     => AxiRdCmd_Rdy,
            Wr_Data         => AxiWrDat_Data,
            Wr_Be           => AxiWrDat_Be,
            Wr_Valid        => r.WrAlignVld,
            Wr_Ready        => AxiWrDat_Rdy,
            Rd_Data         => AxiRdDat_Data,
            Rd_Valid        => AxiRdDat_Vld,
            Rd_Ready        => AxiRdDat_Rdy,
            Rd_Last         => AxiRdDat_Last,
            Wr_Done         => Wr_Done,
            Wr_Error        => Wr_Error,
            Rd_Done         => Rd_Done,
            Rd_Error        => Rd_Error,
            M_Axi_AwAddr    => M_Axi_AwAddr,
            M_Axi_AwLen     => M_Axi_AwLen,
            M_Axi_AwSize    => M_Axi_AwSize,
            M_Axi_AwBurst   => M_Axi_AwBurst,
            M_Axi_AwLock    => M_Axi_AwLock,
            M_Axi_AwCache   => M_Axi_AwCache,
            M_Axi_AwProt    => M_Axi_AwProt,
            M_Axi_AwValid   => M_Axi_AwValid,
            M_Axi_AwReady   => M_Axi_AwReady,
            M_Axi_WData     => M_Axi_WData,
            M_Axi_WStrb     => M_Axi_WStrb,
            M_Axi_WLast     => M_Axi_WLast,
            M_Axi_WValid    => M_Axi_WValid,
            M_Axi_WReady    => M_Axi_WReady,
            M_Axi_BResp     => M_Axi_BResp,
            M_Axi_BValid    => M_Axi_BValid,
            M_Axi_BReady    => M_Axi_BReady,
            M_Axi_ArAddr    => M_Axi_ArAddr,
            M_Axi_ArLen     => M_Axi_ArLen,
            M_Axi_ArSize    => M_Axi_ArSize,
            M_Axi_ArBurst   => M_Axi_ArBurst,
            M_Axi_ArLock    => M_Axi_ArLock,
            M_Axi_ArCache   => M_Axi_ArCache,
            M_Axi_ArProt    => M_Axi_ArProt,
            M_Axi_ArValid   => M_Axi_ArValid,
            M_Axi_ArReady   => M_Axi_ArReady,
            M_Axi_RData     => M_Axi_RData,
            M_Axi_RResp     => M_Axi_RResp,
            M_Axi_RLast     => M_Axi_RLast,
            M_Axi_RValid    => M_Axi_RValid,
            M_Axi_RReady    => M_Axi_RReady
        );

    g_write : if ImplWrite_g generate

        WrPl_Rdy <= WrWconv_Rdy and WrWconvEna;

        i_pl_wr_data : entity work.olo_base_pl_stage
            generic map (
                Width_g        => UserDataWidth_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data     => Wr_Data,
                In_Valid    => Wr_Valid,
                In_Ready    => Wr_Ready,
                Out_Data    => WrPl_Data,
                Out_Valid   => WrPl_Vld,
                Out_Ready   => WrPl_Rdy
            );

        WrWconv_Vld <= WrWconvEna and WrPl_Vld;
        WrData_Rdy  <= AxiWrDat_Rdy and WrDataEna;

        i_wc_wr : entity work.olo_base_wconv_n2xn
            generic map (
                InWidth_g   => UserDataWidth_g,
                OutWidth_g  => AxiDataWidth_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Valid    => WrWconv_Vld,
                In_Ready    => WrWconv_Rdy,
                In_Data     => WrPl_Data,
                In_Last     => WrWconv_Last,
                Out_Valid   => WrData_Vld,
                Out_Ready   => WrData_Rdy,
                Out_Data    => WrData_Data,
                Out_Last    => WrData_Last,
                Out_WordEna => WrData_We
            );

    end generate;

    g_nwrite : if not ImplWrite_g generate
        Wr_Ready <= '0';
    end generate;

    g_read : if ImplRead_g generate
        signal InData, OutData : std_logic_vector(UserDataWidth_g downto 0);
    begin
        InData <= RdPl_Last & RdPl_Data;

        i_pl_rd_data : entity work.olo_base_pl_stage
            generic map (
                Width_g     => UserDataWidth_g+1
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data     => InData,
                In_Valid    => RdPl_Vld,
                In_Ready    => RdPl_Rdy,
                Out_Data    => OutData,
                Out_Valid   => Rd_Valid,
                Out_Ready   => Rd_Ready
            );

        Rd_Last <= OutData(UserDataWidth_g);
        Rd_Data <= OutData(UserDataWidth_g-1 downto 0);

    end generate;

    g_nread : if not ImplRead_g generate
        Rd_Valid <= '0';
        Rd_Data  <= (others => '0');
        Rd_Last  <= '0';
    end generate;

end architecture;",45
"This entity executes transactions requested through a simple command interface on an AXI4 bus according to all specifications. This entity includes FIFOs to buffer read- and write-data but not for the commands. The user can request transaction of any size and they will get split automatically in order to not exceed AXI bust size and not burst over 4kB boundaries (prohibited by the AXI4 specification). The response is sent to the user when his whole command is executed (which may involve multiple AXI transactions). For each command there are two operation modes: - High Latency - The AXI-master only starts the command after sufficient data (write-case) or space (read-case) is available in the corresponding data FIFO - This ensures that commands can be executed without blocking the AXI bus. - This approach leads to more latency, since the user has to handle data before the command is sent. - Suggested default. - Low Latency - The AXI-master starts the transaction immediately, with no regard on FIFO states. - If the user logic cannot provide the data in-time, the AXI bus may get blocked. - This approach leads to lowest latency since the user logic can prepare the data on the fly without the transaction being delayed. This entity does not handle unaligned transactions and word-width conversions. The data width of the user interface and the AXI bus are the same and all commands must be aligned to that word-width. This is the reason for the term _simple_ in the name of the entity. Read and write logic are fully independent. Reads and writes can happen at the same time. There is no required timing relationship between command and data signals. So for writes the user can provide write data before, after or together with the command. Note that this entity does require a minimum of four clock cycles for every write transaction. **It is not optimal for producing access patterns with many single-beat transactions.**

# VHDL Analysis for 'olo_axi_master_simple.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements a simple AXI master. Simple means: It does not
- Plus 147 more comments

## Libraries and Packages
- Library: ieee
- Library: work
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: work.olo_base_pkg_math.all
- Use: work.olo_base_pkg_logic.all
- Use: work.olo_axi_pkg_protocol.all
- Use: registered WDataFifoWrite: This helps with timing and it does not introduce any risk since
            -- .. the decrement is still done immediately, the increment is delayed by one clock cycle. So worst
            -- .. case a High-Latency transfer is delayed by one cycle which is acceptable.
            v.WDataFifoWrite := WrData_Rdy_I and Wr_Valid
- Use: v. because it may have been modified above and this modification has not to be overriden
                if WrRespIsLast = '1' then
                    if (M_Axi_BResp /= AxiResp_Okay_c) then
                        v.Wr_Error := '1'
- Use: registered RDataFifoRead: This helps with timing and it does not introduce any risk since
            -- .. the decrement is still done immediately, the increment is delayed by one clock cycle. So worst
            -- .. case a High-Latency transfer is delayed by one cycle which is acceptable.
            v.RDataFifoRead := Rd_Ready and RdDat_Vld_I
- Use: v. because it may have been modified above and this modification has not to be overriden
                if RdRespIsLast = '1' then
                    if (M_Axi_RResp /= AxiResp_Okay_c) then
                        v.Rd_Error := '1'

## Entity: olo_axi_master_simple

## Architecture: rtl of olo_axi_master_simple

### Signals
- r: TwoProcess_r
- r_next: TwoProcess_r
- WrDataFifoORdy: std_logic
- WrDataFifoOVld: std_logic
- WrTransFifoInVld: std_logic
- WrTransFifoBeats: std_logic_vector(BeatsBits_c - 1 downto 0)
- WrTransFifoOutVld: std_logic
- WrRespIsLast: std_logic
- WrRespFifoVld: std_logic
- WrData_Rdy_I: std_logic
- RdTransFifoInVld: std_logic
- RdRespIsLast: std_logic
- RdRespFifoVld: std_logic
- RdDat_Vld_I: std_logic
- RdRespLast: std_logic
- M_Axi_RReady_I: std_logic
- ***
        r_next <= v;
    end process;

    -- *** Registered Process ***
    p_reg: process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next
- InData: std_logic_vector(Wr_Data'length + Wr_Be'length - 1 downto 0)
- OutData: std_logic_vector(InData'range)
- InData: std_logic_vector(Rd_Data'length downto 0)
- OutData: std_logic_vector(Rd_Data'length downto 0)

### Component Instantiations
- Instance 'i_fifo_wr_trans' of component 'olo_base_fifo_sync'
- Instance 'i_fifo_wr_data' of component 'olo_base_fifo_sync'
- Instance 'i_fifo_wr_resp' of component 'olo_base_fifo_sync'
- Instance 'i_fifo_rd_data' of component 'olo_base_fifo_sync'
- Instance 'i_fifo_rd_resp' of component 'olo_base_fifo_sync'

### Processes
- Process 'p_assert :' (Clocked) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'p_comb :' (Has Reset) with sensitivity list: r, M_Axi_AwReady, M_Axi_BValid, M_Axi_BResp, WrDataFifoORdy, WrDataFifoOVld, WrTransFifoOutVld,
                      WrTransFifoBeats, WrRespIsLast, WrRespFifoVld, CmdWr_Addr, CmdWr_Size, CmdWr_LowLat, CmdWr_Valid,
                      Wr_Valid, WrData_Rdy_I, M_Axi_ArReady, RdRespIsLast, RdRespFifoVld, RdRespLast, CmdRd_Addr,
                      CmdRd_Size, CmdRd_LowLat, CmdRd_Valid, Rd_Ready, RdDat_Vld_I, M_Axi_RResp
  - Implements case-based selection logic
- Process 'p_reg :' (Clocked) (Has Reset) with sensitivity list: Clk
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements case-based selection logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

### Concurrent Statements
- Masked_v(UnusedAddrBits_c - 1 downto 0) := (others => '0')
- return Masked_v

## Functional Analysis

- This appears to be a Finite State Machine implementation
- Contains 2 clock domain(s): Clk, clock
- Uses reset signal(s): StartWBurst_v, M_Axi_ArBurst, M_Axi_AwBurst, AxiBurst_Incr_c, Rst, burst, worst
- Implements memory functionality
- Implements control logic
- Implements interface or communication protocol
- This appears to be a CPU component
- Implements instruction execution functionality
- Defines custom functions: addrMasked

## Code Metrics
- Line count: 837
- Process count: 6
- Signal count: 21

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_axi_master_simple.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: AXI Master Simple (olo_axi_master_simple)**

**Overview**

The olo_axi_master_simple component is a simple AXI master interface designed to facilitate data transfer between a user logic and an AXI slave device. This component supports both write and read transactions, with optional low-latency and maximum open transactions.

**Functional Description**

The olo_axi_master_simple component acts as a bridge between a user logic and an AXI slave device. It provides a simple interface for the user logic to initiate write and read transactions, while handling the complexities of the AXI protocol.

**Inputs**

* **Clk**: Clock input
* **Rst**: Reset input
* **CmdWr_Addr**: Write address input (width: AxiAddrWidth_g)
* **CmdWr_Size**: Write size input (width: UserTransactionSizeBits_g)
* **CmdWr_LowLat**: Write low-latency input (1-bit)
* **CmdWr_Valid**: Write valid input (1-bit)
* **CmdRd_Addr**: Read address input (width: AxiAddrWidth_g)
* **CmdRd_Size**: Read size input (width: UserTransactionSizeBits_g)
* **CmdRd_LowLat**: Read low-latency input (1-bit)
* **CmdRd_Valid**: Read valid input (1-bit)
* **Wr_Data**: Write data input (width: AxiDataWidth_g)
* **Wr_Be**: Write byte enable input (width: Axi","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;
    use work.olo_axi_pkg_protocol.all;

entity olo_axi_master_simple is
    generic (
        AxiAddrWidth_g              : positive range 12 to 64  := 32;
        AxiDataWidth_g              : positive range 8 to 1024 := 32;
        AxiMaxBeats_g               : positive range 1 to 256  := 256;
        AxiMaxOpenTransactions_g    : positive range 1 to 8    := 8;
        UserTransactionSizeBits_g   : positive                 := 24;
        DataFifoDepth_g             : positive                 := 1024;
        ImplRead_g                  : boolean                  := true;
        ImplWrite_g                 : boolean                  := true;
        RamBehavior_g               : string                   := ""RBW""
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        CmdWr_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdWr_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdWr_LowLat    : in    std_logic                                                := '0';
        CmdWr_Valid     : in    std_logic                                                := '0';
        CmdWr_Ready     : out   std_logic;
        CmdRd_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdRd_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdRd_LowLat    : in    std_logic                                                := '0';
        CmdRd_Valid     : in    std_logic                                                := '0';
        CmdRd_Ready     : out   std_logic;
        Wr_Data         : in    std_logic_vector(AxiDataWidth_g - 1 downto 0)            := (others => '0');
        Wr_Be           : in    std_logic_vector(AxiDataWidth_g / 8 - 1 downto 0)        := (others => '0');
        Wr_Valid        : in    std_logic                                                := '0';
        Wr_Ready        : out   std_logic;
        Rd_Data         : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        Rd_Last         : out   std_logic;
        Rd_Valid        : out   std_logic;
        Rd_Ready        : in    std_logic                                                := '1';
        Wr_Done         : out   std_logic;
        Wr_Error        : out   std_logic;
        Rd_Done         : out   std_logic;
        Rd_Error        : out   std_logic;
        M_Axi_AwAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_AwLen     : out   std_logic_vector(7 downto 0);
        M_Axi_AwSize    : out   std_logic_vector(2 downto 0);
        M_Axi_AwBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_AwLock    : out   std_logic;
        M_Axi_AwCache   : out   std_logic_vector(3 downto 0);
        M_Axi_AwProt    : out   std_logic_vector(2 downto 0);
        M_Axi_AwValid   : out   std_logic;
        M_Axi_AwReady   : in    std_logic                                                := '0';
        M_Axi_WData     : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        M_Axi_WStrb     : out   std_logic_vector(AxiDataWidth_g / 8 - 1 downto 0);
        M_Axi_WLast     : out   std_logic;
        M_Axi_WValid    : out   std_logic;
        M_Axi_WReady    : in    std_logic                                                := '0';
        M_Axi_BResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_BValid    : in    std_logic                                                := '0';
        M_Axi_BReady    : out   std_logic;
        M_Axi_ArAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_ArLen     : out   std_logic_vector(7 downto 0);
        M_Axi_ArSize    : out   std_logic_vector(2 downto 0);
        M_Axi_ArBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_ArLock    : out   std_logic;
        M_Axi_ArCache   : out   std_logic_vector(3 downto 0);
        M_Axi_ArProt    : out   std_logic_vector(2 downto 0);
        M_Axi_ArValid   : out   std_logic;
        M_Axi_ArReady   : in    std_logic                                                := '0';
        M_Axi_RData     : in    std_logic_vector(AxiDataWidth_g - 1 downto 0)            := (others => '0');
        M_Axi_RResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_RLast     : in    std_logic                                                := '0';
        M_Axi_RValid    : in    std_logic                                                := '0';
        M_Axi_RReady    : out   std_logic
    );
end entity;

architecture rtl of olo_axi_master_simple is

    constant UnusedAddrBits_c : natural := log2(AxiDataWidth_g / 8);

    constant BeatsBits_c     : natural := log2ceil(AxiMaxBeats_g + 1);
    constant MaxBeatsNoCmd_c : natural := max(AxiMaxBeats_g * AxiMaxOpenTransactions_g, DataFifoDepth_g);

    type WriteTfGen_t is (Idle_s, MaxCalc_s, GenTf_s, WriteTf_s);
    type ReadTfGen_t is (Idle_s, MaxCalc_s, GenTf_s, WriteTf_s);
    type AwFsm_t is (Idle_s, Wait_s);
    type ArFsm_t is (Idle_s, Wait_s);
    type WrFsm_t is (Idle_s, NonLast_s, Last_s);

    function addrMasked (Addr : in std_logic_vector) return std_logic_vector is
        variable Masked_v : std_logic_vector(Addr'range);
    begin
        Masked_v                                := Addr;
        Masked_v(UnusedAddrBits_c - 1 downto 0) := (others => '0');
        return Masked_v;
    end function;

    type TwoProcess_r is record
        CmdWr_Ready     : std_logic;
        Wr_Error        : std_logic;
        Wr_Done         : std_logic;
        WriteTfGenState : WriteTfGen_t;
        WrAddr          : unsigned(CmdWr_Addr'range);
        WrBeats         : unsigned(CmdWr_Size'range);
        WrLowLat        : std_logic;
        WrMaxBeats      : unsigned(BeatsBits_c - 1 downto 0);
        WrTfBeats       : unsigned(BeatsBits_c - 1 downto 0);
        WrTfVld         : std_logic;
        WrTfIsLast      : std_logic;
        AwFsm           : AwFsm_t;
        AwFsmRdy        : std_logic;
        AwCmdSent       : std_logic;
        AwCmdSize       : unsigned(BeatsBits_c - 1 downto 0);
        AwCmdSizeMin1   : unsigned(BeatsBits_c - 1 downto 0); -- AwCmdSize-1 for timing optimization reasons
        WDataFifoWrite  : std_logic;
        WFsm            : WrFsm_t;
        WDataFifoRd     : std_logic;
        WDataEna        : std_logic;
        WDataBeats      : unsigned(BeatsBits_c - 1 downto 0);
        WrRespError     : std_logic;
        WrOpenTrans     : integer range -1 to AxiMaxOpenTransactions_g;
        WrBeatsNoCmd    : signed(log2ceil(MaxBeatsNoCmd_c + 1) downto 0);
        M_Axi_AwAddr    : std_logic_vector(M_Axi_AwAddr'range);
        M_Axi_AwLen     : std_logic_vector(M_Axi_AwLen'range);
        M_Axi_AwValid   : std_logic;
        M_Axi_WLast     : std_logic;

        CmdRd_Ready     : std_logic;
        Rd_Error        : std_logic;
        Rd_Done         : std_logic;
        ReadTfGenState  : ReadTfGen_t;
        RdAddr          : unsigned(CmdRd_Addr'range);
        RdBeats         : unsigned(CmdRd_Size'range);
        RdLowLat        : std_logic;
        RdMaxBeats      : unsigned(BeatsBits_c - 1 downto 0);
        RdTfBeats       : unsigned(BeatsBits_c - 1 downto 0);
        RdTfVld         : std_logic;
        RdTfIsLast      : std_logic;
        ArFsm           : ArFsm_t;
        ArFsmRdy        : std_logic;
        ArCmdSent       : std_logic;
        ArCmdSize       : unsigned(BeatsBits_c - 1 downto 0);
        ArCmdSizeMin1   : unsigned(BeatsBits_c - 1 downto 0); -- ArCmdSize-1 for timing optimization reasons
        RDataFifoRead   : std_logic;
        RdRespError     : std_logic;
        RdOpenTrans     : unsigned(log2ceil(AxiMaxOpenTransactions_g + 1) - 1 downto 0);
        RdFifoSpaceFree : signed(log2ceil(MaxBeatsNoCmd_c + 1) downto 0);
        M_Axi_ArAddr    : std_logic_vector(M_Axi_ArAddr'range);
        M_Axi_ArLen     : std_logic_vector(M_Axi_ArLen'range);
        M_Axi_ArValid   : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal WrDataFifoORdy    : std_logic;
    signal WrDataFifoOVld    : std_logic;
    signal WrTransFifoInVld  : std_logic;
    signal WrTransFifoBeats  : std_logic_vector(BeatsBits_c - 1 downto 0);
    signal WrTransFifoOutVld : std_logic;
    signal WrRespIsLast      : std_logic;
    signal WrRespFifoVld     : std_logic;
    signal WrData_Rdy_I      : std_logic;
    signal RdTransFifoInVld  : std_logic;
    signal RdRespIsLast      : std_logic;
    signal RdRespFifoVld     : std_logic;
    signal RdDat_Vld_I       : std_logic;
    signal RdRespLast        : std_logic;
    signal M_Axi_RReady_I    : std_logic;

begin

    assert AxiDataWidth_g mod 8 = 0
        report ""###ERROR###: olo_axi_master_simple AxiDataWidth_g must be a multiple of 8""
        severity failure;
    assert isPower2(AxiDataWidth_g/8)
        report ""###ERROR###: olo_axi_master_simple AxiDataWidth_g must be 2^X bytes""
        severity failure;
    assert UserTransactionSizeBits_g < AxiAddrWidth_g-log2(AxiDataWidth_g/8)
        report ""###ERROR###: olo_axi_master_simple UserTransactionSizeBits_g must be smaller than AxiAddrWidth_g-log2(AxiDataWidth_g/8), see documentation""
        severity failure;

    p_assert : process (Clk) is
    begin
        if rising_edge(Clk) then
            if ImplRead_g and RdRespLast = '1' then
                assert RdRespFifoVld = '1'
                    report ""###ERROR###: olo_axi_master_simple: Unexpected Read Response (RdRespFifo Empty)""
                    severity error;
            end if;
            if ImplWrite_g and M_Axi_BValid = '1' then
                assert WrRespFifoVld = '1'
                    report ""###ERROR###: olo_axi_master_simple: Unexpected Write Response (WrRespFifo Empty)""
                    severity error;
            end if;
        end if;
    end process;

    p_comb : process (r, M_Axi_AwReady, M_Axi_BValid, M_Axi_BResp, WrDataFifoORdy, WrDataFifoOVld, WrTransFifoOutVld,
                      WrTransFifoBeats, WrRespIsLast, WrRespFifoVld, CmdWr_Addr, CmdWr_Size, CmdWr_LowLat, CmdWr_Valid,
                      Wr_Valid, WrData_Rdy_I, M_Axi_ArReady, RdRespIsLast, RdRespFifoVld, RdRespLast, CmdRd_Addr,
                      CmdRd_Size, CmdRd_LowLat, CmdRd_Valid, Rd_Ready, RdDat_Vld_I, M_Axi_RResp) is
        variable v               : TwoProcess_r;
        variable WrMax4kBeats_v  : unsigned(13 - UnusedAddrBits_c downto 0);
        variable RdMax4kBeats_v  : unsigned(13 - UnusedAddrBits_c downto 0);
        variable Stdlv9Bit_v     : std_logic_vector(8 downto 0);
        variable WDataTransfer_v : boolean;
        variable StartWBurst_v   : boolean := true;
    begin
        v := r;

        if ImplWrite_g then

            WrMax4kBeats_v := (others => '0');

            case r.WriteTfGenState is
                when Idle_s =>
                    v.CmdWr_Ready := '1';
                    if (r.CmdWr_Ready = '1') and (CmdWr_Valid = '1') then
                        v.CmdWr_Ready     := '0';
                        v.WrAddr          := unsigned(addrMasked(CmdWr_Addr));
                        v.WrBeats         := unsigned(CmdWr_Size);
                        v.WrLowLat        := CmdWr_LowLat;
                        v.WriteTfGenState := MaxCalc_s;
                    end if;

                when MaxCalc_s =>
                    WrMax4kBeats_v := resize(unsigned('0' & not r.WrAddr(11 downto UnusedAddrBits_c)) + 1, WrMax4kBeats_v'length);
                    if WrMax4kBeats_v > AxiMaxBeats_g then
                        v.WrMaxBeats := to_unsigned(AxiMaxBeats_g, BeatsBits_c);
                    else
                        v.WrMaxBeats := WrMax4kBeats_v(BeatsBits_c - 1 downto 0);
                    end if;
                    v.WriteTfGenState := GenTf_s;

                when GenTf_s =>
                    if (r.WrMaxBeats < r.WrBeats) then
                        v.WrTfBeats  := r.WrMaxBeats;
                        v.WrTfIsLast := '0';
                    else
                        v.WrTfBeats  := r.WrBeats(BeatsBits_c - 1 downto 0);
                        v.WrTfIsLast := '1';
                    end if;
                    v.WrTfVld         := '1';
                    v.WriteTfGenState := WriteTf_s;

                when WriteTf_s =>
                    if (r.WrTfVld = '1') and (r.AwFsmRdy = '1') then
                        v.WrTfVld := '0';
                        v.WrBeats := r.WrBeats - r.WrTfBeats;
                        v.WrAddr  := r.WrAddr + resize(2**UnusedAddrBits_c * r.WrTfBeats, v.WrAddr'length);
                        if r.WrTfIsLast = '1' then
                            v.WriteTfGenState := Idle_s;
                        else
                            v.WriteTfGenState := MaxCalc_s;
                        end if;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.AwCmdSent := '0';

            case r.AwFsm is
                when Idle_s =>
                    if ((r.WrLowLat = '1') or (r.WrBeatsNoCmd >= signed('0' & r.WrTfBeats))) and
                       (r.WrOpenTrans < AxiMaxOpenTransactions_g) and (r.WrTfVld = '1') then
                        v.AwFsmRdy := '1';
                    end if;
                    if (r.AwFsmRdy = '1') and (r.WrTfVld = '1') then
                        v.AwFsmRdy      := '0';
                        v.M_Axi_AwAddr  := std_logic_vector(r.WrAddr);
                        Stdlv9Bit_v     := std_logic_vector(resize(r.WrTfBeats - 1, 9));
                        v.M_Axi_AwLen   := Stdlv9Bit_v(7 downto 0);
                        v.M_Axi_AwValid := '1';
                        v.AwFsm         := Wait_s;
                        v.AwCmdSent     := '1';
                        v.AwCmdSize     := r.WrTfBeats;
                        v.AwCmdSizeMin1 := r.WrTfBeats - 1;
                    end if;

                when Wait_s =>
                    if M_Axi_AwReady = '1' then
                        v.WrOpenTrans   := r.WrOpenTrans + 1;
                        v.M_Axi_AwValid := '0';
                        v.AwFsm         := Idle_s;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.WDataFifoWrite := WrData_Rdy_I and Wr_Valid;
            if r.AwCmdSent = '1' then
                if r.WDataFifoWrite = '1' then
                    v.WrBeatsNoCmd := r.WrBeatsNoCmd - signed('0' & r.AwCmdSizeMin1); -- Decrement by size and increment by one (timing opt)
                else
                    v.WrBeatsNoCmd := r.WrBeatsNoCmd - signed('0' & r.AwCmdSize);
                end if;
            elsif r.WDataFifoWrite = '1' then
                v.WrBeatsNoCmd := r.WrBeatsNoCmd + 1;
            end if;

            WDataTransfer_v := (r.WDataEna = '1') and (WrDataFifoOVld = '1') and (WrDataFifoORdy = '1');
            v.WDataFifoRd   := '0';
            StartWBurst_v   := false;

            case r.WFsm is
                when Idle_s =>
                    if WrTransFifoOutVld = '1' then
                        StartWBurst_v := true;      -- shared code
                    end if;

                when NonLast_s =>
                    if WDataTransfer_v then
                        if r.WDataBeats = 2 then
                            v.M_Axi_WLast := '1';
                            v.WFsm        := Last_s;
                        end if;
                        v.WDataBeats := r.WDataBeats - 1;
                    end if;

                when Last_s =>
                    if WDataTransfer_v then
                        if (WrTransFifoOutVld = '1') and (r.WDataFifoRd = '0') then
                            StartWBurst_v := true;    -- shared code
                        else
                            v.WDataEna    := '0';
                            v.WFsm        := Idle_s;
                            v.M_Axi_WLast := '0';
                        end if;
                    end if;

                when others => null; -- unreachable code

            end case;

            if StartWBurst_v then
                v.WDataFifoRd := '1';
                v.WDataEna    := '1';
                v.WDataBeats  := unsigned(WrTransFifoBeats);
                if unsigned(WrTransFifoBeats) = 1 then
                    v.M_Axi_WLast := '1';
                    v.WFsm        := Last_s;
                else
                    v.M_Axi_WLast := '0';
                    v.WFsm        := NonLast_s;
                end if;
            end if;

            v.Wr_Done  := '0';
            v.Wr_Error := '0';

            if M_Axi_BValid = '1' then
                v.WrOpenTrans := v.WrOpenTrans - 1; -- Use v. because it may have been modified above and this modification has not to be overriden
                if WrRespIsLast = '1' then
                    if (M_Axi_BResp /= AxiResp_Okay_c) then
                        v.Wr_Error := '1';
                    else
                        v.Wr_Error    := r.WrRespError;
                        v.Wr_Done     := not r.WrRespError;
                        v.WrRespError := '0';
                    end if;
                elsif M_Axi_BResp /= AxiResp_Okay_c then
                    v.WrRespError := '1';
                end if;
            end if;

        end if;

        if ImplRead_g then

            RdMax4kBeats_v := (others => '0');

            case r.ReadTfGenState is
                when Idle_s =>
                    v.CmdRd_Ready := '1';
                    if (r.CmdRd_Ready = '1') and (CmdRd_Valid = '1') then
                        v.CmdRd_Ready    := '0';
                        v.RdAddr         := unsigned(addrMasked(CmdRd_Addr));
                        v.RdBeats        := unsigned(CmdRd_Size);
                        v.RdLowLat       := CmdRd_LowLat;
                        v.ReadTfGenState := MaxCalc_s;
                    end if;

                when MaxCalc_s =>
                    RdMax4kBeats_v := resize(unsigned('0' & not r.RdAddr(11 downto UnusedAddrBits_c)) + 1, RdMax4kBeats_v'length);
                    if RdMax4kBeats_v > AxiMaxBeats_g then
                        v.RdMaxBeats := to_unsigned(AxiMaxBeats_g, BeatsBits_c);
                    else
                        v.RdMaxBeats := RdMax4kBeats_v(BeatsBits_c - 1 downto 0);
                    end if;
                    v.ReadTfGenState := GenTf_s;

                when GenTf_s =>
                    if (r.RdMaxBeats < r.RdBeats) then
                        v.RdTfBeats  := r.RdMaxBeats;
                        v.RdTfIsLast := '0';
                    else
                        v.RdTfBeats  := r.RdBeats(BeatsBits_c - 1 downto 0);
                        v.RdTfIsLast := '1';
                    end if;
                    v.RdTfVld        := '1';
                    v.ReadTfGenState := WriteTf_s;

                when WriteTf_s =>
                    if (r.RdTfVld = '1') and (r.ArFsmRdy = '1') then
                        v.RdTfVld := '0';
                        v.RdBeats := r.RdBeats - r.RdTfBeats;
                        v.RdAddr  := r.RdAddr + resize(2**UnusedAddrBits_c * r.RdTfBeats, v.RdAddr'length);
                        if r.RdTfIsLast = '1' then
                            v.ReadTfGenState := Idle_s;
                        else
                            v.ReadTfGenState := MaxCalc_s;
                        end if;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.ArCmdSent := '0';

            case r.ArFsm is
                when Idle_s =>
                    if ((r.RdLowLat = '1') or (r.RdFifoSpaceFree >= signed('0' & r.RdTfBeats))) and
                       (r.RdOpenTrans < AxiMaxOpenTransactions_g) and (r.RdTfVld = '1') then
                        v.ArFsmRdy := '1';
                    end if;
                    if (r.ArFsmRdy = '1') and (r.RdTfVld = '1') then
                        v.ArFsmRdy      := '0';
                        v.M_Axi_ArAddr  := std_logic_vector(r.RdAddr);
                        Stdlv9Bit_v     := std_logic_vector(resize(r.RdTfBeats - 1, 9));
                        v.M_Axi_ArLen   := Stdlv9Bit_v(7 downto 0);
                        v.M_Axi_ArValid := '1';
                        v.ArFsm         := Wait_s;
                        v.ArCmdSent     := '1';
                        v.ArCmdSize     := r.RdTfBeats;
                        v.ArCmdSizeMin1 := r.RdTfBeats - 1;
                    end if;

                when Wait_s =>
                    if M_Axi_ArReady = '1' then
                        v.RdOpenTrans   := r.RdOpenTrans + 1;
                        v.M_Axi_ArValid := '0';
                        v.ArFsm         := Idle_s;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.RDataFifoRead := Rd_Ready and RdDat_Vld_I;
            if r.ArCmdSent = '1' then
                if r.RDataFifoRead = '1' then
                    v.RdFifoSpaceFree := r.RdFifoSpaceFree - signed('0' & r.ArCmdSizeMin1); -- Decrement by size and increment by one (timing opt)
                else
                    v.RdFifoSpaceFree := r.RdFifoSpaceFree - signed('0' & r.ArCmdSize);
                end if;
            elsif r.RDataFifoRead = '1' then
                v.RdFifoSpaceFree := r.RdFifoSpaceFree + 1;
            end if;

            v.Rd_Done  := '0';
            v.Rd_Error := '0';

            if RdRespLast = '1' then
                v.RdOpenTrans := v.RdOpenTrans - 1; -- Use v. because it may have been modified above and this modification has not to be overriden
                if RdRespIsLast = '1' then
                    if (M_Axi_RResp /= AxiResp_Okay_c) then
                        v.Rd_Error := '1';
                    else
                        v.Rd_Error    := r.RdRespError;
                        v.Rd_Done     := not r.RdRespError;
                        v.RdRespError := '0';
                    end if;
                elsif M_Axi_RResp /= AxiResp_Okay_c then
                    v.RdRespError := '1';
                end if;
            end if;

        end if;

        r_next <= v;
    end process;

    p_reg : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                if ImplWrite_g then
                    r.CmdWr_Ready     <= '0';
                    r.WriteTfGenState <= Idle_s;
                    r.WrTfVld         <= '0';
                    r.AwFsm           <= Idle_s;
                    r.AwFsmRdy        <= '0';
                    r.AwCmdSent       <= '0';
                    r.M_Axi_AwValid   <= '0';
                    r.WDataFifoRd     <= '0';
                    r.WDataEna        <= '0';
                    r.WrOpenTrans     <= 0;
                    r.WrRespError     <= '0';
                    r.Wr_Done         <= '0';
                    r.Wr_Error        <= '0';
                    r.WrBeatsNoCmd    <= (others => '0');
                    r.WFsm            <= Idle_s;
                    r.WDataFifoWrite  <= '0';
                end if;
                if ImplRead_g then
                    r.CmdRd_Ready     <= '0';
                    r.ReadTfGenState  <= Idle_s;
                    r.RdTfVld         <= '0';
                    r.ArFsmRdy        <= '0';
                    r.ArCmdSent       <= '0';
                    r.M_Axi_ArValid   <= '0';
                    r.ArFsm           <= Idle_s;
                    r.RdOpenTrans     <= (others => '0');
                    r.RdRespError     <= '0';
                    r.Rd_Done         <= '0';
                    r.Rd_Error        <= '0';
                    r.RdFifoSpaceFree <= to_signed(DataFifoDepth_g, r.RdFifoSpaceFree'length);
                    r.RDataFifoRead   <= '0';
                end if;
            end if;
        end if;
    end process;

    CmdWr_Ready   <= r.CmdWr_Ready;
    M_Axi_AwAddr  <= r.M_Axi_AwAddr;
    M_Axi_AwLen   <= r.M_Axi_AwLen;
    M_Axi_AwValid <= r.M_Axi_AwValid;
    M_Axi_WLast   <= r.M_Axi_WLast;
    Wr_Done       <= r.Wr_Done;
    Wr_Error      <= r.Wr_Error;
    CmdRd_Ready   <= r.CmdRd_Ready;
    M_Axi_ArAddr  <= r.M_Axi_ArAddr;
    M_Axi_ArLen   <= r.M_Axi_ArLen;
    M_Axi_ArValid <= r.M_Axi_ArValid;
    Rd_Done       <= r.Rd_Done;
    Rd_Error      <= r.Rd_Error;

    M_Axi_AwSize  <= std_logic_vector(to_unsigned(log2(AxiDataWidth_g / 8), 3));
    M_Axi_ArSize  <= std_logic_vector(to_unsigned(log2(AxiDataWidth_g / 8), 3));
    M_Axi_AwBurst <= AxiBurst_Incr_c;
    M_Axi_ArBurst <= AxiBurst_Incr_c;
    M_Axi_AwCache <= ""0011"";              -- According AXI reference guide
    M_Axi_ArCache <= ""0011"";              -- According AXI reference guide
    M_Axi_AwProt  <= ""000"";               -- According AXI reference guide
    M_Axi_ArProt  <= ""000"";               -- According AXI reference guide
    M_Axi_AwLock  <= '0';                 -- Exclusive access support not implemented
    M_Axi_ArLock  <= '0';                 -- Exclusive access support not implemented
    M_Axi_BReady  <= '1' when ImplWrite_g else '0';


    g_write : if ImplWrite_g generate

        WrTransFifoInVld <= r.AwFsmRdy and r.WrTfVld;

        i_fifo_wr_trans : entity work.olo_base_fifo_sync
            generic map (
                Width_g        => BeatsBits_c,
                Depth_g        => AxiMaxOpenTransactions_g,
                RamBehavior_g  => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data     => std_logic_vector(r.WrTfBeats),
                In_Valid    => WrTransFifoInVld,
                In_Ready    => open,                  -- Not required since maximum of open transactions is limitted
                Out_Data    => WrTransFifoBeats,
                Out_Valid   => WrTransFifoOutVld,
                Out_Ready   => r.WDataFifoRd
            );

        b_fifo_wr_data : block is
            signal InData  : std_logic_vector(Wr_Data'length + Wr_Be'length - 1 downto 0);
            signal OutData : std_logic_vector(InData'range);
        begin
            InData(Wr_Data'high downto Wr_Data'low)                     <= Wr_Data;
            InData(Wr_Data'high + Wr_Be'length downto Wr_Data'high + 1) <= Wr_Be;

            i_fifo_wr_data : entity work.olo_base_fifo_sync
                generic map (
                    Width_g         => Wr_Data'length + Wr_Be'length,
                    Depth_g         => DataFifoDepth_g,
                    RamBehavior_g   => RamBehavior_g
                )
                port map (
                    Clk         => Clk,
                    Rst         => Rst,
                    In_Data     => InData,
                    In_Valid    => Wr_Valid,
                    In_Ready    => WrData_Rdy_I,
                    Out_Data    => OutData,
                    Out_Valid   => WrDataFifoOVld,
                    Out_Ready   => WrDataFifoORdy
                );

            M_Axi_WData    <= OutData(Wr_Data'high downto Wr_Data'low);
            M_Axi_WStrb    <= OutData(Wr_Data'high + Wr_Be'length downto Wr_Data'high + 1);
            M_Axi_WValid   <= WrDataFifoOVld and r.WDataEna;
            WrDataFifoORdy <= M_Axi_WReady and r.WDataEna;
            Wr_Ready       <= WrData_Rdy_I;
        end block;

        i_fifo_wr_resp : entity work.olo_base_fifo_sync
            generic map (
                Width_g        => 1,
                Depth_g        => AxiMaxOpenTransactions_g,
                RamBehavior_g  => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data(0)  => r.WrTfIsLast,
                In_Valid    => WrTransFifoInVld,
                In_Ready    => open,               -- Not required since maximum of open transactions is limitted
                Out_Data(0) => WrRespIsLast,
                Out_Valid   => WrRespFifoVld,
                Out_Ready   => M_Axi_BValid
            );

    end generate;

    g_nwrite : if not ImplWrite_g generate
        M_Axi_WStrb  <= (others => '0');
        M_Axi_WData  <= (others => '0');
        M_Axi_WValid <= '0';
        Wr_Ready     <= '0';
    end generate;

    g_read : if ImplRead_g generate

        b_fifo_rd_data : block is
            signal InData, OutData : std_logic_vector(Rd_Data'length downto 0);
        begin
            InData(M_Axi_RData'high downto 0) <= M_Axi_RData;
            InData(M_Axi_RData'high + 1) <= M_Axi_RLast and RdRespIsLast;

            i_fifo_rd_data : entity work.olo_base_fifo_sync
                generic map (
                    Width_g        => Rd_Data'length+1,
                    Depth_g        => DataFifoDepth_g,
                    RamBehavior_g  => RamBehavior_g
                )
                port map (
                    Clk         => Clk,
                    Rst         => Rst,
                    In_Data     => InData,
                    In_Valid    => M_Axi_RValid,
                    In_Ready    => M_Axi_RReady_I,
                    Out_Data    => OutData,
                    Out_Valid   => RdDat_Vld_I,
                    Out_Ready   => Rd_Ready
                );

            Rd_Data      <= OutData(Rd_Data'high downto 0);
            Rd_Last      <= OutData(Rd_Data'high+1);
            Rd_Valid     <= RdDat_Vld_I;
            M_Axi_RReady <= M_Axi_RReady_I;
        end block;

        RdTransFifoInVld <= r.ArFsmRdy and r.RdTfVld;
        RdRespLast       <= M_Axi_RValid and M_Axi_RReady_I and M_Axi_RLast;

        i_fifo_rd_resp : entity work.olo_base_fifo_sync
            generic map (
                Width_g        => 1,
                Depth_g        => AxiMaxOpenTransactions_g,
                RamBehavior_g  => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data(0)  => r.RdTfIsLast,
                In_Valid    => RdTransFifoInVld,
                In_Ready    => open,               -- Not required since maximum of open transactions is limitted
                Out_Data(0) => RdRespIsLast,
                Out_Valid   => RdRespFifoVld,
                Out_Ready   => RdRespLast
            );

    end generate;

    g_nread : if not ImplRead_g generate
        M_Axi_RReady <= '0';
        Rd_Data      <= (others => '0');
        Rd_Valid     <= '0';
    end generate;

end architecture;",46
"VHDL component olo_axi_pkg_protocol

# VHDL Analysis for 'olo_axi_pkg_protocol.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Oliver Bruendler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- Package containing axi protocol definitions
- Documentation:
- Plus 10 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Functional Analysis

- Uses reset signal(s): AxiBurst_Wrap_c, AxiBurst_Incr_c, AxiBurst_Fixed_c, Burst_t

## Code Metrics
- Line count: 58
- Process count: N/A
- Signal count: N/A

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_axi_pkg_protocol.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

This VHDL package, `olo_axi_pkg_protocol`, defines a set of constants and subtypes for AXI (Advanced eXtensible Interface) protocol signals. Specifically, it provides type definitions and constants for response codes, burst types, and data sizes, which are used to configure and communicate the results of AXI transactions. The package does not define any components or entities, but rather provides a set of reusable definitions for use in AXI-related designs.

**Detailed Component Specification**

* **Package Name:** `olo_axi_pkg_protocol`
* **Purpose:** Define AXI protocol-related constants and subtypes for use in digital design.
* **Inputs:** None
* **Outputs:** None
* **Defined Constants:**
	+ Response codes (`Resp_t`):
		- `AxiResp_Okay_c`: OK response (00)
		- `AxiResp_ExOkay_c`: Exclusive OK response (01)
		- `AxiResp_SlvErr_c`: Slave error response (10)
		- `AxiResp_DecErr_c`: Decode error response (11)
	+ Burst types (`Burst_t`):
		- `AxiBurst_Fixed_c`: Fixed burst (00)
		- `AxiBurst_Incr_c`: Incrementing burst (01)
		- `AxiBurst_Wrap_c`: Wrapping burst (10)
	+ Data sizes (`Size_t`):
		- `AxiSize_1_c`: 1","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

package olo_axi_pkg_protocol is

    subtype Resp_t is std_logic_vector(1 downto 0);
    constant AxiResp_Okay_c   : Resp_t := ""00"";
    constant AxiResp_ExOkay_c : Resp_t := ""01"";
    constant AxiResp_SlvErr_c : Resp_t := ""10"";
    constant AxiResp_DecErr_c : Resp_t := ""11"";

    subtype Burst_t is std_logic_vector(1 downto 0);
    constant AxiBurst_Fixed_c : Burst_t := ""00"";
    constant AxiBurst_Incr_c  : Burst_t := ""01"";
    constant AxiBurst_Wrap_c  : Burst_t := ""10"";

    subtype Size_t is std_logic_vector(2 downto 0);
    constant AxiSize_1_c   : Size_t := ""000"";
    constant AxiSize_2_c   : Size_t := ""001"";
    constant AxiSize_4_c   : Size_t := ""010"";
    constant AxiSize_8_c   : Size_t := ""011"";
    constant AxiSize_16_c  : Size_t := ""100"";
    constant AxiSize_32_c  : Size_t := ""101"";
    constant AxiSize_64_c  : Size_t := ""110"";
    constant AxiSize_128_c : Size_t := ""111"";

end package;

package body olo_axi_pkg_protocol is

end package body;",47
"This component implements a pipeline stage for AXI4 interfaces. The component registers all signals of the interface. Note that the component can be used for AXI4-Lite by simply leaving all unused signals unconnected.

# VHDL Analysis for 'olo_axi_pl_stage.vhd'

## File Comments
- -------------------------------------------------------------------------------------------------
- Copyright (c) 2019 by Enclustra GmbH, Switzerland
- Copyright (c) 2024 by Oliver Bründler
- All rights reserved.
- Authors: Eduardo del Castillo, Oliver Bründler
- -------------------------------------------------------------------------------------------------
- -------------------------------------------------------------------------------------------------
- Description
- -------------------------------------------------------------------------------------------------
- This entity implements multiple pipeline stages for an axi4 interface.
- Plus 46 more comments

## Libraries and Packages
- Library: ieee
- Use: an older version, the documentation might not match the code.

---------------------------------------------------------------------------------------------------
-- Libraries
---------------------------------------------------------------------------------------------------
library ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: olo_axi_pl_stage

## Architecture: rtl of olo_axi_pl_stage

### Signals
- AwDataIn: std_logic_vector(AwRegionRng_c'high downto 0)
- AwDataOut: std_logic_vector(AwRegionRng_c'high downto 0)
- WDataIn: std_logic_vector(WUserRng_c'high downto 0)
- WDataOut: std_logic_vector(WUserRng_c'high downto 0)
- BDataIn: std_logic_vector(BuserRng_c'high downto 0)
- BDataOut: std_logic_vector(BuserRng_c'high downto 0)
- ArDataIn: std_logic_vector(ArRegionRng_c'high downto 0)
- ArDataOut: std_logic_vector(ArRegionRng_c'high downto 0)
- RDataIn: std_logic_vector(RUserRng_c'high downto 0)
- RDataOut: std_logic_vector(RUserRng_c'high downto 0)

### Component Instantiations
- Instance 'i_pl' of component 'olo_base_pl_stage'
- Instance 'i_pl' of component 'olo_base_pl_stage'
- Instance 'i_bch_pl' of component 'olo_base_pl_stage'
- Instance 'i_pl' of component 'olo_base_pl_stage'
- Instance 'i_rch_pl' of component 'olo_base_pl_stage'

### Concurrent Statements
- AwDataIn(AwCacheRng_c)  <= S_AwCache
- AwDataIn(AwLockIdx_C)   <= S_AwLock
- AwDataIn(AwBurstRng_c)  <= S_AwBurst
- AwDataIn(AwSizeRng_c)   <= S_AwSize
- AwDataIn(AwLenRng_c)    <= S_AwLen
- Plus 17 more statements

## Functional Analysis

- Contains 1 clock domain(s): Clk
- Uses reset signal(s): S_AwBurst, ArBurstRng_c, S_ArBurst, Rst, AwBurstRng_c, M_AwBurst, M_ArBurst
- Implements control logic
- Implements interface or communication protocol
- May be part of a pipeline architecture

## Code Metrics
- Line count: 398
- Process count: 0
- Signal count: 10

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'olo_axi_pl_stage.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: AXI Pipeline Stage**

**Overview**

The `olo_axi_pl_stage` component is a parameterized, pipelined AXI (Advanced eXtensible Interface) stage that provides a flexible and modular way to pipeline AXI signals. This component supports AXI4 and AXI4-Lite interfaces.

**Functionality**

The component takes in AXI signals from a slave interface (S) and outputs pipelined AXI signals to a master interface (M). It supports configurable pipelining of AW, W, B, AR, and R channels.

**Inputs**

* **Clock and Reset**
	+ `Clk`: Clock signal
	+ `Rst`: Reset signal
* **Slave Interface (S)**
	+ AW channel: `S_AwId`, `S_AwAddr`, `S_AwValid`, `S_AwLen`, `S_AwSize`, `S_AwBurst`, `S_AwLock`, `S_AwCache`, `S_AwProt`, `S_AwQos`, `S_AwUser`, `S_AwRegion`
	+ W channel: `S_WData`, `S_WStrb`, `S_WValid`, `S_WLast`, `S_WUser`
	+ B channel: `S_BReady`
	+ AR channel: `S_ArId`, `S_ArAddr`, `S_ArValid`, `S_ArLen`, `","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_axi_pl_stage is
    generic (
        AddrWidth_g : positive := 32;
        DataWidth_g : positive := 32;
        IdWidth_g   : natural  := 0;
        UserWidth_g : natural  := 0;
        Stages_g    : positive := 1
    );
    port (
        Clk        : in    std_logic;
        Rst        : in    std_logic;

        S_AwId     : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        S_AwAddr   : in    std_logic_vector(AddrWidth_g - 1 downto 0);
        S_AwValid  : in    std_logic;
        S_AwReady  : out   std_logic;
        S_AwLen    : in    std_logic_vector(7 downto 0)               := (others => '0');
        S_AwSize   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_AwBurst  : in    std_logic_vector(1 downto 0)               := (others => '0');
        S_AwLock   : in    std_logic                                  := '0';
        S_AwCache  : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_AwProt   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_AwQos    : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_AwUser   : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        S_AwRegion : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_WData    : in    std_logic_vector(DataWidth_g - 1 downto 0);
        S_WStrb    : in    std_logic_vector(DataWidth_g / 8 - 1 downto 0);
        S_WValid   : in    std_logic;
        S_WReady   : out   std_logic;
        S_WLast    : in    std_logic                                  := '1';
        S_WUser    : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        S_BId      : out   std_logic_vector(IdWidth_g - 1 downto 0);
        S_BResp    : out   std_logic_vector(1 downto 0);
        S_BValid   : out   std_logic;
        S_BReady   : in    std_logic;
        S_BUser    : out   std_logic_vector(UserWidth_g - 1 downto 0);
        S_ArId     : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        S_ArAddr   : in    std_logic_vector(AddrWidth_g - 1 downto 0);
        S_ArValid  : in    std_logic;
        S_ArReady  : out   std_logic;
        S_ArLen    : in    std_logic_vector(7 downto 0)               := (others => '0');
        S_ArSize   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_ArBurst  : in    std_logic_vector(1 downto 0)               := (others => '0');
        S_ArLock   : in    std_logic;
        S_ArCache  : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_ArProt   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_ArQos    : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_ArUser   : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        S_ArRegion : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_RId      : out   std_logic_vector(IdWidth_g - 1 downto 0);
        S_RData    : out   std_logic_vector(DataWidth_g - 1 downto 0);
        S_RValid   : out   std_logic;
        S_RReady   : in    std_logic;
        S_RResp    : out   std_logic_vector(1 downto 0);
        S_RLast    : out   std_logic;
        S_RUser    : out   std_logic_vector(UserWidth_g - 1 downto 0);

        M_AwId     : out   std_logic_vector(IdWidth_g - 1 downto 0);
        M_AwAddr   : out   std_logic_vector(AddrWidth_g - 1 downto 0);
        M_AwValid  : out   std_logic;
        M_AwReady  : in    std_logic;
        M_AwLen    : out   std_logic_vector(7 downto 0);
        M_AwSize   : out   std_logic_vector(2 downto 0);
        M_AwBurst  : out   std_logic_vector(1 downto 0);
        M_AwLock   : out   std_logic;
        M_AwCache  : out   std_logic_vector(3 downto 0);
        M_AwProt   : out   std_logic_vector(2 downto 0);
        M_AwQos    : out   std_logic_vector(3 downto 0);
        M_AwUser   : out   std_logic_vector(UserWidth_g - 1 downto 0);
        M_AwRegion : out   std_logic_vector(3 downto 0);
        M_WData    : out   std_logic_vector(DataWidth_g - 1 downto 0);
        M_WStrb    : out   std_logic_vector(DataWidth_g / 8 - 1 downto 0);
        M_WValid   : out   std_logic;
        M_WReady   : in    std_logic;
        M_WLast    : out   std_logic;
        M_WUser    : out   std_logic_vector(UserWidth_g - 1 downto 0);
        M_BId      : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        M_BResp    : in    std_logic_vector(1 downto 0);
        M_BValid   : in    std_logic;
        M_BReady   : out   std_logic;
        M_BUser    : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        M_ArId     : out   std_logic_vector(IdWidth_g - 1 downto 0);
        M_ArAddr   : out   std_logic_vector(AddrWidth_g - 1 downto 0);
        M_ArValid  : out   std_logic;
        M_ArReady  : in    std_logic;
        M_ArLen    : out   std_logic_vector(7 downto 0);
        M_ArSize   : out   std_logic_vector(2 downto 0);
        M_ArBurst  : out   std_logic_vector(1 downto 0);
        M_ArLock   : out   std_logic;
        M_ArCache  : out   std_logic_vector(3 downto 0);
        M_ArProt   : out   std_logic_vector(2 downto 0);
        M_ArQos    : out   std_logic_vector(3 downto 0);
        M_ArUser   : out   std_logic_vector(UserWidth_g - 1 downto 0);
        M_ArRegion : out   std_logic_vector(3 downto 0);
        M_RId      : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        M_RData    : in    std_logic_vector(DataWidth_g - 1 downto 0);
        M_RValid   : in    std_logic;
        M_RReady   : out   std_logic;
        M_RResp    : in    std_logic_vector(1 downto 0);
        M_RLast    : in    std_logic                                  := '1';
        M_RUser    : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0')
    );
end entity;

architecture rtl of olo_axi_pl_stage is

begin

    b_aw : block is
        subtype  AwProtRng_c   is natural range S_AwProt'length-1                   downto 0;
        subtype  AwCacheRng_c  is natural range S_AwCache'length+AwProtRng_c'high   downto AwProtRng_c'high+1;
        constant AwLockIdx_C : natural := AwCacheRng_c'high+1;
        subtype  AwBurstRng_c  is natural range S_AwBurst'length+AwLockIdx_C          downto AwLockIdx_C+1;
        subtype  AwSizeRng_c   is natural range S_AwSize'length+AwBurstRng_c'high   downto AwBurstRng_c'high+1;
        subtype  AwLenRng_c    is natural range S_AwLen'length+AwSizeRng_c'high     downto AwSizeRng_c'high+1;
        subtype  AwAddrRng_c   is natural range S_AwAddr'length+AwLenRng_c'high     downto AwLenRng_c'high+1;
        subtype  AwIdRng_c     is natural range S_AwId'length+AwAddrRng_c'high      downto AwAddrRng_c'high+1;
        subtype  AwQosRng_c    is natural range S_AwQos'length+AwIdRng_c'high       downto AwIdRng_c'high+1;
        subtype  AwUserRng_c   is natural range S_AwUser'length+AwQosRng_c'high     downto AwQosRng_c'high+1;
        subtype  AwRegionRng_c is natural range S_AwRegion'length+AwUserRng_c'high  downto AwUserRng_c'high+1;

        signal AwDataIn, AwDataOut : std_logic_vector(AwRegionRng_c'high downto 0);
    begin
        AwDataIn(AwProtRng_c)   <= S_AwProt;
        AwDataIn(AwCacheRng_c)  <= S_AwCache;
        AwDataIn(AwLockIdx_C)   <= S_AwLock;
        AwDataIn(AwBurstRng_c)  <= S_AwBurst;
        AwDataIn(AwSizeRng_c)   <= S_AwSize;
        AwDataIn(AwLenRng_c)    <= S_AwLen;
        AwDataIn(AwAddrRng_c)   <= S_AwAddr;
        AwDataIn(AwIdRng_c)     <= S_AwId;
        AwDataIn(AwQosRng_c)    <= S_AwQos;
        AwDataIn(AwUserRng_c)   <= S_AwUser;
        AwDataIn(AwRegionRng_c) <= S_AwRegion;

        i_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => AwDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => S_AwValid,
                In_Ready   => S_AwReady,
                In_Data    => AwDataIn,
                Out_Valid  => M_AwValid,
                Out_Ready  => M_AwReady,
                Out_Data   => AwDataOut
            );

        M_AwProt   <= AwDataOut(AwProtRng_c);
        M_AwCache  <= AwDataOut(AwCacheRng_c);
        M_AwLock   <= AwDataOut(AwLockIdx_C);
        M_AwBurst  <= AwDataOut(AwBurstRng_c);
        M_AwSize   <= AwDataOut(AwSizeRng_c);
        M_AwLen    <= AwDataOut(AwLenRng_c);
        M_AwAddr   <= AwDataOut(AwAddrRng_c);
        M_AwId     <= AwDataOut(AwIdRng_c);
        M_AwQos    <= AwDataOut(AwQosRng_c);
        M_AwUser   <= AwDataOut(AwUserRng_c);
        M_AwRegion <= AwDataOut(AwRegionRng_c);
    end block;

    b_w : block is
        subtype  WDataRng_c is natural range S_WData'length-1              downto 0;
        subtype  WStrbRng_c is natural range S_WStrb'length+WDataRng_c'high  downto WDataRng_c'high+1;
        constant WLastIdx_c : natural := WStrbRng_c'high+1;
        subtype  WUserRng_c is natural range S_WUser'length+WLastIdx_c       downto WLastIdx_c+1;

        signal WDataIn, WDataOut : std_logic_vector(WUserRng_c'high downto 0);
    begin

        WDataIn(WDataRng_c) <= S_WData;
        WDataIn(WStrbRng_c) <= S_WStrb;
        WDataIn(WLastIdx_c) <= S_WLast;
        WDataIn(WUserRng_c) <= S_WUser;

        i_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => WDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => S_WValid,
                In_Ready   => S_WReady,
                In_Data    => WDataIn,
                Out_Valid  => M_WValid,
                Out_Ready  => M_WReady,
                Out_Data   => WDataOut
            );

        M_WLast <= WDataOut(WLastIdx_c);
        M_WStrb <= WDataOut(WStrbRng_c);
        M_WData <= WDataOut(WDataRng_c);
        M_WUser <= WDataOut(WUserRng_c);
    end block;

    b_b : block is
        subtype BRespRng_c is natural range S_BResp'length-1           downto 0;
        subtype BIdRng_c   is natural range S_BId'length+BRespRng_c'high downto BRespRng_c'high+1;
        subtype BuserRng_c is natural range S_BUser'length+BIdRng_c'high downto BIdRng_c'high+1;

        signal BDataIn, BDataOut : std_logic_vector(BuserRng_c'high downto 0);
    begin
        BDataIn(BIdRng_c)   <= M_BId;
        BDataIn(BRespRng_c) <= M_BResp;
        BDataIn(BuserRng_c) <= M_BUser;

        i_bch_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => BDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => M_BValid,
                In_Ready   => M_BReady,
                In_Data    => BDataIn,
                Out_Valid  => S_BValid,
                Out_Ready  => S_BReady,
                Out_Data   => BDataOut
            );

        S_BId   <= BDataOut(BIdRng_c);
        S_BResp <= BDataOut(BRespRng_c);
        S_BUser <= BDataOut(BuserRng_c);
    end block;

    b_ar : block is
        subtype  ArProtRng_c   is natural range S_ArProt'length-1                 downto 0;
        subtype  ArCacheRng_c  is natural range S_ArCache'length+ArProtRng_c'high   downto ArProtRng_c'high+1;
        constant ArLockIdx_c : natural := ArCacheRng_c'high+1;
        subtype  ArBurstRng_c  is natural range S_ArBurst'length+ArLockIdx_c        downto ArLockIdx_c+1;
        subtype  ArSizeRng_c   is natural range S_ArSize'length+ArBurstRng_c'high   downto ArBurstRng_c'high+1;
        subtype  ArLenRng_c    is natural range S_ArLen'length+ArSizeRng_c'high     downto ArSizeRng_c'high+1;
        subtype  ArAddrRng_c   is natural range S_ArAddr'length+ArLenRng_c'high     downto ArLenRng_c'high+1;
        subtype  ArIdRng_c     is natural range S_ArId'length+ArAddrRng_c'high      downto ArAddrRng_c'high+1;
        subtype  ArQosRng_c    is natural range S_ArQos'length+ArIdRng_c'high       downto ArIdRng_c'high+1;
        subtype  ArUserRng_c   is natural range S_ArUser'length+ArQosRng_c'high     downto ArQosRng_c'high+1;
        subtype  ArRegionRng_c is natural range S_ArRegion'length+ArUserRng_c'high  downto ArUserRng_c'high+1;

        signal ArDataIn, ArDataOut : std_logic_vector(ArRegionRng_c'high downto 0);
    begin

        ArDataIn(ArProtRng_c)   <= S_ArProt;
        ArDataIn(ArCacheRng_c)  <= S_ArCache;
        ArDataIn(ArLockIdx_c)   <= S_ArLock;
        ArDataIn(ArBurstRng_c)  <= S_ArBurst;
        ArDataIn(ArSizeRng_c)   <= S_ArSize;
        ArDataIn(ArLenRng_c)    <= S_ArLen;
        ArDataIn(ArAddrRng_c)   <= S_ArAddr;
        ArDataIn(ArIdRng_c)     <= S_ArId;
        ArDataIn(ArQosRng_c)    <= S_ArQos;
        ArDataIn(ArUserRng_c)   <= S_ArUser;
        ArDataIn(ArRegionRng_c) <= S_ArRegion;

        i_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => ArDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => S_ArValid,
                In_Ready   => S_ArReady,
                In_Data    => ArDataIn,
                Out_Valid  => M_ArValid,
                Out_Ready  => M_ArReady,
                Out_Data   => ArDataOut
            );

        M_ArProt   <= ArDataOut(ArProtRng_c);
        M_ArCache  <= ArDataOut(ArCacheRng_c);
        M_ArLock   <= ArDataOut(ArLockIdx_c);
        M_ArBurst  <= ArDataOut(ArBurstRng_c);
        M_ArSize   <= ArDataOut(ArSizeRng_c);
        M_ArLen    <= ArDataOut(ArLenRng_c);
        M_ArAddr   <= ArDataOut(ArAddrRng_c);
        M_ArId     <= ArDataOut(ArIdRng_c);
        M_ArQos    <= ArDataOut(ArQosRng_c);
        M_ArUser   <= ArDataOut(ArUserRng_c);
        M_ArRegion <= ArDataOut(ArRegionRng_c);
    end block;

    b_r : block is
        subtype  RDataRng_c is natural range S_RData'length-1             downto 0;
        constant RLastIdx_c : natural := RDataRng_c'high+1;
        subtype  RRespRng_c is natural range S_RResp'length+RLastIdx_c    downto RLastIdx_c+1;
        subtype  RIdRng_c   is natural range S_RId'length+RRespRng_c'high downto RRespRng_c'high+1;
        subtype  RUserRng_c is natural range S_RUser'length+RIdRng_c'high downto RIdRng_c'high+1;

        signal RDataIn, RDataOut : std_logic_vector(RUserRng_c'high downto 0);
    begin
        RDataIn(RDataRng_c) <= M_RData;
        RDataIn(RRespRng_c) <= M_RResp;
        RDataIn(RLastIdx_c) <= M_RLast;
        RDataIn(RIdRng_c)   <= M_RId;
        RDataIn(RUserRng_c) <= M_RUser;

        i_rch_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => RDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => M_RValid,
                In_Ready   => M_RReady,
                In_Data    => RDataIn,
                Out_Valid  => S_RValid,
                Out_Ready  => S_RReady,
                Out_Data   => RDataOut
            );

        S_RData <= RDataOut(RDataRng_c);
        S_RResp <= RDataOut(RRespRng_c);
        S_RLast <= RDataOut(RLastIdx_c);
        S_RId   <= RDataOut(RIdRng_c);
        S_RUser <= RDataOut(RUserRng_c);
    end block;

end architecture;",48
"Coprocessor  Part of the LXP32 test platform   Performs a simple arithmetic operation, uses interrupt to wake up the CPU.  Note: regardless of whether this description is synthesizable, it was designed exclusively for simulation purposes.

# VHDL Analysis for 'coprocessor.vhd'

## File Comments
- -------------------------------------------------------------------
- Coprocessor
- Part of the LXP32 test platform
- Copyright (c) 2016 by Alex I. Kuznetsov
- Performs a simple arithmetic operation, uses interrupt to wake
- up the CPU.
- Note: regardless of whether this description is synthesizable,
- it was designed exclusively for simulation purposes.
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: coprocessor

## Architecture: rtl of coprocessor

### Signals
- value: unsigned(31 downto 0):=(others=>'0')
- result: unsigned(31 downto 0):=(others=>'0')
- cnt: integer range 0 to 50:=0
- irq: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- This appears to be a CPU component

## Code Metrics
- Line count: 98
- Process count: 4
- Signal count: 4

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'coprocessor.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Coprocessor**

**Overview**

The Coprocessor is a digital component designed to perform a simple arithmetic operation and generate an interrupt signal to wake up the CPU. It is part of the LXP32 test platform and is intended for simulation purposes.

**Inputs**

* **clk_i**: Clock input signal
* **rst_i**: Reset input signal
* **wbs_cyc_i**: Wishbone cycle input signal
* **wbs_stb_i**: Wishbone strobe input signal
* **wbs_we_i**: Wishbone write enable input signal
* **wbs_sel_i**: Wishbone select input signal (4-bit vector)
* **wbs_adr_i**: Wishbone address input signal (26-bit vector)
* **wbs_dat_i**: Wishbone data input signal (32-bit vector)

**Outputs**

* **wbs_ack_o**: Wishbone acknowledge output signal
* **wbs_dat_o**: Wishbone data output signal (32-bit vector)
* **irq_o**: Interrupt request output signal

**Functionality**

The Coprocessor performs the following functions:

1. **Data Storage**: The component stores a 32-bit value, which can be written to through the Wishbone interface.
2. **Arithmetic Operation**: The component performs a simple arithmetic operation on the stored value, specifically: `result = (value << 1) + value`.
3. **Interrupt Generation**: The component generates an interrupt signal (`irq_o`)","---------------------------------------------------------------------
-- Coprocessor
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Performs a simple arithmetic operation, uses interrupt to wake
-- up the CPU.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity coprocessor is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(27 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		irq_o: out std_logic
	);
end entity;

architecture rtl of coprocessor is

signal value: unsigned(31 downto 0):=(others=>'0');
signal result: unsigned(31 downto 0):=(others=>'0');
signal cnt: integer range 0 to 50:=0;
signal irq: std_logic:='0';

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			value<=(others=>'0');
			cnt<=0;
			irq<='0';
		else
			if cnt>0 then
				cnt<=cnt-1;
			end if;
			
			if cnt=1 then
				irq<='1';
			else
				irq<='0';
			end if;
			
			if wbs_cyc_i='1' and wbs_stb_i='1' and wbs_we_i='1' then
				for i in wbs_sel_i'range loop
					if wbs_sel_i(i)='1' then
						if wbs_adr_i=""00""&X""000000"" then
							value(i*8+7 downto i*8)<=
								unsigned(wbs_dat_i(i*8+7 downto i*8));
							cnt<=50;
						end if;
					end if;
				end loop;
			end if;
		end if;
	end if;
end process;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			result<=(others=>'0');
		else
			result<=shift_left(value,1)+value;
		end if;
	end if;
end process;

wbs_ack_o<=wbs_cyc_i and wbs_stb_i;
wbs_dat_o<=std_logic_vector(value) when wbs_adr_i=""00""&X""000000"" else
	std_logic_vector(result) when wbs_adr_i=""00""&X""000001"" else
	(others=>'-');

irq_o<=irq;

end architecture;
",49
"DBUS monitor  Part of the LXP32 test platform   Monitors LXP32 data bus transactions, optionally throttles them.  Note: regardless of whether this description is synthesizable, it was designed exclusively for simulation purposes.

# VHDL Analysis for 'dbus_monitor.vhd'

## File Comments
- -------------------------------------------------------------------
- DBUS monitor
- Part of the LXP32 test platform
- Copyright (c) 2016 by Alex I. Kuznetsov
- Monitors LXP32 data bus transactions, optionally throttles them.
- Note: regardless of whether this description is synthesizable,
- it was designed exclusively for simulation purposes.
- -------------------------------------------------------------------
- Manage throttling
- CPU interface
- Plus 2 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: dbus_monitor

## Architecture: rtl of dbus_monitor

### Signals
- prbs: std_logic
- cycle: std_logic:='0'
- cyc_ff: std_logic:='0'
- ack_ff: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements interface or communication protocol
- This appears to be a CPU component

## Code Metrics
- Line count: 118
- Process count: 4
- Signal count: 4

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'dbus_monitor.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: DBUS Monitor**

### Overview

The DBUS Monitor is a digital component designed to monitor and optionally throttle data bus transactions on the LXP32 test platform. This component acts as a bridge between the CPU interface and the interconnect interface, ensuring proper handshake and data transfer.

### Functionality

The DBUS Monitor performs the following functions:

* Monitors data bus transactions on the CPU interface and interconnect interface
* Optionally throttles data bus transactions using a pseudo-random bit sequence (PRBS) generator
* Ensures proper handshake between the CPU interface and interconnect interface
* Checks for errors in the handshake protocol

### Inputs

The DBUS Monitor has the following inputs:

* `clk_i`: Clock signal
* `rst_i`: Reset signal
* `wbs_cyc_i`: CPU interface cycle signal
* `wbs_stb_i`: CPU interface strobe signal
* `wbs_we_i`: CPU interface write enable signal
* `wbs_sel_i`: CPU interface select signal (4-bit)
* `wbs_adr_i`: CPU interface address signal (30-bit)
* `wbs_dat_i`: CPU interface data signal (32-bit)
* `wbm_ack_i`: Interconnect interface acknowledge signal

### Outputs

The DBUS Monitor has the following outputs:

* `wbs_ack_o`: CPU interface acknowledge signal
* `wbs_dat_o`: CPU interface data signal (32-bit)
* `wbm_cyc_o","---------------------------------------------------------------------
-- DBUS monitor
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Monitors LXP32 data bus transactions, optionally throttles them.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity dbus_monitor is
	generic(
		THROTTLE: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(31 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		wbm_cyc_o: out std_logic;
		wbm_stb_o: out std_logic;
		wbm_we_o: out std_logic;
		wbm_sel_o: out std_logic_vector(3 downto 0);
		wbm_ack_i: in std_logic;
		wbm_adr_o: out std_logic_vector(31 downto 2);
		wbm_dat_o: out std_logic_vector(31 downto 0);
		wbm_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of dbus_monitor is

signal prbs: std_logic;
signal cycle: std_logic:='0';

signal cyc_ff: std_logic:='0';
signal ack_ff: std_logic:='0';

begin

-- Manage throttling

gen_throttling: if THROTTLE generate
	throttle_inst: entity work.scrambler(rtl)
		generic map(TAP1=>6,TAP2=>7)
		port map(clk_i=>clk_i,rst_i=>rst_i,ce_i=>'1',d_o=>prbs);
end generate;

gen_no_throttling: if not THROTTLE generate
	prbs<='0';
end generate;

-- CPU interface

wbs_ack_o<=wbm_ack_i;
wbs_dat_o<=wbm_dat_i when wbm_ack_i='1' else (others=>'-');

-- Interconnect interface

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			cycle<='0';
		elsif prbs='0' and wbs_cyc_i='1' then
			cycle<='1';
		elsif wbs_cyc_i='0' then
			cycle<='0';
		end if;
	end if;
end process;

wbm_cyc_o<=wbs_cyc_i and (not prbs or cycle);
wbm_stb_o<=wbs_stb_i and (not prbs or cycle);
wbm_we_o<=wbs_we_i;
wbm_sel_o<=wbs_sel_i;
wbm_adr_o<=wbs_adr_i;
wbm_dat_o<=wbs_dat_i;

-- Check handshake correctness

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			cyc_ff<='0';
			ack_ff<='0';
		else
			cyc_ff<=wbs_cyc_i;
			ack_ff<=wbm_ack_i;
			
			assert wbm_ack_i='0' or (wbs_cyc_i and (not prbs or cycle))='1'
				report ""DBUS error: ACK asserted without CYC""
				severity failure;
			
			assert not (wbs_cyc_i='0' and cyc_ff='1' and ack_ff/='1')
				report ""DBUS error: cycle terminated prematurely""
				severity failure;
		end if;
	end if;
end process;

end architecture;
",50
"Generic FPGA memory block   Portable description of a dual-port memory block with one write port.  Parameters: * DATA_WIDTH:  data port width * ADDR_WIDTH:  address port width * SIZE:        memory size * MODE:        read/write synchronization mode for port A DONTCARE: choose the most efficient design WR_FIRST: feed written value to the output RD_FIRST: read old value NOCHANGE: don't change output during write

# VHDL Analysis for 'generic_dpram.vhd'

## File Comments
- -------------------------------------------------------------------
- Generic FPGA memory block
- Copyright (c) 2015 by Alex I. Kuznetsov
- Portable description of a dual-port memory block with one write
- port.
- Parameters:
- * DATA_WIDTH:  data port width
- * ADDR_WIDTH:  address port width
- * SIZE:        memory size
- * MODE:        read/write synchronization mode for port A
- Plus 9 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: generic_dpram

## Architecture: rtl of generic_dpram

### Signals
- ram: ram_type
- is ""no_rw_check"";
attribute ram_style: string
- is ""block"";

begin

-- Ensure that generics have valid values

assert SIZE<=2**ADDR_WIDTH
	report ""SIZE must be less or equal than 2^ADDR_WIDTH""
	severity failure;

assert MODE=""DONTCARE"" or MODE=""WR_FIRST"" or MODE=""RD_FIRST"" or MODE=""NOCHANGE""
	report ""Unrecognized MODE value (DONTCARE: if MODE=""DONTCARE"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i
- WR_FIRST: if MODE=""DONTCARE"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i
- RD_FIRST or NOCHANGE expected)""
	severity failure;

-- Port A (read/write)

port_a_dont_care_gen: if MODE=""DONTCARE"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clka_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clka_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clka_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clka_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clkb_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): RD_FIRST, port_a_write_first_gen, port_a_read_first_gen, WR_FIRST
- Implements memory functionality

## Code Metrics
- Line count: 163
- Process count: 10
- Signal count: 5

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'generic_dpram.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Generic Dual-Port RAM (DPRAM)**

### Overview

The Generic DPRAM is a configurable, dual-port memory block with one write port and one read port. It is designed to be portable and efficient, with various synchronization modes for the write port.

### Parameters

* **DATA_WIDTH**: The width of the data ports (in bits). This parameter determines the number of bits that can be written or read from the memory.
* **ADDR_WIDTH**: The width of the address ports (in bits). This parameter determines the number of unique addresses that can be accessed in the memory.
* **SIZE**: The total size of the memory (in words). This parameter must be less than or equal to 2^ADDR_WIDTH.
* **MODE**: The synchronization mode for the write port. This parameter can take one of the following values:
	+ **DONTCARE**: The output of the write port is not specified during a write operation.
	+ **WR_FIRST**: The written value is fed to the output during a write operation.
	+ **RD_FIRST**: The old value is read from the memory during a write operation.
	+ **NOCHANGE**: The output of the write port does not change during a write operation.

### Ports

* **clka_i**: The clock input for the write port (Port A).
* **cea_i**: The enable input for the write port (Port A).
* **wea_i**: The write enable input for the write","---------------------------------------------------------------------
-- Generic FPGA memory block
--
-- Copyright (c) 2015 by Alex I. Kuznetsov
--
-- Portable description of a dual-port memory block with one write
-- port.
--
-- Parameters:
--     * DATA_WIDTH:  data port width
--     * ADDR_WIDTH:  address port width
--     * SIZE:        memory size
--     * MODE:        read/write synchronization mode for port A
--                      DONTCARE: choose the most efficient design
--                      WR_FIRST: feed written value to the output
--                      RD_FIRST: read old value 
--                      NOCHANGE: don't change output during write
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity generic_dpram is
	generic(
		DATA_WIDTH: integer;
		ADDR_WIDTH: integer;
		SIZE: integer;
		MODE: string:=""DONTCARE""
	);
	port(
		clka_i: in std_logic;
		cea_i: in std_logic;
		wea_i: in std_logic;
		addra_i: in std_logic_vector(ADDR_WIDTH-1 downto 0);
		da_i: in std_logic_vector(DATA_WIDTH-1 downto 0);
		da_o: out std_logic_vector(DATA_WIDTH-1 downto 0);
		
		clkb_i: in std_logic;
		ceb_i: in std_logic;
		addrb_i: in std_logic_vector(ADDR_WIDTH-1 downto 0);
		db_o: out std_logic_vector(DATA_WIDTH-1 downto 0)
	);
end entity;

architecture rtl of generic_dpram is

type ram_type is array(SIZE-1 downto 0) of std_logic_vector(DATA_WIDTH-1 downto 0);
signal ram: ram_type;

attribute syn_ramstyle: string;
attribute syn_ramstyle of ram: signal is ""no_rw_check"";
attribute ram_style: string; -- for Xilinx
attribute ram_style of ram: signal is ""block"";

begin

-- Ensure that generics have valid values

assert SIZE<=2**ADDR_WIDTH
	report ""SIZE must be less or equal than 2^ADDR_WIDTH""
	severity failure;

assert MODE=""DONTCARE"" or MODE=""WR_FIRST"" or MODE=""RD_FIRST"" or MODE=""NOCHANGE""
	report ""Unrecognized MODE value (DONTCARE, WR_FIRST, RD_FIRST or NOCHANGE expected)""
	severity failure;

-- Port A (read/write)

port_a_dont_care_gen: if MODE=""DONTCARE"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
					da_o<=(others=>'-');
				else
					if is_x(addra_i) then
						da_o<=(others=>'X');
					else
						da_o<=ram(to_integer(unsigned(addra_i)));
					end if;
				end if;
			end if;
		end if;
	end process;
end generate;

port_a_write_first_gen: if MODE=""WR_FIRST"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
					da_o<=da_i;
				else
					if is_x(addra_i) then
						da_o<=(others=>'X');
					else
						da_o<=ram(to_integer(unsigned(addra_i)));
					end if;
				end if;
			end if;
		end if;
	end process;
end generate;

port_a_read_first_gen: if MODE=""RD_FIRST"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
				end if;
				if is_x(addra_i) then
					da_o<=(others=>'X');
				else
					da_o<=ram(to_integer(unsigned(addra_i)));
				end if;
			end if;
		end if;
	end process;
end generate;

port_a_no_change_gen: if MODE=""NOCHANGE"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
				else
					if is_x(addra_i) then
						da_o<=(others=>'X');
					else
						da_o<=ram(to_integer(unsigned(addra_i)));
					end if;
				end if;
			end if;
		end if;
	end process;
end generate;

-- Port B (read only)

process (clkb_i) is
begin
	if rising_edge(clkb_i) then
		if ceb_i='1' then
			if is_x(addrb_i) then
				db_o<=(others=>'X');
			else
				db_o<=ram(to_integer(unsigned(addrb_i)));
			end if;
		end if;
	end if;
end process;

end architecture;
",51
"IBUS adapter  Part of the LXP32 test platform   Converts the Low Latency Interface to WISHBONE registered feedback protocol.  Note: regardless of whether this description is synthesizable, it was designed exclusively for simulation purposes.

# VHDL Analysis for 'ibus_adapter.vhd'

## File Comments
- -------------------------------------------------------------------
- IBUS adapter
- Part of the LXP32 test platform
- Copyright (c) 2016 by Alex I. Kuznetsov
- Converts the Low Latency Interface to WISHBONE registered
- feedback protocol.
- Note: regardless of whether this description is synthesizable,
- it was designed exclusively for simulation purposes.
- -------------------------------------------------------------------
- Insert burst delay
- Plus 3 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: ibus_adapter

## Architecture: rtl of ibus_adapter

### Signals
- burst_delay_cnt: integer:=0
- delay_burst: std_logic
- re: std_logic
- requested: std_logic:='0'
- adr: unsigned(29 downto 0)
- ack: std_logic

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): burst_delay_cnt, delay_burst, rst_i, burst_delay, burst
- Implements interface or communication protocol

## Code Metrics
- Line count: 102
- Process count: 4
- Signal count: 6

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'ibus_adapter.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: IBUS Adapter**

**Overview**

The IBUS Adapter is a digital component designed to interface between the Low Latency Interface (LLI) and the WISHBONE registered feedback protocol. Its primary function is to convert LLI signals to WISHBONE-compliant signals, enabling seamless communication between LLI devices and WISHBONE-based systems.

**Inputs**

* **clk_i**: Clock input (std_logic)
* **rst_i**: Reset input (std_logic)
* **ibus_cyc_i**: Cycle input (std_logic)
* **ibus_stb_i**: Strobe input (std_logic)
* **ibus_cti_i**: Cycle Type Identifier input (std_logic_vector(2 downto 0))
* **ibus_bte_i**: Burst Type Encoding input (std_logic_vector(1 downto 0))
* **ibus_adr_i**: Address input (std_logic_vector(29 downto 0))
* **lli_dat_i**: Data input from LLI (std_logic_vector(31 downto 0))
* **lli_busy_i**: Busy input from LLI (std_logic)

**Outputs**

* **ibus_ack_o**: Acknowledge output (std_logic)
* **ibus_dat_o**: Data output to IBUS (std_logic_vector(31 downto 0))
* **lli_re_o**: Read Enable output to LLI (std_logic)
* **lli_adr_o**: Address output to LLI (std_logic_vector(29 downto","---------------------------------------------------------------------
-- IBUS adapter
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Converts the Low Latency Interface to WISHBONE registered
-- feedback protocol.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity ibus_adapter is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		ibus_cyc_i: in std_logic;
		ibus_stb_i: in std_logic;
		ibus_cti_i: in std_logic_vector(2 downto 0);
		ibus_bte_i: in std_logic_vector(1 downto 0);
		ibus_ack_o: out std_logic;
		ibus_adr_i: in std_logic_vector(29 downto 0);
		ibus_dat_o: out std_logic_vector(31 downto 0);
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic
	);
end entity;

architecture rtl of ibus_adapter is

constant burst_delay: integer:=5;
signal burst_delay_cnt: integer:=0;
signal delay_burst: std_logic;

signal re: std_logic;
signal requested: std_logic:='0';
signal adr: unsigned(29 downto 0);
signal ack: std_logic;

begin

-- Insert burst delay

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			burst_delay_cnt<=0;
		elsif ibus_cyc_i='0' then
			burst_delay_cnt<=burst_delay;
		elsif burst_delay_cnt/=0 then
			burst_delay_cnt<=burst_delay_cnt-1;
		end if;
	end if;
end process;

delay_burst<='1' when burst_delay_cnt/=0 else '0';

-- Generate ACK signal

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			requested<='0';
		elsif lli_busy_i='0' then
			requested<=re;
		end if;
	end if;
end process;

ack<=requested and not lli_busy_i;

-- Generate LLI signals

re<=(ibus_cyc_i and ibus_stb_i and not delay_burst) when ack='0' or
	(ibus_cti_i=""010"" and ibus_bte_i=""00"") else '0';

adr<=unsigned(ibus_adr_i) when re='1' and ack='0' else
	unsigned(ibus_adr_i)+1 when re='1' and ack='1' else
	(others=>'-');

lli_re_o<=re;
lli_adr_o<=std_logic_vector(adr);

-- Generate IBUS signals

ibus_ack_o<=ack;
ibus_dat_o<=lli_dat_i when ack='1' else (others=>'-');

end architecture;
",52
"Simple WISHBONE interconnect  Generated by wigen at Sat Nov  2 11:45:49 2024  Configuration: Number of masters:     2 Number of slaves:      5 Master address width:  32 Slave address width:   28 Port size:             32 Port granularity:      8 Entity name:           intercon Pipelined arbiter:     no Registered feedback:   no Unsafe slave decoder:  no  Command line: wigen -e intercon 2 5 32 28 32 8

# VHDL Analysis for 'intercon.vhd'

## File Comments
- -------------------------------------------------------------------
- Simple WISHBONE interconnect
- Generated by wigen at Sat Nov  2 11:45:49 2024
- Configuration:
- Number of masters:     2
- Number of slaves:      5
- Master address width:  32
- Slave address width:   28
- Port size:             32
- Port granularity:      8
- Plus 16 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: intercon

## Architecture: rtl of intercon

### Signals
- request: std_logic_vector(1 downto 0)
- grant_next: std_logic_vector(1 downto 0)
- grant: std_logic_vector(1 downto 0)
- grant_reg: std_logic_vector(1 downto 0):=(others=>'0')
- select_slave: std_logic_vector(5 downto 0)
- cyc_mux: std_logic
- stb_mux: std_logic
- we_mux: std_logic
- sel_mux: std_logic_vector(3 downto 0)
- adr_mux: std_logic_vector(31 downto 2)
- wdata_mux: std_logic_vector(31 downto 0)
- ack_mux: std_logic
- rdata_mux: std_logic_vector(31 downto 0)

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i

## Code Metrics
- Line count: 235
- Process count: 2
- Signal count: 13

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'intercon.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: WISHBONE Interconnect**

**Overview**

The WISHBONE Interconnect is a digital component that enables communication between multiple masters and slaves in a system-on-chip (SoC) design. This component is generated by the WIGEN tool and provides a simple interconnect for 2 masters and 5 slaves.

**Functional Description**

The WISHBONE Interconnect performs the following functions:

* Arbitrates access to the slaves among multiple masters using a priority-based arbiter.
* Routes the master requests to the corresponding slaves based on the address.
* Routes the slave responses back to the corresponding masters.

**Inputs**

* **Clock (clk_i)**: A clock signal that drives the interconnect.
* **Reset (rst_i)**: An asynchronous reset signal that resets the interconnect.

**Master Interface**

* **s0_cyc_i, s1_cyc_i**: Cycle signals from masters 0 and 1, respectively.
* **s0_stb_i, s1_stb_i**: Strobe signals from masters 0 and 1, respectively.
* **s0_we_i, s1_we_i**: Write enable signals from masters 0 and 1, respectively.
* **s0_sel_i, s1_sel_i**: Byte select signals from masters 0 and 1, respectively.
* **s0_adr_i, s1_adr_i**: Address signals from masters 0 and 1, respectively.
* **s0_dat_i","---------------------------------------------------------------------
-- Simple WISHBONE interconnect
--
-- Generated by wigen at Sat Nov  2 11:45:49 2024
--
-- Configuration:
--     Number of masters:     2
--     Number of slaves:      5
--     Master address width:  32
--     Slave address width:   28
--     Port size:             32
--     Port granularity:      8
--     Entity name:           intercon
--     Pipelined arbiter:     no
--     Registered feedback:   no
--     Unsafe slave decoder:  no
--
-- Command line:
--     wigen -e intercon 2 5 32 28 32 8
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity intercon is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;

		s0_cyc_i: in std_logic;
		s0_stb_i: in std_logic;
		s0_we_i: in std_logic;
		s0_sel_i: in std_logic_vector(3 downto 0);
		s0_ack_o: out std_logic;
		s0_adr_i: in std_logic_vector(31 downto 2);
		s0_dat_i: in std_logic_vector(31 downto 0);
		s0_dat_o: out std_logic_vector(31 downto 0);

		s1_cyc_i: in std_logic;
		s1_stb_i: in std_logic;
		s1_we_i: in std_logic;
		s1_sel_i: in std_logic_vector(3 downto 0);
		s1_ack_o: out std_logic;
		s1_adr_i: in std_logic_vector(31 downto 2);
		s1_dat_i: in std_logic_vector(31 downto 0);
		s1_dat_o: out std_logic_vector(31 downto 0);

		m0_cyc_o: out std_logic;
		m0_stb_o: out std_logic;
		m0_we_o: out std_logic;
		m0_sel_o: out std_logic_vector(3 downto 0);
		m0_ack_i: in std_logic;
		m0_adr_o: out std_logic_vector(27 downto 2);
		m0_dat_o: out std_logic_vector(31 downto 0);
		m0_dat_i: in std_logic_vector(31 downto 0);

		m1_cyc_o: out std_logic;
		m1_stb_o: out std_logic;
		m1_we_o: out std_logic;
		m1_sel_o: out std_logic_vector(3 downto 0);
		m1_ack_i: in std_logic;
		m1_adr_o: out std_logic_vector(27 downto 2);
		m1_dat_o: out std_logic_vector(31 downto 0);
		m1_dat_i: in std_logic_vector(31 downto 0);

		m2_cyc_o: out std_logic;
		m2_stb_o: out std_logic;
		m2_we_o: out std_logic;
		m2_sel_o: out std_logic_vector(3 downto 0);
		m2_ack_i: in std_logic;
		m2_adr_o: out std_logic_vector(27 downto 2);
		m2_dat_o: out std_logic_vector(31 downto 0);
		m2_dat_i: in std_logic_vector(31 downto 0);

		m3_cyc_o: out std_logic;
		m3_stb_o: out std_logic;
		m3_we_o: out std_logic;
		m3_sel_o: out std_logic_vector(3 downto 0);
		m3_ack_i: in std_logic;
		m3_adr_o: out std_logic_vector(27 downto 2);
		m3_dat_o: out std_logic_vector(31 downto 0);
		m3_dat_i: in std_logic_vector(31 downto 0);

		m4_cyc_o: out std_logic;
		m4_stb_o: out std_logic;
		m4_we_o: out std_logic;
		m4_sel_o: out std_logic_vector(3 downto 0);
		m4_ack_i: in std_logic;
		m4_adr_o: out std_logic_vector(27 downto 2);
		m4_dat_o: out std_logic_vector(31 downto 0);
		m4_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of intercon is

signal request: std_logic_vector(1 downto 0);
signal grant_next: std_logic_vector(1 downto 0);
signal grant: std_logic_vector(1 downto 0);
signal grant_reg: std_logic_vector(1 downto 0):=(others=>'0');

signal select_slave: std_logic_vector(5 downto 0);

signal cyc_mux: std_logic;
signal stb_mux: std_logic;
signal we_mux: std_logic;
signal sel_mux: std_logic_vector(3 downto 0);
signal adr_mux: std_logic_vector(31 downto 2);
signal wdata_mux: std_logic_vector(31 downto 0);

signal ack_mux: std_logic;
signal rdata_mux: std_logic_vector(31 downto 0);

begin

-- ARBITER
-- Selects the active master. Masters with lower port numbers
-- have higher priority. Ongoing cycles are not interrupted.

request<=s1_cyc_i&s0_cyc_i;

grant_next<=""01"" when request(0)='1' else
	""10"" when request(1)='1' else
	(others=>'0');

grant<=grant_reg when (request and grant_reg)/=""00"" else grant_next;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			grant_reg<=(others=>'0');
		else
			grant_reg<=grant;
		end if;
	end if;
end process;

-- MASTER->SLAVE MUX

cyc_mux<=(s0_cyc_i and grant(0)) or
	(s1_cyc_i and grant(1));

stb_mux<=(s0_stb_i and grant(0)) or
	(s1_stb_i and grant(1));

we_mux<=(s0_we_i and grant(0)) or
	(s1_we_i and grant(1));

sel_mux_gen: for i in sel_mux'range generate
	sel_mux(i)<=(s0_sel_i(i) and grant(0)) or
		(s1_sel_i(i) and grant(1));
end generate;

adr_mux_gen: for i in adr_mux'range generate
	adr_mux(i)<=(s0_adr_i(i) and grant(0)) or
		(s1_adr_i(i) and grant(1));
end generate;

wdata_mux_gen: for i in wdata_mux'range generate
	wdata_mux(i)<=(s0_dat_i(i) and grant(0)) or
		(s1_dat_i(i) and grant(1));
end generate;

-- MASTER->SLAVE DEMUX

select_slave<=""000001"" when adr_mux(31 downto 28)=""0000"" else
	""000010"" when adr_mux(31 downto 28)=""0001"" else
	""000100"" when adr_mux(31 downto 28)=""0010"" else
	""001000"" when adr_mux(31 downto 28)=""0011"" else
	""010000"" when adr_mux(31 downto 28)=""0100"" else
	""100000""; -- fallback slave

m0_cyc_o<=cyc_mux and select_slave(0);
m0_stb_o<=stb_mux and select_slave(0);
m0_we_o<=we_mux;
m0_sel_o<=sel_mux;
m0_adr_o<=adr_mux(m0_adr_o'range);
m0_dat_o<=wdata_mux;

m1_cyc_o<=cyc_mux and select_slave(1);
m1_stb_o<=stb_mux and select_slave(1);
m1_we_o<=we_mux;
m1_sel_o<=sel_mux;
m1_adr_o<=adr_mux(m1_adr_o'range);
m1_dat_o<=wdata_mux;

m2_cyc_o<=cyc_mux and select_slave(2);
m2_stb_o<=stb_mux and select_slave(2);
m2_we_o<=we_mux;
m2_sel_o<=sel_mux;
m2_adr_o<=adr_mux(m2_adr_o'range);
m2_dat_o<=wdata_mux;

m3_cyc_o<=cyc_mux and select_slave(3);
m3_stb_o<=stb_mux and select_slave(3);
m3_we_o<=we_mux;
m3_sel_o<=sel_mux;
m3_adr_o<=adr_mux(m3_adr_o'range);
m3_dat_o<=wdata_mux;

m4_cyc_o<=cyc_mux and select_slave(4);
m4_stb_o<=stb_mux and select_slave(4);
m4_we_o<=we_mux;
m4_sel_o<=sel_mux;
m4_adr_o<=adr_mux(m4_adr_o'range);
m4_dat_o<=wdata_mux;

-- SLAVE->MASTER MUX

ack_mux<=(m0_ack_i and select_slave(0)) or
	(m1_ack_i and select_slave(1)) or
	(m2_ack_i and select_slave(2)) or
	(m3_ack_i and select_slave(3)) or
	(m4_ack_i and select_slave(4)) or
	(cyc_mux and stb_mux and select_slave(5)); -- fallback slave

rdata_mux_gen: for i in rdata_mux'range generate
	rdata_mux(i)<=(m0_dat_i(i) and select_slave(0)) or
		(m1_dat_i(i) and select_slave(1)) or
		(m2_dat_i(i) and select_slave(2)) or
		(m3_dat_i(i) and select_slave(3)) or
		(m4_dat_i(i) and select_slave(4));
end generate;

-- SLAVE->MASTER DEMUX

s0_ack_o<=ack_mux and grant(0);
s0_dat_o<=rdata_mux;

s1_ack_o<=ack_mux and grant(1);
s1_dat_o<=rdata_mux;

end architecture;
",53
"LXP32 platform top-level design unit  Part of the LXP32 test platform   A SoC-like simulation platform for the LXP32 CPU, containing a few peripherals such as program RAM, timer and coprocessor.  Note: regardless of whether this description is synthesizable, it was designed exclusively for simulation purposes.

# VHDL Analysis for 'platform.vhd'

## File Comments
- -------------------------------------------------------------------
- LXP32 platform top-level design unit
- Part of the LXP32 test platform
- Copyright (c) 2016 by Alex I. Kuznetsov
- A SoC-like simulation platform for the LXP32 CPU, containing
- a few peripherals such as program RAM, timer and coprocessor.
- Note: regardless of whether this description is synthesizable,
- it was designed exclusively for simulation purposes.
- -------------------------------------------------------------------
- Interconnect
- Plus 8 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: platform

## Architecture: rtl of platform

### Signals
- cpu_rst: std_logic
- cpu_irq: std_logic_vector(7 downto 0)
- cpu_dbus: wbm_type
- cpu_ibus: ibus_type
- lli_re: std_logic
- lli_adr: std_logic_vector(29 downto 0)
- lli_dat: std_logic_vector(31 downto 0)
- lli_busy: std_logic
- monitor_dbus: wbm_type
- ram_wb: wbs_type
- timer_wb: wbs_type
- timer_elapsed: std_logic
- coprocessor_wb: wbs_type
- coprocessor_irq: std_logic
- timer2_wb: wbs_type
- timer2_irq: std_logic

## Functional Analysis

- Uses reset signal(s): cpu_rst, cpu_rst_i, IBUS_BURST_SIZE, rst_i
- Implements memory functionality
- This appears to be a CPU component

## Code Metrics
- Line count: 388
- Process count: 0
- Signal count: 16

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'platform.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Platform**

**Overview**

The LXP32 Platform is a System-on-Chip (SoC) simulation platform designed for the LXP32 CPU. This component provides a comprehensive environment for testing and verifying the functionality of the LXP32 CPU, along with several peripherals.

**Functionality**

The LXP32 Platform integrates the following components:

* LXP32 CPU (either LXP32U or LXP32C)
* Program RAM
* Timer
* Coprocessor
* Interconnect

The platform provides a Wishbone bus interface for communication between the CPU and peripherals.

**Inputs**

* `clk_i`: Clock input
* `rst_i`: Reset input
* `cpu_rst_i`: CPU reset input
* `wbm_cyc_o`, `wbm_stb_o`, `wbm_we_o`, `wbm_sel_o`, `wbm_adr_o`, `wbm_dat_o`, `wbm_dat_i`: Wishbone Master bus signals
* `wbs_cyc_i`, `wbs_stb_i`, `wbs_we_i`, `wbs_sel_i`, `wbs_adr_i`, `wbs_dat_i`, `wbs_dat_o`: Wishbone Slave bus signals
* `gp_io`: General-purpose I/O bus

**Outputs**

* `wbm_ack_i`: Wishbone Master bus acknowledge signal
* `wbs_ack_o`: Wishbone Slave bus acknowledge signal","---------------------------------------------------------------------
-- LXP32 platform top-level design unit
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A SoC-like simulation platform for the LXP32 CPU, containing
-- a few peripherals such as program RAM, timer and coprocessor.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity platform is
	generic(
		CPU_DBUS_RMW: boolean;
		CPU_MUL_ARCH: string;
		MODEL_LXP32C: boolean;
		THROTTLE_DBUS: boolean;
		THROTTLE_IBUS: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		cpu_rst_i: in std_logic;
		
		wbm_cyc_o: out std_logic;
		wbm_stb_o: out std_logic;
		wbm_we_o: out std_logic;
		wbm_sel_o: out std_logic_vector(3 downto 0);
		wbm_ack_i: in std_logic;
		wbm_adr_o: out std_logic_vector(27 downto 2);
		wbm_dat_o: out std_logic_vector(31 downto 0);
		wbm_dat_i: in std_logic_vector(31 downto 0);
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(31 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		gp_io: inout std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of platform is

type wbm_type is record
	cyc: std_logic;
	stb: std_logic;
	we: std_logic;
	sel: std_logic_vector(3 downto 0);
	ack: std_logic;
	adr: std_logic_vector(31 downto 2);
	wdata: std_logic_vector(31 downto 0);
	rdata: std_logic_vector(31 downto 0);
end record;

type wbs_type is record
	cyc: std_logic;
	stb: std_logic;
	we: std_logic;
	sel: std_logic_vector(3 downto 0);
	ack: std_logic;
	adr: std_logic_vector(27 downto 2);
	wdata: std_logic_vector(31 downto 0);
	rdata: std_logic_vector(31 downto 0);
end record;

type ibus_type is record
	cyc: std_logic;
	stb: std_logic;
	cti: std_logic_vector(2 downto 0);
	bte: std_logic_vector(1 downto 0);
	ack: std_logic;
	adr: std_logic_vector(29 downto 0);
	dat: std_logic_vector(31 downto 0);
end record;

signal cpu_rst: std_logic;
signal cpu_irq: std_logic_vector(7 downto 0);
signal cpu_dbus: wbm_type;
signal cpu_ibus: ibus_type;

signal lli_re: std_logic;
signal lli_adr: std_logic_vector(29 downto 0);
signal lli_dat: std_logic_vector(31 downto 0);
signal lli_busy: std_logic;

signal monitor_dbus: wbm_type;

signal ram_wb: wbs_type;

signal timer_wb: wbs_type;
signal timer_elapsed: std_logic;

signal coprocessor_wb: wbs_type;
signal coprocessor_irq: std_logic;

signal timer2_wb: wbs_type;
signal timer2_irq: std_logic;

begin

-- Interconnect

intercon_inst: entity work.intercon(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,

		s0_cyc_i=>wbs_cyc_i,
		s0_stb_i=>wbs_stb_i,
		s0_we_i=>wbs_we_i,
		s0_sel_i=>wbs_sel_i,
		s0_ack_o=>wbs_ack_o,
		s0_adr_i=>wbs_adr_i,
		s0_dat_i=>wbs_dat_i,
		s0_dat_o=>wbs_dat_o,

		s1_cyc_i=>monitor_dbus.cyc,
		s1_stb_i=>monitor_dbus.stb,
		s1_we_i=>monitor_dbus.we,
		s1_sel_i=>monitor_dbus.sel,
		s1_ack_o=>monitor_dbus.ack,
		s1_adr_i=>monitor_dbus.adr,
		s1_dat_i=>monitor_dbus.wdata,
		s1_dat_o=>monitor_dbus.rdata,

		m0_cyc_o=>ram_wb.cyc,
		m0_stb_o=>ram_wb.stb,
		m0_we_o=>ram_wb.we,
		m0_sel_o=>ram_wb.sel,
		m0_ack_i=>ram_wb.ack,
		m0_adr_o=>ram_wb.adr,
		m0_dat_o=>ram_wb.wdata,
		m0_dat_i=>ram_wb.rdata,

		m1_cyc_o=>wbm_cyc_o,
		m1_stb_o=>wbm_stb_o,
		m1_we_o=>wbm_we_o,
		m1_sel_o=>wbm_sel_o,
		m1_ack_i=>wbm_ack_i,
		m1_adr_o=>wbm_adr_o,
		m1_dat_o=>wbm_dat_o,
		m1_dat_i=>wbm_dat_i,
		
		m2_cyc_o=>timer_wb.cyc,
		m2_stb_o=>timer_wb.stb,
		m2_we_o=>timer_wb.we,
		m2_sel_o=>timer_wb.sel,
		m2_ack_i=>timer_wb.ack,
		m2_adr_o=>timer_wb.adr,
		m2_dat_o=>timer_wb.wdata,
		m2_dat_i=>timer_wb.rdata,
		
		m3_cyc_o=>coprocessor_wb.cyc,
		m3_stb_o=>coprocessor_wb.stb,
		m3_we_o=>coprocessor_wb.we,
		m3_sel_o=>coprocessor_wb.sel,
		m3_ack_i=>coprocessor_wb.ack,
		m3_adr_o=>coprocessor_wb.adr,
		m3_dat_o=>coprocessor_wb.wdata,
		m3_dat_i=>coprocessor_wb.rdata,

		m4_cyc_o=>timer2_wb.cyc,
		m4_stb_o=>timer2_wb.stb,
		m4_we_o=>timer2_wb.we,
		m4_sel_o=>timer2_wb.sel,
		m4_ack_i=>timer2_wb.ack,
		m4_adr_o=>timer2_wb.adr,
		m4_dat_o=>timer2_wb.wdata,
		m4_dat_i=>timer2_wb.rdata
	);

-- CPU

cpu_rst<=cpu_rst_i or rst_i;

-- Note: we connect the timer IRQ to 2 CPU channels to test
-- handling of simultaneously arriving interrupt requests.

cpu_irq<=""0000""&timer2_irq&coprocessor_irq&timer_elapsed&timer_elapsed;

gen_lxp32u: if not MODEL_LXP32C generate
	lxp32u_top_inst: entity work.lxp32u_top(rtl)
		generic map(
			DBUS_RMW=>CPU_DBUS_RMW,
			DIVIDER_EN=>true,
			MUL_ARCH=>CPU_MUL_ARCH,
			START_ADDR=>(others=>'0')
		)
		port map(
			clk_i=>clk_i,
			rst_i=>cpu_rst,
			
			lli_re_o=>lli_re,
			lli_adr_o=>lli_adr,
			lli_dat_i=>lli_dat,
			lli_busy_i=>lli_busy,
			
			dbus_cyc_o=>cpu_dbus.cyc,
			dbus_stb_o=>cpu_dbus.stb,
			dbus_we_o=>cpu_dbus.we,
			dbus_sel_o=>cpu_dbus.sel,
			dbus_ack_i=>cpu_dbus.ack,
			dbus_adr_o=>cpu_dbus.adr,
			dbus_dat_o=>cpu_dbus.wdata,
			dbus_dat_i=>cpu_dbus.rdata,
			
			irq_i=>cpu_irq
		);
end generate;

gen_lxp32c: if MODEL_LXP32C generate
	lxp32c_top_inst: entity work.lxp32c_top(rtl)
		generic map(
			DBUS_RMW=>CPU_DBUS_RMW,
			DIVIDER_EN=>true,
			IBUS_BURST_SIZE=>16,
			IBUS_PREFETCH_SIZE=>32,
			MUL_ARCH=>CPU_MUL_ARCH,
			START_ADDR=>(others=>'0')
		)
		port map(
			clk_i=>clk_i,
			rst_i=>cpu_rst,
			
			ibus_cyc_o=>cpu_ibus.cyc,
			ibus_stb_o=>cpu_ibus.stb,
			ibus_cti_o=>cpu_ibus.cti,
			ibus_bte_o=>cpu_ibus.bte,
			ibus_ack_i=>cpu_ibus.ack,
			ibus_adr_o=>cpu_ibus.adr,
			ibus_dat_i=>cpu_ibus.dat,
			
			dbus_cyc_o=>cpu_dbus.cyc,
			dbus_stb_o=>cpu_dbus.stb,
			dbus_we_o=>cpu_dbus.we,
			dbus_sel_o=>cpu_dbus.sel,
			dbus_ack_i=>cpu_dbus.ack,
			dbus_adr_o=>cpu_dbus.adr,
			dbus_dat_o=>cpu_dbus.wdata,
			dbus_dat_i=>cpu_dbus.rdata,
			
			irq_i=>cpu_irq
		);
	
	ibus_adapter_inst: entity work.ibus_adapter(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			
			ibus_cyc_i=>cpu_ibus.cyc,
			ibus_stb_i=>cpu_ibus.stb,
			ibus_cti_i=>cpu_ibus.cti,
			ibus_bte_i=>cpu_ibus.bte,
			ibus_ack_o=>cpu_ibus.ack,
			ibus_adr_i=>cpu_ibus.adr,
			ibus_dat_o=>cpu_ibus.dat,
			
			lli_re_o=>lli_re,
			lli_adr_o=>lli_adr,
			lli_dat_i=>lli_dat,
			lli_busy_i=>lli_busy
		);
end generate;

-- DBUS monitor

dbus_monitor_inst: entity work.dbus_monitor(rtl)
	generic map(
		THROTTLE=>THROTTLE_DBUS
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>cpu_dbus.cyc,
		wbs_stb_i=>cpu_dbus.stb,
		wbs_we_i=>cpu_dbus.we,
		wbs_sel_i=>cpu_dbus.sel,
		wbs_ack_o=>cpu_dbus.ack,
		wbs_adr_i=>cpu_dbus.adr,
		wbs_dat_i=>cpu_dbus.wdata,
		wbs_dat_o=>cpu_dbus.rdata,
		
		wbm_cyc_o=>monitor_dbus.cyc,
		wbm_stb_o=>monitor_dbus.stb,
		wbm_we_o=>monitor_dbus.we,
		wbm_sel_o=>monitor_dbus.sel,
		wbm_ack_i=>monitor_dbus.ack,
		wbm_adr_o=>monitor_dbus.adr,
		wbm_dat_o=>monitor_dbus.wdata,
		wbm_dat_i=>monitor_dbus.rdata
	);

-- Program RAM

program_ram_inst: entity work.program_ram(rtl)
	generic map(
		THROTTLE=>THROTTLE_IBUS
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>ram_wb.cyc,
		wbs_stb_i=>ram_wb.stb,
		wbs_we_i=>ram_wb.we,
		wbs_sel_i=>ram_wb.sel,
		wbs_ack_o=>ram_wb.ack,
		wbs_adr_i=>ram_wb.adr,
		wbs_dat_i=>ram_wb.wdata,
		wbs_dat_o=>ram_wb.rdata,
		
		lli_re_i=>lli_re,
		lli_adr_i=>lli_adr,
		lli_dat_o=>lli_dat,
		lli_busy_o=>lli_busy
	);

-- Timer

timer_inst: entity work.timer(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>timer_wb.cyc,
		wbs_stb_i=>timer_wb.stb,
		wbs_we_i=>timer_wb.we,
		wbs_sel_i=>timer_wb.sel,
		wbs_ack_o=>timer_wb.ack,
		wbs_adr_i=>timer_wb.adr,
		wbs_dat_i=>timer_wb.wdata,
		wbs_dat_o=>timer_wb.rdata,
		
		elapsed_o=>timer_elapsed
	);

-- Timer with a level-sensitive IRQ

timer2_inst: entity work.timer(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,

		wbs_cyc_i=>timer2_wb.cyc,
		wbs_stb_i=>timer2_wb.stb,
		wbs_we_i=>timer2_wb.we,
		wbs_sel_i=>timer2_wb.sel,
		wbs_ack_o=>timer2_wb.ack,
		wbs_adr_i=>timer2_wb.adr,
		wbs_dat_i=>timer2_wb.wdata,
		wbs_dat_o=>timer2_wb.rdata,

		elapsed_o=>timer2_irq
	);

-- Coprocessor

coprocessor_inst: entity work.coprocessor(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>coprocessor_wb.cyc,
		wbs_stb_i=>coprocessor_wb.stb,
		wbs_we_i=>coprocessor_wb.we,
		wbs_sel_i=>coprocessor_wb.sel,
		wbs_ack_o=>coprocessor_wb.ack,
		wbs_adr_i=>coprocessor_wb.adr,
		wbs_dat_i=>coprocessor_wb.wdata,
		wbs_dat_o=>coprocessor_wb.rdata,
		
		irq_o=>coprocessor_irq
	);

end architecture;
",54
"Program RAM  Part of the LXP32 test platform   Program RAM for the LXP32 test platform. Has two interfaces: WISHBONE (for data access) and LLI (for LXP32 instruction bus). Optionally performs throttling.  Note: regardless of whether this description is synthesizable, it was designed exclusively for simulation purposes.

# VHDL Analysis for 'program_ram.vhd'

## File Comments
- -------------------------------------------------------------------
- Program RAM
- Part of the LXP32 test platform
- Copyright (c) 2016 by Alex I. Kuznetsov
- Program RAM for the LXP32 test platform. Has two interfaces:
- WISHBONE (for data access) and LLI (for LXP32 instruction bus).
- Optionally performs throttling.
- Note: regardless of whether this description is synthesizable,
- it was designed exclusively for simulation purposes.
- -------------------------------------------------------------------
- Plus 3 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: work.common_pkg.all

## Entity: program_ram

## Architecture: rtl of program_ram

### Signals
- ram_a_we: std_logic_vector(3 downto 0)
- ram_a_rdata: std_logic_vector(31 downto 0)
- ram_b_re: std_logic
- ram_b_rdata: std_logic_vector(31 downto 0)
- ack_write: std_logic
- ack_read: std_logic
- prbs: std_logic
- lli_busy: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements memory functionality
- Implements interface or communication protocol
- This appears to be a CPU component
- Implements instruction fetching functionality

## Code Metrics
- Line count: 146
- Process count: 6
- Signal count: 8

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'program_ram.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Program RAM**

**Overview**

The Program RAM component is a dual-interface memory module designed for the LXP32 test platform. It provides a WISHBONE interface for data access and an LLI (Low Latency Interface) for instruction fetching. The component optionally performs throttling to simulate real-world memory access scenarios.

**Functional Description**

The Program RAM component is a 64KB (16384 words) dual-port RAM with two independent interfaces:

1. **WISHBONE Interface**: A standard WISHBONE interface for data access, supporting read and write operations. The interface consists of:
	* Inputs:
		+ `wbs_cyc_i`: Cycle signal
		+ `wbs_stb_i`: Strobe signal
		+ `wbs_we_i`: Write enable signal
		+ `wbs_sel_i`: Byte select signal (4 bits)
		+ `wbs_adr_i`: Address signal (26 bits)
		+ `wbs_dat_i`: Write data signal (32 bits)
	* Outputs:
		+ `wbs_ack_o`: Acknowledge signal
		+ `wbs_dat_o`: Read data signal (32 bits)
2. **LLI (Low Latency Interface)**: A custom interface for instruction fetching, supporting read operations. The interface consists of:
	* Inputs:
		+ `lli_re_i`: Read enable signal
		+ `lli","---------------------------------------------------------------------
-- Program RAM
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Program RAM for the LXP32 test platform. Has two interfaces:
-- WISHBONE (for data access) and LLI (for LXP32 instruction bus).
-- Optionally performs throttling.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

use work.common_pkg.all;

entity program_ram is
	generic(
		THROTTLE: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(27 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		lli_re_i: in std_logic;
		lli_adr_i: in std_logic_vector(29 downto 0);
		lli_dat_o: out std_logic_vector(31 downto 0);
		lli_busy_o: out std_logic
	);
end entity;

architecture rtl of program_ram is

signal ram_a_we: std_logic_vector(3 downto 0);
signal ram_a_rdata: std_logic_vector(31 downto 0);

signal ram_b_re: std_logic;
signal ram_b_rdata: std_logic_vector(31 downto 0);

signal ack_write: std_logic;
signal ack_read: std_logic;

signal prbs: std_logic;
signal lli_busy: std_logic:='0';

begin

-- The total memory size is 16384 words, i.e. 64K bytes

gen_dprams: for i in 3 downto 0 generate
	generic_dpram_inst: entity work.generic_dpram(rtl)
		generic map(
			DATA_WIDTH=>8,
			ADDR_WIDTH=>14,
			SIZE=>16384,
			MODE=>""DONTCARE""
		)
		port map(
			clka_i=>clk_i,
			cea_i=>'1',
			wea_i=>ram_a_we(i),
			addra_i=>wbs_adr_i(15 downto 2),
			da_i=>wbs_dat_i(i*8+7 downto i*8),
			da_o=>ram_a_rdata(i*8+7 downto i*8),
			
			clkb_i=>clk_i,
			ceb_i=>ram_b_re,
			addrb_i=>lli_adr_i(13 downto 0),
			db_o=>ram_b_rdata(i*8+7 downto i*8)
		);
end generate;

-- WISHBONE interface

gen_ram_a_we: for i in 3 downto 0 generate
	ram_a_we(i)<='1' when wbs_cyc_i='1' and wbs_stb_i='1' and wbs_we_i='1'
		and wbs_sel_i(i)='1' and wbs_adr_i(27 downto 16)=""000000000000"" else '0';
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		ack_read<=wbs_cyc_i and wbs_stb_i and not wbs_we_i and not ack_read;
	end if;
end process;

ack_write<=wbs_cyc_i and wbs_stb_i and wbs_we_i;

wbs_ack_o<=ack_read or ack_write;
wbs_dat_o<=ram_a_rdata;

-- Low Latency Interface (with optional pseudo-random throttling)

process (clk_i) is
begin
	if rising_edge(clk_i) then
		assert lli_re_i='0' or lli_adr_i(lli_adr_i'high downto 14)=X""0000""
			report ""Attempted to fetch instruction from a non-existent address 0x""&
				hex_string(lli_adr_i&""00"")
			severity failure;
	end if;
end process;

gen_throttling: if THROTTLE generate
	throttle_inst: entity work.scrambler(rtl)
		generic map(TAP1=>9,TAP2=>11)
		port map(clk_i=>clk_i,rst_i=>rst_i,ce_i=>'1',d_o=>prbs);
end generate;

gen_no_throttling: if not THROTTLE generate
	prbs<='0';
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			lli_busy<='0';
		elsif prbs='1' and lli_re_i='1' then
			lli_busy<='1';
		elsif prbs='0' then
			lli_busy<='0';
		end if;
	end if;
end process;

ram_b_re<=lli_re_i and not lli_busy;

lli_busy_o<=lli_busy;
lli_dat_o<=ram_b_rdata when lli_busy='0' else (others=>'-');

end architecture;
",55
"Scrambler  Part of the LXP32 test platform   Generates a pseudo-random binary sequence using a Linear-Feedback Shift Register (LFSR).  In order to generate a maximum-length sequence, 1+x^TAP1+x^TAP2 must be a primitive polynomial. Typical polynomials include: (6,7), (9,11), (14,15).  Note: regardless of whether this description is synthesizable, it was designed exclusively for simulation purposes.

# VHDL Analysis for 'scrambler.vhd'

## File Comments
- -------------------------------------------------------------------
- Scrambler
- Part of the LXP32 test platform
- Copyright (c) 2016 by Alex I. Kuznetsov
- Generates a pseudo-random binary sequence using a Linear-Feedback
- Shift Register (LFSR).
- In order to generate a maximum-length sequence, 1+x^TAP1+x^TAP2
- must be a primitive polynomial. Typical polynomials include:
- (6,7), (9,11), (14,15).
- Note: regardless of whether this description is synthesizable,
- Plus 2 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: scrambler

## Architecture: rtl of scrambler

### Signals
- reg: std_logic_vector(TAP2 downto 1):=(others=>'1')

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i

## Code Metrics
- Line count: 55
- Process count: 2
- Signal count: 1

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'scrambler.vhd' plays a specific role in the overall CPU architecture.
","**Technical Description:**
The scrambler component generates a pseudo-random binary sequence using a Linear-Feedback Shift Register (LFSR) with a configurable polynomial. It takes in a clock signal (`clk_i`), reset signal (`rst_i`), and clock enable signal (`ce_i`), and produces a single-bit output (`d_o`) representing the pseudo-random sequence. The LFSR polynomial is defined by two tap positions (`TAP1` and `TAP2`) specified as generics.

**Component Specification:**

**Component Name:** Scrambler

**Functionality:** Pseudo-random binary sequence generator using a Linear-Feedback Shift Register (LFSR)

**Inputs:**

* `clk_i`: Clock signal (std_logic)
* `rst_i`: Reset signal (std_logic)
* `ce_i`: Clock enable signal (std_logic)

**Outputs:**

* `d_o`: Pseudo-random binary sequence output (std_logic)

**Generics:**

* `TAP1`: First tap position for LFSR polynomial (integer)
* `TAP2`: Second tap position for LFSR polynomial (integer)

**Notes:**

* The LFSR polynomial is defined as 1 + x^TAP1 + x^TAP2, which must be a primitive polynomial for maximum-length sequence generation.
* Typical polynomials include (6,7), (9,11), and (14,15).
* This component is designed for simulation purposes and may not be synthesizable.

**Behavior:**

* On reset (`rst_i='","---------------------------------------------------------------------
-- Scrambler
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Generates a pseudo-random binary sequence using a Linear-Feedback
-- Shift Register (LFSR).
--
-- In order to generate a maximum-length sequence, 1+x^TAP1+x^TAP2
-- must be a primitive polynomial. Typical polynomials include:
-- (6,7), (9,11), (14,15).
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity scrambler is
	generic(
		TAP1: integer;
		TAP2: integer
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		d_o: out std_logic
	);
end entity;

architecture rtl of scrambler is

signal reg: std_logic_vector(TAP2 downto 1):=(others=>'1');

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			reg<=(others=>'1');
		elsif ce_i='1' then
			reg<=reg(TAP2-1 downto 1)&(reg(TAP2) xor reg(TAP1));
		end if;
	end if;
end process;

d_o<=reg(1);

end architecture;
",56
"Timer  Part of the LXP32 test platform   A simple programmable interval timer.  Note: regardless of whether this description is synthesizable, it was designed exclusively for simulation purposes.

# VHDL Analysis for 'timer.vhd'

## File Comments
- -------------------------------------------------------------------
- Timer
- Part of the LXP32 test platform
- Copyright (c) 2016 by Alex I. Kuznetsov
- A simple programmable interval timer.
- Note: regardless of whether this description is synthesizable,
- it was designed exclusively for simulation purposes.
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: timer

## Architecture: rtl of timer

### Signals
- irq_level_triggered: std_logic:='0'
- irq_invert: std_logic:='0'
- pulses: unsigned(31 downto 0):=(others=>'0')
- interval: unsigned(31 downto 0):=(others=>'0')
- cnt: unsigned(31 downto 0):=(others=>'0')
- elapsed: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i

## Code Metrics
- Line count: 111
- Process count: 2
- Signal count: 6

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'timer.vhd' plays a specific role in the overall CPU architecture.
","**Component Technical Description**
The VHDL component described here is a simple programmable interval timer designed for simulation purposes. It takes in a clock signal (`clk_i`), reset signal (`rst_i`), and various Wishbone bus signals (`wbs_*`) to control and configure the timer. The timer outputs an elapsed signal (`elapsed_o`) indicating when a programmed interval has expired.

**Component Specification**

**Component Name:** Programmable Interval Timer

**Description:** A simple, configurable timer component that generates an elapsed signal when a programmed interval has expired.

**Inputs:**

* **clk_i**: Clock signal (std_logic)
* **rst_i**: Reset signal (std_logic)
* **wbs_cyc_i**: Wishbone cycle signal (std_logic)
* **wbs_stb_i**: Wishbone strobe signal (std_logic)
* **wbs_we_i**: Wishbone write enable signal (std_logic)
* **wbs_sel_i**: Wishbone select signal (std_logic_vector(3 downto 0))
* **wbs_adr_i**: Wishbone address signal (std_logic_vector(27 downto 2))
* **wbs_dat_i**: Wishbone data input signal (std_logic_vector(31 downto 0))

**Outputs:**

* **wbs_ack_o**: Wishbone acknowledge signal (std_logic)
* **wbs_dat_o**: Wishbone data output signal (std_logic_vector(31 downto 0))
* **elapsed_o**: Elapsed signal (std_logic)

**Registers","---------------------------------------------------------------------
-- Timer
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A simple programmable interval timer.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity timer is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(27 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		elapsed_o: out std_logic
	);
end entity;

architecture rtl of timer is

signal irq_level_triggered: std_logic:='0';
signal irq_invert: std_logic:='0';

signal pulses: unsigned(31 downto 0):=(others=>'0');
signal interval: unsigned(31 downto 0):=(others=>'0');
signal cnt: unsigned(31 downto 0):=(others=>'0');
signal elapsed: std_logic:='0';

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			pulses<=(others=>'0');
			interval<=(others=>'0');
			cnt<=(others=>'0');
			elapsed<='0';
		else
			if irq_level_triggered='0' then
				elapsed<='0';
			end if;
			if pulses/=X""00000000"" or cnt/=X""00000000"" then
				if cnt=X""00000000"" then
					if pulses/=X""FFFFFFFF"" then
						pulses<=pulses-1;
					end if;
					if pulses/=X""00000000"" then
						cnt<=interval;
					end if;
				else
					cnt<=cnt-1;
				end if;
				if cnt=X""00000001"" then
					elapsed<='1';
				end if;
			end if;
			
			if wbs_cyc_i='1' and wbs_stb_i='1' and wbs_we_i='1' then
				for i in wbs_sel_i'range loop
					if wbs_sel_i(i)='1' then
						if wbs_adr_i=""00""&X""000000"" then
							pulses(i*8+7 downto i*8)<=
								unsigned(wbs_dat_i(i*8+7 downto i*8));
							cnt<=(others=>'0');
						end if;
						if wbs_adr_i=""00""&X""000001"" then
							interval(i*8+7 downto i*8)<=
								unsigned(wbs_dat_i(i*8+7 downto i*8));
							cnt<=(others=>'0');
						end if;
						if wbs_adr_i=""00""&X""000002"" and i=0 then
							irq_level_triggered<=wbs_dat_i(0);
							irq_invert<=wbs_dat_i(1);
						end if;
						if wbs_adr_i=""00""&X""000003"" and wbs_dat_i(0)='1' and i=0 then
							elapsed<='0';
						end if;
					end if;
				end loop;
			end if;
		end if;
	end if;
end process;

wbs_ack_o<=wbs_cyc_i and wbs_stb_i;
wbs_dat_o<=std_logic_vector(pulses) when wbs_adr_i=""00""&X""000000"" else
	std_logic_vector(interval) when wbs_adr_i=""00""&X""000001"" else
	(others=>'-');

elapsed_o<=elapsed xor irq_invert;

end architecture;
",57
"# VHDL Analysis for 'lxp32_alu.vhd'

## File Comments
- -------------------------------------------------------------------
- Arithmetic logic unit
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- Performs arithmetic and logic operations.
- -------------------------------------------------------------------
- Add/subtract
- Comparator (needs cmd_negate_op2_i to work correctly)
- Bitwise operations (and, or, xor)
- Note: (a or b) = (a and b) or (a xor b)
- Plus 5 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_alu

## Architecture: rtl of lxp32_alu

### Signals
- addend1: unsigned(31 downto 0)
- addend2: unsigned(31 downto 0)
- adder_result: unsigned(32 downto 0)
- adder_we: std_logic
- cmp_eq: std_logic
- cmp_carry: std_logic
- cmp_s1: std_logic
- cmp_s2: std_logic
- logic_result: std_logic_vector(31 downto 0)
- logic_we: std_logic
- mul_result: std_logic_vector(31 downto 0)
- mul_ce: std_logic
- mul_we: std_logic
- div_result: std_logic_vector(31 downto 0)
- div_ce: std_logic
- div_we: std_logic
- shift_result: std_logic_vector(31 downto 0)
- shift_ce: std_logic
- shift_we: std_logic
- result_mux: std_logic_vector(31 downto 0)
- result_we: std_logic
- busy: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements arithmetic/computational functionality
- Implements control logic
- May be part of a pipeline architecture
- This appears to be a CPU component

## Code Metrics
- Line count: 251
- Process count: 4
- Signal count: 22

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_alu.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Arithmetic Logic Unit (ALU)**

**Overview**

The LXP32 ALU is a digital component designed to perform arithmetic and logic operations for the LXP32 CPU. It takes two 32-bit operands and control signals as inputs, executes the specified operation, and produces a 32-bit result.

**Inputs**

* **clk_i**: Clock input (1-bit)
* **rst_i**: Reset input (1-bit)
* **valid_i**: Operation validity signal (1-bit)
* **cmd_signed_i**: Signed/unsigned operation mode (1-bit)
* **cmd_addsub_i**: Add/subtract operation control (1-bit)
* **cmd_mul_i**: Multiply operation control (1-bit)
* **cmd_div_i**: Divide operation control (1-bit)
* **cmd_div_mod_i**: Divide/modulo operation control (1-bit)
* **cmd_cmp_i**: Compare operation control (1-bit)
* **cmd_negate_op2_i**: Negate operand 2 control (1-bit)
* **cmd_and_i**: Bitwise AND operation control (1-bit)
* **cmd_xor_i**: Bitwise XOR operation control (1-bit)
* **cmd_shift_i**: Shift operation control (1-bit)
* **cmd_shift_right_i**: Shift direction control (1-bit)
* **op1_i**: Operand 1 (32-bit)
* **op2_i**: Operand 2 (32-bit)

**Outputs**

* **result_o**:","---------------------------------------------------------------------
-- Arithmetic logic unit
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Performs arithmetic and logic operations.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_alu is
	generic(
		DIVIDER_EN: boolean;
		MUL_ARCH: string
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		valid_i: in std_logic;
		
		cmd_signed_i: in std_logic;
		cmd_addsub_i: in std_logic;
		cmd_mul_i: in std_logic;
		cmd_div_i: in std_logic;
		cmd_div_mod_i: in std_logic;
		cmd_cmp_i: in std_logic;
		cmd_negate_op2_i: in std_logic;
		cmd_and_i: in std_logic;
		cmd_xor_i: in std_logic;
		cmd_shift_i: in std_logic;
		cmd_shift_right_i: in std_logic;
		
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		
		result_o: out std_logic_vector(31 downto 0);
		
		cmp_eq_o: out std_logic;
		cmp_ug_o: out std_logic;
		cmp_sg_o: out std_logic;
		
		we_o: out std_logic;
		busy_o: out std_logic
	);
end entity;

architecture rtl of lxp32_alu is

signal addend1: unsigned(31 downto 0);
signal addend2: unsigned(31 downto 0);
signal adder_result: unsigned(32 downto 0);
signal adder_we: std_logic;

signal cmp_eq: std_logic;
signal cmp_carry: std_logic;
signal cmp_s1: std_logic;
signal cmp_s2: std_logic;

signal logic_result: std_logic_vector(31 downto 0);
signal logic_we: std_logic;

signal mul_result: std_logic_vector(31 downto 0);
signal mul_ce: std_logic;
signal mul_we: std_logic;

signal div_result: std_logic_vector(31 downto 0);
signal div_ce: std_logic;
signal div_we: std_logic;

signal shift_result: std_logic_vector(31 downto 0);
signal shift_ce: std_logic;
signal shift_we: std_logic;

signal result_mux: std_logic_vector(31 downto 0);
signal result_we: std_logic;

signal busy: std_logic:='0';

begin

assert MUL_ARCH=""dsp"" or MUL_ARCH=""seq"" or MUL_ARCH=""opt""
	report ""Invalid MUL_ARCH generic value: dsp, opt or seq expected""
	severity failure;

-- Add/subtract

addend1<=unsigned(op1_i);

addend2_gen: for i in addend2'range generate
	addend2(i)<=op2_i(i) xor cmd_negate_op2_i;
end generate;

adder_result<=(""0""&addend1)+(""0""&addend2)+(to_unsigned(0,adder_result'length-1)&cmd_negate_op2_i);
adder_we<=cmd_addsub_i and valid_i;

-- Comparator (needs cmd_negate_op2_i to work correctly)

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if valid_i='1' and cmd_cmp_i='1' then
			if op1_i=op2_i then
				cmp_eq<='1';
			else
				cmp_eq<='0';
			end if;
			
			cmp_carry<=adder_result(adder_result'high);
			cmp_s1<=op1_i(op1_i'high);
			cmp_s2<=op2_i(op2_i'high);
		end if;
	end if;
end process;

cmp_eq_o<=cmp_eq;
cmp_ug_o<=cmp_carry and not cmp_eq;
cmp_sg_o<=((cmp_s1 and cmp_s2 and cmp_carry) or
	(not cmp_s1 and not cmp_s2 and cmp_carry) or
	(not cmp_s1 and cmp_s2)) and not cmp_eq;

-- Bitwise operations (and, or, xor)
-- Note: (a or b) = (a and b) or (a xor b)

logic_result_gen: for i in logic_result'range generate
	logic_result(i)<=((op1_i(i) and op2_i(i)) and cmd_and_i) or
		((op1_i(i) xor op2_i(i)) and cmd_xor_i);
end generate;

logic_we<=(cmd_and_i or cmd_xor_i) and valid_i;

-- Multiplier

mul_ce<=cmd_mul_i and valid_i;

gen_mul_dsp: if MUL_ARCH=""dsp"" generate
	mul_inst: entity work.lxp32_mul_dsp(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>mul_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			ce_o=>mul_we,
			result_o=>mul_result
		);
end generate;

gen_mul_opt: if MUL_ARCH=""opt"" generate
	mul_inst: entity work.lxp32_mul_opt(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>mul_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			ce_o=>mul_we,
			result_o=>mul_result
		);
end generate;

gen_mul_seq: if MUL_ARCH=""seq"" generate
	mul_inst: entity work.lxp32_mul_seq(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>mul_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			ce_o=>mul_we,
			result_o=>mul_result
		);
end generate;

-- Divider

div_ce<=cmd_div_i and valid_i;

gen_divider: if DIVIDER_EN generate
	divider_inst: entity work.lxp32_divider(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>div_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			signed_i=>cmd_signed_i,
			rem_i=>cmd_div_mod_i,
			ce_o=>div_we,
			result_o=>div_result
		);
end generate;

gen_no_divider: if not DIVIDER_EN generate
	div_we<=div_ce;
	div_result<=(others=>'0');
end generate;

-- Shifter

shift_ce<=cmd_shift_i and valid_i;

shifter_inst: entity work.lxp32_shifter(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		ce_i=>shift_ce,
		d_i=>op1_i,
		s_i=>op2_i(4 downto 0),
		right_i=>cmd_shift_right_i,
		sig_i=>cmd_signed_i,
		ce_o=>shift_we,
		d_o=>shift_result
	);

-- Result multiplexer

result_mux_gen: for i in result_mux'range generate
	result_mux(i)<=(adder_result(i) and adder_we) or
		(logic_result(i) and logic_we) or
		(mul_result(i) and mul_we) or
		(div_result(i) and div_we) or
		(shift_result(i) and shift_we);
end generate;

result_o<=result_mux;

result_we<=adder_we or logic_we or mul_we or div_we or shift_we;
we_o<=result_we;

-- Pipeline control

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' or result_we='1' then
			busy<='0';
		elsif shift_ce='1' or mul_ce='1' or div_ce='1' then
			busy<='1';
		end if;
	end if;
end process;

busy_o<=busy;

end architecture;
",58
"# VHDL Analysis for 'lxp32_compl.vhd'

## File Comments
- -------------------------------------------------------------------
- Complementor
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- Computes a 2's complement of its input. Used as an auxiliary
- unit in the divider.
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_compl

## Architecture: rtl of lxp32_compl

### Signals
- d_prepared: unsigned(d_i'range)
- sum_low: unsigned(16 downto 0)
- d_high: unsigned(15 downto 0)
- sum_high: unsigned(15 downto 0)

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- This appears to be a CPU component

## Code Metrics
- Line count: 51
- Process count: 2
- Signal count: 4

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_compl.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `lxp32_compl` component computes the two's complement of its 32-bit input `d_i` based on the control signal `compl_i`. It generates the two's complement representation on its output `d_o` on every clock cycle. The component is designed to work as an auxiliary unit in a divider.

**Inputs**

* `clk_i`: A clock signal (std_logic) that drives the component's sequential logic.
* `compl_i`: A control signal (std_logic) that determines whether to compute the two's complement of `d_i`.
* `d_i`: A 32-bit input data signal (std_logic_vector) to be converted to its two's complement representation.

**Outputs**

* `d_o`: A 32-bit output data signal (std_logic_vector) that represents the two's complement of `d_i` when `compl_i` is high.

**Component Specification**

* **Functionality**: Two's complement computation
* **Input Width**: 32 bits
* **Output Width**: 32 bits
* **Clock Frequency**: Dependent on the system clock
* **Latency**: 1 clock cycle
* **Control Signal**: `compl_i` (active high)

**Detailed Component Specification**

### Overview

The `lxp32_compl` component is a digital circuit designed to compute the two's complement representation of a 32-bit input data signal `d_i`. The component is controlled by a clock signal `","---------------------------------------------------------------------
-- Complementor
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Computes a 2's complement of its input. Used as an auxiliary
-- unit in the divider.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_compl is
	port(
		clk_i: in std_logic;
		compl_i: in std_logic;
		d_i: in std_logic_vector(31 downto 0);
		d_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_compl is

signal d_prepared: unsigned(d_i'range);
signal sum_low: unsigned(16 downto 0);
signal d_high: unsigned(15 downto 0);
signal sum_high: unsigned(15 downto 0);

begin

d_prepared_gen: for i in d_prepared'range generate
	d_prepared(i)<=d_i(i) xor compl_i;
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		sum_low<=(""0""&d_prepared(15 downto 0))+(to_unsigned(0,16)&compl_i);
		d_high<=d_prepared(31 downto 16);
	end if;
end process;

sum_high<=d_high+(to_unsigned(0,15)&sum_low(sum_low'high));

d_o<=std_logic_vector(sum_high&sum_low(15 downto 0));

end architecture;
",59
"# VHDL Analysis for 'lxp32_cpu.vhd'

## File Comments
- -------------------------------------------------------------------
- LXP32 CPU Core
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: lxp32_cpu

## Architecture: rtl of lxp32_cpu

### Signals
- fetch_word: std_logic_vector(31 downto 0)
- fetch_next_ip: std_logic_vector(29 downto 0)
- fetch_current_ip: std_logic_vector(29 downto 0)
- fetch_valid: std_logic
- fetch_jump_ready: std_logic
- decode_ready: std_logic
- decode_valid: std_logic
- decode_cmd_loadop3: std_logic
- decode_cmd_signed: std_logic
- decode_cmd_dbus: std_logic
- decode_cmd_dbus_store: std_logic
- decode_cmd_dbus_byte: std_logic
- decode_cmd_addsub: std_logic
- decode_cmd_mul: std_logic
- decode_cmd_div: std_logic
- decode_cmd_div_mod: std_logic
- decode_cmd_cmp: std_logic
- decode_cmd_jump: std_logic
- decode_cmd_negate_op2: std_logic
- decode_cmd_and: std_logic
- decode_cmd_xor: std_logic
- decode_cmd_shift: std_logic
- decode_cmd_shift_right: std_logic
- decode_jump_type: std_logic_vector(3 downto 0)
- decode_op1: std_logic_vector(31 downto 0)
- decode_op2: std_logic_vector(31 downto 0)
- decode_op3: std_logic_vector(31 downto 0)
- decode_dst: std_logic_vector(7 downto 0)
- execute_ready: std_logic
- execute_jump_valid: std_logic
- execute_jump_dst: std_logic_vector(29 downto 0)
- sp_raddr1: std_logic_vector(7 downto 0)
- sp_rdata1: std_logic_vector(31 downto 0)
- sp_raddr2: std_logic_vector(7 downto 0)
- sp_rdata2: std_logic_vector(31 downto 0)
- sp_waddr: std_logic_vector(7 downto 0)
- sp_we: std_logic
- sp_wdata: std_logic_vector(31 downto 0)
- interrupt_valid: std_logic
- interrupt_vector: std_logic_vector(2 downto 0)
- interrupt_ready: std_logic
- interrupt_return: std_logic
- interrupt_wakeup: std_logic

## Functional Analysis

- Uses reset signal(s): rst_i
- This appears to be a CPU component

## Code Metrics
- Line count: 262
- Process count: 0
- Signal count: 43

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_cpu.vhd' plays a specific role in the overall CPU architecture.
","**Component Name:** LXP32 CPU Core

**Functionality:** The LXP32 CPU Core is a 32-bit RISC processor core designed to execute instructions and manage data transfer between various components. It features a pipelined architecture with separate fetch, decode, and execute stages.

**Inputs:**

* **clk_i**: Clock input
* **rst_i**: Reset input
* **lli_dat_i**: Instruction data input from the LLI (Low-Level Interface) bus
* **lli_busy_i**: LLI bus busy signal
* **dbus_dat_i**: Data input from the data bus
* **dbus_ack_i**: Data bus acknowledge signal
* **irq_i**: Interrupt request input (8-bit vector)

**Outputs:**

* **lli_re_o**: LLI read enable output
* **lli_adr_o**: LLI address output (30-bit)
* **dbus_cyc_o**: Data bus cycle output
* **dbus_stb_o**: Data bus strobe output
* **dbus_we_o**: Data bus write enable output
* **dbus_sel_o**: Data bus select output (4-bit)
* **dbus_adr_o**: Data bus address output (30-bit)
* **dbus_dat_o**: Data bus data output (32-bit)

**Purpose:** The LXP32 CPU Core is designed to execute a subset of instructions, perform data transfer operations, and handle interrupts. It provides a flexible and customizable processor core for various applications.

**Key Features:**

*","---------------------------------------------------------------------
-- LXP32 CPU Core
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_cpu is
	generic(
		DBUS_RMW: boolean;
		DIVIDER_EN: boolean;
		MUL_ARCH: string;
		START_ADDR: std_logic_vector(31 downto 0)
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		irq_i: in std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32_cpu is

signal fetch_word: std_logic_vector(31 downto 0);
signal fetch_next_ip: std_logic_vector(29 downto 0);
signal fetch_current_ip: std_logic_vector(29 downto 0);
signal fetch_valid: std_logic;
signal fetch_jump_ready: std_logic;

signal decode_ready: std_logic;
signal decode_valid: std_logic;

signal decode_cmd_loadop3: std_logic;
signal decode_cmd_signed: std_logic;
signal decode_cmd_dbus: std_logic;
signal decode_cmd_dbus_store: std_logic;
signal decode_cmd_dbus_byte: std_logic;
signal decode_cmd_addsub: std_logic;
signal decode_cmd_mul: std_logic;
signal decode_cmd_div: std_logic;
signal decode_cmd_div_mod: std_logic;
signal decode_cmd_cmp: std_logic;
signal decode_cmd_jump: std_logic;
signal decode_cmd_negate_op2: std_logic;
signal decode_cmd_and: std_logic;
signal decode_cmd_xor: std_logic;
signal decode_cmd_shift: std_logic;
signal decode_cmd_shift_right: std_logic;

signal decode_jump_type: std_logic_vector(3 downto 0);

signal decode_op1: std_logic_vector(31 downto 0);
signal decode_op2: std_logic_vector(31 downto 0);
signal decode_op3: std_logic_vector(31 downto 0);
signal decode_dst: std_logic_vector(7 downto 0);

signal execute_ready: std_logic;
signal execute_jump_valid: std_logic;
signal execute_jump_dst: std_logic_vector(29 downto 0);

signal sp_raddr1: std_logic_vector(7 downto 0);
signal sp_rdata1: std_logic_vector(31 downto 0);
signal sp_raddr2: std_logic_vector(7 downto 0);
signal sp_rdata2: std_logic_vector(31 downto 0);
signal sp_waddr: std_logic_vector(7 downto 0);
signal sp_we: std_logic;
signal sp_wdata: std_logic_vector(31 downto 0);

signal interrupt_valid: std_logic;
signal interrupt_vector: std_logic_vector(2 downto 0);
signal interrupt_ready: std_logic;
signal interrupt_return: std_logic;
signal interrupt_wakeup: std_logic;

begin

fetch_inst: entity work.lxp32_fetch(rtl)
	generic map(
		START_ADDR=>START_ADDR
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_o=>lli_re_o,
		lli_adr_o=>lli_adr_o,
		lli_dat_i=>lli_dat_i,
		lli_busy_i=>lli_busy_i,
		
		word_o=>fetch_word,
		next_ip_o=>fetch_next_ip,
		current_ip_o=>fetch_current_ip,
		valid_o=>fetch_valid,
		ready_i=>decode_ready,
		
		jump_valid_i=>execute_jump_valid,
		jump_dst_i=>execute_jump_dst,
		jump_ready_o=>fetch_jump_ready
	);

decode_inst: entity work.lxp32_decode(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		word_i=>fetch_word,
		next_ip_i=>fetch_next_ip,
		current_ip_i=>fetch_current_ip,
		valid_i=>fetch_valid,
		jump_valid_i=>execute_jump_valid,
		ready_o=>decode_ready,
		
		interrupt_valid_i=>interrupt_valid,
		interrupt_vector_i=>interrupt_vector,
		interrupt_ready_o=>interrupt_ready,

		wakeup_i=>interrupt_wakeup,
		
		sp_raddr1_o=>sp_raddr1,
		sp_rdata1_i=>sp_rdata1,
		sp_raddr2_o=>sp_raddr2,
		sp_rdata2_i=>sp_rdata2,
		
		ready_i=>execute_ready,
		valid_o=>decode_valid,
		
		cmd_loadop3_o=>decode_cmd_loadop3,
		cmd_signed_o=>decode_cmd_signed,
		cmd_dbus_o=>decode_cmd_dbus,
		cmd_dbus_store_o=>decode_cmd_dbus_store,
		cmd_dbus_byte_o=>decode_cmd_dbus_byte,
		cmd_addsub_o=>decode_cmd_addsub,
		cmd_mul_o=>decode_cmd_mul,
		cmd_div_o=>decode_cmd_div,
		cmd_div_mod_o=>decode_cmd_div_mod,
		cmd_cmp_o=>decode_cmd_cmp,
		cmd_jump_o=>decode_cmd_jump,
		cmd_negate_op2_o=>decode_cmd_negate_op2,
		cmd_and_o=>decode_cmd_and,
		cmd_xor_o=>decode_cmd_xor,
		cmd_shift_o=>decode_cmd_shift,
		cmd_shift_right_o=>decode_cmd_shift_right,
		
		jump_type_o=>decode_jump_type,
		
		op1_o=>decode_op1,
		op2_o=>decode_op2,
		op3_o=>decode_op3,
		dst_o=>decode_dst
	);

execute_inst: entity work.lxp32_execute(rtl)
	generic map(
		DBUS_RMW=>DBUS_RMW,
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		cmd_loadop3_i=>decode_cmd_loadop3,
		cmd_signed_i=>decode_cmd_signed,
		cmd_dbus_i=>decode_cmd_dbus,
		cmd_dbus_store_i=>decode_cmd_dbus_store,
		cmd_dbus_byte_i=>decode_cmd_dbus_byte,
		cmd_addsub_i=>decode_cmd_addsub,
		cmd_mul_i=>decode_cmd_mul,
		cmd_div_i=>decode_cmd_div,
		cmd_div_mod_i=>decode_cmd_div_mod,
		cmd_cmp_i=>decode_cmd_cmp,
		cmd_jump_i=>decode_cmd_jump,
		cmd_negate_op2_i=>decode_cmd_negate_op2,
		cmd_and_i=>decode_cmd_and,
		cmd_xor_i=>decode_cmd_xor,
		cmd_shift_i=>decode_cmd_shift,
		cmd_shift_right_i=>decode_cmd_shift_right,
		
		jump_type_i=>decode_jump_type,
		
		op1_i=>decode_op1,
		op2_i=>decode_op2,
		op3_i=>decode_op3,
		dst_i=>decode_dst,
		
		sp_waddr_o=>sp_waddr,
		sp_we_o=>sp_we,
		sp_wdata_o=>sp_wdata,
		
		valid_i=>decode_valid,
		ready_o=>execute_ready,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i,
		
		jump_valid_o=>execute_jump_valid,
		jump_dst_o=>execute_jump_dst,
		jump_ready_i=>fetch_jump_ready,
		
		interrupt_return_o=>interrupt_return
	);

scratchpad_inst: entity work.lxp32_scratchpad(rtl)
	port map(
		clk_i=>clk_i,
		
		raddr1_i=>sp_raddr1,
		rdata1_o=>sp_rdata1,
		raddr2_i=>sp_raddr2,
		rdata2_o=>sp_rdata2,
		
		waddr_i=>sp_waddr,
		we_i=>sp_we,
		wdata_i=>sp_wdata
	);

interrupt_mux_inst: entity work.lxp32_interrupt_mux(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		irq_i=>irq_i,
		
		interrupt_valid_o=>interrupt_valid,
		interrupt_vector_o=>interrupt_vector,
		interrupt_ready_i=>interrupt_ready,
		interrupt_return_i=>interrupt_return,

		wakeup_o=>interrupt_wakeup,
		
		sp_waddr_i=>sp_waddr,
		sp_we_i=>sp_we,
		sp_wdata_i=>sp_wdata
	);

end architecture;
",60
"# VHDL Analysis for 'lxp32_dbus.vhd'

## File Comments
- -------------------------------------------------------------------
- DBUS master
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- Manages data bus (DBUS) access.
- -------------------------------------------------------------------
- synthesis translate_off
- synthesis translate_on

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_dbus

## Architecture: rtl of lxp32_dbus

### Signals
- strobe: std_logic:='0'
- we_out: std_logic:='0'
- we: std_logic
- byte_mode: std_logic
- sel: std_logic_vector(3 downto 0)
- sig: std_logic
- rmw_mode: std_logic
- dbus_rdata: std_logic_vector(31 downto 0)
- selected_byte: std_logic_vector(7 downto 0)

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements interface or communication protocol
- This appears to be a CPU component

## Code Metrics
- Line count: 172
- Process count: 4
- Signal count: 9

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_dbus.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Data Bus (DBUS) Master**

**Overview**

The LXP32 Data Bus (DBUS) Master is a digital component responsible for managing data bus access in the LXP32 CPU. It acts as a bridge between the CPU's internal data bus and the external data bus, controlling data transfer and providing necessary handshake signals.

**Inputs**

* **clk_i**: Clock input (1-bit)
* **rst_i**: Reset input (1-bit)
* **valid_i**: Validity signal indicating a valid data transfer request (1-bit)
* **cmd_dbus_i**: Command to access the data bus (1-bit)
* **cmd_dbus_store_i**: Command to store data on the data bus (1-bit)
* **cmd_dbus_byte_i**: Command to access data in byte mode (1-bit)
* **cmd_signed_i**: Command to perform signed data transfer (1-bit)
* **addr_i**: Address input (32-bit)
* **wdata_i**: Write data input (32-bit)
* **dbus_ack_i**: Acknowledge signal from the external data bus (1-bit)
* **dbus_dat_i**: Read data input from the external data bus (32-bit)

**Outputs**

* **rdata_o**: Read data output (32-bit)
* **we_o**: Write enable output (1-bit)
* **busy_o**: Busy signal indicating data bus access (1-bit)
* **dbus_cyc_o**: Data","---------------------------------------------------------------------
-- DBUS master
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Manages data bus (DBUS) access.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_dbus is
	generic(
		RMW: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		valid_i: in std_logic;
		
		cmd_dbus_i: in std_logic;
		cmd_dbus_store_i: in std_logic;
		cmd_dbus_byte_i: in std_logic;
		cmd_signed_i: in std_logic;
		addr_i: in std_logic_vector(31 downto 0);
		wdata_i: in std_logic_vector(31 downto 0);
		
		rdata_o: out std_logic_vector(31 downto 0);
		we_o: out std_logic;
		busy_o: out std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_dbus is

signal strobe: std_logic:='0';
signal we_out: std_logic:='0';
signal we: std_logic;
signal byte_mode: std_logic;
signal sel: std_logic_vector(3 downto 0);
signal sig: std_logic;
signal rmw_mode: std_logic;

signal dbus_rdata: std_logic_vector(31 downto 0);
signal selected_byte: std_logic_vector(7 downto 0);

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			we_out<='0';
			strobe<='0';
			sig<='-';
			byte_mode<='-';
			sel<=(others=>'-');
			we<='-';
			rmw_mode<='-';
			dbus_adr_o<=(others=>'-');
			dbus_dat_o<=(others=>'-');
		else
			we_out<='0';
			if strobe='0' then
				if valid_i='1' and cmd_dbus_i='1' then
					strobe<='1';
					sig<=cmd_signed_i;
					
					dbus_adr_o<=addr_i(31 downto 2);
					
					if cmd_dbus_byte_i='0' then
						byte_mode<='0';
						dbus_dat_o<=wdata_i;
						sel<=""1111"";
						
						-- synthesis translate_off
						assert addr_i(1 downto 0)=""00""
							report ""Misaligned word-granular access on data bus""
							severity warning;
						-- synthesis translate_on
					else
						byte_mode<='1';
						dbus_dat_o<=wdata_i(7 downto 0)&wdata_i(7 downto 0)&
							wdata_i(7 downto 0)&wdata_i(7 downto 0);
						
						case addr_i(1 downto 0) is
						when ""00"" => sel<=""0001"";
						when ""01"" => sel<=""0010"";
						when ""10"" => sel<=""0100"";
						when ""11"" => sel<=""1000"";
						when others =>
						end case;
					end if;
					
					if not RMW then
						we<=cmd_dbus_store_i;
						rmw_mode<='0';
					else
						we<=cmd_dbus_store_i and not cmd_dbus_byte_i;
						rmw_mode<=cmd_dbus_store_i and cmd_dbus_byte_i;
					end if;
				end if;
			else
				if dbus_ack_i='1' then
					if rmw_mode='1' and we='0' and RMW then
						we<='1';
						for i in sel'range loop
							if sel(i)='0' then
								dbus_dat_o(i*8+7 downto i*8)<=
									dbus_dat_i(i*8+7 downto i*8);
							end if;
						end loop;
					else
						strobe<='0';
						if we='0' then
							we_out<='1';
						end if;
					end if;
				end if;
			end if;
		end if;
	end if;
end process;

dbus_cyc_o<=strobe;
dbus_stb_o<=strobe;
dbus_we_o<=we;

sel_no_rmw_gen: if not RMW generate
	dbus_sel_o<=sel;
end generate;

sel_rmw_gen: if RMW generate
	dbus_sel_o<=(others=>'1');
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		dbus_rdata<=dbus_dat_i;
	end if;
end process;

selected_byte_gen: for i in selected_byte'range generate
	selected_byte(i)<=(dbus_rdata(i) and sel(0)) or
		(dbus_rdata(i+8) and sel(1)) or
		(dbus_rdata(i+16) and sel(2)) or
		(dbus_rdata(i+24) and sel(3));
end generate;

rdata_o<=dbus_rdata when byte_mode='0' else
	X""000000""&selected_byte when selected_byte(selected_byte'high)='0' or sig='0' else
	X""FFFFFF""&selected_byte;

we_o<=we_out;
busy_o<=strobe or we_out;

end architecture;
",61
"# VHDL Analysis for 'lxp32_decode.vhd'

## File Comments
- -------------------------------------------------------------------
- Instruction decoder
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- The second stage of the LXP32 pipeline.
- -------------------------------------------------------------------
- Decoder FSM state
- Input instruction portions
- Signals related to pipeline control
- Signals related to RD operand decoding
- Plus 11 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_decode

## Architecture: rtl of lxp32_decode

### Signals
- state: DecoderState:=Regular
- opcode: std_logic_vector(5 downto 0)
- t1: std_logic
- t2: std_logic
- destination: std_logic_vector(7 downto 0)
- rd1: std_logic_vector(7 downto 0)
- rd2: std_logic_vector(7 downto 0)
- downstream_busy: std_logic
- self_busy: std_logic:='0'
- busy: std_logic
- valid_out: std_logic:='0'
- dst_out: std_logic_vector(7 downto 0)
- rd1_reg: std_logic_vector(7 downto 0)
- rd2_reg: std_logic_vector(7 downto 0)
- rd1_select: std_logic
- rd1_direct: std_logic_vector(31 downto 0)
- rd2_select: std_logic
- rd2_direct: std_logic_vector(31 downto 0)
- interrupt_ready: std_logic:='0'
- wakeup_reg: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- This appears to be a Finite State Machine implementation
- Uses reset signal(s): DecoderState, rst_i
- Implements control logic
- May be part of a pipeline architecture
- This appears to be a CPU component
- Implements instruction decoding functionality

## Code Metrics
- Line count: 334
- Process count: 4
- Signal count: 20

## Summary
- This module implements control logic.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_decode.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Instruction Decoder**

**Overview**

The LXP32 Instruction Decoder is a digital component responsible for decoding instructions in the LXP32 CPU. It takes in a 32-bit instruction word and outputs control signals, operands, and destination register information.

**Inputs**

* **clk_i**: Clock input (1-bit)
* **rst_i**: Reset input (1-bit)
* **word_i**: 32-bit instruction word
* **next_ip_i**: 30-bit next instruction pointer
* **current_ip_i**: 30-bit current instruction pointer
* **valid_i**: Instruction validity signal (1-bit)
* **jump_valid_i**: Jump validity signal (1-bit)
* **interrupt_valid_i**: Interrupt validity signal (1-bit)
* **interrupt_vector_i**: 3-bit interrupt vector
* **wakeup_i**: Wake-up signal (1-bit)
* **ready_i**: Downstream component readiness signal (1-bit)
* **sp_rdata1_i**: Stack pointer register data 1 (32-bit)
* **sp_rdata2_i**: Stack pointer register data 2 (32-bit)

**Outputs**

* **ready_o**: Decoder readiness signal (1-bit)
* **interrupt_ready_o**: Interrupt readiness signal (1-bit)
* **valid_o**: Instruction validity output signal (1-bit)
* **cmd_loadop3_o**: Load operand 3 control signal (1-bit)
* **cmd_signed_o**: Signed operand control signal (1-bit","---------------------------------------------------------------------
-- Instruction decoder
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The second stage of the LXP32 pipeline.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_decode is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		word_i: in std_logic_vector(31 downto 0);
		next_ip_i: in std_logic_vector(29 downto 0);
		current_ip_i: in std_logic_vector(29 downto 0);
		valid_i: in std_logic;
		jump_valid_i: in std_logic;
		ready_o: out std_logic;
		
		interrupt_valid_i: in std_logic;
		interrupt_vector_i: in std_logic_vector(2 downto 0);
		interrupt_ready_o: out std_logic;

		wakeup_i: in std_logic;
		
		sp_raddr1_o: out std_logic_vector(7 downto 0);
		sp_rdata1_i: in std_logic_vector(31 downto 0);
		sp_raddr2_o: out std_logic_vector(7 downto 0);
		sp_rdata2_i: in std_logic_vector(31 downto 0);
		
		ready_i: in std_logic;
		valid_o: out std_logic;
		
		cmd_loadop3_o: out std_logic;
		cmd_signed_o: out std_logic;
		cmd_dbus_o: out std_logic;
		cmd_dbus_store_o: out std_logic;
		cmd_dbus_byte_o: out std_logic;
		cmd_addsub_o: out std_logic;
		cmd_mul_o: out std_logic;
		cmd_div_o: out std_logic;
		cmd_div_mod_o: out std_logic;
		cmd_cmp_o: out std_logic;
		cmd_jump_o: out std_logic;
		cmd_negate_op2_o: out std_logic;
		cmd_and_o: out std_logic;
		cmd_xor_o: out std_logic;
		cmd_shift_o: out std_logic;
		cmd_shift_right_o: out std_logic;
		
		jump_type_o: out std_logic_vector(3 downto 0);
		
		op1_o: out std_logic_vector(31 downto 0);
		op2_o: out std_logic_vector(31 downto 0);
		op3_o: out std_logic_vector(31 downto 0);
		dst_o: out std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32_decode is

-- Decoder FSM state

type DecoderState is (Regular,ContinueLc,ContinueCjmp,ContinueInterrupt,Halt);
signal state: DecoderState:=Regular;

-- Input instruction portions

signal opcode: std_logic_vector(5 downto 0);
signal t1: std_logic;
signal t2: std_logic;
signal destination: std_logic_vector(7 downto 0);
signal rd1: std_logic_vector(7 downto 0);
signal rd2: std_logic_vector(7 downto 0);

-- Signals related to pipeline control

signal downstream_busy: std_logic;
signal self_busy: std_logic:='0';
signal busy: std_logic;
signal valid_out: std_logic:='0';

signal dst_out: std_logic_vector(7 downto 0);

-- Signals related to RD operand decoding

signal rd1_reg: std_logic_vector(7 downto 0);
signal rd2_reg: std_logic_vector(7 downto 0);

signal rd1_select: std_logic;
signal rd1_direct: std_logic_vector(31 downto 0);
signal rd2_select: std_logic;
signal rd2_direct: std_logic_vector(31 downto 0);

-- Signals related to interrupt handling

signal interrupt_ready: std_logic:='0';
signal wakeup_reg: std_logic:='0';

begin

-- Dissect input word

opcode<=word_i(31 downto 26);
t1<=word_i(25);
t2<=word_i(24);
destination<=word_i(23 downto 16);
rd1<=word_i(15 downto 8);
rd2<=word_i(7 downto 0);

-- Pipeline control

downstream_busy<=valid_out and not ready_i;
busy<=downstream_busy or self_busy;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			valid_out<='0';
			self_busy<='0';
			state<=Regular;
			interrupt_ready<='0';
			cmd_loadop3_o<='-';
			cmd_signed_o<='-';
			cmd_dbus_o<='-';
			cmd_dbus_store_o<='-';
			cmd_dbus_byte_o<='-';
			cmd_addsub_o<='-';
			cmd_negate_op2_o<='-';
			cmd_mul_o<='-';
			cmd_div_o<='-';
			cmd_div_mod_o<='-';
			cmd_cmp_o<='-';
			cmd_jump_o<='-';
			cmd_and_o<='-';
			cmd_xor_o<='-';
			cmd_shift_o<='-';
			cmd_shift_right_o<='-';
			rd1_select<='-';
			rd1_direct<=(others=>'-');
			rd2_select<='-';
			rd2_direct<=(others=>'-');
			op3_o<=(others=>'-');
			jump_type_o<=(others=>'-');
			dst_out<=(others=>'-');
			wakeup_reg<='0';
		else
			interrupt_ready<='0';
			wakeup_reg<=wakeup_reg or wakeup_i;
			if jump_valid_i='1' then
				valid_out<='0';
				self_busy<='0';
				state<=Regular;
			elsif downstream_busy='0' then
				op3_o<=(others=>'-');
				rd1_direct<=std_logic_vector(resize(signed(rd1),rd1_direct'length));
				rd2_direct<=std_logic_vector(resize(signed(rd2),rd2_direct'length));
				
				cmd_signed_o<=opcode(0);
				cmd_div_mod_o<=opcode(1);
				cmd_shift_right_o<=opcode(1);
				cmd_dbus_byte_o<=opcode(1);
				cmd_dbus_store_o<=opcode(2);
				
				case state is
				when Regular =>
					cmd_loadop3_o<='0';
					cmd_dbus_o<='0';
					cmd_addsub_o<='0';
					cmd_negate_op2_o<='0';
					cmd_mul_o<='0';
					cmd_div_o<='0';
					cmd_cmp_o<='0';
					cmd_jump_o<='0';
					cmd_and_o<='0';
					cmd_xor_o<='0';
					cmd_shift_o<='0';
					
					jump_type_o<=opcode(3 downto 0);
					
					if interrupt_valid_i='1' and valid_i='1' then
						cmd_jump_o<='1';
						cmd_loadop3_o<='1';
						op3_o<=current_ip_i&""01""; -- LSB indicates interrupt return
						dst_out<=X""FD""; -- interrupt return pointer
						rd1_select<='1';
						rd2_select<='0';
						valid_out<='1';
						interrupt_ready<='1';
						self_busy<='1';
						state<=ContinueInterrupt;
					else
						if opcode(5 downto 3)=""101"" or opcode=""000001"" then -- lc or lcs
							cmd_loadop3_o<='1';
-- Setting op3_o here only affects the lcs instruction
							op3_o<=std_logic_vector(resize(signed(opcode(2 downto 0)&
								t1&t2&rd1&rd2),op3_o'length));
						end if;
						
						if opcode(5 downto 3)=""001"" then
							cmd_dbus_o<='1';
						end if;
						
						if opcode(5 downto 1)=""01000"" then
							cmd_addsub_o<='1';
						end if;
						
						cmd_negate_op2_o<=opcode(0);
						
						if opcode=""010010"" then
							cmd_mul_o<='1';
						end if;
						
						if opcode(5 downto 2)=""0101"" then
							cmd_div_o<='1';
						end if;
						
						if opcode(5 downto 3)=""100"" then -- jump or call
							cmd_jump_o<='1';
							cmd_loadop3_o<=opcode(0);
-- Setting op3_o here only affects the call instruction
							op3_o<=next_ip_i&""00"";
						end if;
						
						-- Note: (a or b) = (a and b) or (a xor b)
						
						if opcode(5 downto 1)=""01100"" then
							cmd_and_o<='1';
						end if;
						
						if opcode=""011010"" or opcode=""011001"" then
							cmd_xor_o<='1';
						end if;
						
						if opcode(5 downto 2)=""0111"" then
							cmd_shift_o<='1';
						end if;
						
						if opcode(5 downto 4)=""11"" then
							cmd_cmp_o<='1';
							cmd_negate_op2_o<='1';
						end if;
						
						rd1_select<=t1;
						rd2_select<=t2;
						
						dst_out<=destination;
						
						if valid_i='1' then
							if opcode=""000001"" then
								valid_out<='0';
								self_busy<='0';
								state<=ContinueLc;
							elsif opcode=""000010"" then
								valid_out<='0';
								self_busy<='1';
								wakeup_reg<='0';
								state<=Halt;
							elsif opcode(5 downto 4)=""11"" then
								valid_out<='1';
								self_busy<='1';
								state<=ContinueCjmp;
							else
								valid_out<='1';
							end if;
						else
							valid_out<='0';
						end if;
					end if;
				when ContinueLc =>
					if valid_i='1' then
						valid_out<='1';
						op3_o<=word_i;
						self_busy<='0';
						state<=Regular;
					end if;
				when ContinueCjmp =>
					valid_out<='1';
					cmd_jump_o<='1';
					rd1_select<='1';
					self_busy<='0';
					state<=Regular;
				when ContinueInterrupt =>
					valid_out<='0';
				when Halt =>
					if interrupt_valid_i='1' or wakeup_i='1' or wakeup_reg='1' then
						self_busy<='0';
						state<=Regular;
					end if;
				end case;
			end if;
		end if;
	end if;
end process;

valid_o<=valid_out;
dst_o<=dst_out;

ready_o<=not busy;

interrupt_ready_o<=interrupt_ready;

-- Decode RD (register/direct) operands

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if busy='0' then
			rd1_reg<=rd1;
			rd2_reg<=rd2;
		end if;
	end if;
end process;

sp_raddr1_o<=""11110""&interrupt_vector_i when (state=Regular and interrupt_valid_i='1' and downstream_busy='0') or state=ContinueInterrupt else
	dst_out when (state=ContinueCjmp and downstream_busy='0') else
	rd1_reg when busy='1' else
	rd1;

sp_raddr2_o<=rd2_reg when busy='1' else rd2;

op1_o<=sp_rdata1_i when rd1_select='1' else rd1_direct;
op2_o<=sp_rdata2_i when rd2_select='1' else rd2_direct;

end architecture;
",62
"# VHDL Analysis for 'lxp32_divider.vhd'

## File Comments
- -------------------------------------------------------------------
- Divider
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- Based on the NRD (Non Restoring Division) algorithm. Takes
- 36 cycles to calculate quotient (37 for remainder).
- -------------------------------------------------------------------
- Complementor signals
- Divider FSM signals
- Output restoration signals
- Plus 3 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_divider

## Architecture: rtl of lxp32_divider

### Signals
- compl_inv: std_logic
- compl_mux: std_logic_vector(31 downto 0)
- compl_out: std_logic_vector(31 downto 0)
- inv_res: std_logic
- fsm_ce: std_logic:='0'
- dividend: unsigned(31 downto 0)
- divisor: unsigned(32 downto 0)
- want_remainder: std_logic
- partial_remainder: unsigned(32 downto 0)
- addend: unsigned(32 downto 0)
- sum: unsigned(32 downto 0)
- sum_positive: std_logic
- sum_subtract: std_logic
- cnt: integer range 0 to 34:=0
- ceo: std_logic:='0'
- remainder_corrector: unsigned(31 downto 0)
- remainder_corrector_1: std_logic
- remainder_pos: unsigned(31 downto 0)
- result_pos: unsigned(31 downto 0)

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements control logic
- This appears to be a CPU component

## Code Metrics
- Line count: 173
- Process count: 6
- Signal count: 19

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_divider.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Divider**

**Overview**

The LXP32 Divider is a digital component designed to perform division operations on 32-bit integers. It implements the Non-Restoring Division (NRD) algorithm and provides both quotient and remainder outputs.

**Inputs**

* `clk_i`: Clock input (1-bit)
* `rst_i`: Reset input (1-bit)
* `ce_i`: Clock enable input (1-bit)
* `op1_i`: Dividend input (32-bit)
* `op2_i`: Divisor input (32-bit)
* `signed_i`: Signed operation indicator (1-bit)
* `rem_i`: Remainder calculation indicator (1-bit)

**Outputs**

* `ce_o`: Clock enable output (1-bit)
* `result_o`: Division result output (32-bit)

**Functionality**

The LXP32 Divider performs the following operations:

1. Division: computes the quotient of `op1_i` divided by `op2_i`
2. Remainder calculation: computes the remainder of `op1_i` divided by `op2_i` (optional)

The component supports both signed and unsigned operations, as indicated by the `signed_i` input. The `rem_i` input determines whether to calculate the remainder.

**Operation Modes**

* **Signed operation**: When `signed_i` is high, the component performs signed division and remainder calculations.
* **Unsigned operation**: When `signed_i` is low, the component performs unsigned division","---------------------------------------------------------------------
-- Divider
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Based on the NRD (Non Restoring Division) algorithm. Takes
-- 36 cycles to calculate quotient (37 for remainder).
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_divider is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		signed_i: in std_logic;
		rem_i: in std_logic;
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_divider is

-- Complementor signals

signal compl_inv: std_logic;
signal compl_mux: std_logic_vector(31 downto 0);
signal compl_out: std_logic_vector(31 downto 0);

signal inv_res: std_logic;

-- Divider FSM signals

signal fsm_ce: std_logic:='0';

signal dividend: unsigned(31 downto 0);
signal divisor: unsigned(32 downto 0);
signal want_remainder: std_logic;

signal partial_remainder: unsigned(32 downto 0);
signal addend: unsigned(32 downto 0);
signal sum: unsigned(32 downto 0);
signal sum_positive: std_logic;
signal sum_subtract: std_logic;

signal cnt: integer range 0 to 34:=0;

signal ceo: std_logic:='0';

-- Output restoration signals

signal remainder_corrector: unsigned(31 downto 0);
signal remainder_corrector_1: std_logic;
signal remainder_pos: unsigned(31 downto 0);
signal result_pos: unsigned(31 downto 0);

begin

compl_inv<=op1_i(31) and signed_i when ce_i='1' else inv_res;
compl_mux<=op1_i when ce_i='1' else std_logic_vector(result_pos);

compl_op1_inst: entity work.lxp32_compl(rtl)
	port map(
		clk_i=>clk_i,
		compl_i=>compl_inv,
		d_i=>compl_mux,
		d_o=>compl_out
	);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			fsm_ce<='0';
			want_remainder<='-';
			inv_res<='-';
		else
			fsm_ce<=ce_i;
			if ce_i='1' then
				want_remainder<=rem_i;
				if rem_i='1' then
					inv_res<=op1_i(31) and signed_i;
				else
					inv_res<=(op1_i(31) xor op2_i(31)) and signed_i;
				end if;
			end if;
		end if;
	end if;
end process;

-- Main adder/subtractor

addend_gen: for i in addend'range generate
	addend(i)<=divisor(i) xor sum_subtract;
end generate;

sum<=partial_remainder+addend+(to_unsigned(0,32)&sum_subtract);
sum_positive<=not sum(32);

-- Divider state machine

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			cnt<=0;
			ceo<='0';
			divisor<=(others=>'-');
			dividend<=(others=>'-');
			partial_remainder<=(others=>'-');
			sum_subtract<='-';
		else
			if cnt=1 then
				ceo<='1';
			else
				ceo<='0';
			end if;
			
			if ce_i='1' then
				divisor(31 downto 0)<=unsigned(op2_i);
				divisor(32)<=op2_i(31) and signed_i;
			end if;
			
			if fsm_ce='1' then
				dividend<=unsigned(compl_out(30 downto 0)&""0"");
				partial_remainder<=to_unsigned(0,32)&compl_out(31);
				sum_subtract<=not divisor(32);
				if want_remainder='1' then
					cnt<=34;
				else
					cnt<=33;
				end if;
			else
				partial_remainder<=sum(31 downto 0)&dividend(31);
				sum_subtract<=sum_positive xor divisor(32);
				dividend<=dividend(30 downto 0)&sum_positive;
				if cnt>0 then
					cnt<=cnt-1;
				end if;
			end if;
		end if;
	end if;
end process;

-- Output restoration circuit

process (clk_i) is
begin
	if rising_edge(clk_i) then
		for i in remainder_corrector'range loop
			remainder_corrector(i)<=(divisor(i) xor divisor(32)) and not sum_positive;
		end loop;
		remainder_corrector_1<=divisor(32) and not sum_positive;
		remainder_pos<=partial_remainder(32 downto 1)+remainder_corrector+
			(to_unsigned(0,31)&remainder_corrector_1);
	end if;
end process;

result_pos<=remainder_pos when want_remainder='1' else dividend;

result_o<=compl_out;
ce_o<=ceo;

end architecture;
",63
"# VHDL Analysis for 'lxp32_execute.vhd'

## File Comments
- -------------------------------------------------------------------
- Execution unit
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- The third stage of the LXP32 pipeline.
- -------------------------------------------------------------------
- Pipeline control signals
- ALU signals
- OP3 loader signals
- Jump machine signals
- Plus 10 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: lxp32_execute

## Architecture: rtl of lxp32_execute

### Signals
- busy: std_logic
- can_execute: std_logic
- alu_result: std_logic_vector(31 downto 0)
- alu_we: std_logic
- alu_busy: std_logic
- alu_cmp_eq: std_logic
- alu_cmp_ug: std_logic
- alu_cmp_sg: std_logic
- loadop3_we: std_logic
- jump_condition: std_logic
- jump_valid: std_logic:='0'
- jump_dst: std_logic_vector(jump_dst_o'range)
- dbus_result: std_logic_vector(31 downto 0)
- dbus_busy: std_logic
- dbus_we: std_logic
- result_mux: std_logic_vector(31 downto 0)
- result_valid: std_logic
- result_regaddr: std_logic_vector(7 downto 0)
- dst_reg: std_logic_vector(7 downto 0)
- interrupt_return: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements arithmetic/computational functionality
- Implements control logic
- May be part of a pipeline architecture
- This appears to be a CPU component

## Code Metrics
- Line count: 261
- Process count: 4
- Signal count: 20

## Summary
- This module implements arithmetic and logic operations.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_execute.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Execute Unit**

**Overview**

The LXP32 Execute Unit is a digital circuit component responsible for executing arithmetic, logical, and memory operations within the LXP32 CPU pipeline. It serves as the third stage of the pipeline, taking in instructions and operands from the previous stages and producing results for the subsequent stages.

**Inputs**

* **clk_i**: Clock signal
* **rst_i**: Reset signal
* **cmd_loadop3_i**: Load OP3 command
* **cmd_signed_i**: Signed operation command
* **cmd_dbus_i**: DBUS access command
* **cmd_dbus_store_i**: DBUS store command
* **cmd_dbus_byte_i**: DBUS byte access command
* **cmd_addsub_i**: Add/Subtract command
* **cmd_mul_i**: Multiply command
* **cmd_div_i**: Divide command
* **cmd_div_mod_i**: Divide/Modulus command
* **cmd_cmp_i**: Compare command
* **cmd_jump_i**: Jump command
* **cmd_negate_op2_i**: Negate OP2 command
* **cmd_and_i**: AND command
* **cmd_xor_i**: XOR command
* **cmd_shift_i**: Shift command
* **cmd_shift_right_i**: Shift right command
* **jump_type_i**: Jump type (4-bit)
* **op1_i**, **op2_i**, **op3_i**: Operand inputs (32-bit)
*","---------------------------------------------------------------------
-- Execution unit
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The third stage of the LXP32 pipeline.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_execute is
	generic(
		DBUS_RMW: boolean;
		DIVIDER_EN: boolean;
		MUL_ARCH: string
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		cmd_loadop3_i: in std_logic;
		cmd_signed_i: in std_logic;
		cmd_dbus_i: in std_logic;
		cmd_dbus_store_i: in std_logic;
		cmd_dbus_byte_i: in std_logic;
		cmd_addsub_i: in std_logic;
		cmd_mul_i: in std_logic;
		cmd_div_i: in std_logic;
		cmd_div_mod_i: in std_logic;
		cmd_cmp_i: in std_logic;
		cmd_jump_i: in std_logic;
		cmd_negate_op2_i: in std_logic;
		cmd_and_i: in std_logic;
		cmd_xor_i: in std_logic;
		cmd_shift_i: in std_logic;
		cmd_shift_right_i: in std_logic;
		
		jump_type_i: in std_logic_vector(3 downto 0);
		
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		op3_i: in std_logic_vector(31 downto 0);
		dst_i: in std_logic_vector(7 downto 0);
		
		sp_waddr_o: out std_logic_vector(7 downto 0);
		sp_we_o: out std_logic;
		sp_wdata_o: out std_logic_vector(31 downto 0);
		
		valid_i: in std_logic;
		ready_o: out std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		jump_valid_o: out std_logic;
		jump_dst_o: out std_logic_vector(29 downto 0);
		jump_ready_i: in std_logic;
		
		interrupt_return_o: out std_logic
	);
end entity;

architecture rtl of lxp32_execute is

-- Pipeline control signals

signal busy: std_logic;
signal can_execute: std_logic;

-- ALU signals

signal alu_result: std_logic_vector(31 downto 0);
signal alu_we: std_logic;
signal alu_busy: std_logic;

signal alu_cmp_eq: std_logic;
signal alu_cmp_ug: std_logic;
signal alu_cmp_sg: std_logic;

-- OP3 loader signals

signal loadop3_we: std_logic;

-- Jump machine signals

signal jump_condition: std_logic;
signal jump_valid: std_logic:='0';
signal jump_dst: std_logic_vector(jump_dst_o'range);

-- DBUS signals

signal dbus_result: std_logic_vector(31 downto 0);
signal dbus_busy: std_logic;
signal dbus_we: std_logic;

-- Result mux signals

signal result_mux: std_logic_vector(31 downto 0);
signal result_valid: std_logic;
signal result_regaddr: std_logic_vector(7 downto 0);

signal dst_reg: std_logic_vector(7 downto 0);

-- Signals related to interrupt handling

signal interrupt_return: std_logic:='0';

begin

-- Pipeline control

busy<=alu_busy or dbus_busy;
ready_o<=not busy;
can_execute<=valid_i and not busy;

-- ALU

alu_inst: entity work.lxp32_alu(rtl)
	generic map(
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		valid_i=>can_execute,
		
		cmd_signed_i=>cmd_signed_i,
		cmd_addsub_i=>cmd_addsub_i,
		cmd_mul_i=>cmd_mul_i,
		cmd_div_i=>cmd_div_i,
		cmd_div_mod_i=>cmd_div_mod_i,
		cmd_cmp_i=>cmd_cmp_i,
		cmd_negate_op2_i=>cmd_negate_op2_i,
		cmd_and_i=>cmd_and_i,
		cmd_xor_i=>cmd_xor_i,
		cmd_shift_i=>cmd_shift_i,
		cmd_shift_right_i=>cmd_shift_right_i,
		
		op1_i=>op1_i,
		op2_i=>op2_i,
		
		result_o=>alu_result,
		
		cmp_eq_o=>alu_cmp_eq,
		cmp_ug_o=>alu_cmp_ug,
		cmp_sg_o=>alu_cmp_sg,
		
		we_o=>alu_we,
		busy_o=>alu_busy
	);

-- OP3 loader

loadop3_we<=can_execute and cmd_loadop3_i;

-- Jump logic

jump_condition<=(not cmd_cmp_i) or (jump_type_i(3) and alu_cmp_eq) or
	(jump_type_i(2) and not alu_cmp_eq) or (jump_type_i(1) and alu_cmp_ug) or
	(jump_type_i(0) and alu_cmp_sg);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			jump_valid<='0';
			interrupt_return<='0';
			jump_dst<=(others=>'-');
		else
			if jump_valid='0' then
				jump_dst<=op1_i(31 downto 2);
				if can_execute='1' and cmd_jump_i='1' and jump_condition='1' then
					jump_valid<='1';
					interrupt_return<=op1_i(0);
				end if;
			elsif jump_ready_i='1' then
				jump_valid<='0';
				interrupt_return<='0';
			end if;
		end if;
	end if;
end process;

jump_valid_o<=jump_valid or (can_execute and cmd_jump_i and jump_condition);
jump_dst_o<=jump_dst when jump_valid='1' else op1_i(31 downto 2);

interrupt_return_o<=interrupt_return;

-- DBUS access

dbus_inst: entity work.lxp32_dbus(rtl)
	generic map(
		RMW=>DBUS_RMW
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		valid_i=>can_execute,
		
		cmd_dbus_i=>cmd_dbus_i,
		cmd_dbus_store_i=>cmd_dbus_store_i,
		cmd_dbus_byte_i=>cmd_dbus_byte_i,
		cmd_signed_i=>cmd_signed_i,
		addr_i=>op1_i,
		wdata_i=>op2_i,
		
		rdata_o=>dbus_result,
		busy_o=>dbus_busy,
		we_o=>dbus_we,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i
	);

-- Result multiplexer

result_mux_gen: for i in result_mux'range generate
	result_mux(i)<=(alu_result(i) and alu_we) or
		(op3_i(i) and loadop3_we) or
		(dbus_result(i) and dbus_we);
end generate;

result_valid<=alu_we or loadop3_we or dbus_we;

-- Write destination register

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if can_execute='1' then
			dst_reg<=dst_i;
		end if;
	end if;
end process;

result_regaddr<=dst_i when can_execute='1' else dst_reg;

sp_we_o<=result_valid;
sp_waddr_o<=result_regaddr;
sp_wdata_o<=result_mux;

end architecture;
",64
"# VHDL Analysis for 'lxp32_fetch.vhd'

## File Comments
- -------------------------------------------------------------------
- Instruction fetch
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- The first stage of the LXP32 pipeline.
- -------------------------------------------------------------------
- INIT state machine (to initialize all registers)
- All CPU registers are expected to be zero-initialized after reset.
- Since these registers are implemented as a RAM block, we perform
- the initialization sequentially by generating ""mov rN, 0"" instructions
- Plus 30 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all
- Use: when either the decoder or the IBUS
-- stalls, the fetch_addr counter will also stop incrementing.
				next_ip<=fetch_addr

## Entity: lxp32_fetch

## Architecture: rtl of lxp32_fetch

### Signals
- init: std_logic:='1'
- init_cnt: unsigned(7 downto 0):=(others=>'0')
- fetch_addr: std_logic_vector(29 downto 0):=START_ADDR(31 downto 2)
- next_word: std_logic
- suppress_re: std_logic:='0'
- re: std_logic
- requested: std_logic:='0'
- fifo_rst: std_logic
- fifo_we: std_logic
- fifo_din: std_logic_vector(31 downto 0)
- fifo_re: std_logic
- fifo_dout: std_logic_vector(31 downto 0)
- fifo_empty: std_logic
- fifo_full: std_logic
- jr: std_logic:='0'
- next_ip: std_logic_vector(fetch_addr'range)
- current_ip: std_logic_vector(fetch_addr'range)
- is asserted.

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			init<='0';
			init_cnt<=(others=>'0');
		else
			if init='0' and ready_i='1' then
				init_cnt<=init_cnt+1;
				if init_cnt=X""FF"" then
					init<='1';
				end if;
			end if;
		end if;
	end if;
end process;

-- FETCH state machine

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			fetch_addr<=START_ADDR(31 downto 2);
			requested<='0';
			jr<='0';
			suppress_re<='0';
			next_ip<=(others=>'-');
		else
			jr<='0';
-- Suppress LLI request if jump signal is active but will not be processed
-- in this cycle. Helps to reduce jump latency with high-latency LLI slaves.
-- Note: gating ""re"" with ""jump_valid_i and not jr"" asynchronously would
-- reduce jump latency even more, but we really want to avoid too large
-- clock-to-out on LLI outputs.
			suppress_re<=jump_valid_i and not jr and not next_word

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Contains 1 clock domain(s): clock
- Uses reset signal(s): first, reset, fifo_rst, rst_i
- Implements memory functionality
- Implements control logic
- May be part of a pipeline architecture
- This appears to be a CPU component
- Implements instruction decoding functionality
- Implements instruction fetching functionality
- Defines custom procedures: described, calls

## Code Metrics
- Line count: 227
- Process count: 6
- Signal count: 18

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_fetch.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: Instruction Fetch Unit (IFU) for LXP32 CPU**

**Overview**

The Instruction Fetch Unit (IFU) is the first stage of the LXP32 CPU pipeline, responsible for fetching instructions from memory. It takes in clock, reset, and memory interface signals, and produces instruction data, current and next instruction pointers, and control signals.

**Inputs**

* `clk_i`: Clock input
* `rst_i`: Reset input
* `lli_re_o`: Low-Level Interface (LLI) request output (generated internally)
* `lli_adr_o`: LLI address output (generated internally)
* `lli_dat_i`: LLI data input
* `lli_busy_i`: LLI busy input
* `ready_i`: Ready input from downstream pipeline stages
* `jump_valid_i`: Jump valid input
* `jump_dst_i`: Jump destination input

**Outputs**

* `word_o`: Instruction data output
* `current_ip_o`: Current instruction pointer output
* `next_ip_o`: Next instruction pointer output
* `valid_o`: Instruction validity output
* `jump_ready_o`: Jump ready output

**Functionality**

The IFU performs the following functions:

1. **Initialization**: Upon reset, the IFU initializes all internal registers by generating ""mov rN,0"" instructions for each N from 0 to 255.
2. **Instruction Fetch**: The IFU fetches instructions from memory using the LLI","---------------------------------------------------------------------
-- Instruction fetch
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The first stage of the LXP32 pipeline.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_fetch is
	generic(
		START_ADDR: std_logic_vector(31 downto 0)
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic;
		
		word_o: out std_logic_vector(31 downto 0);
		current_ip_o: out std_logic_vector(29 downto 0);
		next_ip_o: out std_logic_vector(29 downto 0);
		valid_o: out std_logic;
		ready_i: in std_logic;
		
		jump_valid_i: in std_logic;
		jump_dst_i: in std_logic_vector(29 downto 0);
		jump_ready_o: out std_logic
	);
end entity;

architecture rtl of lxp32_fetch is

signal init: std_logic:='1';
signal init_cnt: unsigned(7 downto 0):=(others=>'0');

signal fetch_addr: std_logic_vector(29 downto 0):=START_ADDR(31 downto 2);

signal next_word: std_logic;
signal suppress_re: std_logic:='0';
signal re: std_logic;
signal requested: std_logic:='0';

signal fifo_rst: std_logic;
signal fifo_we: std_logic;
signal fifo_din: std_logic_vector(31 downto 0);
signal fifo_re: std_logic;
signal fifo_dout: std_logic_vector(31 downto 0);
signal fifo_empty: std_logic;
signal fifo_full: std_logic;

signal jr: std_logic:='0';

signal next_ip: std_logic_vector(fetch_addr'range);
signal current_ip: std_logic_vector(fetch_addr'range);

begin

-- INIT state machine (to initialize all registers)

-- All CPU registers are expected to be zero-initialized after reset.
-- Since these registers are implemented as a RAM block, we perform
-- the initialization sequentially by generating ""mov rN, 0"" instructions
-- for each N from 0 to 255.
--
-- With SRAM-based FPGAs, flip-flops and RAM blocks have deterministic
-- state after configuration. On these technologies the CPU can operate
-- without reset and the initialization procedure described above is not
-- needed. However, the initialization is still performed as usual when
-- external reset signal is asserted.

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			init<='0';
			init_cnt<=(others=>'0');
		else
			if init='0' and ready_i='1' then
				init_cnt<=init_cnt+1;
				if init_cnt=X""FF"" then
					init<='1';
				end if;
			end if;
		end if;
	end if;
end process;

-- FETCH state machine

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			fetch_addr<=START_ADDR(31 downto 2);
			requested<='0';
			jr<='0';
			suppress_re<='0';
			next_ip<=(others=>'-');
		else
			jr<='0';
-- Suppress LLI request if jump signal is active but will not be processed
-- in this cycle. Helps to reduce jump latency with high-latency LLI slaves.
-- Note: gating ""re"" with ""jump_valid_i and not jr"" asynchronously would
-- reduce jump latency even more, but we really want to avoid too large
-- clock-to-out on LLI outputs.
			suppress_re<=jump_valid_i and not jr and not next_word;
			if lli_busy_i='0' then
				requested<=re and not (jump_valid_i and not jr);
			end if;
			if next_word='1' then
-- It's not immediately obvious why, but current_ip and next_ip will contain
-- the addresses of the current instruction and the next instruction to be
-- fetched, respectively, by the time the instruction is passed to the decode
-- stage. Basically, this is because when either the decoder or the IBUS
-- stalls, the fetch_addr counter will also stop incrementing.
				next_ip<=fetch_addr;
				current_ip<=next_ip;
				if jump_valid_i='1' and jr='0' then
					fetch_addr<=jump_dst_i;
					jr<='1';
				else
					fetch_addr<=std_logic_vector(unsigned(fetch_addr)+1);
				end if;
			end if;
		end if;
	end if;
end process;

next_word<=(fifo_empty or ready_i) and not lli_busy_i and init;
re<=(fifo_empty or ready_i) and init and not suppress_re;
lli_re_o<=re;
lli_adr_o<=fetch_addr;

jump_ready_o<=jr;

-- Small instruction buffer

fifo_rst<=rst_i or (jump_valid_i and not jr);
fifo_we<=requested and not lli_busy_i;
fifo_din<=lli_dat_i;
fifo_re<=ready_i and not fifo_empty;

ubuf_inst: entity work.lxp32_ubuf(rtl)
	generic map(
		DATA_WIDTH=>32
	)
	port map(
		clk_i=>clk_i,
		rst_i=>fifo_rst,
		
		we_i=>fifo_we,
		d_i=>fifo_din,
		re_i=>fifo_re,
		d_o=>fifo_dout,
		
		empty_o=>fifo_empty,
		full_o=>fifo_full
	);

next_ip_o<=next_ip;
current_ip_o<=current_ip;
word_o<=fifo_dout when init='1' else X""40""&std_logic_vector(init_cnt)&X""0000"";
valid_o<=not fifo_empty or not init;

-- Note: the following code contains a few simulation-only assertions
-- to check that current_ip and next_ip signals, used in procedure calls
-- and interrupts, are correct. 
-- This code should be ignored by a synthesizer since it doesn't drive
-- any signals, but we also surround it by metacomments, just in case.

-- synthesis translate_off

process (clk_i) is
	type Pair is record
		addr: std_logic_vector(fetch_addr'range);
		data: std_logic_vector(31 downto 0);
	end record;
	type Pairs is array (7 downto 0) of Pair;
	variable buf: Pairs;
	variable count: integer range buf'range:=0;
	variable current_pair: Pair;
begin
	if rising_edge(clk_i) then
		if fifo_rst='1' then -- jump
			count:=0;
		elsif fifo_we='1' then -- LLI returned data
			current_pair.data:=fifo_din;
			buf(count):=current_pair;
			count:=count+1;
		end if;
		if re='1' and lli_busy_i='0' then -- data requested
			current_pair.addr:=fetch_addr;
		end if;
		if fifo_empty='0' and fifo_rst='0' then -- fetch output is valid
			assert count>0
				report ""Fetch: buffer should be empty""
				severity failure;
			assert buf(0).data=fifo_dout
				report ""Fetch: incorrect data""
				severity failure;
			assert buf(0).addr=current_ip
				report ""Fetch: incorrect current_ip""
				severity failure;
			assert std_logic_vector(unsigned(buf(0).addr)+1)=next_ip
				report ""Fetch: incorrect next_ip""
				severity failure;
			if ready_i='1' then
				buf(buf'high-1 downto 0):=buf(buf'high downto 1); -- we don't care about the highest item
				count:=count-1;
			end if;
		end if;
	end if;
end process;

-- synthesis translate_on

end architecture;
",65
"# VHDL Analysis for 'lxp32_icache.vhd'

## File Comments
- -------------------------------------------------------------------
- Instruction cache
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- A simple single-page buffer providing both caching and
- prefetching capabilities. Useful for high-latency memory,
- such as external SDRAM.
- -------------------------------------------------------------------
- Note: the following five signals are zero-initialized for
- simulation only, to suppress warnings from numeric_std.
- Plus 16 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_icache

## Architecture: rtl of lxp32_icache

### Signals
- lli_adr_reg: std_logic_vector(lli_adr_i'range)
- lli_adr_mux: std_logic_vector(lli_adr_i'range)
- ram_waddr: std_logic_vector(7 downto 0)
- ram_raddr: std_logic_vector(7 downto 0)
- ram_re: std_logic
- ram_we: std_logic
- read_base: unsigned(21 downto 0)
- read_offset: unsigned(7 downto 0)
- init: std_logic:='0'
- burst1: std_logic
- terminate_burst: std_logic
- near_miss: std_logic:='0'
- prefetch_distance: unsigned(7 downto 0)
- wrap_cnt: integer range 0 to 3:=0
- burst_cnt: integer range 0 to BURST_SIZE:=0
- wb_stb: std_logic:='0'
- wb_cti: std_logic_vector(2 downto 0)
- current_base: unsigned(21 downto 0):=(others=>'0')
- current_offset: unsigned(7 downto 0):=(others=>'0')
- prev_base: unsigned(21 downto 0):=(others=>'0')
- next_base: unsigned(21 downto 0):=(others=>'0')
- start_offset: unsigned(7 downto 0):=(others=>'0')
- hitc: std_logic
- hitp: std_logic
- miss: std_logic:='0'
- is detected

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			init<='0';
		elsif lli_re_i='1' then
			init<='1';
		end if;
	end if;
end process;

-- Fill cache

prefetch_distance<=current_offset-read_offset;

-- Note: ""near_miss"" signal prevents cache invalidation when difference
-- between the requested address and the currently fetched address 
-- is too small (and, therefore, the requested data will be fetched soon
-- without invalidation).

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			near_miss<='0'

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): burst_cnt, first, terminate_burst, burst1, BURST_SIZE, rst_i
- Implements memory functionality
- This appears to be a CPU component

## Code Metrics
- Line count: 290
- Process count: 10
- Signal count: 26

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_icache.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Instruction Cache (lxp32_icache)**

**Overview**

The LXP32 Instruction Cache (lxp32_icache) is a single-page buffer designed to provide caching and prefetching capabilities for high-latency memory, such as external SDRAM. This component is part of the LXP32 CPU.

**Functionality**

The lxp32_icache acts as a cache layer between the CPU and external memory, reducing the number of memory accesses and improving system performance. It implements a simple ring buffer cache with a single page, using a Least Recently Used (LRU) replacement policy.

**Inputs**

* `clk_i`: Clock input
* `rst_i`: Reset input
* `lli_re_i`: Read enable input
* `lli_adr_i`: Address input (29 bits)

**Outputs**

* `lli_dat_o`: Data output (32 bits)
* `lli_busy_o`: Busy output (indicates cache miss)
* `wbm_cyc_o`: Wishbone cycle output
* `wbm_stb_o`: Wishbone strobe output
* `wbm_cti_o`: Wishbone cycle type output (3 bits)
* `wbm_bte_o`: Wishbone burst type output (2 bits)
* `wbm_adr_o`: Wishbone address output (29 bits)

**Parameters**

* `BURST_SIZE`: Burst size parameter (integer, minimum 4)
* `PREFETCH","---------------------------------------------------------------------
-- Instruction cache
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A simple single-page buffer providing both caching and
-- prefetching capabilities. Useful for high-latency memory,
-- such as external SDRAM.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_icache is
	generic(
		BURST_SIZE: integer;
		PREFETCH_SIZE: integer
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_i: in std_logic;
		lli_adr_i: in std_logic_vector(29 downto 0);
		lli_dat_o: out std_logic_vector(31 downto 0);
		lli_busy_o: out std_logic;
		
		wbm_cyc_o: out std_logic;
		wbm_stb_o: out std_logic;
		wbm_cti_o: out std_logic_vector(2 downto 0);
		wbm_bte_o: out std_logic_vector(1 downto 0);
		wbm_ack_i: in std_logic;
		wbm_adr_o: out std_logic_vector(29 downto 0);
		wbm_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_icache is

signal lli_adr_reg: std_logic_vector(lli_adr_i'range);
signal lli_adr_mux: std_logic_vector(lli_adr_i'range);

signal ram_waddr: std_logic_vector(7 downto 0);
signal ram_raddr: std_logic_vector(7 downto 0);
signal ram_re: std_logic;
signal ram_we: std_logic;

signal read_base: unsigned(21 downto 0);
signal read_offset: unsigned(7 downto 0);

signal init: std_logic:='0';
signal burst1: std_logic;
signal terminate_burst: std_logic;
signal near_miss: std_logic:='0';
signal prefetch_distance: unsigned(7 downto 0);
signal wrap_cnt: integer range 0 to 3:=0;
signal burst_cnt: integer range 0 to BURST_SIZE:=0;
signal wb_stb: std_logic:='0';
signal wb_cti: std_logic_vector(2 downto 0);

-- Note: the following five signals are zero-initialized for
-- simulation only, to suppress warnings from numeric_std.
-- This initialization is not required for synthesis.

signal current_base: unsigned(21 downto 0):=(others=>'0');
signal current_offset: unsigned(7 downto 0):=(others=>'0');
signal prev_base: unsigned(21 downto 0):=(others=>'0');
signal next_base: unsigned(21 downto 0):=(others=>'0');
signal start_offset: unsigned(7 downto 0):=(others=>'0');

signal hitc: std_logic;
signal hitp: std_logic;
signal miss: std_logic:='0';

begin

assert PREFETCH_SIZE>=4
	report ""PREFETCH_SIZE cannot be less than 4""
	severity failure;
assert BURST_SIZE>=4
	report ""BURST_SIZE cannot be less than 4""
	severity failure;
assert PREFETCH_SIZE+BURST_SIZE<=128
	report ""PREFETCH_SIZE and BURST_SIZE combined cannot be greater than 128""
	severity failure;


process (clk_i) is
begin
	if rising_edge(clk_i) then
		if miss='0' then
			lli_adr_reg<=lli_adr_i;
		end if;
	end if;
end process;

lli_adr_mux<=lli_adr_i when miss='0' else lli_adr_reg;

read_base<=unsigned(lli_adr_mux(29 downto 8));
read_offset<=unsigned(lli_adr_mux(7 downto 0));

-- Cache RAM

ram_waddr<=std_logic_vector(current_offset);
ram_raddr<=std_logic_vector(read_offset);
ram_we<=wb_stb and wbm_ack_i;
ram_re<=lli_re_i or miss;

ram_inst: entity work.lxp32_ram256x32(rtl)
	port map(
		clk_i=>clk_i,
		
		we_i=>ram_we,
		waddr_i=>ram_waddr,
		wdata_i=>wbm_dat_i,
		
		re_i=>ram_re,
		raddr_i=>ram_raddr,
		rdata_o=>lli_dat_o
	);

-- Determine hit/miss

-- This cache uses a single ring buffer. Address in buffer corresponds
-- to the lower 8 bits of the full address. The part of the buffer that
-- is higher than current_offset represents a previous block (""p""), the
-- other part represents a current block (""c"").

hitc<='1' when read_base=current_base and read_offset<current_offset and
	((wrap_cnt=1 and read_offset>=start_offset) or
	wrap_cnt=2 or wrap_cnt=3) else '0';

hitp<='1' when read_base=prev_base and read_offset>current_offset and
	((wrap_cnt=2 and read_offset>=start_offset) or
	wrap_cnt=3) else '0';

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			miss<='0';
		else
			if hitc='0' and hitp='0' and ram_re='1' then
				miss<='1';
			else
				miss<='0';
			end if;
		end if;
	end if;
end process;

lli_busy_o<=miss;

-- Set INIT flag when the first lli_re_i signal is detected

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			init<='0';
		elsif lli_re_i='1' then
			init<='1';
		end if;
	end if;
end process;

-- Fill cache

prefetch_distance<=current_offset-read_offset;

-- Note: ""near_miss"" signal prevents cache invalidation when difference
-- between the requested address and the currently fetched address 
-- is too small (and, therefore, the requested data will be fetched soon
-- without invalidation).

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			near_miss<='0';
		elsif wrap_cnt>0 and read_offset-current_offset<=to_unsigned(BURST_SIZE/2,8) and
			((read_base=current_base and read_offset>=current_offset) or
			(read_base=next_base and read_offset<current_offset))
		then
			near_miss<='1';
		else
			near_miss<='0';
		end if;
	end if;
end process;

terminate_burst<='1' when burst_cnt<BURST_SIZE-1 and miss='1' and
	(burst_cnt>2 or burst1='0') and near_miss='0' else '0';

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			burst_cnt<=0;
			wb_stb<='0';
			wrap_cnt<=0;
			wb_cti<=(others=>'-');
			burst1<='-';
			current_offset<=(others=>'-');
			start_offset<=(others=>'-');
			current_base<=(others=>'-');
			next_base<=(others=>'-');
			prev_base<=(others=>'-');
			
			-- To suppress numeric_std warnings
			-- synthesis translate_off
			current_offset<=(others=>'0');
			start_offset<=(others=>'0');
			current_base<=(others=>'0');
			next_base<=(others=>'0');
			prev_base<=(others=>'0');
			-- synthesis translate_on
		else
			if burst_cnt=0 and init='1' then
				if miss='1' and near_miss='0' then
					wb_stb<='1';
					wb_cti<=""010"";
					current_offset<=read_offset;
					start_offset<=read_offset;
					current_base<=read_base;
					next_base<=read_base+1;
					burst_cnt<=1;
					burst1<='1';
					wrap_cnt<=1;
				elsif prefetch_distance<to_unsigned(PREFETCH_SIZE,8) or near_miss='1' then
					wb_stb<='1';
					wb_cti<=""010"";
					burst_cnt<=1;
					burst1<='0';
				end if;
			else
				if wbm_ack_i='1' then
					current_offset<=current_offset+1;
					if current_offset=X""FF"" then
						current_base<=next_base;
						next_base<=next_base+1;
						prev_base<=current_base;
						if wrap_cnt<3 then
							wrap_cnt<=wrap_cnt+1;
						end if;
					end if;
					if burst_cnt=BURST_SIZE-1 or terminate_burst='1' then
						burst_cnt<=BURST_SIZE;
						wb_cti<=""111"";
					elsif burst_cnt<BURST_SIZE-1 then
						burst_cnt<=burst_cnt+1;
						wb_cti<=""010"";
					else
						if miss='1' and near_miss='0' then
							wb_stb<='1';
							wb_cti<=""010"";
							current_offset<=read_offset;
							start_offset<=read_offset;
							current_base<=read_base;
							next_base<=read_base+1;
							burst_cnt<=1;
							burst1<='1';
							wrap_cnt<=1;
						elsif prefetch_distance<to_unsigned(PREFETCH_SIZE,8) or near_miss='1' then
							wb_stb<='1';
							wb_cti<=""010"";
							burst_cnt<=1;
							burst1<='0';
						else
							burst_cnt<=0;
							wb_stb<='0';
						end if;
					end if;
				end if;
			end if;
		end if;
	end if;
end process;

wbm_cyc_o<=wb_stb;
wbm_stb_o<=wb_stb;
wbm_cti_o<=wb_cti;
wbm_bte_o<=""00"";
wbm_adr_o<=std_logic_vector(current_base&current_offset);

end architecture;
",66
"# VHDL Analysis for 'lxp32_interrupt_mux.vhd'

## File Comments
- -------------------------------------------------------------------
- Interrupt multiplexer
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- Manages LXP32 interrupts. Interrupts with lower numbers have
- higher priority.
- -------------------------------------------------------------------
- Note: ""disabled"" interrupts (i.e. for which interrupts_enabled_i(i)='0')
- are ignored completely, meaning that the interrupt handler won't be
- called even if the interrupt is enabled later.
- Plus 3 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_interrupt_mux

## Architecture: rtl of lxp32_interrupt_mux

### Signals
- irq: std_logic_vector(irq_i'range)
- irq_reg: std_logic_vector(irq_i'range):=(others=>'0')
- state: state_type:=Ready
- pending_interrupts: std_logic_vector(irq_i'range):=(others=>'0')
- interrupt_valid: std_logic:='0'
- interrupts_enabled: std_logic_vector(7 downto 0):=(others=>'0')
- interrupts_wakeup: std_logic_vector(7 downto 0):=(others=>'0')
- interrupts_level: std_logic_vector(7 downto 0):=(others=>'0')
- interrupts_invert: std_logic_vector(7 downto 0):=(others=>'0')

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- This appears to be a Finite State Machine implementation
- Uses reset signal(s): rst_i
- Implements control logic
- This appears to be a CPU component

## Code Metrics
- Line count: 140
- Process count: 4
- Signal count: 9

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_interrupt_mux.vhd' plays a specific role in the overall CPU architecture.
","**Component Name:** LXP32 Interrupt Multiplexer

**Description:** The LXP32 Interrupt Multiplexer is a digital component responsible for managing interrupts in the LXP32 CPU. It prioritizes and handles interrupts, ensuring that the CPU responds to interrupt requests in a timely and efficient manner.

**Functionality:**

* The component receives interrupt requests (IRQs) from various sources and prioritizes them based on their interrupt numbers, with lower numbers having higher priority.
* It manages the interrupt handling process, including:
	+ Detecting and registering pending interrupts
	+ Generating an interrupt vector to indicate the source of the interrupt
	+ Asserting an interrupt valid signal to notify the CPU of an interrupt request
	+ Handling interrupt return and wake-up signals
* The component also provides a wake-up signal to the CPU when an interrupt is triggered.

**Inputs:**

* `clk_i`: Clock input
* `rst_i`: Reset input
* `irq_i`: Interrupt request input (8-bit vector)
* `interrupt_ready_i`: Interrupt ready input from the CPU
* `interrupt_return_i`: Interrupt return input from the CPU
* `sp_waddr_i`: Write address input for interrupt configuration registers
* `sp_we_i`: Write enable input for interrupt configuration registers
* `sp_wdata_i`: Write data input for interrupt configuration registers (32-bit vector)

**Outputs:**

* `interrupt_valid_o`: Interrupt valid output to the CPU
* `interrupt_vector_o`: Interrupt vector","---------------------------------------------------------------------
-- Interrupt multiplexer
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Manages LXP32 interrupts. Interrupts with lower numbers have
-- higher priority.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_interrupt_mux is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		irq_i: in std_logic_vector(7 downto 0);
		
		interrupt_valid_o: out std_logic;
		interrupt_vector_o: out std_logic_vector(2 downto 0);
		interrupt_ready_i: in std_logic;
		interrupt_return_i: in std_logic;

		wakeup_o: out std_logic;
		
		sp_waddr_i: in std_logic_vector(7 downto 0);
		sp_we_i: in std_logic;
		sp_wdata_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_interrupt_mux is

signal irq: std_logic_vector(irq_i'range);
signal irq_reg: std_logic_vector(irq_i'range):=(others=>'0');

type state_type is (Ready,Requested,WaitForExit);
signal state: state_type:=Ready;

signal pending_interrupts: std_logic_vector(irq_i'range):=(others=>'0');

signal interrupt_valid: std_logic:='0';

signal interrupts_enabled: std_logic_vector(7 downto 0):=(others=>'0');
signal interrupts_wakeup: std_logic_vector(7 downto 0):=(others=>'0');
signal interrupts_level: std_logic_vector(7 downto 0):=(others=>'0');
signal interrupts_invert: std_logic_vector(7 downto 0):=(others=>'0');

begin

irq<=irq_i xor interrupts_invert;

-- Note: ""disabled"" interrupts (i.e. for which interrupts_enabled_i(i)='0')
-- are ignored completely, meaning that the interrupt handler won't be
-- called even if the interrupt is enabled later.

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			irq_reg<=(others=>'0');
			pending_interrupts<=(others=>'0');
			state<=Ready;
			interrupt_valid<='0';
			interrupt_vector_o<=(others=>'-');
			wakeup_o<='0';
		else
			irq_reg<=irq;
			
			pending_interrupts<=(pending_interrupts or 
				(irq and not irq_reg)) and not interrupts_level and
				interrupts_enabled and not interrupts_wakeup;
			
			case state is
			when Ready =>
				for i in irq'reverse_range loop -- lower interrupts have priority
					if (interrupts_level(i)='0' and pending_interrupts(i)='1') or
							(interrupts_level(i)='1' and irq(i)='1' and
							interrupts_enabled(i)='1' and interrupts_wakeup(i)='0') then
						pending_interrupts(i)<='0';
						interrupt_valid<='1';
						interrupt_vector_o<=std_logic_vector(to_unsigned(i,3));
						state<=Requested;
						exit;
					end if;
				end loop;
			when Requested =>
				if interrupt_ready_i='1' then
					interrupt_valid<='0';
					state<=WaitForExit;
				end if;
			when WaitForExit =>
				if interrupt_return_i='1' then
					state<=Ready;
				end if;
			end case;

			wakeup_o<='0';
			for i in irq'range loop
				if interrupts_enabled(i)='1' and interrupts_wakeup(i)='1' then
					if interrupts_level(i)='0' then -- edge triggered
						if irq(i)='1' and irq_reg(i)='0' then
							wakeup_o<='1';
						end if;
					else -- level triggered
						if irq(i)='1' then
							wakeup_o<='1';
						end if;
					end if;
				end if;
			end loop;
		end if;
	end if;
end process;

interrupt_valid_o<=interrupt_valid;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			interrupts_enabled<=(others=>'0');
			interrupts_wakeup<=(others=>'0');
			interrupts_level<=(others=>'0');
			interrupts_invert<=(others=>'0');
		elsif sp_we_i='1' and sp_waddr_i=X""FC"" then
			interrupts_enabled<=sp_wdata_i(7 downto 0);
			interrupts_wakeup<=sp_wdata_i(15 downto 8);
			interrupts_level<=sp_wdata_i(23 downto 16);
			interrupts_invert<=sp_wdata_i(31 downto 24);
		end if;
	end if;
end process;

end architecture;
",67
"# VHDL Analysis for 'lxp32_mul16x16.vhd'

## File Comments
- -------------------------------------------------------------------
- A basic parallel 16x16 multiplier with an output register
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- A straightforward behavioral description. Can be replaced
- with a library component wrapper if needed.
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_mul16x16

## Architecture: rtl of lxp32_mul16x16

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- This appears to be a CPU component

## Code Metrics
- Line count: 37
- Process count: 2
- Signal count: 0

## Summary
- This module implements register or flip-flop functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_mul16x16.vhd' plays a specific role in the overall CPU architecture.
","Here is a concise technical description of the VHDL component:

The `lxp32_mul16x16` component is a 16x16 parallel multiplier with a registered output, designed to perform unsigned multiplication of two 16-bit inputs and produce a 32-bit output. The component takes in two 16-bit inputs `a_i` and `b_i`, a clock signal `clk_i`, and produces a 32-bit output `p_o`. The output is registered on the rising edge of the clock signal.

And here is a detailed component specification:

**Component Name:** `lxp32_mul16x16`

**Functionality:** 16x16 parallel multiplier with output register

**Inputs:**

* `clk_i`: Clock signal (1-bit)
* `a_i`: 16-bit unsigned multiplier input
* `b_i`: 16-bit unsigned multiplier input

**Outputs:**

* `p_o`: 32-bit unsigned product output

**Description:** The `lxp32_mul16x16` component performs unsigned multiplication of two 16-bit inputs `a_i` and `b_i` on the rising edge of the clock signal `clk_i`. The product is registered and output on `p_o` as a 32-bit unsigned value.

**Specifications:**

* Multiplication type: Unsigned
* Input width: 16 bits
* Output width: 32 bits
* Clocking: Rising edge-triggered
* Output registration: Registered output

**Notes:**

*","---------------------------------------------------------------------
-- A basic parallel 16x16 multiplier with an output register
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A straightforward behavioral description. Can be replaced
-- with a library component wrapper if needed.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul16x16 is
	port(
		clk_i: in std_logic;
		a_i: in std_logic_vector(15 downto 0);
		b_i: in std_logic_vector(15 downto 0);
		p_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul16x16 is

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		p_o<=std_logic_vector(unsigned(a_i)*unsigned(b_i));
	end if;
end process;

end architecture;
",68
"# VHDL Analysis for 'lxp32_mul_dsp.vhd'

## File Comments
- -------------------------------------------------------------------
- DSP multiplier
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- This multiplier is designed for technologies that provide fast
- 16x16 multipliers, including most modern FPGA families. One
- multiplication takes 2 cycles.
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_mul_dsp

## Architecture: rtl of lxp32_mul_dsp

### Signals
- pp00: std_logic_vector(31 downto 0)
- pp01: std_logic_vector(31 downto 0)
- pp10: std_logic_vector(31 downto 0)
- product: unsigned(31 downto 0)
- ceo: std_logic:='0'

### Component Instantiations
- Instance 'mul00_inst' of component 'lxp32_mul16x16'
- Instance 'mul01_inst' of component 'lxp32_mul16x16'
- Instance 'mul10_inst' of component 'lxp32_mul16x16'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- This appears to be a CPU component

## Code Metrics
- Line count: 83
- Process count: 2
- Signal count: 5

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_mul_dsp.vhd' plays a specific role in the overall CPU architecture.
","### Technical Description

The `lxp32_mul_dsp` component is a 32-bit digital multiplier designed for implementation on modern FPGA families that provide fast 16x16 multipliers. It takes two 32-bit operands (`op1_i` and `op2_i`) as inputs and produces a 32-bit product (`result_o`) along with a clock enable signal (`ce_o`) that indicates when the output is valid. The multiplication operation completes in 2 clock cycles.

### Component Specification

**Component Name:** LXP32 DSP Multiplier

**Functionality:** 32-bit multiplication using 16x16 multiplier blocks

**Inputs:**

* `clk_i`: Clock input (rising edge)
* `rst_i`: Asynchronous reset input (active high)
* `ce_i`: Clock enable input (active high)
* `op1_i`: 32-bit operand 1 (unsigned)
* `op2_i`: 32-bit operand 2 (unsigned)

**Outputs:**

* `ce_o`: Clock enable output (active high) indicating valid output
* `result_o`: 32-bit product (unsigned)

**Performance:**

* Multiplication completion: 2 clock cycles
* Throughput: 1 multiplication per 2 clock cycles

**Implementation:**

* Utilizes 16x16 multiplier blocks (e.g., DSP blocks in modern FPGAs)
* Optimized for low latency and high throughput

**Reset Behavior:**

* Asynchronous reset (`rst_i`) sets `ce_o` to","---------------------------------------------------------------------
-- DSP multiplier
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This multiplier is designed for technologies that provide fast
-- 16x16 multipliers, including most modern FPGA families. One
-- multiplication takes 2 cycles.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul_dsp is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul_dsp is

signal pp00: std_logic_vector(31 downto 0);
signal pp01: std_logic_vector(31 downto 0);
signal pp10: std_logic_vector(31 downto 0);

signal product: unsigned(31 downto 0);

signal ceo: std_logic:='0';

begin

mul00_inst: entity work.lxp32_mul16x16
	port map(
		clk_i=>clk_i,
		a_i=>op1_i(15 downto 0),
		b_i=>op2_i(15 downto 0),
		p_o=>pp00
	);

mul01_inst: entity work.lxp32_mul16x16
	port map(
		clk_i=>clk_i,
		a_i=>op1_i(15 downto 0),
		b_i=>op2_i(31 downto 16),
		p_o=>pp01
	);

mul10_inst: entity work.lxp32_mul16x16
	port map(
		clk_i=>clk_i,
		a_i=>op1_i(31 downto 16),
		b_i=>op2_i(15 downto 0),
		p_o=>pp10
	);

product(31 downto 16)<=unsigned(pp00(31 downto 16))+unsigned(pp01(15 downto 0))+unsigned(pp10(15 downto 0));
product(15 downto 0)<=unsigned(pp00(15 downto 0));
result_o<=std_logic_vector(product);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
		else
			ceo<=ce_i;
		end if;
	end if;
end process;

ce_o<=ceo;

end architecture;
",69
"# VHDL Analysis for 'lxp32_mul_opt.vhd'

## File Comments
- -------------------------------------------------------------------
- Optimized multiplier
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- This multiplier is designed for technologies that don't provide
- fast 16x16 multipliers. One multiplication takes 6 cycles.
- The multiplication algorithm is based on carry-save accumulation
- of partial products.
- -------------------------------------------------------------------
- Calculate 8 partial products in parallel
- Plus 5 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_mul_opt

## Architecture: rtl of lxp32_mul_opt

### Signals
- reg1: unsigned(op1_i'range)
- reg2: unsigned(op2_i'range)
- pp: pp_type
- pp_sum: pp_sum_type
- pp_carry: pp_carry_type
- acc_sum: unsigned(31 downto 0)
- acc_carry: unsigned(31 downto 0)
- cnt: integer range 0 to 4:=0
- result: std_logic_vector(result_o'range)
- ceo: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements arithmetic/computational functionality
- Implements control logic
- This appears to be a CPU component
- Defines custom functions: csa_sum, csa_carry

## Code Metrics
- Line count: 169
- Process count: 4
- Signal count: 10

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_mul_opt.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Optimized Multiplier**

**Overview**

The LXP32 Optimized Multiplier is a digital component designed to perform 32-bit multiplication operations. It is optimized for technologies that do not provide fast 16x16 multipliers and achieves multiplication in 6 clock cycles.

**Functional Description**

The LXP32 Optimized Multiplier takes two 32-bit unsigned integer inputs, `op1_i` and `op2_i`, and produces a 32-bit unsigned integer output, `result_o`. The component uses a carry-save accumulation of partial products algorithm to perform the multiplication.

**Inputs**

* `clk_i`: Clock input (1-bit)
* `rst_i`: Reset input (1-bit)
* `ce_i`: Clock enable input (1-bit)
* `op1_i`: 32-bit unsigned integer operand 1
* `op2_i`: 32-bit unsigned integer operand 2

**Outputs**

* `ce_o`: Clock enable output (1-bit)
* `result_o`: 32-bit unsigned integer result

**Behavior**

* When `ce_i` is high, the component starts a multiplication operation and loads the operands `op1_i` and `op2_i`.
* The component performs the multiplication in 6 clock cycles.
* During the multiplication operation, the component asserts `ce_o` high for one clock cycle to indicate that the result is valid.
* When `rst_i` is high, the component resets its internal state.

**Performance**","---------------------------------------------------------------------
-- Optimized multiplier
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This multiplier is designed for technologies that don't provide
-- fast 16x16 multipliers. One multiplication takes 6 cycles.
--
-- The multiplication algorithm is based on carry-save accumulation
-- of partial products.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul_opt is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul_opt is

function csa_sum(a: unsigned; b: unsigned; c: unsigned; n: integer) return unsigned is
	variable r: unsigned(n-1 downto 0);
begin
	for i in r'range loop
		r(i):=a(i) xor b(i) xor c(i);
	end loop;
	return r;
end function;

function csa_carry(a: unsigned; b: unsigned; c: unsigned; n: integer) return unsigned is
	variable r: unsigned(n-1 downto 0);
begin
	for i in r'range loop
		r(i):=(a(i) and b(i)) or (a(i) and c(i)) or (b(i) and c(i));
	end loop;
	return r&""0"";
end function;

signal reg1: unsigned(op1_i'range);
signal reg2: unsigned(op2_i'range);

type pp_type is array (7 downto 0) of unsigned(31 downto 0);
signal pp: pp_type;

type pp_sum_type is array (7 downto 0) of unsigned(31 downto 0);
signal pp_sum: pp_sum_type;

type pp_carry_type is array (7 downto 0) of unsigned(32 downto 0);
signal pp_carry: pp_carry_type;

signal acc_sum: unsigned(31 downto 0);
signal acc_carry: unsigned(31 downto 0);

signal cnt: integer range 0 to 4:=0;

signal result: std_logic_vector(result_o'range);
signal ceo: std_logic:='0';

begin

-- Calculate 8 partial products in parallel

pp_gen: for i in pp'range generate
	pp(i)<=shift_left(reg1,i) when reg2(i)='1' else (others=>'0');
end generate;

-- Add partial products to the accumulator using carry-save adder tree

pp_sum(0)<=csa_sum(pp(0),pp(1),pp(2),32);
pp_carry(0)<=csa_carry(pp(0),pp(1),pp(2),32);

pp_sum(1)<=csa_sum(pp(3),pp(4),pp(5),32);
pp_carry(1)<=csa_carry(pp(3),pp(4),pp(5),32);

pp_sum(2)<=csa_sum(pp(6),pp(7),acc_sum,32);
pp_carry(2)<=csa_carry(pp(6),pp(7),acc_sum,32);

pp_sum(3)<=csa_sum(pp_sum(0),pp_carry(0),pp_sum(1),32);
pp_carry(3)<=csa_carry(pp_sum(0),pp_carry(0),pp_sum(1),32);

pp_sum(4)<=csa_sum(pp_carry(1),pp_sum(2),pp_carry(2),32);
pp_carry(4)<=csa_carry(pp_carry(1),pp_sum(2),pp_carry(2),32);

pp_sum(5)<=csa_sum(pp_sum(3),pp_carry(3),pp_sum(4),32);
pp_carry(5)<=csa_carry(pp_sum(3),pp_carry(3),pp_sum(4),32);

pp_sum(6)<=csa_sum(pp_sum(5),pp_carry(5),pp_carry(4),32);
pp_carry(6)<=csa_carry(pp_sum(5),pp_carry(5),pp_carry(4),32);

pp_sum(7)<=csa_sum(pp_sum(6),pp_carry(6),acc_carry,32);
pp_carry(7)<=csa_carry(pp_sum(6),pp_carry(6),acc_carry,32);

-- Multiplier state machine

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
			cnt<=0;
			reg1<=(others=>'-');
			reg2<=(others=>'-');
			acc_sum<=(others=>'-');
			acc_carry<=(others=>'-');
		else
			if cnt=1 then
				ceo<='1';
			else
				ceo<='0';
			end if;
			
			if ce_i='1' then
				cnt<=4;
				reg1<=unsigned(op1_i);
				reg2<=unsigned(op2_i);
				acc_sum<=(others=>'0');
				acc_carry<=(others=>'0');
			else
				acc_sum<=pp_sum(7);
				acc_carry<=pp_carry(7)(acc_carry'range);
				reg1<=reg1(reg1'high-8 downto 0)&X""00"";
				reg2<=X""00""&reg2(reg2'high downto 8);
				if cnt>0 then
					cnt<=cnt-1;
				end if;
			end if;
		end if;
	end if;
end process;

result<=std_logic_vector(acc_sum+acc_carry);

result_o<=result;
ce_o<=ceo;

-- A simulation-time multiplication check

-- synthesis translate_off

process (clk_i) is
	variable p: unsigned(op1_i'length+op2_i'length-1 downto 0);
begin
	if rising_edge(clk_i) then
		if ce_i='1' then
			p:=unsigned(op1_i)*unsigned(op2_i);
		elsif ceo='1' then
			assert result=std_logic_vector(p(result'range))
				report ""Incorrect multiplication result""
				severity failure;
		end if;
	end if;
end process;

-- synthesis translate_on

end architecture;
",70
"# VHDL Analysis for 'lxp32_mul_seq.vhd'

## File Comments
- -------------------------------------------------------------------
- Sequential multiplier
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- The smallest possible multiplier. Implemented using
- an accumulator. One multiplication takes 34 cycles.
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_mul_seq

## Architecture: rtl of lxp32_mul_seq

### Signals
- reg1: unsigned(op1_i'range)
- reg2: unsigned(op2_i'range)
- pp: unsigned(31 downto 0)
- acc_sum: unsigned(31 downto 0)
- cnt: integer range 0 to 32:=0
- ceo: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- This appears to be a CPU component

## Code Metrics
- Line count: 78
- Process count: 2
- Signal count: 6

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_mul_seq.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `lxp32_mul_seq` component is a sequential multiplier designed for the LXP32 CPU. It performs 32-bit multiplication using an accumulator-based approach, completing a multiplication operation in 34 clock cycles. The component takes two 32-bit operands as input and produces a 32-bit result.

**Inputs**

* `clk_i`: Clock input (std_logic)
* `rst_i`: Reset input (std_logic)
* `ce_i`: Clock enable input (std_logic)
* `op1_i`: First operand (32-bit std_logic_vector)
* `op2_i`: Second operand (32-bit std_logic_vector)

**Outputs**

* `ce_o`: Clock enable output (std_logic)
* `result_o`: Multiplication result (32-bit std_logic_vector)

**Functionality**

The component performs the following operations:

1. When `ce_i` is high, the component initializes the multiplication process with the provided operands.
2. The component then performs a sequential multiplication using an accumulator-based approach, iterating over 32 clock cycles.
3. During each cycle, the component shifts the operands and accumulates the partial products.
4. After 34 clock cycles (32 iterations + 2 initialization cycles), the component asserts the `ce_o` output and presents the final result on `result_o`.

**Component Specification**

* **Component Name**: lxp32_mul_seq
* **Component Type**: Sequential Multiplier
* **Operand Size**: 32 bits","---------------------------------------------------------------------
-- Sequential multiplier
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The smallest possible multiplier. Implemented using
-- an accumulator. One multiplication takes 34 cycles.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul_seq is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul_seq is

signal reg1: unsigned(op1_i'range);
signal reg2: unsigned(op2_i'range);
signal pp: unsigned(31 downto 0);
signal acc_sum: unsigned(31 downto 0);
signal cnt: integer range 0 to 32:=0;
signal ceo: std_logic:='0';

begin

pp<=reg1 when reg2(0)='1' else (others=>'0');

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
			cnt<=0;
			reg1<=(others=>'-');
			reg2<=(others=>'-');
			acc_sum<=(others=>'-');
		else
			if cnt=1 then
				ceo<='1';
			else
				ceo<='0';
			end if;
			
			if ce_i='1' then
				cnt<=32;
				reg1<=unsigned(op1_i);
				reg2<=unsigned(op2_i);
				acc_sum<=(others=>'0');
			else
				acc_sum<=acc_sum+pp;
				reg1<=reg1(reg1'high-1 downto 0)&""0"";
				reg2<=""0""&reg2(reg2'high downto 1);
				if cnt>0 then
					cnt<=cnt-1;
				end if;
			end if;
		end if;
	end if;
end process;

result_o<=std_logic_vector(acc_sum);
ce_o<=ceo;

end architecture;
",71
"# VHDL Analysis for 'lxp32_ram256x32.vhd'

## File Comments
- -------------------------------------------------------------------
- Generic dual-port memory
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- Portable description of a dual-port memory block with one write
- port. Major FPGA synthesis tools can infer on-chip block RAM
- from this description. Can be replaced with a library component
- wrapper if needed.
- -------------------------------------------------------------------
- zero-initialize for SRAM-based FPGAs
- Plus 4 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all
- Use: ieee.numeric_std.all

## Entity: lxp32_ram256x32

## Architecture: rtl of lxp32_ram256x32

### Signals
- ram: ram_type:=(others=>(others=>'0'))
- is ""no_rw_check"";
attribute ram_style: string

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Implements memory functionality
- This appears to be a CPU component

## Code Metrics
- Line count: 71
- Process count: 4
- Signal count: 2

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_ram256x32.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `lxp32_ram256x32` component is a generic dual-port memory block with one write port, designed to be synthesized into on-chip block RAM on FPGAs. It provides a 256x32-bit memory array, allowing for concurrent read and write operations.

**Inputs**

* `clk_i`: Clock input (1-bit)
* `we_i`: Write enable input (1-bit)
* `waddr_i`: Write address input (8-bit)
* `wdata_i`: Write data input (32-bit)
* `re_i`: Read enable input (1-bit)
* `raddr_i`: Read address input (8-bit)

**Outputs**

* `rdata_o`: Read data output (32-bit)

**Functionality**

The component performs the following operations:

* Write: When `we_i` is high, the component writes `wdata_i` to the memory location specified by `waddr_i` on the rising edge of `clk_i`.
* Read: When `re_i` is high, the component outputs the data stored at the memory location specified by `raddr_i` on the rising edge of `clk_i`. If the read address is unknown (i.e., contains 'X' values), the component outputs a data bus with all 'X' values.

**Attributes and Configuration**

The component is configured with the following attributes:

* `syn_ramstyle`: Set to ""no_rw_check"" to disable read/write","---------------------------------------------------------------------
-- Generic dual-port memory
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Portable description of a dual-port memory block with one write
-- port. Major FPGA synthesis tools can infer on-chip block RAM
-- from this description. Can be replaced with a library component
-- wrapper if needed.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_ram256x32 is
	port(
		clk_i: in std_logic;
		
		we_i: in std_logic;
		waddr_i: in std_logic_vector(7 downto 0);
		wdata_i: in std_logic_vector(31 downto 0);
		
		re_i: in std_logic;
		raddr_i: in std_logic_vector(7 downto 0);
		rdata_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_ram256x32 is

type ram_type is array(255 downto 0) of std_logic_vector(31 downto 0);
signal ram: ram_type:=(others=>(others=>'0')); -- zero-initialize for SRAM-based FPGAs

attribute syn_ramstyle: string;
attribute syn_ramstyle of ram: signal is ""no_rw_check"";
attribute ram_style: string; -- for Xilinx
attribute ram_style of ram: signal is ""block"";

begin

-- Write port

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if we_i='1' then
			ram(to_integer(unsigned(waddr_i)))<=wdata_i;
		end if;
	end if;
end process;

-- Read port

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if re_i='1' then
			if is_x(raddr_i) then -- to avoid numeric_std warnings during simulation
				rdata_o<=(others=>'X');
			else
				rdata_o<=ram(to_integer(unsigned(raddr_i)));
			end if;
		end if;
	end if;
end process;

end architecture;
",72
"# VHDL Analysis for 'lxp32_scratchpad.vhd'

## File Comments
- -------------------------------------------------------------------
- Scratchpad
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- LXP32 register file implemented as a RAM block. Since we need
- to read two registers simultaneously, the memory is duplicated.
- -------------------------------------------------------------------
- RAM 1
- RAM 2
- Read/write collision detection

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: lxp32_scratchpad

## Architecture: rtl of lxp32_scratchpad

### Signals
- wdata_reg: std_logic_vector(wdata_i'range)
- ram1_rdata: std_logic_vector(31 downto 0)
- ram2_rdata: std_logic_vector(31 downto 0)
- ram1_collision: std_logic
- ram2_collision: std_logic

### Processes
- Process 'Unnamed process' (Clocked) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Implements memory functionality
- This appears to be a CPU component
- Implements register file/bank functionality

## Code Metrics
- Line count: 94
- Process count: 2
- Signal count: 5

## Summary
- This module implements memory functionality.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_scratchpad.vhd' plays a specific role in the overall CPU architecture.
","**Component Specification: LXP32 Scratchpad**

**Overview**

The LXP32 Scratchpad is a dual-port register file implemented as a RAM block, designed to provide fast access to 32-bit data for the LXP32 CPU. It allows for simultaneous reads from two registers while supporting write operations.

**Functional Description**

The LXP32 Scratchpad is a 256x32-bit RAM block with two read ports and one write port. It provides the following functionality:

* Two simultaneous read operations from different registers
* Single write operation to a register
* Read/write collision detection to ensure data coherence

**Inputs**

* `clk_i`: Clock input (1-bit)
* `raddr1_i`: Read address 1 (8-bit)
* `raddr2_i`: Read address 2 (8-bit)
* `waddr_i`: Write address (8-bit)
* `we_i`: Write enable (1-bit)
* `wdata_i`: Write data (32-bit)

**Outputs**

* `rdata1_o`: Read data 1 (32-bit)
* `rdata2_o`: Read data 2 (32-bit)

**Specifications**

* **Capacity**: 256x32-bit
* **Read Ports**: 2
* **Write Ports**: 1
* **Read/Write Collision Detection**: Yes
* **Clock Frequency**: Dependent on the target technology and implementation

**Behavioral Description**

* When `we_i` is high","---------------------------------------------------------------------
-- Scratchpad
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- LXP32 register file implemented as a RAM block. Since we need
-- to read two registers simultaneously, the memory is duplicated.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_scratchpad is
	port(
		clk_i: in std_logic;
		
		raddr1_i: in std_logic_vector(7 downto 0);
		rdata1_o: out std_logic_vector(31 downto 0);
		raddr2_i: in std_logic_vector(7 downto 0);
		rdata2_o: out std_logic_vector(31 downto 0);
		
		waddr_i: in std_logic_vector(7 downto 0);
		we_i: in std_logic;
		wdata_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_scratchpad is

signal wdata_reg: std_logic_vector(wdata_i'range);
signal ram1_rdata: std_logic_vector(31 downto 0);
signal ram2_rdata: std_logic_vector(31 downto 0);

signal ram1_collision: std_logic;
signal ram2_collision: std_logic;

begin

-- RAM 1

ram_inst1: entity work.lxp32_ram256x32(rtl)
	port map(
		clk_i=>clk_i,
		
		we_i=>we_i,
		waddr_i=>waddr_i,
		wdata_i=>wdata_i,
		
		re_i=>'1',
		raddr_i=>raddr1_i,
		rdata_o=>ram1_rdata
	);

-- RAM 2

ram_inst2: entity work.lxp32_ram256x32(rtl)
	port map(
		clk_i=>clk_i,
		
		we_i=>we_i,
		waddr_i=>waddr_i,
		wdata_i=>wdata_i,
		
		re_i=>'1',
		raddr_i=>raddr2_i,
		rdata_o=>ram2_rdata
	);

-- Read/write collision detection

process (clk_i) is
begin
	if rising_edge(clk_i) then
		wdata_reg<=wdata_i;
		if waddr_i=raddr1_i and we_i='1' then
			ram1_collision<='1';
		else
			ram1_collision<='0';
		end if;
		if waddr_i=raddr2_i and we_i='1' then
			ram2_collision<='1';
		else
			ram2_collision<='0';
		end if;
	end if;
end process;

rdata1_o<=ram1_rdata when ram1_collision='0' else wdata_reg;
rdata2_o<=ram2_rdata when ram2_collision='0' else wdata_reg;

end architecture;
",73
"# VHDL Analysis for 'lxp32_shifter.vhd'

## File Comments
- -------------------------------------------------------------------
- Barrel shifter
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- Performs logical (unsigned) and arithmetic (signed) shifts
- in both directions. Pipeline latency: 1 cycle.
- -------------------------------------------------------------------
- 0 for unsigned shifts, sign bit for signed ones
- Internally, data are shifted in left direction. For right shifts
- we reverse the argument's bit order
- Plus 2 more comments

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: lxp32_shifter

## Architecture: rtl of lxp32_shifter

### Signals
- data: std_logic_vector(d_i'range)
- data_shifted: std_logic_vector(d_i'range)
- fill: std_logic
- fill_v: std_logic_vector(3 downto 0)
- cascades: cascades_type
- stage2_data: std_logic_vector(d_i'range)
- stage2_s: std_logic_vector(s_i'range)
- stage2_fill: std_logic
- stage2_fill_v: std_logic_vector(15 downto 0)
- stage2_right: std_logic
- ceo: std_logic:='0'

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- May be part of a pipeline architecture
- This appears to be a CPU component

## Code Metrics
- Line count: 100
- Process count: 2
- Signal count: 11

## Summary
- This module implements a pipeline stage.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_shifter.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The `lxp32_shifter` component is a barrel shifter designed for the LXP32 CPU. It performs logical (unsigned) and arithmetic (signed) shifts in both left and right directions with a pipeline latency of 1 cycle.

**Functionality**

* The component takes a 32-bit input data `d_i` and shifts it by a 5-bit shift amount `s_i` in either left or right direction, as specified by `right_i`.
* The shift operation can be either logical (unsigned) or arithmetic (signed), depending on the value of `sig_i`.
* The component outputs the shifted data `d_o` and a clock enable signal `ce_o`.

**Inputs**

* `clk_i`: Clock input
* `rst_i`: Reset input
* `ce_i`: Clock enable input
* `d_i`: 32-bit input data to be shifted
* `s_i`: 5-bit shift amount
* `right_i`: Direction of shift (0 for left, 1 for right)
* `sig_i`: Signed/unsigned shift mode (0 for unsigned, 1 for signed)

**Outputs**

* `ce_o`: Clock enable output
* `d_o`: 32-bit shifted data output

**Component Specification**

* **Component Name:** lxp32_shifter
* **Component Type:** Barrel Shifter
* **Input Data Width:** 32 bits
* **Shift Amount Width:**","---------------------------------------------------------------------
-- Barrel shifter
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Performs logical (unsigned) and arithmetic (signed) shifts
-- in both directions. Pipeline latency: 1 cycle.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_shifter is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		d_i: in std_logic_vector(31 downto 0);
		s_i: in std_logic_vector(4 downto 0);
		right_i: in std_logic;
		sig_i: in std_logic;
		ce_o: out std_logic;
		d_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_shifter is

signal data: std_logic_vector(d_i'range);
signal data_shifted: std_logic_vector(d_i'range);

signal fill: std_logic; -- 0 for unsigned shifts, sign bit for signed ones
signal fill_v: std_logic_vector(3 downto 0);

type cascades_type is array (4 downto 0) of std_logic_vector(d_i'range);
signal cascades: cascades_type;

signal stage2_data: std_logic_vector(d_i'range);
signal stage2_s: std_logic_vector(s_i'range);
signal stage2_fill: std_logic;
signal stage2_fill_v: std_logic_vector(15 downto 0);
signal stage2_right: std_logic;

signal ceo: std_logic:='0';

begin

-- Internally, data are shifted in left direction. For right shifts
-- we reverse the argument's bit order

data_gen: for i in data'range generate
	data(i)<=d_i(i) when right_i='0' else d_i(d_i'high-i);
end generate;

-- A set of cascaded shifters shifting by powers of two

fill<=sig_i and data(0);
fill_v<=(others=>fill);

cascades(0)<=data(30 downto 0)&fill_v(0) when s_i(0)='1' else data;
cascades(1)<=cascades(0)(29 downto 0)&fill_v(1 downto 0) when s_i(1)='1' else cascades(0);
cascades(2)<=cascades(1)(27 downto 0)&fill_v(3 downto 0) when s_i(2)='1' else cascades(1);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
			stage2_data<=(others=>'-');
			stage2_s<=(others=>'-');
			stage2_fill<='-';
			stage2_right<='-';
		else
			ceo<=ce_i;
			stage2_data<=cascades(2);
			stage2_s<=s_i;
			stage2_fill<=fill;
			stage2_right<=right_i;
		end if;
	end if;
end process;

stage2_fill_v<=(others=>stage2_fill);

cascades(3)<=stage2_data(23 downto 0)&stage2_fill_v(7 downto 0) when stage2_s(3)='1' else stage2_data;
cascades(4)<=cascades(3)(15 downto 0)&stage2_fill_v(15 downto 0) when stage2_s(4)='1' else cascades(3);

-- Reverse bit order back, if needed

data_shifted_gen: for i in data_shifted'range generate
	data_shifted(i)<=cascades(4)(i) when stage2_right='0' else cascades(4)(cascades(4)'high-i);
end generate;

d_o<=data_shifted;
ce_o<=ceo;

end architecture;
",74
"# VHDL Analysis for 'lxp32_ubuf.vhd'

## File Comments
- -------------------------------------------------------------------
- Microbuffer
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- A small buffer with a FIFO-like interface, implemented
- using registers.
- -------------------------------------------------------------------

## Libraries and Packages
- Library: ieee
- Use: ieee.std_logic_1164.all

## Entity: lxp32_ubuf

## Architecture: rtl of lxp32_ubuf

### Signals
- we: std_logic
- re: std_logic
- empty: std_logic:='1'
- full: std_logic:='0'
- regs: regs_type
- regs_mux: regs_type

### Processes
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: clk_i
  - Implements synchronous logic
- Process 'Unnamed process' (Clocked) (Has Reset) with sensitivity list: None (uses wait statements)
  - Implements synchronous logic

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements memory functionality
- Implements interface or communication protocol
- This appears to be a CPU component

## Code Metrics
- Line count: 85
- Process count: 2
- Signal count: 6

## Summary
- This module appears to be a general-purpose digital logic implementation.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32_ubuf.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**
The `lxp32_ubuf` component is a small, 2-element buffer with a FIFO-like interface, implemented using registers. It provides a simple, clock-synchronous interface for writing and reading data, with flags indicating whether the buffer is empty or full.

**Functionality**

* The buffer has two registers, `regs(0)` and `regs(1)`, which store data of width `DATA_WIDTH`.
* Write (`we_i`) and read (`re_i`) enable signals control the flow of data into and out of the buffer.
* The buffer has three main states:
	+ Empty (`empty_o='1'`): no valid data is stored in the buffer.
	+ Not empty (`empty_o='0'`): at least one valid data element is stored in the buffer.
	+ Full (`full_o='1'`): both registers contain valid data.

**Inputs**

* `clk_i`: clock input
* `rst_i`: asynchronous reset input
* `we_i`: write enable input
* `d_i`: data input (width `DATA_WIDTH`)
* `re_i`: read enable input

**Outputs**

* `d_o`: data output (width `DATA_WIDTH`)
* `empty_o`: empty flag output (`'1'` if buffer is empty)
* `full_o`: full flag output (`'1'` if buffer is full)

**Behavior**

* When `we_i='1'` and the buffer is not full,","---------------------------------------------------------------------
-- Microbuffer
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A small buffer with a FIFO-like interface, implemented
-- using registers.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_ubuf is
	generic(
		DATA_WIDTH: integer
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		we_i: in std_logic;
		d_i: in std_logic_vector(DATA_WIDTH-1 downto 0);
		re_i: in std_logic;
		d_o: out std_logic_vector(DATA_WIDTH-1 downto 0);
		
		empty_o: out std_logic;
		full_o: out std_logic
	);
end entity;

architecture rtl of lxp32_ubuf is

signal we: std_logic;
signal re: std_logic;

signal empty: std_logic:='1';
signal full: std_logic:='0';

type regs_type is array (1 downto 0) of std_logic_vector(DATA_WIDTH-1 downto 0);
signal regs: regs_type;
signal regs_mux: regs_type;

begin

we<=we_i and not full;
re<=re_i and not empty;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			empty<='1';
			full<='0';
			regs<=(others=>(others=>'-'));
		else
			if re='0' then
				regs(0)<=regs_mux(0);
			else
				regs(0)<=regs_mux(1);
			end if;
			
			regs(1)<=regs_mux(1);
			
			if we='1' and re='0' then
				empty<='0';
				full<=not empty;
			elsif we='0' and re='1' then
				empty<=not full;
				full<='0';
			end if;
		end if;
	end if;
end process;

regs_mux(0)<=regs(0) when we='0' or empty='0' else d_i;
regs_mux(1)<=regs(1) when we='0' or empty='1' else d_i;

d_o<=regs(0);
empty_o<=empty;
full_o<=full;

end architecture;
",75
"# VHDL Analysis for 'lxp32c_top.vhd'

## File Comments
- -------------------------------------------------------------------
- LXP32C CPU top-level module (C-series, with instruction cache)
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- This version uses Wishbone B3 interface for the instruction bus
- (IBUS). It is designed for high-latency program memory, such as
- external SDRAM chips.
- Parameters:
- DBUS_RMW:           Use RMW cycle instead of SEL_O() signal
- for byte-granular access to data bus
- Plus 9 more comments

## Libraries and Packages
- Library: ieee
- Use: RMW cycle instead of SEL_O() signal
--                         for byte-granular access to data bus
--     DIVIDER_EN:         enable divider
--     IBUS_BURST_SIZE:    size of the burst
--     IBUS_PREFETCH_SIZE: initiate read burst if number of words
--                         left in the buffer is less than specified
--     MUL_ARCH:           multiplier architecture (""dsp"", ""opt""
--                         or ""seq"")
--     START_ADDR:         address in program memory where execution
--                         starts
---------------------------------------------------------------------

library ieee
- Use: ieee.std_logic_1164.all

## Entity: lxp32c_top

## Architecture: rtl of lxp32c_top

### Signals
- lli_re: std_logic
- lli_adr: std_logic_vector(29 downto 0)
- lli_dat: std_logic_vector(31 downto 0)
- lli_busy: std_logic

## Functional Analysis

- Uses reset signal(s): IBUS_BURST_SIZE, burst, rst_i, BURST_SIZE
- Implements memory functionality
- Implements interface or communication protocol
- This appears to be a CPU component

## Code Metrics
- Line count: 123
- Process count: 0
- Signal count: 4

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32c_top.vhd' plays a specific role in the overall CPU architecture.
","**Component Description**

The LXP32C CPU top-level module is a 32-bit processor core designed for high-latency program memory, such as external SDRAM chips. It features a Wishbone B3 interface for the instruction bus and includes an instruction cache for improved performance.

**Functionality**

The LXP32C CPU top-level module executes instructions from a program memory, handles data transfer between the processor and external memory, and manages interrupts. It consists of a CPU core and an instruction cache.

**Inputs**

* `clk_i`: Clock input
* `rst_i`: Reset input
* `dbus_dat_i`: Data input from data bus
* `dbus_ack_i`: Acknowledge input from data bus
* `ibus_dat_i`: Data input from instruction bus
* `ibus_ack_i`: Acknowledge input from instruction bus
* `irq_i`: Interrupt request input (8-bit vector)

**Outputs**

* `dbus_cyc_o`: Cycle output to data bus
* `dbus_stb_o`: Strobe output to data bus
* `dbus_we_o`: Write enable output to data bus
* `dbus_sel_o`: Select output to data bus (4-bit vector)
* `dbus_adr_o`: Address output to data bus (30-bit vector)
* `dbus_dat_o`: Data output to data bus (32-bit vector)
* `ibus_cyc_o`: Cycle output to instruction bus
* `ibus_stb_o`: Strobe output","---------------------------------------------------------------------
-- LXP32C CPU top-level module (C-series, with instruction cache)
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This version uses Wishbone B3 interface for the instruction bus
-- (IBUS). It is designed for high-latency program memory, such as
-- external SDRAM chips.
--
-- Parameters:
--     DBUS_RMW:           Use RMW cycle instead of SEL_O() signal
--                         for byte-granular access to data bus
--     DIVIDER_EN:         enable divider
--     IBUS_BURST_SIZE:    size of the burst
--     IBUS_PREFETCH_SIZE: initiate read burst if number of words
--                         left in the buffer is less than specified
--     MUL_ARCH:           multiplier architecture (""dsp"", ""opt""
--                         or ""seq"")
--     START_ADDR:         address in program memory where execution
--                         starts
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32c_top is
	generic(
		DBUS_RMW: boolean:=false;
		DIVIDER_EN: boolean:=true;
		IBUS_BURST_SIZE: integer:=16;
		IBUS_PREFETCH_SIZE: integer:=32;
		MUL_ARCH: string:=""dsp"";
		START_ADDR: std_logic_vector(31 downto 0):=(others=>'0')
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		ibus_cyc_o: out std_logic;
		ibus_stb_o: out std_logic;
		ibus_cti_o: out std_logic_vector(2 downto 0);
		ibus_bte_o: out std_logic_vector(1 downto 0);
		ibus_ack_i: in std_logic;
		ibus_adr_o: out std_logic_vector(29 downto 0);
		ibus_dat_i: in std_logic_vector(31 downto 0);
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		irq_i: in std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32c_top is

signal lli_re: std_logic;
signal lli_adr: std_logic_vector(29 downto 0);
signal lli_dat: std_logic_vector(31 downto 0);
signal lli_busy: std_logic;

begin

cpu_inst: entity work.lxp32_cpu(rtl)
	generic map(
		DBUS_RMW=>DBUS_RMW,
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH,
		START_ADDR=>START_ADDR
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_o=>lli_re,
		lli_adr_o=>lli_adr,
		lli_dat_i=>lli_dat,
		lli_busy_i=>lli_busy,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i,
		
		irq_i=>irq_i
	);

icache_inst: entity work.lxp32_icache(rtl)
	generic map(
		BURST_SIZE=>IBUS_BURST_SIZE,
		PREFETCH_SIZE=>IBUS_PREFETCH_SIZE
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_i=>lli_re,
		lli_adr_i=>lli_adr,
		lli_dat_o=>lli_dat,
		lli_busy_o=>lli_busy,
		
		wbm_cyc_o=>ibus_cyc_o,
		wbm_stb_o=>ibus_stb_o,
		wbm_cti_o=>ibus_cti_o,
		wbm_bte_o=>ibus_bte_o,
		wbm_ack_i=>ibus_ack_i,
		wbm_adr_o=>ibus_adr_o,
		wbm_dat_i=>ibus_dat_i
	);

end architecture;
",76
"# VHDL Analysis for 'lxp32u_top.vhd'

## File Comments
- -------------------------------------------------------------------
- LXP32U CPU top-level module (U-series, without instruction cache)
- Part of the LXP32 CPU
- Copyright (c) 2016 by Alex I. Kuznetsov
- This version uses a Low Latency Interface for the instruction bus
- (IBUS). It is designed for low-latency slaves such as on-chip
- RAM blocks.
- Parameters:
- DBUS_RMW:           Use RMW cycle instead of SEL_O() signal
- for byte-granular access to data bus
- Plus 6 more comments

## Libraries and Packages
- Library: ieee
- Use: RMW cycle instead of SEL_O() signal
--                         for byte-granular access to data bus
--     DIVIDER_EN:         enable divider
--     MUL_ARCH:           multiplier architecture (""dsp"", ""opt""
--                         or ""seq"")
--     START_ADDR:         address in program memory where execution
--                         starts
---------------------------------------------------------------------

library ieee
- Use: ieee.std_logic_1164.all

## Entity: lxp32u_top

## Architecture: rtl of lxp32u_top

## Functional Analysis

- Uses reset signal(s): rst_i
- Implements memory functionality
- Implements interface or communication protocol
- This appears to be a CPU component

## Code Metrics
- Line count: 87
- Process count: 0
- Signal count: 0

## Summary
- This appears to be a top-level module in the design.

This file is part of the LXP32 CPU design, which is likely a 32-bit processor implementation. The file 'lxp32u_top.vhd' plays a specific role in the overall CPU architecture.
","**Component Description:**
The LXP32U CPU top-level module is a 32-bit processor core designed for low-latency applications. It interfaces with an instruction bus (IBUS) using a Low Latency Interface and a data bus, executing instructions from a program memory location specified by the `START_ADDR` parameter.

**Inputs:**

* `clk_i`: Clock input
* `rst_i`: Reset input
* `lli_dat_i`: Instruction data input from IBUS
* `lli_busy_i`: IBUS busy signal input
* `dbus_ack_i`: Data bus acknowledge input
* `dbus_dat_i`: Data bus data input
* `irq_i`: Interrupt request input (8-bit vector)

**Outputs:**

* `lli_re_o`: IBUS read enable output
* `lli_adr_o`: IBUS address output (30-bit)
* `dbus_cyc_o`: Data bus cycle output
* `dbus_stb_o`: Data bus strobe output
* `dbus_we_o`: Data bus write enable output
* `dbus_sel_o`: Data bus select output (4-bit)
* `dbus_adr_o`: Data bus address output (30-bit)
* `dbus_dat_o`: Data bus data output (32-bit)

**Parameters:**

* `DBUS_RMW`: Use RMW cycle instead of `SEL_O()` signal for byte-granular access to data bus (boolean, default: `false`)
* `DIVIDER_EN`: Enable divider","---------------------------------------------------------------------
-- LXP32U CPU top-level module (U-series, without instruction cache)
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This version uses a Low Latency Interface for the instruction bus
-- (IBUS). It is designed for low-latency slaves such as on-chip
-- RAM blocks.
--
-- Parameters:
--     DBUS_RMW:           Use RMW cycle instead of SEL_O() signal
--                         for byte-granular access to data bus
--     DIVIDER_EN:         enable divider
--     MUL_ARCH:           multiplier architecture (""dsp"", ""opt""
--                         or ""seq"")
--     START_ADDR:         address in program memory where execution
--                         starts
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32u_top is
	generic(
		DBUS_RMW: boolean:=false;
		DIVIDER_EN: boolean:=true;
		MUL_ARCH: string:=""dsp"";
		START_ADDR: std_logic_vector(31 downto 0):=(others=>'0')
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		irq_i: in std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32u_top is

begin

cpu_inst: entity work.lxp32_cpu(rtl)
	generic map(
		DBUS_RMW=>DBUS_RMW,
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH,
		START_ADDR=>START_ADDR
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_o=>lli_re_o,
		lli_adr_o=>lli_adr_o,
		lli_dat_i=>lli_dat_i,
		lli_busy_i=>lli_busy_i,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i,
		
		irq_i=>irq_i
	);

end architecture;
",77
