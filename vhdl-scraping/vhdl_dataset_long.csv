input,output
The `olo_intf_clk_meas` component is a clock measurement module designed to calculate the frequency of an input clock signal, `ClkTest`, relative to a reference clock signal, `Clk`. Its primary purpose is to provide an accurate measurement of the input clock frequency in Hertz, which is then output as a 32-bit unsigned integer value on the `Freq_Hz` port. The component plays a crucial role in larger systems where clock frequency monitoring and validation are essential, such as in clock generation and distribution systems, or in applications requiring precise timing and synchronization. The component has five ports: `Clk`, `Rst`, `ClkTest`, `Freq_Hz`, and `Freq_Valid`. The `Clk` and `ClkTest` ports are clock inputs, with `Clk` serving as the reference clock and `ClkTest` being the clock signal whose frequency is to be measured. The `Rst` port is an asynchronous reset input that initializes the component to a known state. The `Freq_Hz` port outputs the measured frequency as a 32-bit unsigned integer, while the `Freq_Valid` port indicates the validity of the frequency measurement. Internally, the component consists of several key modules. The `p_control` process, clocked by `Clk`, manages the control logic, including the generation of the `Freq_Valid` signal, the updating of the `Freq_Hz` output, and the reset of internal states. The `p_meas` process, clocked by `ClkTest`, is responsible for measuring the frequency of `ClkTest` by counting the number of its cycles within a one-second window generated by the `i_sec_pulse` strobe generator. The measured frequency is then transferred from the `ClkTest` clock domain to the `Clk` clock domain through the `i_result_cc` clock-crossing module. The `i_sec_pulse` strobe generator produces a one-second pulse, `SecPulse_M`, which is used to trigger the measurement of the `ClkTest` frequency. This pulse is generated based on the reference clock frequency, `ClkFrequency_g`, and is used to reset and enable the frequency measurement process. The `i_sec_pulse_cc` clock-crossing pulse module translates the `SecPulse_M` pulse from the `Clk` clock domain to the `ClkTest` clock domain, producing `SecPulse_T`, which is used to latch the measured frequency. The component's architectural description reveals a well-structured design with clear separation of functions. The internal state machines and counters work in tandem to provide an accurate measurement of the input clock frequency. The use of clock-crossing modules (`i_result_cc` and `i_sec_pulse_cc`) ensures that data and control signals are properly transferred between different clock domains, preventing metastability issues. In terms of functional behavior, the component operates by first generating a one-second strobe signal, which triggers the measurement process. During this measurement window, the component counts the number of cycles of the `ClkTest` signal. Once the measurement is complete, the component outputs the frequency measurement on the `Freq_Hz` port and asserts the `Freq_Valid` signal to indicate that the measurement is valid. The control logic within the component is primarily managed by the `p_control` and `p_meas` processes. These processes handle the enable conditions, reset behavior, and state transitions necessary for the frequency measurement. The `Rst` input provides a global reset that reinitializes all internal states and outputs. Data flow through the component involves the movement of control signals and data between different clock domains. The component takes in the `ClkTest` signal and, based on the reference clock `Clk`, outputs the measured frequency on the `Freq_Hz` port. The data transformation involves converting the counted cycles of `ClkTest` within the one-second window into a frequency measurement in Hertz. The component's timing and synchronization are critical to its operation. The design adheres to standard timing constraints, including setup and hold requirements, to ensure that data and control signals are properly captured and transferred between clock domains. The use of clock-crossing modules helps to mitigate timing issues that could arise from clock domain crossings. A special feature of this component is its ability to operate with a wide range of input clock frequencies, limited only by the `MaxClkTestFrequency_g` generic parameter. This flexibility makes it suitable for various applications requiring clock frequency measurement. The `olo_intf_clk_meas` component is typically used in systems where precise clock frequency measurement is necessary, such as in telecommunications equipment, data acquisition systems, or any application requiring accurate timing and synchronization. In terms of implementation considerations, the component's performance and resource usage are influenced by the target technology and the specific parameters chosen for `ClkFrequency_g` and `MaxClkTestFrequency_g`. Design trade-offs may involve balancing the accuracy of the frequency measurement against the resource utilization and power consumption. Overall, the `olo_intf_clk_meas` component is a sophisticated and flexible clock measurement module that provides accurate frequency measurements across a wide range of input clock frequencies. Its robust design, incorporating clock-crossing logic and strobe generation, makes it suitable for use in complex systems requiring precise timing and synchronization., `ClkTest`, relative to a reference clock signal, `Clk`. Its primary purpose is to provide an accurate measurement of the input clock frequency in Hertz, which is then output as a 32-bit unsigned integer value on the `Freq_Hz` port. The component plays a crucial role in larger systems where clock frequency monitoring and validation are essential, such as in clock generation and distribution systems, or in applications requiring precise timing and synchronization. The component has five ports: `Clk`, `Rst`, `ClkTest`, `Freq_Hz`, and `Freq_Valid`. The `Clk` and `ClkTest` ports are clock inputs, with `Clk` serving as the reference clock and `ClkTest` being the clock signal whose frequency is to be measured. The `Rst` port is an asynchronous reset input that initializes the component to a known state. The `Freq_Hz` port outputs the measured frequency as a 32-bit unsigned integer, while the `Freq_Valid` port indicates the validity of the frequency measurement. Internally, the component consists of several key modules. The `p_control` process, clocked by `Clk`, manages the control logic, including the generation of the `Freq_Valid` signal, the updating of the `Freq_Hz` output, and the reset of internal states. The `p_meas` process, clocked by `ClkTest`, is responsible for measuring the frequency of `ClkTest` by counting the number of its cycles within a one-second window generated by the `i_sec_pulse` strobe generator. The measured frequency is then transferred from the `ClkTest` clock domain to the `Clk` clock domain through the `i_result_cc` clock-crossing module. The `i_sec_pulse` strobe generator produces a one-second pulse, `SecPulse_M`, which is used to trigger the measurement of the `ClkTest` frequency. This pulse is generated based on the reference clock frequency, `ClkFrequency_g`, and is used to reset and enable the frequency measurement process. The `i_sec_pulse_cc` clock-crossing pulse module translates the `SecPulse_M` pulse from the `Clk` clock domain to the `ClkTest` clock domain, producing `SecPulse_T`, which is used to latch the measured frequency. The component's architectural description reveals a well-structured design with clear separation of functions. The internal state machines and counters work in tandem to provide an accurate measurement of the input clock frequency. The use of clock-crossing modules (`i_result_cc` and `i_sec_pulse_cc`) ensures that data and control signals are properly transferred between different clock domains, preventing metastability issues. In terms of functional behavior, the component operates by first generating a one-second strobe signal, which triggers the measurement process. During this measurement window, the component counts the number of cycles of the `ClkTest` signal. Once the measurement is complete, the component outputs the frequency measurement on the `Freq_Hz` port and asserts the `Freq_Valid` signal to indicate that the measurement is valid. The control logic within the component is primarily managed by the `p_control` and `p_meas` processes. These processes handle the enable conditions, reset behavior, and state transitions necessary for the frequency measurement. The `Rst` input provides a global reset that reinitializes all internal states and outputs. Data flow through the component involves the movement of control signals and data between different clock domains. The component takes in the `ClkTest` signal and, based on the reference clock `Clk`, outputs the measured frequency on the `Freq_Hz` port. The data transformation involves converting the counted cycles of `ClkTest` within the one-second window into a frequency measurement in Hertz. The component's timing and synchronization are critical to its operation. The design adheres to standard timing constraints, including setup and hold requirements, to ensure that data and control signals are properly captured and transferred between clock domains. The use of clock-crossing modules helps to mitigate timing issues that could arise from clock domain crossings. A special feature of this component is its ability to operate with a wide range of input clock frequencies, limited only by the `MaxClkTestFrequency_g` generic parameter. This flexibility makes it suitable for various applications requiring clock frequency measurement. The `olo_intf_clk_meas` component is typically used in systems where precise clock frequency measurement is necessary, such as in telecommunications equipment, data acquisition systems, or any application requiring accurate timing and synchronization. In terms of implementation considerations, the component's performance and resource usage are influenced by the target technology and the specific parameters chosen for `ClkFrequency_g` and `MaxClkTestFrequency_g`. Design trade-offs may involve balancing the accuracy of the frequency measurement against the resource utilization and power consumption. Overall, the `olo_intf_clk_meas` component is a sophisticated and flexible clock measurement module that provides accurate frequency measurements across a wide range of input clock frequencies. Its robust design, incorporating clock-crossing logic and strobe generation, makes it suitable for use in complex systems requiring precise timing and synchronization.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_intf_clk_meas is
    generic (
        ClkFrequency_g          : real;
        MaxClkTestFrequency_g   : real := 1.0e9
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        ClkTest       : in    std_logic;
        Freq_Hz       : out   std_logic_vector(31 downto 0);
        Freq_Valid    : out   std_logic
    );
end entity;

architecture rtl of olo_intf_clk_meas is

    constant MaxClkTestFrequencyInt_c : integer := integer(MaxClkTestFrequency_g);
    constant ResultWidth_c            : integer := log2ceil(integer(MaxClkTestFrequencyInt_c)+1);

    signal AwaitResult_M : std_logic;
    signal SecPulse_M    : std_logic;
    signal ResultValid_M : std_logic;
    signal Result_M      : std_logic_vector(ResultWidth_c-1 downto 0);

    signal CntrTest_T    : integer range 0 to MaxClkTestFrequencyInt_c;
    signal Rst_T         : std_logic;
    signal SecPulse_T    : std_logic;
    signal Result_T      : std_logic_vector(ResultWidth_c-1 downto 0);
    signal ResultValid_T : std_logic;

begin

    assert ClkFrequency_g >= 100.0
        report ""olo_intfclk_meas: ClkFrequency_g must >= 100 Hz""
        severity failure;
    assert MaxClkTestFrequency_g >= 100.0
        report ""olo_intfclk_meas: MaxClkTestFrequency_g must be >= 100 Hz""
        severity failure;

    p_control : process (Clk) is
    begin
        if rising_edge(Clk) then

            Freq_Valid <= '0';

            if SecPulse_M = '1' then
                AwaitResult_M <= '1';
                if AwaitResult_M = '1' then
                    Freq_Hz    <= (others => '0');
                    Freq_Valid <= '1';
                end if;
            end if;

            if ResultValid_M = '1' then
                Freq_Hz       <= std_logic_vector(resize(unsigned(Result_M), Freq_Hz'length));
                AwaitResult_M <= '0';
                Freq_Valid    <= '1';
            end if;

            if Rst = '1' then
                AwaitResult_M <= '0';
                Freq_Hz       <= (others => '0');
                Freq_Valid    <= '0';
            end if;

        end if;
    end process;

    p_meas : process (ClkTest) is
    begin
        if rising_edge(ClkTest) then

            ResultValid_T <= '0';

            if SecPulse_T = '1' then
                Result_T      <= toUslv(CntrTest_T, ResultWidth_c);
                CntrTest_T    <= 1;          -- the first edge implicitly arrived
                ResultValid_T <= '1';
            elsif CntrTest_T /= MaxClkTestFrequencyInt_c then
                CntrTest_T <= CntrTest_T + 1;
            end if;

            if Rst_T = '1' then
                CntrTest_T    <= 0;
                ResultValid_T <= '0';
            end if;
        end if;
    end process;

    i_sec_pulse : entity work.olo_base_strobe_gen
        generic map (
            FreqClkHz_g    => ClkFrequency_g,
            FreqStrobeHz_g => 1.0
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            Out_Valid   => SecPulse_M
        );

    i_sec_pulse_cc : entity work.olo_base_cc_pulse
        port map (
            In_Clk        => Clk,
            In_RstIn      => Rst,
            In_Pulse(0)   => SecPulse_M,
            Out_Clk       => ClkTest,
            Out_RstOut    => Rst_T,
            Out_Pulse(0)  => SecPulse_T
        );

    i_result_cc : entity work.olo_base_cc_simple
        generic map (
            Width_g     => ResultWidth_c
        )
        port map (
            In_Clk      => ClkTest,
            In_Data     => Result_T,
            In_Valid    => ResultValid_T,
            Out_Clk     => Clk,
            Out_RstIn   => Rst,
            Out_Data    => Result_M,
            Out_Valid   => ResultValid_M
        );

end architecture;
"
"The `olo_intf_debounce` component is a digital debounce filter designed to process asynchronous input signals and produce synchronized, debounced output signals. Its primary purpose is to eliminate glitches and noise from input signals, ensuring that only stable and valid data is transmitted to downstream components. This component is typically used in systems where reliable signal processing is crucial, such as in digital interfaces, communication systems, and control systems. The component has several input and output ports that play critical roles in its operation. The `Clk` port is a clock input that drives the internal logic and synchronization of the component, while the `Rst` port is an asynchronous reset signal that initializes the component to a known state. The `DataAsync` port is an input vector of width `Width_g`, which receives the asynchronous input signals to be debounced. The `DataOut` port is an output vector of the same width, providing the debounced and synchronized output signals. Internally, the component consists of several key elements. The `olo_intf_sync` entity is instantiated to synchronize the asynchronous input signals with the clock domain, producing the `DataSync` signal. A strobe generator, `olo_base_strobe_gen`, is optionally used to produce a tick signal (`Tick`) that drives the debouncing process. The core of the component is a two-process architecture, comprising a combinational process (`p_comb`) and a sequential process (`p_seq`). The `p_comb` process updates the internal state and produces the next state, while the `p_seq` process registers the state on the rising edge of the clock. The architectural description reveals a sophisticated internal structure. The component employs a counter-based approach to implement the debouncing algorithm. The `StableCnt` counter array tracks the stability of each input signal bit, and the `IsStable` signal vector indicates whether each bit has reached a stable state. The `LastState` register stores the last stable state of each input signal bit. The `DataOut` register produces the final debounced output signals. The functional behavior of the component can be described as follows. On power-up or reset, the component initializes the internal state to a known condition, with all counters and registers reset to their initial values. When the input signals change, the synchronizer produces a synchronized version of the input signals, which are then processed by the debouncing algorithm. The algorithm increments the stability counters for each bit that remains stable, and resets the counters when a bit changes. When a bit's stability counter reaches the debouncing threshold, it is considered stable, and its value is propagated to the output. The control logic of the component is governed by the `Mode_g` generic, which selects between two operating modes: `LOW_LATENCY` and `GLITCH_FILTER`. In `LOW_LATENCY` mode, the debounced output follows the synchronized input signals as soon as they are considered stable. In `GLITCH_FILTER` mode, the output is updated only when the input signal has been stable for the debouncing period and the current state is different from the previous stable state. The data flow through the component involves several transformations. The input signals are first synchronized with the clock domain, then processed by the debouncing algorithm, and finally, the debounced output signals are produced. The strobe generator, when used, produces a tick signal that drives the debouncing process. Timing and synchronization are critical aspects of the component's design. The component operates in a single clock domain, with all internal logic and registers clocked by the `Clk` signal. The component has specific setup and hold requirements for the input signals, which must be met to ensure proper operation. A notable feature of the component is its configurability. The debouncing time, input signal width, idle level, and operating mode can be tailored to specific application requirements through generics. The component also provides a flexible strobe generation mechanism, which can be used to optimize the debouncing process. The `olo_intf_debounce` component is suitable for a wide range of applications, including digital interface design, communication systems, and control systems. Its primary use cases involve situations where reliable signal processing is essential, and input signals may be prone to glitches or noise. In terms of implementation considerations, the component's performance and resource usage depend on the specific technology and synthesis settings used. However, the design has been optimized to minimize resource utilization while maintaining high performance. The component's configurability and flexibility make it an attractive solution for a variety of applications, and its robust debouncing algorithm ensures reliable operation in noisy or unstable environments. Overall, the `olo_intf_debounce` component is a versatile and reliable solution for digital system design.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_array.all;


entity olo_intf_debounce is
    generic (
        ClkFrequency_g  : real;
        DebounceTime_g  : real      := 20.0e-3;
        Width_g         : positive  := 1;
        IdleLevel_g     : std_logic := '0';
        Mode_g          : string    := ""LOW_LATENCY""    -- LOW_LATENCY or GLITCH_FILTER
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        DataAsync   : in    std_logic_vector(Width_g - 1 downto 0);
        DataOut     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;


architecture struct of olo_intf_debounce is

    constant TargetTickFrequency_c : real    := 1.0/(DebounceTime_g/31.0);
    constant TickCycles_c          : real    := ceil(ClkFrequency_g/TargetTickFrequency_c);
    constant ActualTickFrequency_c : real    := ClkFrequency_g/TickCycles_c;
    constant DebounceTicks_c       : integer := integer(ceil(DebounceTime_g*ActualTickFrequency_c));
    constant UseStrobeDiv_c        : boolean := integer(TickCycles_c) >= 2;

    constant Bits_c : integer := DataAsync'length;

    signal DataSync : std_logic_vector(DataAsync'range);
    signal Tick     : std_logic;

    subtype Cnt_t is integer range 0 to DebounceTicks_c;
    type Cnt_a is array (0 to Bits_c-1) of Cnt_t;

    type TwoProcess_r is record
        StableCnt : Cnt_a;
        LastState : std_logic_vector(Bits_c-1 downto 0);
        IsStable  : std_logic_vector(Bits_c-1 downto 0);
        DataOut   : std_logic_vector(Bits_c-1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert Mode_g = ""GLITCH_FILTER"" or Mode_g = ""LOW_LATENCY""
        report ""olo_intf_debounce: Illegal Mode_g - "" & Mode_g
        severity failure;

    assert DebounceTicks_c >= 10
        report ""olo_intf_debounce: DebounceTime too short (must be >= 10 clock cycles) - "" &
               ""DebounceTime_g="" & real'image(DebounceTime_g) & "" ClkFrequency_g="" & real'image(ClkFrequency_g)
        severity failure;

    p_comb : process (r, DataSync, Tick) is
        variable v : TwoProcess_r;
    begin
        v := r;

        for i in 0 to DataAsync'length-1 loop

            if Tick = '1' then
                if r.StableCnt(i) = DebounceTicks_c then
                    v.IsStable(i) := '1';
                else
                    v.StableCnt(i) := r.Stablecnt(i) + 1;
                end if;
            end if;

            if DataSync(i) /= r.LastState(i) then
                v.StableCnt(i) := 0;
                v.IsStable(i)  := '0';
            end if;

            if Mode_g = ""GLITCH_FILTER"" then
                if r.IsStable(i) = '1' then
                    v.DataOut(i) := r.LastState(i);
                end if;
            end if;

            if Mode_g = ""LOW_LATENCY"" then
                if r.IsStable(i) = '1' then
                    v.DataOut(i) := DataSync(i);
                end if;
            end if;
        end loop;

        v.LastState := DataSync;

        DataOut <= r.DataOut;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.StableCnt <= (others => DebounceTicks_c);
                r.LastState <= (others => IdleLevel_g);
                r.IsStable  <= (others => '1');
                r.DataOut   <= (others => IdleLevel_g);
            end if;
        end if;
    end process;

    i_sync : entity work.olo_intf_sync
        generic map (
            Width_g     => Width_g,
            RstLevel_g  => IdleLevel_g
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            DataAsync   => DataAsync,
            DataSync    => DataSync
        );

    g_use_strobe : if UseStrobeDiv_c generate

        i_tickgen : entity work.olo_base_strobe_gen
            generic map (
                FreqClkHz_g    => ClkFrequency_g,
                FreqStrobeHz_g => ActualTickFrequency_c
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                Out_Valid   => Tick
            );

    end generate;

    g_no_strobe : if not UseStrobeDiv_c generate
        Tick <= '1';
    end generate;

end architecture;"
"implements an I2C Master interface, specifically designed to interact with I2C slave devices. This component plays a crucial role in larger systems, enabling communication between the system's core logic and I2C peripherals. The I2C Master interface is a complex digital circuit that manages the I2C protocol, including start and stop conditions, data transmission, and arbitration. Its primary purpose is to translate the system's internal commands into I2C signals, facilitating data exchange with external I2C devices. The component has multiple input and output ports, each serving a distinct purpose. The clock input, `Clk`, drives the internal state machines and counters. The reset input, `Rst`, initializes the component to its idle state. The command inputs, `Cmd_Valid`, `Cmd_Command`, `Cmd_Data`, and `Cmd_Ack`, provide the necessary information for the I2C transactions. The response outputs, `Resp_Valid`, `Resp_Command`, `Resp_Data`, `Resp_Ack`, `Resp_ArbLost`, and `Resp_SeqErr`, indicate the status and results of the I2C operations. The I2C interface consists of the `I2c_Scl` and `I2c_Sda` ports, which are bi-directional and can be driven by either the component or external I2C devices. The `I2c_Scl_i`, `I2c_Scl_o`, `I2c_Scl_t`, `I2c_Sda_i`, `I2c_Sda_o`, and `I2c_Sda_t` ports provide additional control and status signals for the I2C interface. Internally, the component consists of a state machine, counters, and registers. The state machine, defined by the `Fsm_t` type, manages the I2C protocol and transitions between various states, such as `BusIdle_s`, `BusBusy_s`, `Start1_s`, and `DataBit1_s`. The counters, including `BusBusyToCnt`, `TimeoutCmdCnt`, and `QuartPeriodCnt`, track timeouts, bus busy conditions, and quarter-period intervals. The component's architectural description reveals a complex interplay between the state machine, counters, and registers. The state machine's transitions are determined by the current state, input commands, and I2C interface signals. The counters and registers are used to implement timeouts, track bus busy conditions, and store data for transmission. The component's functional behavior can be described step-by-step. When in the idle state, the component waits for a valid command. Upon receiving a start command, it transitions to the start state, generating the I2C start condition. The component then proceeds to transmit data, receive data, or perform other I2C operations based on the command type. The control logic is implemented using a combination of state machine transitions, counters, and conditional statements. The component's reset behavior is defined by the `Rst` input, which initializes the state machine, counters, and registers to their default values. Data flow through the component involves the transmission and reception of I2C data. The component stores data in the `ShReg` register and transmits it over the I2C interface. Received data is stored in the `ShReg` register and made available to the system. The component's timing and synchronization are critical to its operation. The `Clk` input drives the internal state machines and counters, while the `Rst` input synchronizes the component's reset. The I2C interface signals, `I2c_Scl` and `I2c_Sda`, are synchronized using the `I2cScl_Sync` and `I2cSda_Sync` signals. The component features several special modes of operation, including an internal tri-state buffer, which can be enabled or disabled using the `InternalTriState_g` generic. The component also supports command timeouts and bus busy detection. The I2C Master interface is typically used in systems that require communication with I2C peripherals, such as microcontrollers, sensors, and actuators. Its applications include industrial control systems, automotive electronics, and consumer electronics. Implementation considerations include performance, resource usage, and design trade-offs. The component's performance is influenced by the clock frequency, I2C frequency, and timeout values. Resource usage is determined by the component's complexity, including the state machine, counters, and registers. Design trade-offs involve balancing performance, area, and power consumption. In conclusion, the provided VHDL code implements a comprehensive I2C Master interface, enabling communication between systems and I2C peripherals. Its complex architecture, state machines, counters, and registers work together to manage the I2C protocol, ensuring reliable data transmission and reception. The component's features, such as internal tri-state buffers, command timeouts, and bus busy detection, make it suitable for a wide range of applications.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

package olo_intf_i2c_master_pkg is

    constant I2cCmd_Start_c    : std_logic_vector(2 downto 0) := ""000"";
    constant I2cCmd_Stop_c     : std_logic_vector(2 downto 0) := ""001"";
    constant I2cCmd_RepStart_c : std_logic_vector(2 downto 0) := ""010"";
    constant I2cCmd_Send_c     : std_logic_vector(2 downto 0) := ""011"";
    constant I2cCmd_Receive_c  : std_logic_vector(2 downto 0) := ""100"";

end package;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_intf_i2c_master_pkg.all;

entity olo_intf_i2c_master is
    generic (
        ClkFrequency_g      : real;
        I2cFrequency_g      : real    := 100.0e3;
        BusBusyTimeout_g    : real    := 1.0e-3;
        CmdTimeout_g        : real    := 1.0e-3;
        InternalTriState_g  : boolean := true;
        DisableAsserts_g    : boolean := false
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Cmd_Ready       : out   std_logic;
        Cmd_Valid       : in    std_logic;
        Cmd_Command     : in    std_logic_vector(2 downto 0);
        Cmd_Data        : in    std_logic_vector(7 downto 0);
        Cmd_Ack         : in    std_logic;
        Resp_Valid      : out   std_logic;
        Resp_Command    : out   std_logic_vector(2 downto 0);
        Resp_Data       : out   std_logic_vector(7 downto 0);
        Resp_Ack        : out   std_logic;
        Resp_ArbLost    : out   std_logic;
        Resp_SeqErr     : out   std_logic;
        Status_BusBusy  : out   std_logic;
        Status_CmdTo    : out   std_logic;
        I2c_Scl         : inout std_logic := 'Z';
        I2c_Sda         : inout std_logic := 'Z';
        I2c_Scl_i       : in    std_logic := '0';
        I2c_Scl_o       : out   std_logic;
        I2c_Scl_t       : out   std_logic;
        I2c_Sda_i       : in    std_logic := '0';
        I2c_Sda_o       : out   std_logic;
        I2c_Sda_t       : out   std_logic
    );
end entity;

architecture rtl of olo_intf_i2c_master is

    constant BusyTimoutLimit_c    : integer := integer(ClkFrequency_g * BusBusyTimeout_g) - 1;
    constant QuarterPeriodLimit_c : integer := integer(ceil(ClkFrequency_g / I2cFrequency_g / 4.0)) - 1;
    constant CmdTimeoutLimit_c    : integer := integer(ClkFrequency_g * CmdTimeout_g) - 1;

    type Fsm_t is (
        BusIdle_s, BusBusy_s, MinIdle_s, Start1_s, Start2_s, WaitCmd_s, WaitLowCenter_s,
        Stop1_s, Stop2_s, Stop3_s, RepStart1_s, DataBit1_s, DataBit2_s, DataBit3_s, DataBit4_s, ArbitLost_s
    );

    type TwoProcess_r is record
        Status_BusBusy : std_logic;
        Cmd_Ready      : std_logic;
        SclLast        : std_logic;
        SdaLast        : std_logic;
        BusBusyToCnt   : unsigned(log2ceil(BusyTimoutLimit_c + 1) - 1 downto 0);
        TimeoutCmdCnt  : unsigned(log2ceil(CmdTimeoutLimit_c + 1) - 1 downto 0);
        QuartPeriodCnt : unsigned(log2ceil(QuarterPeriodLimit_c + 1) - 1 downto 0);
        QPeriodTick    : std_logic;
        CmdTypeLatch   : std_logic_vector(Cmd_Command'range);
        CmdAckLatch    : std_logic;
        Fsm            : Fsm_t;
        SclOut         : std_logic;
        SdaOut         : std_logic;
        Resp_Valid     : std_logic;
        Resp_Ack       : std_logic;
        Resp_SeqErr    : std_logic;
        Resp_Data      : std_logic_vector(7 downto 0);
        Resp_ArbLost   : std_logic;
        BitCnt         : unsigned(3 downto 0); -- 8 Data + 1 Ack = 9 = 4 bits
        ShReg          : std_logic_vector(8 downto 0);
        CmdTimeout     : std_logic;
        Status_CmdTo   : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    attribute dont_touch of r : signal is DontTouch_SuppressChanges_c;

    signal I2cScl_Input : std_logic;
    signal I2cSda_Input : std_logic;
    signal I2cScl_Sync  : std_logic;
    signal I2cSda_Sync  : std_logic;

begin

    p_comb : process (r, I2cScl_Sync, I2cSda_Sync, Cmd_Valid, Cmd_Command, Cmd_Data, Cmd_Ack) is
        variable v                     : TwoProcess_r;
        variable SdaRe_v, SdaFe_v      : std_logic;
        variable I2cStart_v, I2cStop_v : std_logic;
    begin
        v := r;

        SdaRe_v   := not r.SdaLast and I2cSda_Sync;
        SdaFe_v   := r.SdaLast and not I2cSda_Sync;
        v.SclLast := I2cScl_Sync;
        v.SdaLast := I2cSda_Sync;

        I2cStart_v := r.SclLast and I2cScl_Sync and SdaFe_v;
        I2cStop_v  := r.SclLast and I2cScl_Sync and SdaRe_v;

        v.QPeriodTick := '0';
        if (r.Fsm = BusIdle_s) or (r.Fsm = BusBusy_s) then
            v.QuartPeriodCnt := (others => '0');
        elsif r.QuartPeriodCnt = QuarterPeriodLimit_c then
            v.QuartPeriodCnt := (others => '0');
            v.QPeriodTick    := '1';
        else
            v.QuartPeriodCnt := r.QuartPeriodCnt + 1;
        end if;

        if r.Fsm = WaitCmd_s then
            if r.TimeoutCmdCnt = CmdTimeoutLimit_c then
                v.CmdTimeout := '1';
            else
                v.TimeoutCmdCnt := r.TimeoutCmdCnt + 1;
            end if;
        else
            v.TimeoutCmdCnt := (others => '0');
        end if;

        if (r.Cmd_Ready = '1') and (Cmd_Valid = '1') then
            v.CmdTypeLatch := Cmd_Command;
            v.CmdAckLatch  := Cmd_Ack;
        end if;

        v.Resp_Valid   := '0';
        v.Resp_Ack     := not r.ShReg(0);
        v.Resp_Data    := r.ShReg(8 downto 1);
        v.Resp_SeqErr  := '0';
        v.Resp_ArbLost := '0';
        v.Status_CmdTo := '0';
        v.Cmd_Ready    := '0';

        case r.Fsm is

            when BusIdle_s =>
                v.Cmd_Ready    := '1';
                v.BusBusyToCnt := (others => '0');
                v.SclOut       := '1';
                v.SdaOut       := '1';
                v.CmdTimeout   := '0';

                if (r.Cmd_Ready = '1') and (Cmd_Valid = '1') then
                    assert (Cmd_Command = I2cCmd_Start_c) or DisableAsserts_g
                        report ""###ERROR###: olo_intf_i2c_master: In idle state, only I2cCmd_Start_c commands are allowed!""
                        severity error;
                    v.CmdTypeLatch := Cmd_Command;
                    if Cmd_Command = I2cCmd_Start_c then
                        v.Fsm       := Start1_s;
                        v.Cmd_Ready := '0';
                    else
                        v.Resp_Valid  := '1';
                        v.Resp_SeqErr := '1';
                    end if;
                elsif (I2cScl_Sync = '0') or (I2cStart_v = '1') then
                    v.Fsm       := BusBusy_s;
                    v.Cmd_Ready := '0';
                end if;

            when BusBusy_s =>
                if I2cStop_v = '1' then
                    v.Fsm := MinIdle_s;
                end if;
                if I2cScl_Sync = '0' then
                    v.BusBusyToCnt := (others => '0');
                elsif r.BusBusyToCnt = BusyTimoutLimit_c then
                    v.Fsm := BusIdle_s;
                else
                    v.BusBusyToCnt := r.BusBusyToCnt + 1;
                end if;

                v.SclOut := '1';
                v.SdaOut := '1';

            when MinIdle_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := BusIdle_s;
                end if;

                v.SclOut := '1';
                v.SdaOut := '1';

            when Start1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Start2_s;
                end if;

                if I2cScl_Sync = '0' and r.CmdTypeLatch = I2cCmd_RepStart_c then
                    v.QuartPeriodCnt := (others => '0');
                end if;

                if I2cSda_Sync = '0' then
                    v.Fsm := ArbitLost_s;
                end if;

                v.SclOut := '1';
                v.SdaOut := '1';

            when Start2_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm        := WaitCmd_s;
                    v.Resp_Valid := '1';
                end if;
                v.SclOut := '1';
                v.SdaOut := '0';


            when WaitCmd_s =>
                v.Cmd_Ready := '1';
                v.SclOut    := '0';

                if (r.Cmd_Ready = '1') and (Cmd_Valid = '1') then
                    assert (Cmd_Command = I2cCmd_Stop_c) or (Cmd_Command = I2cCmd_RepStart_c) or
                           (Cmd_Command = I2cCmd_Send_c) or (Cmd_Command = I2cCmd_Receive_c) or DisableAsserts_g
                        report ""###ERROR###: olo_intf_i2c_master: In WaitCmd_s state, I2cCmd_Start_c commands are not allowed!""
                        severity error;
                    if (Cmd_Command = I2cCmd_Stop_c) or (Cmd_Command = I2cCmd_RepStart_c) or
                       (Cmd_Command = I2cCmd_Send_c) or (Cmd_Command = I2cCmd_Receive_c) then
                        v.Fsm       := WaitLowCenter_s;
                        v.Cmd_Ready := '0';
                    else
                        v.Resp_Valid  := '1';
                        v.Resp_SeqErr := '1';
                    end if;
                    v.ShReg := Cmd_Data & '0';
                elsif r.CmdTimeout = '1' then
                    v.Fsm          := WaitLowCenter_s;
                    v.Cmd_Ready    := '0';
                    v.Status_CmdTo := '1';
                end if;

            when WaitLowCenter_s =>
                v.SclOut := '0';
                v.BitCnt := (others => '0');

                if r.QPeriodTick = '1' then
                    if r.CmdTimeout = '1' then
                        v.Fsm := Stop1_s;
                    else

                        case r.CmdTypeLatch is
                            when I2cCmd_Stop_c => v.Fsm := Stop1_s;
                            when I2cCmd_RepStart_c => v.Fsm := RepStart1_s;
                            when I2cCmd_Send_c => v.Fsm := DataBit1_s;
                            when I2cCmd_Receive_c => v.Fsm := DataBit1_s;
                            when others => null; -- unreacable code
                        end case;

                    end if;
                end if;


            when RepStart1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Start1_s;

                    if I2cSda_Sync = '0' then
                        v.Fsm := ArbitLost_s;
                    end if;
                end if;
                v.SclOut := '0';
                v.SdaOut := '1';


            when DataBit1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := DataBit2_s;
                end if;
                v.SclOut := '0';

                if r.CmdTypeLatch = I2cCmd_Send_c then
                    if r.BitCnt = 8 then
                        v.SdaOut := '1';
                    else
                        v.SdaOut := r.ShReg(8);
                    end if;
                else
                    if r.BitCnt = 8 then
                        if r.CmdAckLatch = '1' then
                            v.SdaOut := '0';
                        else
                            v.SdaOut := '1';
                        end if;
                    else
                        v.SdaOut := '1';
                    end if;
                end if;

            when DataBit2_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := DataBit3_s;
                    v.ShReg := r.ShReg(7 downto 0) & I2cSda_Sync;
                end if;
                v.SclOut := '1';

                if I2cScl_Sync = '0' then
                    v.QuartPeriodCnt := (others => '0');
                end if;

                if (r.CmdTypeLatch = I2cCmd_Send_c) and (r.BitCnt /= 8) then
                    if I2cSda_Sync /= r.SdaOut then
                        v.Fsm := ArbitLost_s;
                    end if;
                end if;

            when DataBit3_s =>
                if r.QPeriodTick = '1' then
                    if r.BitCnt = 8 then
                        v.Fsm        := WaitCmd_s;
                        v.Resp_Valid := '1';
                    else
                        v.Fsm := DataBit4_s;
                    end if;
                end if;
                v.SclOut := '1';

                if (r.CmdTypeLatch = I2cCmd_Send_c) and (r.BitCnt /= 8) then
                    if I2cSda_Sync /= r.SdaOut then
                        v.Fsm := ArbitLost_s;
                    end if;
                end if;

            when DataBit4_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm    := DataBit1_s;
                    v.BitCnt := r.BitCnt + 1;
                end if;
                v.SclOut := '0';


            when Stop1_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Stop2_s;
                end if;
                v.SclOut := '0';
                v.SdaOut := '0';

            when Stop2_s =>
                if r.QPeriodTick = '1' then
                    v.Fsm := Stop3_s;
                end if;
                v.SclOut := '1';
                v.SdaOut := '0';

                if I2cScl_Sync = '0' then
                    v.QuartPeriodCnt := (others => '0');
                end if;

            when Stop3_s =>
                if r.QPeriodTick = '1' then
                    if I2cSda_Sync = '0' then
                        v.Fsm := ArbitLost_s;
                    else
                        v.Fsm := BusIdle_s;
                        if r.CmdTimeout = '0' then
                            v.Resp_Valid := '1';
                        end if;
                    end if;
                end if;
                v.SclOut := '1';
                v.SdaOut := '1';

            when ArbitLost_s =>
                v.Fsm          := BusBusy_s;
                v.Resp_Valid   := '1';
                v.Resp_Ack     := '0';
                v.Resp_ArbLost := '1';
                v.SclOut       := '1';
                v.SdaOut       := '1';

            when others => null; -- unreacable code
        end case;

        if r.Fsm = BusIdle_s then
            v.Status_BusBusy := '0';
        else
            v.Status_BusBusy := '1';
        end if;

        r_next <= v;
    end process;

    Status_BusBusy <= r.Status_BusBusy;
    Cmd_Ready      <= r.Cmd_Ready;
    Resp_Valid     <= r.Resp_Valid;
    Resp_Command   <= r.CmdTypeLatch;
    Resp_ArbLost   <= r.Resp_ArbLost;
    Resp_Ack       <= r.Resp_Ack;
    Resp_Data      <= r.Resp_Data;
    Resp_SeqErr    <= r.Resp_SeqErr;
    Status_CmdTo   <= r.Status_CmdTo;

    g_int_tristate : if InternalTriState_g generate
        I2c_Scl   <= 'Z' when r.SclOut = '1' else '0';
        I2c_Sda   <= 'Z' when r.SdaOut = '1' else '0';
        I2c_Scl_o <= '0';
        I2c_Sda_o <= '0';
        I2c_Scl_t <= '1';
        I2c_Sda_t <= '1';
    end generate;

    g_ext_tristatte : if not InternalTriState_g generate
        I2c_Scl_o <= r.SclOut;
        I2c_Sda_o <= r.SdaOut;
        I2c_Scl_t <= r.SclOut;
        I2c_Sda_t <= r.SdaOut;
        I2c_Scl   <= 'Z';
        I2c_Sda   <= 'Z';
    end generate;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Status_BusBusy <= '0';
                r.Cmd_Ready      <= '0';
                r.SclLast        <= '1';
                r.SdaLast        <= '1';
                r.BusBusyToCnt   <= (others => '0');
                r.Fsm            <= BusIdle_s;
                r.SclOut         <= '1';
                r.SdaOut         <= '1';
                r.Resp_Valid     <= '0';
            end if;
        end if;
    end process;

    I2cScl_Input <= to01X(I2c_Scl) when InternalTriState_g else I2c_Scl_i;
    I2cSda_Input <= to01X(I2c_Sda) when InternalTriState_g else I2c_Sda_i;

    i_sync : entity work.olo_intf_sync
        generic map (
            Width_g     => 2
        )
        port map (
            Clk             => Clk,
            DataAsync(0)    => I2cScl_Input,
            DataAsync(1)    => I2cSda_Input,
            DataSync(0)     => I2cScl_Sync,
            DataSync(1)     => I2cSda_Sync
        );

end architecture;"
"The `olo_intf_spi_master` component is a VHDL implementation of a SPI (Serial Peripheral Interface) master module. Its primary purpose is to facilitate communication between a system-on-chip (SoC) and one or more SPI slave devices. The component generates the SPI clock (`Spi_Sclk`), chip select (`Spi_Cs_n`), and MOSI (Master Out Slave In) signals, while receiving the MISO (Master In Slave Out) signal from the slave device. The component has several input ports, including `Clk` (the system clock), `Rst` (the reset signal), `Cmd_Valid` (a command valid signal), `Cmd_Slave` (the slave device address), `Cmd_Data` (the data to be transmitted), and `Cmd_TransWidth` (the transaction width). The output ports include `Cmd_Ready` (a command ready signal), `Resp_Valid` (a response valid signal), `Resp_Data` (the received data), `Spi_Sclk`, `Spi_Mosi`, and `Spi_Cs_n`. Internally, the component uses a state machine to manage the SPI transaction. The state machine has five states: `Idle_s`, `SftComp_s`, `ClkInact_s`, `ClkAct_s`, and `CsHigh_s`. The `Idle_s` state is the initial state, where the component waits for a valid command. When a command is received, the component transitions to the `SftComp_s` state, where it prepares the shift register and chip select signal. The `ClkInact_s` and `ClkAct_s` states handle the SPI clock generation and data shifting, while the `CsHigh_s` state manages the chip select signal deassertion. The component uses several registers and counters to manage the SPI transaction. The `shiftReg` register stores the data to be transmitted, and the `RdData` register stores the received data. The `ClkDivCnt` counter divides the system clock to generate the SPI clock, while the `BitCnt` counter tracks the number of bits transmitted. The `CsHighCnt` counter manages the chip select signal deassertion. The component's control logic is driven by the state machine and the input signals. The `Cmd_Valid` signal triggers the start of a new transaction, and the `Cmd_Ready` signal indicates that the component is ready to accept a new command. The `Resp_Valid` signal indicates that the component has received data from the slave device. Data flows through the component as follows: the `Cmd_Data` input is stored in the `shiftReg` register, and then shifted out to the `Spi_Mosi` output during the SPI transaction. The `SpiMiso_i` input is sampled during the SPI transaction and stored in the `RdData` register. The component has specific timing and synchronization requirements. The `Clk` input is used to generate the SPI clock, and the component has setup and hold requirements for the `Cmd_Valid`, `Cmd_Slave`, `Cmd_Data`, and `Cmd_TransWidth` inputs. One of the special features of this component is its support for different SPI modes, as defined by the `SpiCpol_g` and `SpiCpha_g` generics. The component also has a `LsbFirst_g` generic that allows for LSB-first or MSB-first data transmission. The `olo_intf_spi_master` component is typically used in systems that require SPI communication with one or more slave devices. It can be used in a variety of applications, such as embedded systems, microcontrollers, and SoCs. In terms of implementation considerations, the component's performance is dependent on the system clock frequency and the SPI clock frequency. The component's resource usage is moderate, as it requires several registers, counters, and a state machine. Design trade-offs include optimizing the component for low power consumption or high performance, depending on the specific application requirements. The component's generics provide flexibility in configuring the SPI interface. For example, the `SclkFreq_g` generic allows the user to specify the desired SPI clock frequency, while the `MaxTransWidth_g` generic sets the maximum transaction width. The `CsHighTime_g` generic controls the chip select signal deassertion time. Overall, the `olo_intf_spi_master` component is a comprehensive and flexible SPI master module that can be used in a wide range of applications. Its internal structure, control logic, and data flow are designed to provide reliable and efficient SPI communication with one or more slave devices.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_attribute.all;

entity olo_intf_spi_master is
    generic (
        ClkFreq_g       : real;
        SclkFreq_g      : real                 := 1.0e6;
        MaxTransWidth_g : positive             := 32;
        CsHighTime_g    : real                 := 20.0e-9;
        SpiCpol_g       : natural range 0 to 1 := 1;
        SpiCpha_g       : natural range 0 to 1 := 1;
        SlaveCnt_g      : positive             := 1;
        LsbFirst_g      : boolean              := false;
        MosiIdleState_g : std_logic            := '0'
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Cmd_Valid       : in    std_logic;
        Cmd_Ready       : out   std_logic;
        Cmd_Slave       : in    std_logic_vector(log2ceil(SlaveCnt_g) - 1 downto 0)      := (others => '0');
        Cmd_Data        : in    std_logic_vector(MaxTransWidth_g - 1 downto 0)           := (others => '0');
        Cmd_TransWidth  : in    std_logic_vector(log2ceil(MaxTransWidth_g+1)-1 downto 0) := toUslv(MaxTransWidth_g, log2ceil(MaxTransWidth_g+1));
        Resp_Valid      : out   std_logic;
        Resp_Data       : out   std_logic_vector(MaxTransWidth_g - 1 downto 0);
        Spi_Sclk        : out   std_logic;
        Spi_Mosi        : out   std_logic;
        Spi_Miso        : in    std_logic                                                := '0';
        Spi_Cs_n        : out   std_logic_vector(SlaveCnt_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_intf_spi_master is

    type State_t is (Idle_s, SftComp_s, ClkInact_s, ClkAct_s, CsHigh_s);

    constant ClkDiv_c         : natural := integer(round(ClkFreq_g/SclkFreq_g));
    constant ClkDivThres_c    : natural := ClkDiv_c / 2 - 1;
    constant CsHighCycles_c   : natural := integer(ceil(ClkFreq_g*CsHighTime_g));
    constant SclkFreqResult_c : real    := ClkFreq_g/(2.0*real(ClkDivThres_c+1));

    type TwoProcess_r is record
        State      : State_t;
        StateLast  : State_t;
        shiftReg   : std_logic_vector(MaxTransWidth_g - 1 downto 0);
        RdData     : std_logic_vector(MaxTransWidth_g - 1 downto 0);
        Spi_Cs_n   : std_logic_vector(SlaveCnt_g - 1 downto 0);
        Spi_Sclk   : std_logic;
        Spi_Mosi   : std_logic;
        ClkDivCnt  : integer range 0 to ClkDivThres_c;
        BitCnt     : integer range 0 to MaxTransWidth_g;
        CsHighCnt  : integer range 0 to CsHighCycles_c - 1;
        Busy       : std_logic;
        Done       : std_logic;
        MosiNext   : std_logic;
        TransWidth : integer range 0 to MaxTransWidth_g;
    end record;

    signal r, r_next : TwoProcess_r;

    signal SpiMiso_i : std_logic;

    attribute dont_merge of SpiMiso_i   : signal is DontMerge_SuppressChanges_c;
    attribute preserve of SpiMiso_i     : signal is Preserve_SuppressChanges_c;
    attribute keep of SpiMiso_i         : signal is Keep_SuppressChanges_c;
    attribute dont_touch of SpiMiso_i   : signal is DontTouch_SuppressChanges_c;
    attribute syn_keep of SpiMiso_i     : signal is SynKeep_SuppressChanges_c;
    attribute syn_preserve of SpiMiso_i : signal is SynPreserve_SuppressChanges_c;

    function getClockLevel (ClkActive : boolean) return std_logic is
    begin
        if SpiCpol_g = 0 then
            if ClkActive then
                return '1';
            else
                return '0';
            end if;
        else
            if ClkActive then
                return '0';
            else
                return '1';
            end if;
        end if;
    end function;

    procedure shiftReg (
        signal BeforeShift  : in std_logic_vector(MaxTransWidth_g-1 downto 0);
        variable AfterShift : out std_logic_vector(MaxTransWidth_g-1 downto 0);
        signal InputBit     : in std_logic;
        variable OutputBit  : out std_logic;
        TransWidth          : in integer range 0 to MaxTransWidth_g) is
    begin
        if LsbFirst_g then
            OutputBit                := BeforeShift(0);
            AfterShift               := '0' & BeforeShift(BeforeShift'high downto 1);
            AfterShift(TransWidth-1) := InputBit;
        else
            OutputBit  := BeforeShift(TransWidth-1);
            AfterShift := BeforeShift(BeforeShift'high - 1 downto 0) & InputBit;
        end if;
    end procedure;

begin

    assert abs(SclkFreqResult_c/SclkFreq_g - 1.0) < 0.1
        report ""###ERROR###: olo_intf_spi_master - SclkFreq_g is not within 10% of the actual Sclk frequency""
        severity error;

    SpiMiso_i <= Spi_Miso;

    p_comb : process (r, Cmd_Valid, Cmd_Data, SpiMiso_i, Cmd_Slave, Cmd_TransWidth) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.Done := '0';

        case r.State is
            when Idle_s =>
                if Cmd_Valid = '1' then
                    v.shiftReg                                  := Cmd_Data;
                    v.Spi_Cs_n(to_integer(unsigned(Cmd_Slave))) := '0';
                    v.State                                     := SftComp_s;
                    v.Busy                                      := '1';
                    v.TransWidth                                := fromUslv(Cmd_TransWidth);
                end if;
                v.CsHighCnt := 0;
                v.ClkDivCnt := 0;
                v.BitCnt    := 0;

            when SftComp_s =>
                v.State := ClkInact_s;
                if SpiCpha_g = 0 then
                    shiftReg(r.shiftReg, v.shiftReg, SpiMiso_i, v.MosiNext, r.TransWidth);
                end if;

            when ClkInact_s =>
                v.Spi_Sclk := getClockLevel(false);
                if r.ClkDivCnt = 0 then
                    if SpiCpha_g = 0 then
                        v.Spi_Mosi := r.MosiNext;
                    else
                        shiftReg(r.shiftReg, v.shiftReg, SpiMiso_i, v.MosiNext, r.TransWidth);
                    end if;
                end if;
                if r.ClkDivCnt = ClkDivThres_c then
                    if r.BitCnt = r.TransWidth then
                        v.Spi_Mosi := MosiIdleState_g;
                        v.State    := CsHigh_s;
                    else
                        v.State := ClkAct_s;
                    end if;
                    v.ClkDivCnt := 0;
                else
                    v.ClkDivCnt := r.ClkDivCnt + 1;
                end if;

            when ClkAct_s =>
                v.Spi_Sclk := getClockLevel(true);
                if r.ClkDivCnt = 0 then
                    if SpiCpha_g = 1 then
                        v.Spi_Mosi := r.MosiNext;
                    else
                        shiftReg(r.shiftReg, v.shiftReg, SpiMiso_i, v.MosiNext, r.TransWidth);
                    end if;
                end if;
                if r.ClkDivCnt = ClkDivThres_c then
                    v.State     := ClkInact_s;
                    v.ClkDivCnt := 0;
                    v.BitCnt    := r.BitCnt + 1;
                else
                    v.ClkDivCnt := r.ClkDivCnt + 1;
                end if;

            when CsHigh_s =>
                v.Spi_Cs_n := (others => '1');
                if r.CsHighCnt = CsHighCycles_c - 1 then
                    v.State  := Idle_s;
                    v.Busy   := '0';
                    v.Done   := '1';
                    v.RdData := r.shiftReg;
                else
                    v.CsHighCnt := r.CsHighCnt + 1;
                end if;

            when others => null; -- unreachable code
        end case;

        r_next <= v;
    end process;

    Cmd_Ready  <= not r.Busy;
    Resp_Valid <= r.Done;
    Resp_Data  <= r.RdData;
    Spi_Sclk   <= r.Spi_Sclk;
    Spi_Cs_n   <= r.Spi_Cs_n;
    Spi_Mosi   <= r.Spi_Mosi;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.State    <= Idle_s;
                r.Spi_Cs_n <= (others => '1');
                r.Spi_Sclk <= getClockLevel(false);
                r.Busy     <= '0';
                r.Done     <= '0';
                r.Spi_Mosi <= MosiIdleState_g;
            end if;
        end if;
    end process;

end architecture;"
"The `olo_intf_spi_slave` component is a VHDL implementation of a Serial Peripheral Interface (SPI) slave module. Its primary purpose is to facilitate communication between a master device and a slave device over an SPI bus. The component is designed to operate in a variety of configurations, supporting different data widths, clock polarities, and phase relationships. The component has several input and output ports that facilitate its operation. The clock input, `Clk`, drives the internal sequential logic, while the reset input, `Rst`, initializes the component to a known state. The `Tx_Data` and `Tx_Valid` inputs provide the data to be transmitted and a validity signal, respectively. The `Rx_Data` and `Rx_Valid` outputs provide the received data and a validity signal, respectively. The `Spi_Sclk`, `Spi_Mosi`, and `Spi_Cs_n` inputs are the SPI clock, master output slave input, and chip select signals, respectively. The `Spi_Miso`, `Spi_Miso_o`, and `Spi_Miso_t` outputs provide the slave output, which can be configured as either a tristate output or a standard output with a separate tristate control. Internally, the component consists of a state machine that manages the SPI transaction. The state machine has several states, including `Idle_s`, `LatchTx_s`, `WaitSampleEdge_s`, `WaitInactiveEdge_s`, and `WaitCsHigh_s`. The state machine transitions between these states based on the SPI clock and chip select signals. The `LatchTx_s` state latches the transmit data, while the `WaitSampleEdge_s` state samples the incoming data on the SPI clock edge. The `WaitInactiveEdge_s` state waits for the SPI clock to become inactive before transitioning to the next state. The component also features a shift register that serializes the transmit data and deserializes the received data. The shift register is controlled by the state machine and is used to implement the SPI protocol. The component also includes control logic that manages the tristate output, validity signals, and error detection. The component's control logic is responsible for generating the `Tx_Ready`, `Rx_Valid`, `Resp_Sent`, `Resp_Aborted`, and `Resp_CleanEnd` signals. These signals indicate the status of the SPI transaction, including whether the transmit data is ready, the received data is valid, and whether the response was sent or aborted. The component's data flow is straightforward, with data moving from the `Tx_Data` input to the `Rx_Data` output through the shift register. The component also performs data transformations, such as serializing and deserializing the data. The component's timing and synchronization are critical to its operation. The component uses a clock domain to synchronize the SPI clock and data signals. The component also has setup and hold requirements for the SPI clock and data signals to ensure proper operation. One of the special features of this component is its support for consecutive transactions. When `ConsecutiveTransactions_g` is true, the component can handle back-to-back transactions without returning to the idle state. The component also supports internal tristate output, which can be configured using the `InternalTriState_g` generic. The `olo_intf_spi_slave` component is typically used in systems that require SPI communication, such as microcontrollers, sensors, and actuators. The component's flexibility and configurability make it suitable for a wide range of applications. In terms of implementation considerations, the component's performance is dependent on the clock frequency and the SPI clock rate. The component's resource usage is moderate, with a small number of logic cells and registers required. The design trade-offs include optimizing the component for area, speed, or power consumption, depending on the specific application requirements. Overall, the `olo_intf_spi_slave` component is a well-designed and flexible SPI slave module that can be used in a variety of applications. Its configurability, internal tristate output, and support for consecutive transactions make it an attractive solution for system designers.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_intf_spi_slave is
    generic (
        TransWidth_g                : positive             := 32;
        SpiCpol_g                   : natural range 0 to 1 := 0;
        SpiCpha_g                   : natural range 0 to 1 := 0;
        LsbFirst_g                  : boolean              := false;
        ConsecutiveTransactions_g   : boolean              := false;
        InternalTriState_g          : boolean              := true
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Rx_Valid        : out   std_logic;
        Rx_Data         : out   std_logic_vector(TransWidth_g - 1 downto 0);
        Tx_Valid        : in    std_logic                                   := '1';
        Tx_Ready        : out   std_logic;
        Tx_Data         : in    std_logic_vector(TransWidth_g - 1 downto 0) := (others => '0');
        Resp_Valid      : out   std_logic;
        Resp_Sent       : out   std_logic;
        Resp_Aborted    : out   std_logic;
        Resp_CleanEnd   : out   std_logic;
        Spi_Sclk        : in    std_logic;
        Spi_Mosi        : in    std_logic                                   := '0';
        Spi_Cs_n        : in    std_logic;
        Spi_Miso        : out   std_logic;
        Spi_Miso_o      : out   std_logic;
        Spi_Miso_t      : out   std_logic
    );
end entity;

architecture rtl of olo_intf_spi_slave is

    type State_t is (Idle_s, LatchTx_s, WaitSampleEdge_s, WaitInactiveEdge_s, WaitCsHigh_s);

    type TwoProcess_r is record
        SpiCsnLast      : std_logic;
        SpiSclkLast     : std_logic;
        State           : State_t;
        Tx_Ready        : std_logic;
        SpiMisoData     : std_logic;
        SpiMisoTristate : std_logic;
        BitCnt          : integer range 0 to TransWidth_g;
        ShiftReg        : std_logic_vector(TransWidth_g - 1 downto 0);
        IsConsecutive   : boolean;
        Rx_Valid        : std_logic;
        Rx_Data         : std_logic_vector(TransWidth_g - 1 downto 0);
        Resp_Sent       : std_logic;
        Resp_Aborted    : std_logic;
        Resp_Valid      : std_logic;
        Resp_CleanEnd   : std_logic;
        RxOutput        : std_logic;
        DataLatched     : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal SpiMosi_i : std_logic;
    signal SpiSclk_i : std_logic;
    signal SpiCsn_i  : std_logic;

    constant TxIdx_c : integer := choose(LsbFirst_g, 0, TransWidth_g - 1);

begin

    p_comb : process (r, Tx_Data, Tx_Valid, SpiSclk_i, SpiMosi_i, SpiCsn_i) is
        variable v                  : TwoProcess_r;
        variable CsnRe_v, CsnFe_v   : std_logic;
        variable SclkRe_v, SclkFe_v : std_logic;
        variable SampleEdge_v       : std_logic;
        variable TrasmitEdge_v      : std_logic;
        variable LeaveState_v       : boolean;
    begin
        v := r;

        CsnRe_v         := '0';
        CsnFe_v         := '0';
        SclkRe_v        := '0';
        SclkFe_v        := '0';
        LeaveState_v    := false;
        v.Rx_Valid      := '0';
        v.Resp_Sent     := '0';
        v.Resp_Aborted  := '0';
        v.Resp_Valid    := '0';
        v.RxOutput      := '0';
        v.Resp_CleanEnd := '0';

        if SpiCsn_i /= to01(r.SpiCsnLast) then
            CsnRe_v := SpiCsn_i;
            CsnFe_v := not SpiCsn_i;
        end if;
        v.SpiCsnLast := SpiCsn_i;
        if SpiSclk_i /= to01(r.SpiSclkLast) then
            SclkRe_v := SpiSclk_i;
            SclkFe_v := not SpiSclk_i;
        end if;
        v.SpiSclkLast := SpiSclk_i;
        if SpiCpol_g = SpiCpha_g then
            SampleEdge_v  := SclkRe_v;
            TrasmitEdge_v := SclkFe_v;
        else
            SampleEdge_v  := SclkFe_v;
            TrasmitEdge_v := SclkRe_v;
        end if;

        case r.State is
            when Idle_s =>
                v.SpiMisoTristate := '1';
                if CsnFe_v = '1' then
                    v.State       := LatchTx_s;
                    v.DataLatched := '0';
                    v.Tx_Ready    := '1';
                end if;
                v.IsConsecutive := false;

            when LatchTx_s =>
                v.BitCnt := 0;
                if Tx_Valid = '1' then
                    v.ShiftReg    := Tx_Data;
                    v.Tx_Ready    := '0';
                    v.DataLatched := '1';
                    v.SpiMisoData := Tx_Data(TxIdx_c);
                end if;
                if SpiCpha_g = 0 and not r.IsConsecutive then
                    LeaveState_v := true;
                else
                    if TrasmitEdge_v = '1' then
                        LeaveState_v := true;
                    end if;
                end if;
                if LeaveState_v then
                    v.State := WaitSampleEdge_s;
                    if r.DataLatched = '0' and Tx_Valid = '0' then
                        v.ShiftReg := (others => '0');
                    end if;
                    v.Tx_Ready := '0';
                    v.SpiMisoData     := v.ShiftReg(TxIdx_c);
                    v.SpiMisoTristate := '0';
                end if;

            when WaitSampleEdge_s =>
                if SampleEdge_v = '1' then
                    if LsbFirst_g = false then
                        v.ShiftReg    := r.ShiftReg(r.ShiftReg'high - 1 downto 0) & SpiMosi_i;
                        v.SpiMisoData := r.ShiftReg(r.ShiftReg'high-1);
                    else
                        v.ShiftReg    := SpiMosi_i & r.ShiftReg(r.ShiftReg'high downto 1);
                        v.SpiMisoData := r.ShiftReg(1);
                    end if;
                    if r.BitCnt = TransWidth_g - 1 then
                        v.SpiMisoData := r.SpiMisoData;
                        v.RxOutput := '1'; -- Done in next cycle to await shift register update
                        v.Resp_Valid := '1';
                        v.Resp_Sent  := '1';
                        if ConsecutiveTransactions_g then
                            v.State       := LatchTx_s;
                            v.DataLatched := '0';
                            v.Tx_Ready    := '1';
                        else
                            v.State := WaitCsHigh_s;
                        end if;
                    else
                        v.State := WaitInactiveEdge_s;
                    end if;
                end if;
                v.IsConsecutive := true;

            when WaitInactiveEdge_s =>
                if TrasmitEdge_v = '1' then
                    v.State  := WaitSampleEdge_s;
                    v.BitCnt := r.BitCnt + 1;
                end if;

            when WaitCsHigh_s => null;  -- Return to idle is handled after FSM

            when others => null; -- unreachable code
        end case;

        if r.RxOutput = '1' then
            v.Rx_Valid := '1';
            v.Rx_Data  := r.ShiftReg;
        end if;

        if SpiCsn_i = '1' then
            v.State           := Idle_s;
            v.SpiMisoTristate := '1';
            if r.State /= WaitCsHigh_s and r.State /= Idle_s and r.DataLatched = '1' then
                v.Resp_Valid   := '1';
                v.Resp_Aborted := '1';
            elsif r.State /= Idle_s then
                v.Resp_Valid    := '1';
                v.Resp_CleanEnd := '1';
            end if;
        end if;

        r_next <= v;
    end process;

    Rx_Valid      <= r.Rx_Valid;
    Rx_Data       <= r.Rx_Data;
    Tx_Ready      <= r.Tx_Ready;
    Resp_Valid    <= r.Resp_Valid;
    Resp_Sent     <= r.Resp_Sent;
    Resp_Aborted  <= r.Resp_Aborted;
    Resp_CleanEnd <= r.Resp_CleanEnd;

    g_int_tristate : if InternalTriState_g generate
        Spi_Miso <= r.SpiMisoData when r.SpiMisoTristate = '0' else 'Z';
    end generate;

    g_ext_tristate : if not InternalTriState_g generate
        Spi_Miso_o <= r.SpiMisoData;
        Spi_Miso_t <= r.SpiMisoTristate;
    end generate;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.SpiCsnLast      <= '1';
                r.State           <= Idle_s;
                r.Tx_Ready        <= '0';
                r.SpiMisoTristate <= '1';
                r.RxOutput        <= '0';
            end if;
        end if;
    end process;

    b_sync : block is
        signal SyncIn, SyncOut : std_logic_vector(2 downto 0);
    begin
        SyncIn(0) <= Spi_Sclk;
        SyncIn(1) <= Spi_Mosi;
        SyncIn(2) <= Spi_Cs_n;

        i_sync : entity work.olo_intf_sync
            generic map (
                Width_g     => 3,
                RstLevel_g  => '1'
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                DataAsync   => SyncIn,
                DataSync    => SyncOut
            );

        SpiSclk_i <= SyncOut(0);
        SpiMosi_i <= SyncOut(1);
        SpiCsn_i  <= SyncOut(2);
    end block;

end architecture;"
"The `olo_intf_sync` component is a synchronization module designed to interface with asynchronous data signals and produce synchronized output data. Its primary purpose is to ensure that data signals are properly synchronized with a system clock, thereby preventing metastability issues in digital circuits. This component plays a crucial role in larger systems where data originates from different clock domains or asynchronous sources. The component features a generic design, allowing for flexibility in its application. It has three generics: `Width_g`, which specifies the bit width of the data signals and defaults to 1; `RstLevel_g`, which defines the reset level and defaults to '0'; and `SyncStages_g`, which determines the number of synchronization stages and ranges from 2 to 4, defaulting to 2. The input ports include `Clk`, a clock signal; `Rst`, an optional reset signal that defaults to '0'; and `DataAsync`, an input data vector of width `Width_g`. The output port is `DataSync`, a synchronized data vector also of width `Width_g`. Internally, the component utilizes a series of registers to implement the synchronization stages. The signal `Reg0` is a single register that captures the asynchronous input data on the rising edge of the clock. Following `Reg0`, an array of registers `RegN` is used to implement the additional synchronization stages specified by `SyncStages_g`. The use of multiple stages helps to ensure that the data is fully synchronized and stable before it is output. The architectural description reveals a straightforward yet efficient design. The process `p_outff` is sensitive to the clock and implements the sequential logic for updating the registers. On the rising edge of the clock, it updates `Reg0` with the current `DataAsync` and shifts the data through the `RegN` array. A conditional reset statement allows for the initialization of all registers to the specified reset level when the reset signal is asserted. Functionally, the component operates by capturing asynchronous data and passing it through a series of registers to synchronize it with the clock. The step-by-step operation involves the clocked capture of `DataAsync` into `Reg0`, followed by the shifting of data through each stage in `RegN` on subsequent clock cycles. The output `DataSync` is taken directly from the final stage of the synchronization array, ensuring that the data has been fully synchronized. Control logic within the component is primarily managed through the reset signal and the clock. The reset signal, when asserted, directly controls the state of the registers, resetting them to the specified level. The clock enables the sequential updating of the registers, ensuring that data progresses through the synchronization stages. Data flow through the component is straightforward: asynchronous data is captured and then sequentially shifted through the synchronization stages. No data transformation occurs; rather, the focus is on reliable synchronization. In terms of timing and synchronization, the component operates within a single clock domain. The use of a multi-stage synchronizer helps to mitigate issues related to metastability by ensuring that data settles into a stable state before being output. The design implicitly respects setup and hold requirements by utilizing registers for synchronization. A special feature of this component is its configurability, particularly in terms of the number of synchronization stages. This allows designers to balance between the need for robust synchronization and the impact on system performance. The `olo_intf_sync` component finds application in a wide range of digital systems where data needs to be synchronized across different clock domains or where data originates from asynchronous sources. This includes systems on chip (SoCs), field-programmable gate arrays (FPGAs), and digital signal processing (DSP) systems. Implementation considerations include the performance impact of additional synchronization stages, which can introduce latency but enhance reliability. Resource usage is relatively low, as the design primarily utilizes standard sequential logic. Design trade-offs involve balancing the number of synchronization stages against the required level of synchronization reliability and the system's performance constraints. Overall, the `olo_intf_sync` component offers a robust and flexible solution for synchronizing asynchronous data in digital systems.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;


entity olo_intf_sync is
    generic (
        Width_g      : positive              := 1;
        RstLevel_g   : std_logic             := '0';
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic := '0';
        DataAsync   : in    std_logic_vector(Width_g - 1 downto 0);
        DataSync    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;


architecture struct of olo_intf_sync is

    type SyncStages_t is array(0 to SyncStages_g - 2) of std_logic_vector(Width_g - 1 downto 0);

    signal Reg0 : std_logic_vector(Width_g - 1 downto 0) := (others => RstLevel_g);
    signal RegN : SyncStages_t                           := (others => (others => RstLevel_g));

    attribute shreg_extract of Reg0 : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of Reg0 : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegN : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of Reg0 : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN : signal is DontMerge_SuppressChanges_c;

    attribute preserve of Reg0 : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegN : signal is Preserve_SuppressChanges_c;

    attribute syn_keep of Reg0 : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegN : signal is SynKeep_SuppressChanges_c;

    attribute syn_preserve of Reg0 : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN : signal is SynPreserve_SuppressChanges_c;

    attribute async_reg of Reg0 : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN : signal is AsyncReg_TreatAsync_c;

begin

    p_outff : process (Clk) is
    begin
        if rising_edge(Clk) then
            Reg0    <= DataAsync;
            RegN(0) <= Reg0;

            for i in 1 to RegN'high loop
                RegN(i) <= RegN(i - 1);
            end loop;

            if Rst = '1' then
                Reg0 <= (others => RstLevel_g);
                RegN <= (others => (others => RstLevel_g));
            end if;
        end if;
    end process;

    DataSync <= RegN(RegN'high);

end architecture;
"
"The `olo_intf_uart` component is a Universal Asynchronous Receiver-Transmitter (UART) interface designed in VHDL, facilitating serial communication between a digital system and external devices. Its primary purpose is to enable data transmission and reception over a serial link, adhering to the standard UART protocol. This component plays a crucial role in larger systems, such as embedded systems, microcontrollers, and digital signal processing platforms, where serial communication with peripherals or other systems is required. The component features several input and output ports that facilitate its operation. The clock input `Clk` and reset input `Rst` are essential for synchronizing and resetting the component's internal state. The `Tx_Valid` and `Tx_Data` inputs indicate the validity of the data to be transmitted and the data itself, respectively. The `Tx_Ready` output signals the readiness of the transmitter to accept new data. The `Rx_Valid`, `Rx_Data`, and `Rx_ParityError` outputs indicate the validity of the received data, the received data itself, and any parity errors detected during reception, respectively. The `Uart_Tx` and `Uart_Rx` ports connect to the external serial link. Internally, the component consists of two primary state machines: one for transmission (`StateTx`) and one for reception (`StateRx`). The transmission state machine manages the transmission of data, including generating the start bit, data bits, parity bit (if enabled), and stop bits. The reception state machine oversees the reception of data, including detection of the start bit, data bits, parity bit (if enabled), and stop bits. The component also incorporates counters and registers to manage the timing and synchronization of the transmission and reception processes. The component's operation can be described step-by-step. When data is presented to the transmitter, it is buffered and transmitted serially over the `Uart_Tx` line, following the UART protocol. The receiver monitors the `Uart_Rx` line, detecting the start bit and subsequently sampling the data bits, parity bit (if present), and stop bits. The received data is then made available on the `Rx_Data` output, along with a validity indication on `Rx_Valid` and any parity error indication on `Rx_ParityError`. Control logic within the component manages the state transitions of the transmission and reception state machines, based on the input signals and internal counters. The `TxStrobe` and `RxStrobe` signals, generated by separate strobe generators, control the timing of the transmission and reception processes, respectively. The component also features a reset behavior that returns the state machines to their idle states and resets the internal registers. Data flow through the component involves the transformation of parallel data to serial data for transmission and the reverse transformation for reception. The component also performs parity generation and checking, according to the specified parity mode. The component operates within a specific clock domain, with setup and hold requirements that must be met to ensure reliable data transmission and reception. The clock frequency and baud rate are related through a set of generic parameters, allowing for flexible configuration. A special feature of this component is its support for various UART configurations, including selectable data bit lengths, stop bit lengths, and parity modes. The component also incorporates advanced functionality, such as fractional baud rate generation and synchronization of the received data. The `olo_intf_uart` component is typically used in embedded systems, microcontrollers, and digital signal processing platforms, where serial communication with external devices is required. Its applications include industrial control systems, medical devices, and communication interfaces. Implementation considerations for this component include performance optimization, resource usage, and design trade-offs. The component's performance is influenced by the clock frequency, baud rate, and data transfer rates. Resource usage is affected by the component's complexity, including the number of logic cells, memory, and I/O pins required. Design trade-offs involve balancing the component's configurability, performance, and resource usage. In conclusion, the `olo_intf_uart` component is a sophisticated UART interface designed in VHDL, offering a range of features and configurations to facilitate serial communication in digital systems. Its comprehensive functionality, flexibility, and performance make it a valuable component in a wide range of applications.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_intf_uart is
    generic (
        ClkFreq_g       : real;
        BaudRate_g      : real                  := 115.2e3;
        DataBits_g      : positive range 7 to 9 := 8;
        StopBits_g      : string                := ""1"";
        Parity_g        : string                := ""none""
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        Tx_Valid        : in    std_logic                                 := '0';
        Tx_Ready        : out   std_logic;
        Tx_Data         : in    std_logic_vector(DataBits_g - 1 downto 0) := (others => '0');
        Rx_Valid        : out   std_logic;
        Rx_Data         : out   std_logic_vector(DataBits_g - 1 downto 0);
        Rx_ParityError  : out   std_logic;
        Uart_Tx         : out   std_logic;
        Uart_Rx         : in    std_logic                                 := '1'
    );
end entity;

architecture rtl of olo_intf_uart is

    type StateTx_t is (Reset_s, Idle_s, Data_s, Stop_s);
    type StateRx_t is (Idle_s, Start_s, Data_s, Parity_s, Stop_s);

    function parityBit (Data : std_logic_vector) return std_logic is
        variable Parity_v : std_logic := '0';
    begin
        if Parity_g = ""none"" then
            return '0';
        end if;

        for i in Data'range loop
            Parity_v := Parity_v xor Data(i);
        end loop;

        if Parity_g = ""even"" then
            return Parity_v;
        else
            return not Parity_v;
        end if;
    end function;

    function stopStrobeCount return natural is
    begin
        if StopBits_g = ""1"" then
            return 2;
        elsif StopBits_g = ""1.5"" then
            return 3;
        else
            return 4;
        end if;
    end function;

    function transmitBits return natural is
        variable Bits_v : natural := DataBits_g;
    begin
        Bits_v := Bits_v + 1;
        if Parity_g /= ""none"" then
            Bits_v := Bits_v + 1;
        end if;
        return Bits_v;
    end function;

    type TwoProcess_r is record
        StateTx        : StateTx_t;
        TxCount        : natural range 0 to transmitBits*2 - 1;
        Tx_Ready       : std_logic;
        TxSync         : std_logic;
        TxShiftReg     : std_logic_vector(DataBits_g+1 downto 0);
        Uart_Tx        : std_logic;
        StateRx        : StateRx_t;
        RxCount        : natural range 0 to DataBits_g*2 - 1;
        RxSync         : std_logic;
        RxShiftReg     : std_logic_vector(DataBits_g-1 downto 0);
        Rx_ParityError : std_logic;
        Rx_Valid       : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal TxStrobe  : std_logic;
    signal RxStrobe  : std_logic;
    signal UartRxInt : std_logic;

begin

    assert BaudRate_g > 0.0
        report ""olo_intf_uart - BaudRate_g must be greater than 0""
        severity error;

    assert StopBits_g = ""1"" or StopBits_g = ""1.5"" or StopBits_g = ""2""
        report ""olo_intf_uart - StopBits_g must be 1, 1.5 or 2""
        severity error;

    assert Parity_g = ""none"" or Parity_g = ""even"" or Parity_g = ""odd""
        report ""olo_intf_uart - Parity_g must be none, even or odd""
        severity error;

    assert BaudRate_g <= ClkFreq_g / 10.0
        report ""olo_intf_uart - BaudRate_g must be <= ClkFreq_g / 10.0""
        severity error;

    p_comb : process (r, Tx_Valid, Tx_Data, UartRxInt, TxStrobe, RxStrobe) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.TxSync  := '0';
        v.Uart_Tx := '1';

        case r.StateTx is
            when Reset_s =>
                v.Tx_Ready := '1';
                v.StateTx  := Idle_s;

            when Idle_s =>
                if r.Tx_Ready = '0' and TxStrobe = '1' then
                    v.StateTx := Data_s;
                    v.TxCount := 0;
                elsif Tx_Valid = '1' and r.Tx_Ready = '1' then
                    v.Tx_Ready   := '0';
                    v.TxSync     := '1';
                    v.TxShiftReg := parityBit(Tx_Data) & Tx_Data & '0';
                end if;

            when Data_s =>
                v.Uart_Tx := r.TxShiftReg(0);
                if TxStrobe = '1' then
                    if r.TxCount = transmitBits*2 - 1 then
                        v.TxCount := 0;
                        v.StateTx := Stop_s;
                    else
                        if r.TxCount mod 2 = 1 then
                            v.TxShiftReg := '0' & r.TxShiftReg(r.TxShiftReg'high downto 1);
                        end if;
                        v.TxCount := r.TxCount + 1;
                    end if;
                end if;

            when Stop_s =>
                v.Uart_Tx := '1';
                if TxStrobe = '1' then
                    if r.TxCount = stopStrobeCount-1 then
                        v.StateTx  := Idle_s;
                        v.Tx_Ready := '1';
                    else
                        v.TxCount := r.TxCount + 1;
                    end if;
                end if;

            when others =>
                null; -- unreachable code

        end case;

        v.RxSync   := '0';
        v.Rx_Valid := '0';

        case r.StateRx is
            when Idle_s =>
                v.Rx_ParityError := '0';
                if UartRxInt = '0' then
                    v.RxSync  := '1';
                    v.StateRx := Start_s;
                    v.RxCount := 0;
                end if;

            when Start_s =>
                if RxStrobe = '1' then
                    if r.RxCount = 2 then
                        v.StateRx := Data_s;
                        v.RxCount := 0;
                    else
                        if UartRxInt = '1' then
                            v.StateRx := Idle_s;
                        end if;
                        v.RxCount := r.RxCount + 1;
                    end if;
                end if;

            when Data_s =>
                if RxStrobe = '1' then
                    if r.RxCount mod 2 = 0 then
                        v.RxShiftReg := UartRxInt & r.RxShiftReg(DataBits_g-1 downto 1);
                    end if;
                    if r.RxCount = DataBits_g*2 - 1 then
                        if Parity_g = ""none"" then
                            v.StateRx := Stop_s;
                        else
                            v.StateRx := Parity_s;
                        end if;
                        v.RxCount := 0;
                    else
                        v.RxCount := r.RxCount + 1;
                    end if;
                end if;

            when Parity_s =>
                if RxStrobe = '1' then
                    if r.RxCount = 1 then
                        v.StateRx := Stop_s;
                    else
                        v.RxCount := r.RxCount + 1;
                        if UartRxInt /= parityBit(r.RxShiftReg) then
                            v.Rx_ParityError := '1';
                        end if;
                    end if;
                end if;

            when Stop_s =>
                if RxStrobe = '1' then
                    v.StateRx  := Idle_s;
                    v.Rx_Valid := '1';
                end if;

            when others =>
                null; -- unreachable code

        end case;

        r_next <= v;
    end process;

    Tx_Ready       <= r.Tx_Ready;
    Uart_Tx        <= r.Uart_Tx;
    Rx_ParityError <= r.Rx_ParityError;
    Rx_Data        <= r.RxShiftReg;
    Rx_Valid       <= r.Rx_Valid;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.StateTx  <= Reset_s;
                r.Tx_Ready <= '0';
                r.StateRx <= Idle_s;
            end if;
        end if;
    end process;

    i_strb_tx : entity work.olo_base_strobe_gen
        generic map (
            FreqClkHz_g      => ClkFreq_g,
            FractionalMode_g => true,
            FreqStrobeHz_g   => BaudRate_g*2.0 -- 2x baud rate
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            In_Sync     => r.TxSync,
            Out_Valid   => TxStrobe
        );

    i_strb_rx : entity work.olo_base_strobe_gen
        generic map (
            FreqClkHz_g      => ClkFreq_g,
            FractionalMode_g => true,
            FreqStrobeHz_g   => BaudRate_g*2.0 -- 2x baud rate
        )
        port map (
            Clk         => Clk,
            Rst         => Rst,
            In_Sync     => r.RxSync,
            Out_Valid   => RxStrobe
        );

    i_sync : entity work.olo_intf_sync
        port map (
            Clk             => Clk,
            Rst             => Rst,
            DataAsync(0)    => Uart_Rx,
            DataSync(0)     => UartRxInt
        );

end architecture;"
"The `olo_base_arb_prio` component is a priority-based arbiter designed to manage access to a shared resource among multiple requesters. Its primary purpose is to resolve concurrent requests from multiple sources and grant access to the highest-priority requester. This component plays a crucial role in larger systems, such as system-on-chip (SoC) designs, network-on-chip (NoC) architectures, and other digital systems where resource arbitration is necessary. The component has a simple and efficient architecture, with a minimalistic design that makes it suitable for a wide range of applications. The primary inputs to the component are the clock signal `Clk`, the reset signal `Rst`, and the request vector `In_Req`, which is a `Width_g`-bit wide signal indicating the presence of a request from each of the `Width_g` requesters. The output is the grant vector `Out_Grant`, also `Width_g`-bit wide, which indicates which requester has been granted access to the shared resource. The `In_Req` port is a critical input to the component, as it directly influences the arbitration process. Each bit in the `In_Req` vector corresponds to a requester, and a high value indicates that the requester is requesting access to the shared resource. The bit width of `In_Req` is determined by the `Width_g` generic parameter, which must be a positive integer. The timing requirements for `In_Req` are not explicitly specified, but it is assumed to be a combinatorial input that can change at any time. The `Out_Grant` port is the primary output of the component, indicating which requester has been granted access to the shared resource. The bit width of `Out_Grant` is also determined by the `Width_g` generic parameter, and its timing is directly related to the clock signal `Clk` and the latency parameter `Latency_g`. When `Latency_g` is greater than 0, the grant is pipelined, and the output is registered, which introduces a latency of `Latency_g` clock cycles between the request and the grant. Internally, the component consists of a simple combinatorial logic and a pipelined register structure. The core of the arbitration logic is a process that performs a bitwise OR operation on the `In_Req` vector, followed by a priority encoding to generate the grant signal `Grant_I`. This process is implemented using a simple and efficient algorithm that ensures the highest-priority requester is granted access. The `Grant_I` signal is then either directly assigned to the output `Out_Grant` when the latency is 0 or pipelined through a series of registers (`RdPipe`) when the latency is greater than 0. The pipelining is implemented using a generate statement that creates a series of registers, each clocked by the `Clk` signal. The output of the last register in the pipeline is assigned to `Out_Grant`. The control logic of the component is primarily governed by the clock signal `Clk` and the reset signal `Rst`. When `Rst` is high, the component resets the pipeline registers to zero, ensuring that the output is cleared. The clock signal `Clk` governs the pipelining of the grant signal, and its rising edge triggers the update of the pipeline registers. The data flow through the component is straightforward: the request vector `In_Req` is processed by the arbitration logic to generate the grant signal `Grant_I`, which is then either directly output or pipelined to the output `Out_Grant`. There are no complex data transformations performed within the component, as its primary function is to resolve the priority of the requests. The component operates in a single clock domain, and its timing is determined by the `Clk` signal. The setup and hold requirements for the inputs are not explicitly specified, but it is assumed that the inputs must be stable for a certain period around the rising edge of `Clk`. The component does not have any specific timing constraints, other than those imposed by the clock frequency and the latency parameter. One of the special features of this component is its ability to operate with a variable latency, determined by the `Latency_g` generic parameter. This allows the designer to trade off between the latency of the arbitration process and the resource utilization. When `Latency_g` is 0, the component operates with zero latency, and the grant is generated combinatorially. When `Latency_g` is greater than 0, the component introduces a pipelined delay, which can help to improve the performance of the system by allowing the requests to be processed in a pipelined fashion. The `olo_base_arb_prio` component is suitable for a wide range of applications, including SoC design, NoC architectures, and other digital systems where resource arbitration is necessary. It can be used in systems with a single shared resource, where multiple requesters need to access the resource in a mutually exclusive manner. In terms of implementation considerations, the component's performance is primarily determined by the clock frequency and the latency parameter. The resource utilization is minimal, as the component only requires a small amount of combinatorial logic and a series of registers. The design trade-offs are primarily related to the choice of the latency parameter, which affects the balance between the latency of the arbitration process and the resource utilization. Overall, the `olo_base_arb_prio` component is a simple, efficient, and highly configurable priority-based arbiter that can be used in a wide range of digital systems. Its modular design and parameterized architecture make it an attractive solution for system designers who need to implement resource arbitration in their systems.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_arb_prio is
    generic (
        Width_g    : positive;
        Latency_g  : natural := 1
    );
    port (
        Clk        : in    std_logic;
        Rst        : in    std_logic;
        In_Req     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Grant  : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_arb_prio is

    type Data_t is array (natural range<>) of std_logic_vector(Out_Grant'range);

    signal Grant_I : std_logic_vector(Out_Grant'range);
    signal RdPipe  : Data_t(1 to Latency_g);

begin

    g_non_zero : if Width_g > 0 generate

        p_comb : process (In_Req) is
            variable OredRequest_v : std_logic_vector(In_Req'range);
        begin
            OredRequest_v := ppcOr(In_Req);

            Grant_I <= OredRequest_v and not ('0' & OredRequest_v(OredRequest_v'high downto 1));
        end process;

        g_reg : if Latency_g > 0 generate

            p_outreg : process (Clk) is
            begin
                if rising_edge(Clk) then
                    if Rst = '1' then
                        RdPipe <= (others => (others => '0'));
                    else
                        RdPipe(1)              <= Grant_I;
                        RdPipe(2 to Latency_g) <= RdPipe(1 to Latency_g-1);
                    end if;
                end if;
            end process;

            Out_Grant <= RdPipe(Latency_g);
        end generate;

        g_nreg : if Latency_g = 0 generate
            Out_Grant <= Grant_I;
        end generate;

    end generate;

end architecture;"
"The `olo_base_arb_rr` component is a Round-Robin arbiter designed to manage access to a shared resource among multiple requesters. Its primary purpose is to ensure fair and efficient allocation of the resource, preventing any single requester from monopolizing it. This component is typically used in systems-on-chip (SoCs) and other digital systems where multiple masters need to access a shared bus or resource. The `olo_base_arb_rr` has several input and output ports that facilitate its operation. The `Clk` and `Rst` ports are used for clocking and resetting the component, respectively. The `In_Req` port, a vector of width `Width_g`, conveys the request signals from multiple requesters. The `Out_Grant` port, also a vector of width `Width_g`, outputs the grant signals to the requesters, indicating which requester has been granted access to the resource. The `Out_Ready` port is an input that indicates whether the resource is ready to be accessed, and the `Out_Valid` port outputs a signal indicating whether a valid grant has been generated. Internally, the `olo_base_arb_rr` consists of two main processes: `p_comb` and `p_seq`. The `p_comb` process is a combinational process that calculates the next state of the arbiter based on the current state, input requests, and the `Out_Ready` signal. It uses a record type `TwoProcess_t` to store the state of the arbiter, which currently only contains a `Mask` field. The `p_seq` process is a sequential process that updates the state of the arbiter on every clock cycle, and also handles reset. The `p_comb` process first masks the input requests using the current mask value, and then determines the grant signals based on the masked requests. If there are no pending requests, it uses an unmasked grant value; otherwise, it uses a masked grant value. The grant signals are then output on the `Out_Grant` port. The process also updates the mask value based on the grant signals and the `Out_Ready` signal. The `olo_base_arb_rr` uses two instances of another component, `olo_base_arb_prio`, to generate the masked and unmasked grant signals. These components are priority arbiters that allocate the resource to the highest-priority requester. The `olo_base_arb_prio` instances are configured with a latency of 0, indicating that they generate the grant signals immediately. The internal state of the `olo_base_arb_rr` is stored in a register `r`, which is updated on every clock cycle. The register contains a `Mask` field that keeps track of the requesters that have been granted access recently. The mask value is used to ensure that the arbiter allocates the resource fairly among the requesters. The `olo_base_arb_rr` operates as follows: when a requester asserts its request signal on the `In_Req` port, the arbiter generates a grant signal on the `Out_Grant` port if the resource is ready (i.e., `Out_Ready` is high). The grant signal is generated based on the priority of the requesters and the current mask value. If a requester is granted access, its corresponding bit in the mask value is set. The mask value is used to prevent the same requester from being granted access again until other requesters have been serviced. The control logic of the `olo_base_arb_rr` is primarily implemented in the `p_comb` process, which generates the grant signals and updates the mask value based on the input requests and the `Out_Ready` signal. The `p_seq` process handles the clocking and resetting of the arbiter. Data flows through the `olo_base_arb_rr` as follows: the input requests on the `In_Req` port are first masked using the current mask value, and then passed to the `olo_base_arb_prio` instances to generate the grant signals. The grant signals are then output on the `Out_Grant` port and used to update the mask value. The `olo_base_arb_rr` has specific timing and synchronization requirements. It is clocked on the rising edge of the `Clk` signal, and the `Out_Grant` and `Out_Valid` signals are generated based on the clock cycle. The `Out_Ready` signal is used to synchronize the arbiter with the resource, ensuring that the resource is not accessed until it is ready. One special feature of the `olo_base_arb_rr` is its use of a Round-Robin arbitration scheme, which ensures that each requester is granted access fairly and efficiently. The component also has a generic parameter `Width_g`, which allows it to be configured for different numbers of requesters. The `olo_base_arb_rr` is typically used in systems where multiple masters need to access a shared resource, such as a bus or a memory. It can be used in a wide range of applications, including SoCs, networks-on-chip, and other digital systems. In terms of implementation considerations, the `olo_base_arb_rr` requires careful consideration of performance, resource usage, and design trade-offs. The component's performance is critical, as it must be able to handle a high volume of requests and grants. The resource usage is also important, as the component must be efficient in terms of area and power consumption. The design trade-offs include balancing the fairness of the arbitration scheme with the performance requirements of the system. Overall, the `olo_base_arb_rr` is a complex digital component that requires careful analysis and design to ensure that it meets the requirements of the system in which it is used. Its internal structure, functional behavior, and control logic all contribute to its ability to manage access to a shared resource fairly and efficiently.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_arb_rr is
    generic (
        Width_g    : positive
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Req      : in    std_logic_vector(Width_g-1 downto 0);
        Out_Grant   : out   std_logic_vector(Width_g-1 downto 0);
        Out_Ready   : in    std_logic;
        Out_Valid   : out   std_logic
    );
end entity;

architecture rtl of olo_base_arb_rr is

    type TwoProcess_t is record
        Mask : std_logic_vector(In_Req'range);
    end record;

    signal r, r_next : TwoProcess_t;

    signal RequestMasked : std_logic_vector(In_Req'range);
    signal GrantMasked   : std_logic_vector(Out_Grant'range);
    signal GrantUnmasked : std_logic_vector(Out_Grant'range);

begin

    g_non_zero : if Width_g > 0 generate

        p_comb : process (r, In_Req, Out_Ready, GrantMasked, GrantUnmasked) is
            variable v       : TwoProcess_t;
            variable Grant_v : std_logic_vector(Out_Grant'range);
        begin
            v := r;

            RequestMasked <= In_Req and r.Mask;

            if unsigned(GrantMasked) = 0 then
                Grant_v := GrantUnmasked;
            else
                Grant_v := GrantMasked;
            end if;

            if (unsigned(Grant_v) /= 0) and (Out_Ready = '1') then
                v.Mask := '0' & ppcOr(Grant_v(Grant_v'high downto 1));
            end if;

            if unsigned(Grant_v) /= 0 then
                Out_Valid <= '1';
            else
                Out_Valid <= '0';
            end if;

            Out_Grant <= Grant_v;

            r_next <= v;

        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.Mask <= (others => '0');
                end if;
            end if;
        end process;

        i_prio_masked : entity work.olo_base_arb_prio
            generic map (
                Width_g   => Width_g,
                Latency_g => 0
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Req      => RequestMasked,
                Out_Grant   => GrantMasked
            );

        i_prio_unmasked : entity work.olo_base_arb_prio
            generic map (
                Width_g   => Width_g,
                Latency_g => 0
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Req      => In_Req,
                Out_Grant   => GrantUnmasked
            );

    end generate;

end architecture;"
"The `olo_base_cam` component is a Content-Addressable Memory (CAM) designed in VHDL, which serves as a crucial element in larger digital systems, particularly in applications requiring fast and efficient data lookup and storage. Its primary purpose is to store and retrieve data based on content rather than address, making it an essential component in networking, data processing, and artificial intelligence applications. The component features a comprehensive set of input and output ports that facilitate its operation. The clock signal `Clk` and reset signal `Rst` are the primary control inputs. The `Rd_Valid`, `Rd_Ready`, `Rd_Content`, `Wr_Valid`, `Wr_Ready`, `Wr_Content`, `Wr_Addr`, `Wr_Write`, `Wr_Clear`, and `Wr_ClearAll` ports manage the read and write operations, while `Match_Valid`, `Match_Match`, `Addr_Valid`, `Addr_Found`, and `Addr_Addr` ports provide the results of the CAM operations. The bit widths of these ports are carefully defined based on the generic parameters such as `Addresses_g`, `ContentWidth_g`, and calculated values like `log2ceil(Addresses_g)`, ensuring flexibility and adaptability to various applications. Internally, the CAM architecture consists of two main processes: `p_cob` and `p_seq`. The `p_cob` process is a combinational logic block that determines the next state of the CAM, handling read and write operations, address calculations, and control signal generation. It utilizes a record `TwoProcess_r` to maintain the state variables, which include content, address, write, clear, and read flags, among others. The process also incorporates a sophisticated control logic that prioritizes read or write operations based on the `ReadPriority_g` generic parameter and manages the reset and clear operations. The `p_seq` process is a sequential logic block that updates the state variables on the rising edge of the clock. It resets the state variables when the reset signal is asserted and ensures that the CAM returns to a known state after reset. The use of two processes allows for a clear separation of combinational and sequential logic, enhancing the design's readability and maintainability. The CAM's internal structure includes a RAM block (`olo_base_ram_sdp`) that stores the content-addressable data. The RAM is instantiated multiple times in a generate statement (`g_addr`), depending on the `BlocksParallel_c` value, which is calculated based on the content width and block address bits. This parallelization enables the CAM to handle wider content data efficiently. The `RamWrite_1` and `RamRead_1` signals are arrays of vectors, each corresponding to a block of the RAM, facilitating parallel write and read operations. The component also features an optional address output module (`olo_base_decode_firstbit`), which is instantiated if `UseAddrOut_g` is true. This module decodes the first bit of the match result and provides the address and validity signals. The address output logic is configurable through generic parameters like `FirstBitDecLatency_g`, allowing for optimization of the output timing. Functionally, the CAM operates by comparing the input data against stored content and generating match results. The `Match_Valid` and `Match_Match` signals indicate the validity and the address of the match, respectively. The component supports various operating modes, including write, read, clear, and clear-all operations, which are controlled by the input signals and generic parameters. The control logic within the CAM manages the state transitions, enable conditions, and reset behavior. The `ClearAfterReset_g` generic parameter allows for the CAM to be cleared after reset, ensuring a defined state at startup. The `StrictOrdering_g` parameter influences the ordering of read and write operations, providing flexibility in system design. Data flow within the component involves the transformation of input data into a format suitable for storage and comparison. The `ContentExtended_1` signal, for instance, extends the content data to fit the RAM block width, facilitating parallel storage and retrieval. Timing and synchronization are critical aspects of the CAM design. The component operates within a single clock domain, with the clock signal `Clk` driving the sequential logic. The setup and hold requirements are implicitly managed through the use of synchronous reset and the careful design of the state machines. Special features of the CAM include its configurable RAM style and behavior, selectable address output, and optional registration of input and match data. These features make the component versatile and adaptable to a wide range of applications. The `olo_base_cam` component is typically used in systems requiring fast content-addressable memory access, such as network routers, caches, and data processing units. Its implementation considerations include performance optimization through parallelization, resource usage minimization through configurable generics, and design trade-offs between speed, area, and power consumption. In conclusion, the `olo_base_cam` VHDL component is a sophisticated and flexible CAM design that offers a rich set of features and configurability. Its detailed analysis reveals a well-structured and efficient design, suitable for a variety of applications requiring high-speed data lookup and storage.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_cam is
    generic (
        Addresses_g          : positive;
        ContentWidth_g       : positive;
        RamStyle_g           : string   := ""auto"";
        RamBehavior_g        : string   := ""RBW"";
        RamBlockWidth_g      : positive := 32;
        RamBlockDepth_g      : positive := 512;
        ClearAfterReset_g    : boolean  := true;
        ReadPriority_g       : boolean  := true;
        StrictOrdering_g     : boolean  := false;
        UseAddrOut_g         : boolean  := true;
        RegisterInput_g      : boolean  := true;
        RegisterMatch_g      : boolean  := true;
        FirstBitDecLatency_g : natural  := 1
    );
    port (
        Clk                     : in    std_logic;
        Rst                     : in    std_logic;

        Rd_Valid                : in    std_logic;
        Rd_Ready                : out   std_logic;
        Rd_Content              : in    std_logic_vector(ContentWidth_g-1 downto 0);

        Wr_Valid                : in    std_logic;
        Wr_Ready                : out   std_logic;
        Wr_Content              : in    std_logic_vector(ContentWidth_g-1 downto 0);
        Wr_Addr                 : in    std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Wr_Write                : in    std_logic;
        Wr_Clear                : in    std_logic := '0';
        Wr_ClearAll             : in    std_logic := '0';

        Match_Valid             : out   std_logic;
        Match_Match             : out   std_logic_vector(Addresses_g-1 downto 0);

        Addr_Valid              : out   std_logic;
        Addr_Found              : out   std_logic;
        Addr_Addr               : out   std_logic_vector(log2ceil(Addresses_g)-1 downto 0)
    );
end entity;

architecture rtl of olo_base_cam is

    constant BlockAddrBits_c  : positive := log2ceil(RamBlockDepth_g);
    constant BlocksParallel_c : positive := integer(ceil(real(ContentWidth_g) / real(BlockAddrBits_c)));
    constant TotalAddrBits_c  : positive := BlocksParallel_c * BlockAddrBits_c;

    type TwoProcess_r is record
        Content_0         : std_logic_vector(ContentWidth_g - 1 downto 0);
        Addr_0            : std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Write_0           : std_logic;
        Clear_0           : std_logic;
        ClearAll_0        : std_logic;
        Read_0            : std_logic;
        ContentExtended_1 : std_logic_vector(TotalAddrBits_c - 1 downto 0);
        Addr_1            : std_logic_vector(log2ceil(Addresses_g)-1 downto 0);
        Write_1           : std_logic;
        Clear_1           : std_logic;
        ClearAll_1        : std_logic;
        Read_1            : std_logic;
        Match_2           : std_logic_vector(Addresses_g-1 downto 0);
        Read_2            : std_logic;
        RstClearDone      : std_logic;
        RstClearCounter   : unsigned(BlockAddrBits_c-1 downto 0);
        RstClearWr        : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    type RamData_t is array (natural range <>) of std_logic_vector(Addresses_g-1 downto 0);

    signal ReadContent_0 : std_logic_vector(ContentWidth_g-1 downto 0);
    signal RamRead_1     : RamData_t(0 to BlocksParallel_c-1);
    signal RamWrite_1    : RamData_t(0 to BlocksParallel_c-1);
    signal WrMem_1       : std_logic;
    signal MatchInt      : std_logic_vector(Addresses_g-1 downto 0);
    signal MatchValid    : std_logic;

begin

    assert isPower2(RamBlockDepth_g)
        report ""olo_base_cam - RamBlockDepth_g must be a power of 2""
        severity error;

    p_cob : process (Rd_Valid, Rd_Content, Wr_Valid, Wr_Content, Wr_Addr, Wr_Write, Wr_Clear,
                     RamRead_1, Rst, r) is
        variable v                        : TwoProcess_r;
        variable ClearMask_v, SetMask_v   : std_logic_vector(Addresses_g-1 downto 0);
        variable InRdReady_v, InWrReady_v : std_logic;
    begin
        v := r;

        if ReadPriority_g then
            InRdReady_v := '1';
            InWrReady_v := not Rd_Valid;
        else
            InWrReady_v := '1';
            InRdReady_v := not Wr_Valid;
        end if;
        if r.Write_0 = '1' or r.Clear_0 = '1' or r.ClearAll_0 = '1' then
            InWrReady_v := '0';
            if StrictOrdering_g and RamBehavior_g = ""RBW"" then
                InRdReady_v := '0';
            else
                InRdReady_v := '1';
            end if;
        end if;
        if Rst = '1' or (ClearAfterReset_g and r.RstClearDone = '0') then
            InRdReady_v := '0';
            InWrReady_v := '0';
        end if;
        Rd_Ready <= InRdReady_v;
        Wr_Ready <= InWrReady_v;

        v.Addr_0     := Wr_Addr;
        v.Write_0    := '0';
        v.Clear_0    := '0';
        v.Read_0     := '0';
        v.ClearAll_0 := '0';
        if InWrReady_v = '1' and Wr_Valid = '1' then
            v.Content_0  := Wr_Content;
            v.Write_0    := Wr_Write;
            v.Clear_0    := Wr_Clear;
            v.ClearAll_0 := Wr_ClearAll;
        elsif InRdReady_v = '1' and Rd_Valid = '1' then
            v.Content_0 := Rd_Content;
            v.Read_0    := '1';
        end if;
        if RegisterInput_g then
            ReadContent_0 <= r.Content_0;
        else
            ReadContent_0 <= v.Content_0;
        end if;

        if RegisterInput_g then
            v.ContentExtended_1                            := (others => '0');
            v.ContentExtended_1(ContentWidth_g-1 downto 0) := r.Content_0;
            v.Addr_1                                       := r.Addr_0;
            v.Write_1                                      := r.Write_0;
            v.Clear_1                                      := r.Clear_0;
            v.Read_1                                       := r.Read_0;
            v.ClearAll_1                                   := r.ClearAll_0;
        else
            v.ContentExtended_1                            := (others => '0');
            v.ContentExtended_1(ContentWidth_g-1 downto 0) := v.Content_0;
            v.Addr_1                                       := v.Addr_0;
            v.Write_1                                      := v.Write_0;
            v.Clear_1                                      := v.Clear_0;
            v.Read_1                                       := v.Read_0;
            v.ClearAll_1                                   := v.ClearAll_0;
        end if;

        v.Read_2 := r.Read_1;
        v.Match_2 := RamRead_1(0);

        for i in 1 to BlocksParallel_c-1 loop
            v.Match_2 := v.Match_2 and RamRead_1(i);
        end loop;

        ClearMask_v := (others => '1');
        SetMask_v   := (others => '0');
        if r.Write_1 = '1' then
            SetMask_v(fromUslv(to01(r.Addr_1))) := '1';
        end if;
        if r.Clear_1 = '1' then
            ClearMask_v(fromUslv(to01(r.Addr_1))) := '0';
        end if;
        if r.ClearAll_1 = '1' then
            ClearMask_v := not v.Match_2;
        end if;

        for i in 0 to BlocksParallel_c-1 loop
            RamWrite_1(i) <= (RamRead_1(i) and ClearMask_v) or SetMask_v;
        end loop;

        WrMem_1 <= r.Write_1 or r.Clear_1 or r.ClearAll_1 or r.RstClearWr;
        if RegisterMatch_g then
            MatchValid <= r.Read_2;
            MatchInt   <= r.Match_2;
        else
            MatchValid <= v.Read_2;
            MatchInt   <= v.Match_2;
        end if;

        v.RstClearWr := '0';
        if ClearAfterReset_g then
            if r.RstClearDone = '0' then
                if r.RstClearCounter = 2**BlockAddrBits_c-1 then
                    v.RstClearDone := '1';
                else
                    v.RstClearCounter := r.RstClearCounter + 1;
                end if;
            else
                v.RstClearDone := '1';
            end if;
            if r.RstClearDone = '0' then
                v.RstClearWr := '1'; -- Assignment to memory write done further up in code

                for i in 0 to BlocksParallel_c-1 loop
                    v.ContentExtended_1((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c) := std_logic_vector(r.RstClearCounter);
                end loop;

            end if;
            if r.RstClearWr = '1' then
                RamWrite_1 <= (others => (others => '0'));
            end if;
        end if;

        r_next <= v;
    end process;

    Match_Valid <= MatchValid;
    Match_Match <= MatchInt;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Write_0         <= '0';
                r.Clear_0         <= '0';
                r.ClearAll_0      <= '0';
                r.Read_0          <= '0';
                r.Write_1         <= '0';
                r.Clear_1         <= '0';
                r.ClearAll_1      <= '0';
                r.Read_1          <= '0';
                r.Read_2          <= '0';
                r.RstClearDone    <= '0';
                r.RstClearCounter <= (others => '0');
            end if;
        end if;
    end process;

    g_addr : for i in 0 to BlocksParallel_c-1 generate
        signal ContentExtended_0 : std_logic_vector(TotalAddrBits_c-1 downto 0) := (others => '0');
        signal RdAddr_0          : std_logic_vector(BlockAddrBits_c-1 downto 0);
        signal WrAddr_1          : std_logic_vector(BlockAddrBits_c-1 downto 0);
    begin
        ContentExtended_0(ContentWidth_g-1 downto 0) <= ReadContent_0;

        RdAddr_0 <= to01(ContentExtended_0((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c));
        WrAddr_1 <= to01(r.ContentExtended_1((i+1)*BlockAddrBits_c-1 downto i*BlockAddrBits_c));

        i_ram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => RamBlockDepth_g,
                Width_g         => Addresses_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Wr_Addr     => WrAddr_1,
                Wr_Ena      => WrMem_1,
                Wr_Data     => RamWrite_1(i),
                Rd_Addr     => RdAddr_0,
                Rd_Data     => RamRead_1(i)
            );

    end generate;

    g_addrout : if UseAddrOut_g generate

        i_addrout : entity work.olo_base_decode_firstbit
            generic map (
                InWidth_g       => Addresses_g,
                InReg_g         => false,   -- Regiser is in r
                OutReg_g        => choose(FirstBitDecLatency_g = 0, false, true),
                PlRegs_g        => choose(FirstBitDecLatency_g = 0, 0, FirstBitDecLatency_g-1)
            )
            port map (
                Clk          => Clk,
                Rst          => Rst,
                In_Data      => MatchInt,
                In_Valid     => MatchValid,
                Out_FirstBit => Addr_Addr,
                Out_Found    => Addr_Found,
                Out_Valid    => Addr_Valid
            );

    end generate;

    g_naddrout : if not UseAddrOut_g generate

        Addr_Valid <= '0';
        Addr_Found <= '0';
        Addr_Addr  <= (others => '0');

    end generate;

end architecture;"
"The `olo_base_cc_bits` component is a digital circuit designed to transfer data between two clock domains, `In_Clk` and `Out_Clk`, while ensuring reliable data transfer and synchronization. Its primary purpose is to act as a clock domain crossing (CDC) bridge, allowing data to be transmitted from a source clock domain to a destination clock domain with different clock frequencies or phases. The component has several input and output ports that facilitate its operation. The `In_Clk` and `In_Rst` ports are used to clock and reset the input register, respectively, while the `In_Data` port is a `Width_g`-bit wide input data bus that feeds into the component. The `Out_Clk` and `Out_Rst` ports are used to clock and reset the output register, respectively. The `Out_Data` port is also a `Width_g`-bit wide output data bus that provides the synchronized data. Internally, the component consists of several registers and a process for each clock domain. The input register, `RegIn`, is clocked by `In_Clk` and captures the input data on every rising edge. The output register, comprising `Reg0` and `RegN`, is clocked by `Out_Clk` and generates the synchronized output data. The `RegN` register is an array of `SyncStages_g-1` registers, which are used to implement a multi-stage synchronizer. The architectural description reveals that the component uses a multi-stage synchronizer approach to ensure reliable data transfer between the two clock domains. The synchronizer is composed of a series of registers, `Reg0` and `RegN`, which are clocked by `Out_Clk`. The `RegN` array is used to pipeline the data through multiple stages, allowing the data to settle and reducing the risk of metastability. The functional behavior of the component can be described as follows: when `In_Clk` rises, the input data is captured into `RegIn`. When `Out_Clk` rises, the data from `RegIn` is transferred to `Reg0`, and then pipelined through the `RegN` array. The output data is generated from the last stage of the `RegN` array. The component also handles reset conditions, where both `RegIn` and `RegN` are reset to zero when either `In_Rst` or `Out_Rst` is asserted. The control logic of the component is primarily governed by the clock and reset signals. The `In_Clk` and `Out_Clk` signals dictate when data is captured and transferred, while the `In_Rst` and `Out_Rst` signals reset the registers to a known state. The component also uses various attributes to control synthesis and optimization, such as `shreg_extract`, `syn_srlstyle`, `dont_merge`, `preserve`, `syn_preserve`, `syn_keep`, and `async_reg`, which influence how the registers are implemented and optimized. The data flow through the component can be described as follows: the input data is captured into `RegIn` on every rising edge of `In_Clk`. The data is then transferred to `Reg0` on every rising edge of `Out_Clk`, and pipelined through the `RegN` array. The output data is generated from the last stage of the `RegN` array. The component has specific timing and synchronization requirements. The `In_Clk` and `Out_Clk` signals must be related by a known phase and frequency relationship to ensure reliable data transfer. The component also has setup and hold requirements on the input data with respect to `In_Clk` and `Out_Clk`. One special feature of this component is its use of a multi-stage synchronizer approach, which allows it to handle high-speed clock domain crossings with a high degree of reliability. The component also provides a flexible way to adjust the number of synchronization stages through the `SyncStages_g` generic. The `olo_base_cc_bits` component is typically used in digital systems where data needs to be transferred between clock domains with different frequencies or phases. This can occur in systems-on-chip (SoCs), field-programmable gate arrays (FPGAs), or application-specific integrated circuits (ASICs) where multiple clock domains are present. In terms of implementation considerations, the component's performance is influenced by the choice of `Width_g` and `SyncStages_g`, which affect the area and speed of the design. The component's resource usage is also influenced by the target technology and synthesis tool settings. Design trade-offs include balancing the number of synchronization stages with the required data throughput and latency. Overall, the `olo_base_cc_bits` component provides a robust and reliable solution for clock domain crossing, enabling the transfer of data between different clock domains while ensuring data integrity and synchronization.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;


entity olo_base_cc_bits is
    generic (
        Width_g      : positive              := 1;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk   : in    std_logic;
        In_Rst   : in    std_logic := '0';
        In_Data  : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk  : in    std_logic;
        Out_Rst  : in    std_logic := '0';
        Out_Data : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;


architecture struct of olo_base_cc_bits is

    type SyncStages_t is array(0 to SyncStages_g - 2) of std_logic_vector(Width_g - 1 downto 0);

    signal RegIn : std_logic_vector(Width_g - 1 downto 0) := (others => '0');
    signal Reg0  : std_logic_vector(Width_g - 1 downto 0) := (others => '0');
    signal RegN  : SyncStages_t                           := (others => (others => '0'));

    attribute shreg_extract of Reg0  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegN  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RegIn : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of Reg0  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegN  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RegIn : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of Reg0  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegN  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RegIn : signal is DontMerge_SuppressChanges_c;

    attribute preserve of Reg0  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegN  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RegIn : signal is Preserve_SuppressChanges_c;

    attribute syn_preserve of Reg0  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegN  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RegIn : signal is SynPreserve_SuppressChanges_c;

    attribute syn_keep of Reg0  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegN  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RegIn : signal is SynKeep_SuppressChanges_c;

    attribute async_reg of Reg0  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegN  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RegIn : signal is AsyncReg_TreatAsync_c;

    signal In_Clk_Sig : std_logic;

    attribute dont_touch of In_Clk_Sig : signal is DontTouch_SuppressChanges_c;
    attribute keep of In_Clk_Sig       : signal is Keep_SuppressChanges_c;

begin

    In_Clk_Sig <= In_Clk;

    p_inff : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            RegIn <= In_Data;
            if In_Rst = '1' then
                RegIn <= (others => '0');
            end if;
        end if;
    end process;

    p_outff : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            Reg0    <= RegIn;
            RegN(0) <= Reg0;

            for i in 1 to RegN'high loop
                RegN(i) <= RegN(i - 1);
            end loop;

            if Out_Rst = '1' then
                Reg0 <= (others => '0');
                RegN <= (others => (others => '0'));
            end if;
        end if;
    end process;

    Out_Data <= RegN(RegN'high);

end architecture;
"
"The `olo_base_cc_handshake` component is a digital circuit designed to facilitate a handshake-based data transfer between two clock domains. Its primary purpose is to enable the reliable exchange of data between two systems operating at different clock frequencies or phases. This component plays a crucial role in larger systems, such as system-on-chip (SoC) designs, where multiple clock domains are present. The component has several input and output ports, each with specific purposes and bit widths. The input ports include `In_Clk`, a clock signal; `In_RstIn`, an asynchronous reset signal; `In_Data`, a data bus of width `Width_g`; `In_Valid`, a data validity signal; and `Out_Ready`, a readiness signal from the receiving end. The output ports comprise `In_RstOut`, a reset signal; `In_Ready`, a readiness signal; `Out_Clk`, a clock signal; `Out_RstOut`, a reset signal; `Out_Data`, a data bus of width `Width_g`; and `Out_Valid`, a data validity signal. Internally, the component consists of several registers, counters, and state machines that manage the handshake protocol. The architectural description reveals a design comprising two main parts: the input side, which interacts with the incoming data and validity signals, and the output side, which communicates with the outgoing data and readiness signals. The input side features a process `p_in` that manages the latching of incoming data and validity signals, while the output side has a process `p_out` that oversees the latching of outgoing data and validity signals. The functional behavior of the component can be described as follows: when the input data is valid and the input ready signal is high, the component latches the data and asserts the input transaction signal. The input transaction signal is then used to transfer the data to the output side through a simple clock-crossing circuit `i_scc`. On the output side, when the output transaction signal is high and the output ready signal is low, the component latches the data and asserts the output latched signal. The output validity signal is generated based on the output transaction and latched signals. The control logic of the component is governed by the `ReadyRstState_g` generic, which determines the behavior of the input ready signal during reset. If `ReadyRstState_g` is high, the input ready signal is actively pulled low during reset; otherwise, it is only pulled low when the reset signal is high. The state transitions are managed by the `p_in` and `p_out` processes, which update the internal state based on the input and output signals. Data flow through the component involves the transformation of input data and validity signals to output data and validity signals. The data is transferred from the input side to the output side through the `i_scc` clock-crossing circuit, which ensures that the data is properly synchronized with the output clock. The component has specific timing and synchronization requirements. The input and output clocks are assumed to be asynchronous, and the component uses internal synchronization circuits to ensure that the data is properly transferred between the clock domains. The `SyncStages_g` generic determines the number of synchronization stages used in the clock-crossing circuits. A special feature of this component is its ability to handle reset signals independently on both the input and output sides. The `In_RstIn` and `Out_RstIn` signals are used to reset the input and output sides, respectively, while the `In_RstOut` and `Out_RstOut` signals are used to propagate the reset conditions to the external circuitry. The `olo_base_cc_handshake` component is typically used in systems where data needs to be transferred between clock domains, such as in SoC designs, field-programmable gate arrays (FPGAs), or application-specific integrated circuits (ASICs). The component's generic parameters, such as `Width_g`, `ReadyRstState_g`, and `SyncStages_g`, allow for customization to suit specific application requirements. Implementation considerations include optimizing the component for performance, resource usage, and design trade-offs. The component's resource usage is influenced by the `Width_g` and `SyncStages_g` generics, which determine the number of registers and synchronization stages required. The component's performance is affected by the clock frequencies and the timing relationships between the input and output clocks. In conclusion, the `olo_base_cc_handshake` component is a versatile digital circuit that enables reliable data transfer between clock domains. Its comprehensive design, featuring clock-crossing circuits, synchronization stages, and reset management, makes it suitable for a wide range of applications in SoC designs, FPGAs, and ASICs. By understanding the component's internal structure, functional behavior, and timing requirements, designers can effectively integrate it into their systems and optimize its performance and resource usage.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_handshake is
    generic (
        Width_g         : positive;
        ReadyRstState_g : std_logic             := '1';
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1'
    );
end entity;

architecture rtl of olo_base_cc_handshake is

    signal RstInI        : std_logic;
    signal In_ReadyI     : std_logic;
    signal InLatched     : std_logic := '0';
    signal InTransaction : std_logic;
    signal InAck         : std_logic;

    signal RstOutI        : std_logic;
    signal OutTransaction : std_logic;
    signal OutLatched     : std_logic := '0';
    signal OutAck         : std_logic;
    signal Out_ValidI     : std_logic;

begin

    p_in : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then

            if InAck = '1' then
                InLatched <= '0';
            end if;

            if In_Valid = '1' and In_ReadyI = '1' then
                InLatched <= '1';
            end if;

            if RstInI = '1' then
                InLatched <= '0';
            end if;
        end if;
    end process;

    In_ReadyI     <= (not InLatched) or InAck when ReadyRstState_g = '1' else
                     ((not InLatched) or InAck) and (not RstInI); -- Actively pull Ready low during reset if required
    InTransaction <= In_Valid and In_ReadyI;
    In_Ready      <= In_ReadyI;

    i_scc : entity work.olo_base_cc_simple
        generic map (
            Width_g      => Width_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => In_Clk,
            In_RstIn    => In_RstIn,
            In_RstOut   => RstInI,
            In_Data     => In_Data,
            In_Valid    => InTransaction,
            Out_Clk     => Out_Clk,
            Out_RstIn   => Out_RstIn,
            Out_RstOut  => RstOutI,
            Out_Data    => Out_Data,
            Out_Valid   => OutTransaction
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    i_bcc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk          => Out_Clk,
            In_RstIn        => RstOutI,
            In_Pulse(0)     => OutAck,
            Out_Clk         => In_Clk,
            Out_RstIn       => RstInI,
            Out_Pulse(0)    => InAck
        );

    p_out : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then

            if OutTransaction = '1' and Out_Ready = '0' then
                OutLatched <= '1';
            elsif Out_Ready = '1' then
                OutLatched <= '0';
            end if;

            if RstOutI = '1' then
                OutLatched <= '0';
            end if;
        end if;
    end process;

    Out_ValidI <= OutTransaction or OutLatched;
    OutAck     <= Out_ValidI and Out_Ready;
    Out_Valid  <= Out_ValidI;

end architecture;"
"The `olo_base_cc_reset` component is a clock domain crossing (CDC) reset synchronizer designed to facilitate the transfer of reset signals between two asynchronous clock domains, `A_Clk` and `B_Clk`. Its primary purpose is to ensure that the reset signals, `A_RstOut` and `B_RstOut`, are properly synchronized and asserted in both clock domains, preventing metastability and data corruption. The component features two primary input ports: `A_Clk` and `B_Clk`, which are the clock signals for the two respective domains. The input ports `A_RstIn` and `B_RstIn` are used to inject reset requests into the component. The output ports `A_RstOut` and `B_RstOut` provide the synchronized reset signals for each clock domain. A detailed examination of the input/output ports reveals that `A_Clk` and `B_Clk` are used to clock the internal registers and state machines, while `A_RstIn` and `B_RstIn` are asynchronous reset requests that can be asserted to reset the component. The `A_RstOut` and `B_RstOut` ports are driven by internal latch signals, `RstALatch` and `RstBLatch`, which are set or cleared based on the state of the reset requests and acknowledgments. Internally, the component consists of two main sections: the asynchronous reset request generators and the synchronous reset acknowledgment detectors. The asynchronous reset request generators produce reset requests, `RstRqstB2A` and `RstRqstA2B`, which are then synchronized with the opposing clock domain through shift registers. The synchronous reset acknowledgment detectors, implemented using the `olo_base_cc_bits` entity, generate the reset acknowledgments, `RstAckB2A` and `RstAckA2B`, which are then used to clear the internal latch signals. The architectural description reveals a complex interplay between the internal signals. The `RstRqstB2A` and `RstRqstA2B` signals are generated by shifting a '1' through a series of flip-flops, effectively creating a synchronizer for the reset requests. The `RstAckB2A` and `RstAckA2B` signals are generated by the `olo_base_cc_bits` entity, which synchronizes the opposing domain's reset request with the local clock. The functional behavior of the component can be described as follows: when a reset request is asserted on either `A_RstIn` or `B_RstIn`, the corresponding internal latch signal, `RstALatch` or `RstBLatch`, is set. The reset request is then synchronized with the opposing clock domain through the shift registers, producing a reset request signal, `RstRqstB2A` or `RstRqstA2B`. The opposing domain's reset acknowledgment signal, `RstAckB2A` or `RstAckA2B`, is then used to clear the internal latch signal, effectively terminating the reset. The control logic of the component relies on the internal latch signals, `RstALatch` and `RstBLatch`, which are set or cleared based on the state of the reset requests and acknowledgments. The reset requests are synchronized with the opposing clock domain through the shift registers, ensuring that the reset signals are properly asserted and deasserted. The data flow through the component can be described as follows: the reset requests, `A_RstIn` and `B_RstIn`, are injected into the component and used to set the internal latch signals. The latch signals are then used to drive the reset outputs, `A_RstOut` and `B_RstOut`. The reset requests are synchronized with the opposing clock domain through the shift registers, producing reset request signals that are then used to generate the reset acknowledgments. The component's timing and synchronization are critical to its proper operation. The use of shift registers to synchronize the reset requests ensures that the reset signals are properly asserted and deasserted in both clock domains. The `olo_base_cc_bits` entity is used to synchronize the opposing domain's reset request with the local clock, ensuring that the reset acknowledgments are properly generated. The component features several special features, including the ability to suppress extraction of the internal shift registers and the use of specific synthesis attributes to control the implementation of the component. The `olo_base_cc_reset` component is typically used in systems that require the transfer of reset signals between multiple clock domains, such as in systems-on-chip (SoCs) or field-programmable gate arrays (FPGAs). The component's ability to properly synchronize reset signals between clock domains makes it an essential component in many digital systems. In terms of implementation considerations, the component's performance and resource usage are dependent on the specific technology and synthesis tools used. However, the component's use of shift registers and the `olo_base_cc_bits` entity suggests that it is designed to be efficient in terms of area and power consumption. The component's design also suggests that it is optimized for high-reliability applications, where the proper synchronization of reset signals is critical to preventing data corruption and ensuring system stability. The design trade-offs involved in creating this component include balancing the need for proper reset synchronization with the need for low power consumption and small area. The use of shift registers and the `olo_base_cc_bits` entity suggests that the component is designed to be efficient in terms of area and power consumption, while still providing the necessary reset synchronization functionality. Overall, the `olo_base_cc_reset` component is a critical component in many digital systems, providing a reliable and efficient means of synchronizing reset signals between multiple clock domains. Its use of shift registers, internal latch signals, and the `olo_base_cc","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_base_cc_reset is
    generic (
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        A_Clk       : in    std_logic;
        A_RstIn     : in    std_logic := '0';
        A_RstOut    : out   std_logic;
        B_Clk       : in    std_logic;
        B_RstIn     : in    std_logic := '0';
        B_RstOut    : out   std_logic
    );
end entity;

architecture struct of olo_base_cc_reset is

    signal RstALatch  : std_logic                    := '1';
    signal RstRqstB2A : std_logic_vector(2 downto 0) := (others => '0');
    signal RstAckB2A  : std_logic;

    signal RstBLatch  : std_logic                    := '1';
    signal RstRqstA2B : std_logic_vector(2 downto 0) := (others => '0');
    signal RstAckA2B  : std_logic;

    attribute shreg_extract of RstRqstB2A : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckB2A  : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstRqstA2B : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RstAckA2B  : signal is ShregExtract_SuppressExtraction_c;

    attribute syn_srlstyle of RstRqstB2A : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckB2A  : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstRqstA2B : signal is SynSrlstyle_FlipFlops_c;
    attribute syn_srlstyle of RstAckA2B  : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of RstRqstB2A : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckB2A  : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstRqstA2B : signal is DontMerge_SuppressChanges_c;
    attribute dont_merge of RstAckA2B  : signal is DontMerge_SuppressChanges_c;

    attribute preserve of RstRqstB2A : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstAckB2A  : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstRqstA2B : signal is Preserve_SuppressChanges_c;
    attribute preserve of RstAckA2B  : signal is Preserve_SuppressChanges_c;

    attribute syn_keep of RstRqstB2A : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckB2A  : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstRqstA2B : signal is SynKeep_SuppressChanges_c;
    attribute syn_keep of RstAckA2B  : signal is SynKeep_SuppressChanges_c;

    attribute syn_preserve of RstRqstB2A : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckB2A  : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstRqstA2B : signal is SynPreserve_SuppressChanges_c;
    attribute syn_preserve of RstAckA2B  : signal is SynPreserve_SuppressChanges_c;

    attribute async_reg of RstRqstB2A : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckB2A  : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstRqstA2B : signal is AsyncReg_TreatAsync_c;
    attribute async_reg of RstAckA2B  : signal is AsyncReg_TreatAsync_c;

begin

    p_a_rst_sync : process (A_Clk, RstBLatch) is
    begin
        if RstBLatch = '1' then
            RstRqstB2A <= (others => '1');
        elsif rising_edge(A_Clk) then
            RstRqstB2A <= RstRqstB2A(RstRqstB2A'left - 1 downto 0) & '0';
        end if;
    end process;

    p_a_rst : process (A_Clk) is
    begin
        if rising_edge(A_Clk) then
            if A_RstIn = '1' then
                RstALatch <= '1';
            elsif RstAckB2A = '1' then
                RstALatch <= '0';
            end if;
        end if;
    end process;

    A_RstOut <= RstALatch or RstRqstB2A(RstRqstB2A'left);

    p_b_rst_sync : process (B_Clk, RstALatch) is
    begin
        if RstALatch = '1' then
            RstRqstA2B <= (others => '1');
        elsif rising_edge(B_Clk) then
            RstRqstA2B <= RstRqstA2B(RstRqstA2B'left - 1 downto 0) & '0';
        end if;
    end process;

    p_b_rst : process (B_Clk) is
    begin
        if rising_edge(B_Clk) then
            if B_RstIn = '1' then
                RstBLatch <= '1';
            elsif RstAckA2B = '1' then
                RstBLatch <= '0';
            end if;
        end if;
    end process;

    B_RstOut <= RstBLatch or RstRqstA2B(RstRqstA2B'left);

    i_ackb2a : entity work.olo_base_cc_bits
        generic map (
            Width_g      => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => B_Clk,
            In_Rst      => '0',
            In_Data(0)  => RstRqstA2B(RstRqstA2B'left),
            Out_Clk     => A_Clk,
            Out_Rst     => '0',
            Out_Data(0) => RstAckB2A
        );

    i_acka2b : entity work.olo_base_cc_bits
        generic map (
            Width_g      => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => A_Clk,
            In_Rst      => '0',
            In_Data(0)  => RstRqstB2A(RstRqstA2B'left),
            Out_Clk     => B_Clk,
            Out_Rst     => '0',
            Out_Data(0) => RstAckA2B
        );

end architecture;"
"The `olo_base_cc_simple` component is a clock domain crossing (CDC) module designed to transfer data from one clock domain to another while ensuring data validity and synchronization. Its primary purpose is to facilitate communication between two asynchronous clock domains, making it a crucial component in systems that require data exchange between different clock zones. The component has several input and output ports that play distinct roles in its operation. The input ports include `In_Clk`, `In_RstIn`, `In_Data`, and `In_Valid`, which are associated with the input clock domain. The `In_Clk` port is the clock input for the input domain, while `In_RstIn` is an optional reset input. The `In_Data` port is a vector of width `Width_g` that carries the data to be transferred, and `In_Valid` is a control signal indicating the validity of the input data. On the output side, the component has `Out_Clk`, `Out_RstIn`, `Out_Data`, and `Out_Valid` ports, which are associated with the output clock domain. The `Out_Clk` port is the clock input for the output domain, and `Out_RstIn` is an optional reset input. The `Out_Data` port is a vector of width `Width_g` that carries the transferred data, and `Out_Valid` is a control signal indicating the validity of the output data. Internally, the component consists of several key elements. The `i_pulse_cc` instance is a pulse CDC module (`olo_base_cc_pulse`) that synchronizes the `In_Valid` pulse from the input clock domain to the output clock domain, producing the `VldOutI` signal. This synchronization process involves a configurable number of synchronization stages (`SyncStages_g`) to ensure reliable crossing of the clock domains. The `DataLatchIn` signal is a latch that captures the input data when `In_Valid` is high, and its output is used to drive the `Out_Data_Sig` signal in the output clock domain. The component's architectural structure can be understood by examining the two main processes, `p_data_a` and `p_data_b`. The `p_data_a` process, clocked by `In_Clk`, captures the input data into the `DataLatchIn` latch when `In_Valid` is high. On the other hand, the `p_data_b` process, clocked by `Out_Clk`, updates the `Out_Valid` and `Out_Data_Sig` signals based on the synchronized `VldOutI` pulse and the reset condition. The control logic of the component is primarily governed by the interaction between the `i_pulse_cc` instance, the `p_data_a` and `p_data_b` processes, and the reset conditions. The `RstInI` and `RstOutI` signals are used to reset the input and output domains, respectively. The `Out_Valid` signal is asserted when the `VldOutI` pulse is high and deasserted when the reset condition is met. Data flow through the component involves the capture of input data into the `DataLatchIn` latch, followed by the transfer of this data to the `Out_Data_Sig` signal in the output clock domain, synchronized with the `VldOutI` pulse. The data is then presented at the `Out_Data` output port. The component's timing and synchronization are critical aspects of its operation. The input and output clock domains are assumed to be asynchronous, and the component uses a synchronization mechanism to ensure that data is transferred reliably between the domains. The `SyncStages_g` generic parameter allows for configuration of the synchronization process to meet specific timing requirements. The `olo_base_cc_simple` component has several special features that make it suitable for use in a wide range of applications. The use of a pulse CDC module (`i_pulse_cc`) allows for efficient and reliable synchronization of control signals across clock domains. The component also supports optional reset inputs for both clock domains, providing flexibility in system design. The component is typically used in systems that require data transfer between different clock domains, such as in complex digital systems-on-chip (SoCs), field-programmable gate arrays (FPGAs), or application-specific integrated circuits (ASICs). The `olo_base_cc_simple` component can be used in various applications, including data processing, storage, and communication systems. When implementing the `olo_base_cc_simple` component, designers should consider performance, resource usage, and design trade-offs. The component's resource usage is influenced by the `Width_g` and `SyncStages_g` generic parameters, which determine the complexity of the data path and synchronization logic, respectively. Designers should balance these parameters to meet the required performance and resource constraints of the target system. Additionally, careful consideration of timing constraints and clock domain crossing requirements is essential to ensure reliable operation of the component in the larger system. The attributes `dont_touch` and `keep` are applied to the `Out_Data_Sig` signal to prevent optimization and ensure that the signal is preserved in the synthesized design. This is crucial for maintaining the integrity of the data path and preventing unintended changes during the synthesis process. Overall, the `olo_base_cc_simple` component provides a reliable and efficient solution for clock domain crossing, enabling the transfer of data between asynchronous clock domains while ensuring data validity and synchronization. Its flexibility, configurability, and robust operation make it a valuable component in a wide range of digital system designs.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_base_cc_simple is
    generic (
        Width_g      : positive              := 1;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid    : in    std_logic;
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic
    );
end entity;

architecture struct of olo_base_cc_simple is

    signal RstInI      : std_logic;
    signal DataLatchIn : std_logic_vector(Width_g - 1 downto 0);
    signal RstOutI     : std_logic;
    signal VldOutI     : std_logic;

    signal Out_Data_Sig : std_logic_vector(Width_g - 1 downto 0);

    attribute dont_touch of Out_Data_Sig : signal is DontTouch_SuppressChanges_c;
    attribute keep of Out_Data_Sig       : signal is Keep_SuppressChanges_c;

begin

    i_pulse_cc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk       => In_Clk,
            In_RstIn     => In_RstIn,
            In_RstOut    => RstInI,
            In_Pulse(0)  => In_Valid,
            Out_Clk      => Out_Clk,
            Out_RstIn    => Out_RstIn,
            Out_RstOut   => RstOutI,
            Out_Pulse(0) => VldOutI
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    p_data_a : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' then
                DataLatchIn <= In_Data;
            end if;
        end if;
    end process;

    p_data_b : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            Out_Valid <= VldOutI;
            if VldOutI = '1' then
                Out_Data_Sig <= DataLatchIn;
            end if;
            if RstOutI = '1' then
                Out_Valid <= '0';
            end if;
        end if;
    end process;

    Out_Data <= Out_Data_Sig;

end architecture;"
"The `olo_base_cc_status` component is a clock domain crossing (CDC) module designed to transfer data and reset signals between two asynchronous clock domains. Its primary purpose is to ensure reliable data transfer and synchronization between the input clock domain (`In_Clk`) and the output clock domain (`Out_Clk`). This component plays a crucial role in larger systems that involve multiple clock domains, such as system-on-chip (SoC) designs, field-programmable gate arrays (FPGAs), or application-specific integrated circuits (ASICs). The component has several input and output ports, each with specific purposes and requirements. The input ports include `In_Clk`, `In_RstIn`, `In_Data`, `Out_Clk`, and `Out_RstIn`. The `In_Clk` and `Out_Clk` ports are the input and output clocks, respectively, which are asynchronous and may have different frequencies. The `In_RstIn` and `Out_RstIn` ports are the input reset signals for the input and output clock domains, respectively. The `In_Data` port is the input data bus with a width defined by the `Width_g` generic parameter. The output ports include `In_RstOut`, `Out_RstOut`, and `Out_Data`, which are the output reset signals and the output data bus, respectively. Internally, the component consists of several key modules, including a validity generator (`p_vldgen`), a simple clock crossing module (`i_scc`), and a pulse generator (`i_bcc`). The validity generator is responsible for generating a validity signal (`VldIn`) that indicates when the input data is valid. This signal is used to control the flow of data through the component. The simple clock crossing module performs the actual clock domain crossing of the input data and reset signals. The pulse generator generates a feedback validity signal (`VldFb`) that is used to synchronize the validity signal across the clock domains. The architectural description reveals that the component uses a combination of registers, counters, and state machines to manage the flow of data and control signals. The `RstOutI_Sync` signal is a synchronized reset signal that is used to reset the component in case of a reset event. The `Started` signal indicates whether the component has started its operation. The `VldIn` and `VldOut` signals are used to control the validity of the input and output data, respectively. The functional behavior of the component can be described as follows: when the component is reset, the validity generator sets the `VldIn` signal to '1' and the `Started` signal to '1'. When the input data is valid, the simple clock crossing module transfers the data to the output clock domain. The pulse generator generates a feedback validity signal that is used to synchronize the validity signal across the clock domains. The output reset signals (`In_RstOut` and `Out_RstOut`) are generated based on the synchronized reset signals. The control logic of the component is primarily managed by the validity generator and the simple clock crossing module. The validity generator controls the flow of data by generating the `VldIn` signal, which is used to enable or disable the transfer of data. The simple clock crossing module manages the clock domain crossing of the data and reset signals. The pulse generator controls the synchronization of the validity signal across the clock domains. The data flow through the component involves the transfer of data from the input clock domain to the output clock domain. The input data is first synchronized with the input clock domain's reset signal, and then transferred to the output clock domain using the simple clock crossing module. The output data is then synchronized with the output clock domain's reset signal. The component has specific timing and synchronization requirements. The input and output clocks are asynchronous, and the component uses synchronization stages to ensure reliable data transfer. The `SyncStages_g` generic parameter defines the number of synchronization stages used in the component. The component also has setup and hold requirements for the input and output data, which must be met to ensure reliable operation. One of the special features of this component is its ability to handle reset signals in both clock domains. The component generates output reset signals (`In_RstOut` and `Out_RstOut`) that are synchronized with the respective clock domains. This feature is essential in systems where reset signals need to be propagated across clock domains. The `olo_base_cc_status` component is typically used in systems that involve multiple clock domains, such as SoCs, FPGAs, or ASICs. It is particularly useful in systems that require reliable data transfer between clock domains, such as data processing systems, communication systems, or storage systems. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The component's performance is influenced by the clock frequencies, the number of synchronization stages, and the input data rate. The resource usage is influenced by the component's architecture, the number of registers, and the complexity of the control logic. Designers should optimize the component's architecture and parameters to meet the system's performance and resource requirements. In conclusion, the `olo_base_cc_status` component is a clock domain crossing module that enables reliable data transfer and synchronization between two asynchronous clock domains. Its internal structure, functional behavior, and control logic are designed to ensure reliable operation in systems with multiple clock domains. The component's features, such as reset signal handling and synchronization stages, make it suitable for a wide range of applications, from data processing systems to communication systems. By understanding the component's architecture and behavior, designers can effectively use it in their systems and ensure reliable data transfer between clock domains.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_cc_status is
    generic (
        Width_g      : positive;
        SyncStages_g : positive range 2 to 4 := 2
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic := '0';
        In_RstOut   : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic;
        Out_RstOut  : out   std_logic := '0';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_status is

    signal RstInI       : std_logic;
    signal Started      : std_logic := '0';
    signal RstOutI_Sync : std_logic_vector(1 downto 0);
    signal VldIn        : std_logic;
    signal VldFb        : std_logic;

    signal RstOutI : std_logic;
    signal VldOut  : std_logic;

begin

    p_vldgen : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            VldIn <= VldFb;

            if (Started = '0') then
                VldIn   <= '1';
                Started <= '1';
            end if;

            if RstInI = '1' then
                RstOutI_Sync <= (others => '1');
                Started      <= '0';
                VldIn        <= '0';
            end if;
        end if;
    end process;

    i_scc : entity work.olo_base_cc_simple
        generic map (
            Width_g      => Width_g,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk      => In_Clk,
            In_RstIn    => In_RstIn,
            In_RstOut   => RstInI,
            In_Data     => In_Data,
            In_Valid    => VldIn,
            Out_Clk     => Out_Clk,
            Out_RstIn   => Out_RstIn,
            Out_RstOut  => RstOutI,
            Out_Data    => Out_Data,
            Out_Valid   => VldOut
        );

    In_RstOut  <= RstInI;
    Out_RstOut <= RstOutI;

    i_bcc : entity work.olo_base_cc_pulse
        generic map (
            NumPulses_g  => 1,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk          => Out_Clk,
            In_RstIn        => RstOutI,
            In_Pulse(0)     => VldOut,
            Out_Clk         => In_Clk,
            Out_RstIn       => RstInI,
            Out_Pulse(0)    => VldFb
        );

end architecture;"
"The VHDL code provided describes a digital component named `olo_base_cc_xn2n`, which appears to be a clock-domain crossing (CDC) module for transferring data between two asynchronous clock domains. This component plays a crucial role in larger systems where data needs to be transmitted between different clock zones, ensuring that data is accurately transferred without corruption or loss. The primary purpose of this component is to facilitate the transfer of data from an input clock domain (`In_Clk`) to an output clock domain (`Out_Clk`), while handling reset signals and data validity. The component is parameterized by the generic `Width_g`, which defines the bit width of the input and output data. The component has several input and output ports, each serving a specific purpose. The input ports include `In_Clk`, `In_RstIn`, `In_Valid`, `In_Ready`, and `In_Data`. The `In_Clk` and `In_RstIn` ports are used for clocking and resetting the input domain, respectively. The `In_Valid` port indicates whether the input data is valid, and `In_Ready` signals whether the component is ready to accept new data. The `In_Data` port carries the actual data being transferred. On the output side, the ports include `Out_Clk`, `Out_RstIn`, `Out_Valid`, `Out_Ready`, and `Out_Data`. The `Out_Clk` and `Out_RstIn` ports are used for clocking and resetting the output domain, respectively. The `Out_Valid` port indicates whether the output data is valid, and `Out_Ready` is used to throttle the output data transfer. The `Out_Data` port carries the transferred data. Internally, the component consists of several registers and counters. The `InCnt` and `OutCnt` signals are counters used to keep track of the input and output data, respectively. The `InDataReg` and `InDataRegLast` signals are registers that store the input data and the previous input data, respectively. The `OutIn_Valid` signal indicates whether valid data is available on the output. The component's architecture consists of two main processes: `p_input` and `p_output`. The `p_input` process is clocked by `In_Clk` and handles the input data transfer. When `In_Valid` is high and there is space available in the internal buffer (i.e., `InCnt - OutCnt /= 2`), the process increments the `InCnt` counter, stores the input data in `InDataReg`, and stores the previous data in `InDataRegLast`. The process also resets the `InCnt` counter when an internal reset signal (`InRstInt`) is asserted. The `p_output` process is clocked by `Out_Clk` and handles the output data transfer. When valid data is available on the input (i.e., `InCnt /= OutCnt`) and the output is ready (i.e., `Out_Ready = '1'`), the process transfers the data from `InDataReg` or `InDataRegLast` to `Out_Data`, increments the `OutCnt` counter, and sets `OutIn_Valid` high. The process also resets the `OutCnt` counter and `OutIn_Valid` signal when an internal reset signal (`OutRstInt`) is asserted. The component uses a separate entity (`olo_base_cc_reset`) to handle the reset signals and synchronize them across the clock domains. The `In_RstOut` and `Out_RstOut` ports provide the synchronized reset signals for the input and output domains, respectively. The component's functional behavior can be described as follows: when valid data is presented on the input and there is space available in the internal buffer, the component accepts the data and transfers it to the output domain when the output is ready. The component handles backpressure on the output by throttling the data transfer based on the `Out_Ready` signal. The control logic of the component is primarily governed by the counters, valid signals, and reset signals. The internal reset signals (`InRstInt` and `OutRstInt`) are used to reset the counters and registers, ensuring that the component returns to a known state after a reset. Data flow through the component involves the following steps: input data is registered on the rising edge of `In_Clk`, stored in `InDataReg`, and then transferred to the output domain on the rising edge of `Out_Clk`. The data is then presented on `Out_Data` and flagged as valid using `Out_Valid`. The component's timing and synchronization are critical aspects of its design. The use of asynchronous clock domains requires careful consideration of setup and hold times to prevent data corruption or loss. The component's internal registers and counters are designed to operate within the constraints of the input and output clocks. One special feature of this component is its ability to handle backpressure on the output, allowing it to operate in systems where the output data rate may vary. The component also provides synchronized reset signals for both clock domains, ensuring that the system can be reset reliably. This component would typically be used in systems that involve data transfer between different clock domains, such as in complex digital systems-on-chip (SoCs), field-programmable gate arrays (FPGAs), or application-specific integrated circuits (ASICs). The component's ability to handle asynchronous clocks and provide synchronized reset signals makes it a valuable building block in such systems. In terms of implementation considerations, the component's performance is influenced by the choice of clock frequencies, data width, and the specific technology used for implementation. The component's resource usage will depend on the target technology and the specific synthesis and place-and-route tools used. Design trade-offs may involve optimizing the component for area, power consumption, or performance, depending on","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_cc_xn2n is
    generic (
        Width_g       : positive
    );
    port (
        In_Clk      : in    std_logic;
        In_RstIn    : in    std_logic;
        In_RstOut   : out   std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Clk     : in    std_logic;
        Out_RstIn   : in    std_logic := '0';
        Out_RstOut  : out   std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_cc_xn2n is

    signal InCnt         : unsigned(1 downto 0);
    signal InRstInt      : std_logic;
    signal InDataReg     : std_logic_vector(Width_g - 1 downto 0);
    signal InDataRegLast : std_logic_vector(Width_g - 1 downto 0);

    signal OutCnt      : unsigned(1 downto 0);
    signal OutRstInt   : std_logic;
    signal OutIn_Valid : std_logic;

begin

    In_Ready <= '1' when (InCnt - OutCnt /= 2) and (InRstInt = '0') else '0';

    p_input : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            if In_Valid = '1' and InCnt - OutCnt /= 2 then
                InCnt         <= InCnt + 1;
                InDataReg     <= In_Data;
                InDataRegLast <= InDataReg;
            end if;
            if InRstInt = '1' then
                InCnt <= (others => '0');
            end if;
        end if;
    end process;

    p_output : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            if OutIn_Valid = '1' and Out_Ready = '1' then
                OutIn_Valid <= '0';
            end if;
            if InCnt /= OutCnt and (OutIn_Valid = '0' or Out_Ready = '1') then
                if InCnt - OutCnt = 1 then
                    Out_Data <= InDataReg;
                else
                    Out_Data <= InDataRegLast;
                end if;
                OutIn_Valid <= '1';
                OutCnt      <= OutCnt + 1;
            end if;
            if OutRstInt = '1' then
                OutCnt      <= (others => '0');
                OutIn_Valid <= '0';
            end if;
        end if;
    end process;

    Out_Valid <= OutIn_Valid;

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_RstIn,
            A_RstOut    => InRstInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_RstIn,
            B_RstOut    => OutRstInt
        );

    In_RstOut  <= InRstInt;
    Out_RstOut <= OutRstInt;

end architecture;"
"The `olo_base_crc` component is a Cyclic Redundancy Check (CRC) generator designed to compute a CRC value for a given input data stream. Its primary purpose is to provide data integrity verification by detecting errors in digital data transmission or storage. This component plays a crucial role in larger systems, such as communication protocols, data storage systems, and digital signal processing, where data reliability and accuracy are paramount. The component features a generic interface, allowing for flexible configuration of its key parameters, including the CRC width (`CrcWidth_g`), data width (`DataWidth_g`), polynomial (`Polynomial_g`), initial value (`InitialValue_g`), bit order (`BitOrder_g`), byte order (`ByteOrder_g`), bit flip output (`BitflipOutput_g`), and XOR output (`XorOutput_g`). These generics enable the component to be tailored to specific CRC algorithms and application requirements. The input ports include `Clk` (clock), `Rst` (reset), `In_Data` (input data), `In_Valid` (input data validity), `In_Last` (input data last indication), and `In_First` (input data first indication). The output ports comprise `Out_Crc` (CRC value), `Out_Valid` (CRC validity), and `In_Ready` (input data readiness). The `Out_Ready` port is an input that indicates the readiness of the downstream component to accept the CRC value. Internally, the component employs a Linear Feedback Shift Register (LFSR) to compute the CRC value. The LFSR is initialized with the specified `InitialValue_g` and updated based on the input data and polynomial. The `p_lfsr` process implements the LFSR update logic, which involves iterating over each bit of the input data, updating the LFSR value based on the polynomial and input bit, and finally, generating the CRC output. The component's architectural description reveals a straightforward implementation of the CRC calculation. The LFSR register (`LfsrReg`) is updated on each clock cycle, based on the input data and control signals. The `Out_Valid_I` signal indicates the validity of the CRC output, which is asserted when the input data has been fully processed. The functional behavior of the component can be described as follows: when the component is reset, the LFSR is initialized with the `InitialValue_g`, and the CRC output is set to zero. As input data is received, the LFSR is updated iteratively, and the CRC value is computed. When the input data is marked as the last (`In_Last = '1'`), the LFSR is reset to the `InitialValue_g`, and the CRC output is asserted as valid. The control logic of the component is primarily governed by the `p_lfsr` process, which manages the LFSR updates, CRC computation, and output generation. The `In_Ready_I` signal is generated based on the `Out_Ready` and `Out_Valid_I` signals, ensuring that the component can accept new input data only when the previous CRC value has been accepted by the downstream component. Data flow through the component involves the input data being processed in a bit-serial manner, with each bit influencing the LFSR update. The CRC output is generated by XORing the final LFSR value with the `XorOutput_g` value. The component's timing and synchronization are critical to its correct operation. The LFSR updates occur on each clock cycle, and the CRC output is generated based on the input data and control signals. The component assumes that the input data is synchronous with the clock and that the `Out_Ready` signal is properly asserted to indicate the readiness of the downstream component. A notable feature of the component is its support for flexible bit and byte ordering, which allows it to accommodate various data formats. Additionally, the component provides options for bit flipping and XORing the output CRC value, further enhancing its versatility. The `olo_base_crc` component is suitable for use in a wide range of applications, including data communication protocols, digital storage systems, and embedded systems. Its configurability and flexibility make it an attractive solution for designers seeking to implement CRC functionality in their systems. In terms of implementation considerations, the component's performance is primarily determined by the clock frequency and the complexity of the LFSR update logic. The resource usage is influenced by the selected CRC width, data width, and polynomial. Design trade-offs may involve balancing the component's configurability with area and performance requirements. Overall, the `olo_base_crc` component provides a robust and flexible CRC generation solution for digital system designers.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_math.all;

entity olo_base_crc is
    generic (
        CrcWidth_g      : positive range 2 to natural'high;
        DataWidth_g     : positive;
        Polynomial_g    : natural;  -- according to https://crccalc.com/?crc=01&method=CRC-8&datatype=hex&outtype=bin
        InitialValue_g  : natural := 0;
        BitOrder_g      : string  := ""MSB_FIRST""; -- ""MSB_FIRST"" or ""LSB_FIRST""
        ByteOrder_g     : string  := ""NONE"";      -- ""NONE"", ""MSB_FIRST"" or ""LSB_FIRST""
        BitflipOutput_g : boolean := false;
        XorOutput_g     : natural := 0
    );
    port (
        Clk              : in    std_logic;
        Rst              : in    std_logic;
        In_Data          : in    std_logic_vector(DataWidth_g-1 downto 0);
        In_Valid         : in    std_logic := '1';
        In_Ready         : out   std_logic;
        In_Last          : in    std_logic := '0';
        In_First         : in    std_logic := '0';
        Out_Crc          : out   std_logic_vector(CrcWidth_g-1 downto 0);
        Out_Valid        : out   std_logic;
        Out_Ready        : in    std_logic := '1'
    );
end entity;


architecture rtl of olo_base_crc is

    constant Polynomial_c   : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(Polynomial_g, CrcWidth_g);
    constant InitialValue_c : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(InitialValue_g, CrcWidth_g);
    constant XorOutput_c    : std_logic_vector(CrcWidth_g-1 downto 0) := toUslv(XorOutput_g, CrcWidth_g);

    signal LfsrReg     : std_logic_vector(CrcWidth_g-1 downto 0);
    signal Out_Valid_I : std_logic;
    signal In_Ready_I  : std_logic;

begin

    assert BitOrder_g = ""MSB_FIRST"" or BitOrder_g = ""LSB_FIRST""
        report ""###ERROR###: olo_base_crc - Illegal value for BitOrder_g""
        severity error;
    assert ByteOrder_g = ""NONE"" or ByteOrder_g = ""LSB_FIRST"" or ByteOrder_g = ""MSB_FIRST""
        report ""###ERROR###: olo_base_crc - Illegal value for ByteOrder_g""
        severity error;
    assert ByteOrder_g = ""NONE"" or DataWidth_g mod 8 = 0
        report ""###ERROR###: olo_base_crc - For DataWidth_g not being a multiple of 8, only ByteOrder_g=NONE is allowed""
        severity error;

    p_lfsr : process (Clk) is
        variable Input_v : std_logic_vector(In_Data'range);
        variable Lfsr_v  : std_logic_vector(LfsrReg'range);
        variable InBit_v : std_logic;
        variable Out_v   : std_logic_vector(CrcWidth_g-1 downto 0);
    begin
        if rising_edge(Clk) then
            Input_v := In_Data;
            if BitOrder_g = ""MSB_FIRST"" then
                if ByteOrder_g = ""LSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v);
                end if;
            else
                if ByteOrder_g = ""MSB_FIRST"" then
                    Input_v := invertByteOrder(Input_v);
                end if;
                Input_v := invertBitOrder(Input_v);
            end if;

            if Out_Valid_I = '1' and Out_Ready = '1' then
                Out_Valid_I <= '0';
            end if;

            if In_Valid = '1' and In_Ready_I = '1' then
                if In_First = '1' then
                    Lfsr_v := InitialValue_c;
                else
                    Lfsr_v := LfsrReg;
                end if;

                for bit in DataWidth_g-1 downto 0 loop

                    InBit_v := Input_v(bit) xor Lfsr_v(Lfsr_v'high);

                    Lfsr_v := Lfsr_v(Lfsr_v'high-1 downto 0) & '0';
                    if InBit_v = '1' then
                        Lfsr_v := Lfsr_v xor Polynomial_c;
                    end if;

                end loop;

                Out_v := Lfsr_v;
                if BitflipOutput_g then
                    Out_v := invertBitOrder(Out_v);
                end if;
                Out_Crc <= Out_v xor XorOutput_c;

                if In_Last = '1' then
                    Lfsr_v      := InitialValue_c;
                    Out_Valid_I <= '1';
                end if;
                LfsrReg <= Lfsr_v;
            end if;

            if Rst = '1' then
                LfsrReg     <= InitialValue_c;
                Out_Crc     <= (others => '0');
                Out_Valid_I <= '0';
            end if;

        end if;
    end process;

    In_Ready_I <= Out_Ready or not Out_Valid_I;

    Out_Valid <= Out_Valid_I;
    In_Ready  <= In_Ready_I;

end architecture;"
"The `olo_base_decode_firstbit` component is a digital circuit designed to find the position of the first '1' bit in a binary input vector. Its primary purpose is to decode the first bit set in a binary string, which is a fundamental operation in digital processing and data analysis. This component plays a crucial role in larger systems, particularly in applications involving data compression, encryption, and digital signal processing. The component has several input and output ports that facilitate its operation. The `In_Data` port is a `std_logic_vector` with a width defined by the `InWidth_g` generic parameter, which represents the binary input data. The `In_Valid` port is a single-bit input that indicates the validity of the input data. The `Clk` and `Rst` ports are clock and reset signals, respectively, which control the component's sequential logic. The output ports include `Out_FirstBit`, a `std_logic_vector` that represents the position of the first '1' bit; `Out_Found`, a single-bit signal indicating whether a '1' bit was found; and `Out_Valid`, a single-bit signal indicating the validity of the output. Internally, the component consists of a multi-stage architecture that employs a parallel processing approach to achieve high performance. The architecture is divided into `Stages_c` stages, each with a specific bit width and parallelism. The `BinStage_t` and `BinAll_t` types define arrays of binary vectors and arrays of these arrays, respectively, which are used to store the intermediate results. The `Found_t` type defines an array of binary vectors that indicate whether a '1' bit was found in each stage. The component's operation can be described as follows: in the first stage, the input data is divided into parallel blocks, and each block is processed to find the first '1' bit. The results are then propagated through the subsequent stages, which further refine the search. The `Addr` and `Found` arrays are used to store the intermediate results and indicate whether a '1' bit was found in each stage. The final result is generated by the last stage, which produces the position of the first '1' bit and a validity signal. The control logic of the component is governed by the `p_comb` and `p_seq` processes. The `p_comb` process combines the input data and control signals to generate the next state of the component. It also performs the necessary computations to find the first '1' bit. The `p_seq` process is a sequential process that updates the component's state on the rising edge of the clock and resets the component when the reset signal is asserted. The data flow through the component can be described as follows: the input data is first registered or directly fed into the component, depending on the value of the `InReg_g` generic parameter. The data is then processed in parallel across multiple stages, with each stage refining the search for the first '1' bit. The results are propagated through the stages, and the final result is generated by the last stage. The component has specific timing and synchronization requirements. The clock domain is defined by the `Clk` port, and the component has setup and hold requirements that must be met to ensure proper operation. The `Rst` port is used to reset the component, which ensures that it returns to a known state. One of the special features of this component is its ability to operate in a pipelined manner, with the `PlRegs_g` generic parameter controlling the number of pipeline stages. This allows the component to achieve high performance while minimizing the area and power consumption. The `olo_base_decode_firstbit` component is typically used in applications involving digital signal processing, data compression, and encryption. It can be used in a variety of systems, including data processing pipelines, digital filters, and cryptographic accelerators. In terms of implementation considerations, the component's performance is highly dependent on the values of the generic parameters, particularly `InWidth_g`, `PlRegs_g`, and `OutReg_g`. The component's area and power consumption can be optimized by carefully selecting these parameters. Additionally, the component's clock frequency and throughput can be maximized by optimizing the pipeline stages and the parallelism within each stage. Overall, the `olo_base_decode_firstbit` component is a highly efficient and flexible digital circuit that can be used in a wide range of applications. Its ability to operate in a pipelined manner and its configurable parameters make it an attractive solution for high-performance digital systems. The design also ensures that `PlRegs_g` is less than half of the ceiling of the log base 2 of `InWidth_g`, which helps to prevent potential errors. The output is registered or directly fed, depending on the `OutReg_g` generic parameter, which adds flexibility to the component. implements the specifications using structural and behavioral constructs, adhering to professional coding practices. The code organization and commenting facilitate readability and comprehension. Overall, the component's design provides a robust and efficient solution for finding the first '1' bit in a binary vector.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_decode_firstbit is
    generic (
        InWidth_g       : positive;
        InReg_g         : boolean := true;
        OutReg_g        : boolean := true;
        PlRegs_g        : natural := 1
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;

        In_Data         : in    std_logic_vector(InWidth_g-1 downto 0);
        In_Valid        : in    std_logic := '1';

        Out_FirstBit    : out   std_logic_vector(log2ceil(InWidth_g)-1 downto 0);
        Out_Found       : out   std_logic;
        Out_Valid       : out   std_logic
    );
end entity;

architecture rtl of olo_base_decode_firstbit is

    constant Stages_c         : natural := PlRegs_g+1;
    constant BinBits_c        : natural := log2ceil(InWidth_g);
    constant InWidthPow2_c    : natural := 2**BinBits_c;
    constant AddrBitsStageN_c : natural := BinBits_c/Stages_c;
    constant AddrBitsStage1_c : natural := BinBits_c - AddrBitsStageN_c*(Stages_c-1);
    constant ParallelStage1_c : natural := InWidthPow2_c/2**AddrBitsStage1_c;

    type BinStage_t is array (0 to ParallelStage1_c-1) of std_logic_vector(BinBits_c-1 downto 0);
    type BinAll_t is array(0 to Stages_c-1) of BinStage_t;
    type Found_t is array(0 to Stages_c-1) of std_logic_vector(ParallelStage1_c-1 downto 0);

    type TwoProcess_r is record
        DataIn   : std_logic_vector(In_Data'range);
        ValidIn  : std_logic;
        Addr     : BinAll_t;
        Found    : Found_t;
        Valid    : std_logic_vector(Stages_c-1 downto 0);
        FirstBit : std_logic_vector(Out_FirstBit'range);
        FoundOut : std_logic;
        ValidOut : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert PlRegs_g < BinBits_c/2
        report ""olo_base_decode_firstbit - PlRegs_g must be smaller than ceil(log2(InWidth_g))/2""
        severity error;

    p_comb : process (r, In_Data, In_Valid) is
        variable v                : TwoProcess_r;
        variable DataIn_v         : std_logic_vector(2**BinBits_c-1 downto 0);
        variable InValid_v        : std_logic;
        variable AddrBits_v       : natural;
        variable AddrLowIdx_v     : natural;
        variable AddrHighIdx_v    : natural;
        variable Parallelism_v    : natural;
        variable AddrBitsRemain_v : natural;
        variable StartIdx_v       : natural;
        variable InBitsPerInst_v  : natural;
    begin
        v := r;

        DataIn_v := (others => '0');
        if InReg_g then
            v.DataIn                       := In_Data;
            v.ValidIn                      := In_Valid;
            InValid_v                      := r.ValidIn;
            DataIn_v(InWidth_g-1 downto 0) := r.DataIn;
        else
            DataIn_v(InWidth_g-1 downto 0) := In_Data;
            InValid_v                      := In_Valid;
        end if;

        AddrLowIdx_v     := 0;
        AddrBitsRemain_v := BinBits_c;

        for stg in 0 to Stages_c-1 loop
            if stg = 0 then
                v.Valid(stg) := InValid_v;
            else
                v.Valid(stg) := r.Valid(stg-1);
            end if;

            if stg = 0 then
                AddrBits_v := AddrBitsStage1_c;
            else
                AddrBits_v := AddrBitsStageN_c;
            end if;
            AddrHighIdx_v    := AddrLowIdx_v + AddrBits_v - 1;
            AddrBitsRemain_v := AddrBitsRemain_v - AddrBits_v;
            Parallelism_v    := 2**AddrBitsRemain_v;

            InBitsPerInst_v := 2**AddrBits_v;
            StartIdx_v      := 0;

            if stg = 0 then

                for inst in 0 to Parallelism_v-1 loop
                    v.Found(0)(inst) := '0';

                    for bit in 0 to InBitsPerInst_v-1 loop
                        if DataIn_v(StartIdx_v+bit) = '1' then
                            v.Addr(0)(inst)  := toUslv(bit, BinBits_c);
                            v.Found(0)(inst) := '1';
                            exit;
                        end if;
                    end loop;

                    StartIdx_v := StartIdx_v + InBitsPerInst_v;
                end loop;

            else

                for inst in 0 to Parallelism_v-1 loop
                    v.Found(stg)(inst) := '0';

                    for bit in 0 to InBitsPerInst_v-1 loop
                        if r.Found(stg-1)(StartIdx_v+bit) = '1' then
                            v.Addr(stg)(inst)                                    := r.Addr(stg-1)(StartIdx_v+bit);
                            v.Addr(stg)(inst)(AddrHighIdx_v downto AddrLowIdx_v) := toUslv(bit, AddrBits_v);
                            v.Found(stg)(inst)                                   := '1';
                            exit;
                        end if;
                    end loop;

                    StartIdx_v := StartIdx_v + InBitsPerInst_v;
                end loop;

            end if;

            AddrLowIdx_v := AddrLowIdx_v + AddrBits_v;

        end loop;

        v.FoundOut := r.Found(Stages_c-1)(0);
        if v.FoundOUt = '1' then
            v.FirstBit := r.Addr(Stages_c-1)(0);
        else
            v.FirstBit := (others => '0'); -- Output zero if not found, simplifies testing in many cases
        end if;
        v.ValidOut := r.Valid(Stages_c-1);
        if OutReg_g then
            Out_FirstBit <= r.FirstBit;
            Out_Found    <= r.FoundOut;
            Out_Valid    <= r.ValidOut;
        else
            Out_FirstBit <= v.FirstBit;
            Out_Found    <= v.FoundOut;
            Out_Valid    <= v.ValidOut;
        end if;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.ValidIn  <= '0';
                r.Valid    <= (others => '0');
                r.ValidOut <= '0';
            end if;
        end if;
    end process;

end architecture;"
"The `olo_base_delay` component is a generic, parameterized delay element designed to introduce a specified delay in digital signal processing systems. Its primary purpose is to provide a configurable delay line for input data, allowing for synchronization and timing adjustments in larger digital systems. This component can be used in a wide range of applications, from simple data pipelines to complex digital signal processing architectures. The component has several input and output ports that facilitate its operation. The `Clk` port is a clock input that drives the internal timing of the component, while the `Rst` port is an asynchronous reset signal used to initialize the component to a known state. The `In_Data` port is the input data bus, which is a vector of width `Width_g`, and `In_Valid` is a validity signal that indicates whether the input data is valid. The `Out_Data` port is the output data bus, which is also a vector of width `Width_g`. The component's architecture is defined by several generics that control its behavior. The `Width_g` generic specifies the width of the input and output data buses, while `Delay_g` specifies the number of clock cycles of delay to be introduced. The `Resource_g` generic determines the type of resource used to implement the delay, which can be either a shift register (`SRL`), a block RAM (`BRAM`), or an automatically selected resource based on the delay length and a threshold value (`AUTO`). The `BramThreshold_g` generic sets the threshold value for automatic resource selection, and `RstState_g` controls the behavior of the output during reset. Finally, `RamBehavior_g` specifies the behavior of the RAM resource. Internally, the component uses a combination of registers, counters, and memory resources to implement the delay. If the `Resource_g` generic is set to `SRL` or `AUTO` with a short delay, the component uses a shift register (`SrlSig`) to store the input data. The shift register is updated on each clock cycle, and its output is used to drive the `MemOut` signal. If the `Resource_g` generic is set to `BRAM` or `AUTO` with a long delay, the component uses a block RAM (`olo_base_ram_sdp`) to store the input data. The RAM is written and read using separate address counters (`WrAddr` and `RdAddr`), which are incremented on each clock cycle. The component's functional behavior can be described as follows. On each clock cycle, the input data is sampled and stored in the selected resource (shift register or RAM). The stored data is then shifted or read out after the specified delay, and the output data is driven onto the `Out_Data` port. If the `Rst` signal is asserted, the component is reset to a known state, and the output data is driven to zero. The control logic of the component is responsible for managing the flow of data through the delay element. The `In_Valid` signal is used to enable the storage of input data, and the `Rst` signal is used to reset the component. The `RstState_g` generic controls the behavior of the output during reset, allowing the user to specify whether the output should be driven to zero or retain its previous value. Data flow through the component is straightforward. Input data is sampled on each clock cycle and stored in the selected resource. The stored data is then shifted or read out after the specified delay, and the output data is driven onto the `Out_Data` port. If the `Resource_g` generic is set to `BRAM`, the data is stored in a block RAM, which provides a more efficient implementation for large delays. The component's timing and synchronization are critical to its correct operation. The `Clk` port is used to drive the internal timing of the component, and the `Rst` port is used to synchronize the component to a known state. The component has specific setup and hold requirements for the input data, which are determined by the clock frequency and the selected resource. One of the special features of the `olo_base_delay` component is its ability to automatically select the optimal resource based on the delay length and a threshold value. This allows the user to optimize the implementation of the delay element for their specific application. Additionally, the component provides a flexible reset behavior, allowing the user to specify whether the output should be driven to zero or retain its previous value during reset. The `olo_base_delay` component is typically used in digital signal processing systems where data needs to be delayed by a specific number of clock cycles. It can be used in a wide range of applications, from simple data pipelines to complex digital signal processing architectures. When implementing the component, designers should consider performance, resource usage, and design trade-offs. The component's resource usage is determined by the selected resource and the delay length, and designers should optimize the implementation to meet their specific requirements. Overall, the `olo_base_delay` component provides a flexible and efficient solution for introducing delays in digital signal processing systems. The implementation considerations for the `olo_base_delay` component include performance, resource usage, and design trade-offs. Designers should optimize the implementation to meet their specific requirements, taking into account the clock frequency, delay length, and resource usage. The component's performance is determined by the clock frequency and the selected resource, and designers should ensure that the component meets the required timing constraints. The resource usage is determined by the selected resource and the delay length, and designers should optimize the implementation to minimize resource usage while meeting the required performance. The `olo_base_delay` component provides a comprehensive solution for introducing delays in digital signal processing systems. Its flexible architecture, configurable generics, and automatic resource selection make it an attractive solution for a wide range of applications. By understanding the component's internal structure, functional behavior, and implementation considerations, designers can effectively use the `olo_base","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;

entity olo_base_delay is
    generic (
        Width_g         : positive;
        Delay_g         : natural;
        Resource_g      : string                            := ""AUTO"";
        BramThreshold_g : positive range 3 to positive'high := 128;
        RstState_g      : boolean                           := True;
        RamBehavior_g   : string                            := ""RBW""
    );
    port (
        Clk      : in    std_logic;
        Rst      : in    std_logic;
        In_Data  : in    std_logic_vector(Width_g-1 downto 0);
        In_Valid : in    std_logic := '1';
        Out_Data : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_delay is

    signal MemOut      : std_logic_vector(Width_g - 1 downto 0);
    constant MemTaps_c : natural := work.olo_base_pkg_math.max(Delay_g - 1, 0);

begin

    assert Resource_g = ""AUTO"" or Resource_g = ""SRL"" or Resource_g = ""BRAM""
        report ""###ERROR###: olo_base_delay: Unknown Resource_g - "" & Resource_g
        severity error;
    assert Resource_g /= ""BRAM"" or Delay_g >= 3
        report ""###ERROR###: olo_base_delay: Delay_g >= 3 required for Resource_g=BRAM""
        severity error;
    assert BramThreshold_g > 3
        report ""###ERROR###: olo_base_delay: BramThreshold_g must be > 3""
        severity error;

    g_srl : if (Delay_g > 1) and ((Resource_g = ""SRL"") or ((Resource_g = ""AUTO"") and (Delay_g < BramThreshold_g))) generate
        type Srl_t is array (0 to MemTaps_c - 1) of std_logic_vector(Width_g - 1 downto 0);

        signal SrlSig : Srl_t := (others => (others => '0'));

        attribute shreg_extract of SrlSig : signal is ShregExtract_AllowExtraction_c;
        attribute srl_style of SrlSig     : signal is SrlStyle_Srl_c;
    begin

        p_srl : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    SrlSig(0)                <= In_Data;
                    SrlSig(1 to SrlSig'high) <= SrlSig(0 to SrlSig'high - 1);
                end if;
            end if;
        end process;

        MemOut <= SrlSig(SrlSig'high);
    end generate;

    g_bram : if (Delay_g > 1) and ((Resource_g = ""BRAM"") or ((Resource_g = ""AUTO"") and (Delay_g >= BramThreshold_g))) generate
        signal RdAddr, WrAddr : std_logic_vector(log2ceil(MemTaps_c) - 1 downto 0) := (others => '0');
    begin

        p_bram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    if unsigned(WrAddr) = MemTaps_c - 1 then
                        WrAddr <= (others => '0');
                    else
                        WrAddr <= std_logic_vector(unsigned(WrAddr) + 1);
                    end if;
                    if unsigned(RdAddr) = MemTaps_c - 1 then
                        RdAddr <= (others => '0');
                    else
                        RdAddr <= std_logic_vector(unsigned(RdAddr) + 1);
                    end if;
                end if;

                if Rst = '1' then
                    WrAddr <= std_logic_vector(to_unsigned(MemTaps_c - 1, WrAddr'length));
                    RdAddr <= (others => '0');
                end if;
            end if;
        end process;

        i_bram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => MemTaps_c,
                Width_g         => Width_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk     => Clk,
                Wr_Addr => WrAddr,
                Wr_Ena  => In_Valid,
                Wr_Data => In_Data,
                Rd_Addr => RdAddr,
                Rd_Ena  => In_Valid,
                Rd_Data => MemOut
            );

    end generate;

    g_single : if Delay_g = 1 generate
        MemOut <= In_Data;
    end generate;

    g_zero : if Delay_g = 0 generate
        Out_Data <= In_Data;
    end generate;

    g_nonzero : if Delay_g > 0 generate
        signal RstStateCnt : integer range 0 to Delay_g - 1;
    begin

        p_outreg : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    if RstState_g = false or RstStateCnt = Delay_g - 1 then
                        Out_Data <= MemOut;
                    else
                        Out_Data    <= (others => '0');
                        RstStateCnt <= RstStateCnt + 1;
                    end if;
                end if;

                if Rst = '1' then
                    Out_Data    <= (others => '0');
                    RstStateCnt <= 0;
                end if;
            end if;
        end process;

    end generate;

end architecture;"
"The `olo_base_delay_cfg` component is a configurable delay element designed to introduce a variable delay in digital signal processing systems. Its primary purpose is to provide a flexible and efficient way to delay input data by a specified amount, which can be useful in various applications such as data synchronization, filtering, and buffering. This component is likely to be used in larger systems where data needs to be delayed or buffered to accommodate different processing stages or to meet specific timing requirements. The component has several input ports, including `Clk`, `Rst`, `Delay`, `In_Data`, and `In_Valid`. The `Clk` and `Rst` ports are used for clocking and resetting the component, respectively. The `Delay` port is a digital input that specifies the delay amount, with a bit width determined by the `MaxDelay_g` generic parameter. The `In_Data` port is the input data to be delayed, with a bit width specified by the `Width_g` generic parameter. The `In_Valid` port is a control signal that indicates the validity of the input data. The output port `Out_Data` provides the delayed data, also with a bit width of `Width_g`. The component's behavior is influenced by several generic parameters, including `Width_g`, `MaxDelay_g`, `SupportZero_g`, and `RamBehavior_g`. The `Width_g` parameter determines the bit width of the input and output data, while `MaxDelay_g` sets the maximum delay amount. The `SupportZero_g` parameter enables or disables a special mode where the component can output the input data directly when the delay is zero. The `RamBehavior_g` parameter controls the behavior of the embedded RAM block used for larger delay configurations. Internally, the component uses a combination of shift registers and a RAM block to implement the delay functionality. For smaller delay configurations (up to 3), the component uses two shift registers (`SrlSig`) to store and shift the input data. For larger delay configurations, a RAM block (`olo_base_ram_sdp`) is instantiated to provide a more efficient and scalable solution. The RAM block is used to store the input data, and its output is used to provide the delayed data. The component's control logic is primarily driven by the `In_Valid` signal, which enables the component to capture and process the input data. The `Rst` signal is used to reset the component's internal state machines and registers. The `Delay` input is used to determine the delay amount, which is then used to control the RAM block's read and write addresses. The component's data flow can be described as follows: the input data is captured on the rising edge of the clock when `In_Valid` is high. The data is then stored in either the shift registers or the RAM block, depending on the delay configuration. The delayed data is then retrieved from the shift registers or RAM block and output on the `Out_Data` port. In terms of timing and synchronization, the component is designed to operate in a single clock domain, with all internal operations synchronized to the rising edge of the clock. The component has specific setup and hold requirements for the input data and control signals, which must be met to ensure proper operation. One of the special features of this component is its ability to support a ""zero delay"" mode, where the input data is output directly when the delay is zero. This mode is controlled by the `SupportZero_g` generic parameter. The `olo_base_delay_cfg` component can be used in a variety of applications, including digital signal processing, data acquisition, and communication systems. Its flexibility and configurability make it an attractive solution for systems that require variable delay or buffering. In terms of implementation considerations, the component's performance and resource usage are influenced by the generic parameters, particularly `Width_g` and `MaxDelay_g`. The component's resource usage can be optimized by selecting the appropriate values for these parameters. Additionally, the component's design trade-offs include balancing area and performance, as well as optimizing the RAM block's configuration for the specific application. Overall, the `olo_base_delay_cfg` component is a versatile and efficient delay element that can be used in a wide range of digital signal processing applications. Its configurability, flexibility, and scalability make it an attractive solution for systems that require variable delay or buffering.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_delay_cfg is
    generic (
        Width_g         : positive;
        MaxDelay_g      : positive := 256;
        SupportZero_g   : boolean  := false;
        RamBehavior_g   : string   := ""RBW""
    );
    port (
        Clk      : in    std_logic;
        Rst      : in    std_logic;
        Delay    : in    std_logic_vector(log2ceil(MaxDelay_g+1)-1 downto 0);
        In_Data  : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid : in    std_logic;
        Out_Data : out   std_logic_vector((Width_g - 1) downto 0)
    );
end entity;

architecture rtl of olo_base_delay_cfg is

    type Srl_t is array (0 to 1) of std_logic_vector(Width_g - 1 downto 0);

    signal SrlSig     : Srl_t                                  := (others => (others => '0'));
    signal OutNonzero : std_logic_vector(Width_g - 1 downto 0);
    signal MemOut     : std_logic_vector(Width_g - 1 downto 0) := (others => '0');

begin

    g_ram : if MaxDelay_g > 3 generate
        signal RdAddr, WrAddr : std_logic_vector(log2ceil(MaxDelay_g) - 1 downto 0) := (others => '0');
    begin

        p_bram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if In_Valid = '1' then
                    WrAddr <= std_logic_vector(unsigned(WrAddr) + 1);
                    RdAddr <= std_logic_vector(unsigned(WrAddr) - unsigned(Delay) + 3);
                end if;

                if Rst = '1' then
                    WrAddr <= (others => '0');
                    RdAddr <= (others => '0');
                end if;
            end if;
        end process;

        i_bram : entity work.olo_base_ram_sdp
            generic map (
                Depth_g         => 2**log2ceil(MaxDelay_g),
                Width_g         => Width_g,
                RamBehavior_g   => RamBehavior_g
            )
            port map (
                Clk     => Clk,
                Wr_Addr => WrAddr,
                Wr_Ena  => In_Valid,
                Wr_Data => In_Data,
                Rd_Addr => RdAddr,
                Rd_Ena  => In_Valid,
                Rd_Data => MemOut
            );

    end generate;

    p_srl : process (Clk) is
    begin
        if rising_edge(Clk) then
            if In_Valid = '1' then
                SrlSig(0) <= In_Data;
                SrlSig(1) <= SrlSig(0);
            end if;
        end if;
    end process;

    p_outreg : process (Clk) is
        variable DelayInt_v : natural range 0 to MaxDelay_g;
    begin
        if rising_edge(Clk) then
            DelayInt_v := fromUslv(Delay);
            if In_Valid = '1' then

                case DelayInt_v is
                    when 1 =>  OutNonzero <= In_Data;
                    when 2 =>  OutNonzero <= SrlSig(0);
                    when 3 =>  OutNonzero <= SrlSig(1);
                    when others => OutNonzero <= MemOut;
                end case;

            end if;

            if Rst = '1' then
                OutNonzero <= (others => '0');
            end if;
        end if;
    end process;

    g_supportzero : if SupportZero_g generate
        Out_Data <= OutNonzero when fromUslv(Delay) /= 0 else In_Data;
    end generate;

    g_nozero : if not SupportZero_g generate
        Out_Data <= OutNonzero;
    end generate;

end architecture;"
"The `olo_base_dyn_sft` component is a digital circuit designed to perform dynamic shifting on input data. Its primary purpose is to shift the input data by a variable amount, specified by the `In_Shift` input, in either the left or right direction. This component plays a crucial role in larger systems that require flexible data manipulation, such as in digital signal processing, data compression, or cryptography. The component has several input ports, each with specific purposes and requirements. The `Clk` port is a clock signal that drives the sequential logic of the component, while the `Rst` port is an asynchronous reset signal used to initialize the component to a known state. The `In_Valid` port is a validity signal that indicates whether the input data is valid; it defaults to '1' if not provided. The `In_Shift` port is a vector that specifies the shift amount, with a bit width determined by the `MaxShift_g` generic parameter. The `In_Data` port is the input data to be shifted, with a bit width specified by the `Width_g` generic parameter. The component also has two output ports: `Out_Valid` and `Out_Data`. The `Out_Valid` port indicates whether the output data is valid, while the `Out_Data` port is the shifted output data. Internally, the component consists of a multi-stage architecture, with each stage performing a portion of the shifting operation. The number of stages is determined by the `Stages_c` constant, which is calculated based on the bit width of the `In_Shift` port and the `SelBitsPerStage_g` generic parameter. Each stage consists of a register to store the intermediate data, a shift amount register, and a validity signal. The component uses two processes: a combinational process `p_comb` and a sequential process `p_seq`. The `p_comb` process performs the actual shifting operation, using a loop to iterate over each stage. In each iteration, it calculates the shift amount, selects the corresponding portion of the input data, and performs the shifting operation. The `p_seq` process is a clocked process that updates the registers with the new values calculated by the `p_comb` process. The control logic of the component is primarily handled by the `p_seq` process, which updates the registers on every clock cycle. The `Rst` signal is used to reset the validity signals of all stages to '0'. The `In_Valid` signal is used to propagate the validity signal through the stages. The data flow through the component can be described as follows: the input data is first stored in the first stage's register. Then, in each subsequent stage, the data is shifted by the amount specified by the `In_Shift` port, and the validity signal is propagated. The final shifted data is output on the `Out_Data` port. The component has specific timing and synchronization requirements. The `Clk` signal is used to clock the sequential logic, and the component assumes that the input signals are synchronous to the clock. The component also has setup and hold requirements for the input signals, which must be met to ensure correct operation. One of the special features of this component is its ability to perform sign extension when shifting in the right direction. This is controlled by the `SignExtend_g` generic parameter, which defaults to `false`. The `olo_base_dyn_sft` component can be used in a variety of applications that require dynamic shifting, such as in digital signal processing, data compression, or cryptography. It can also be used as a building block for more complex data manipulation operations. In terms of implementation considerations, the component's performance is primarily determined by the number of stages and the bit width of the input data. The resource usage is also dependent on the number of stages and the bit width of the input data. The designer must balance these factors to achieve the desired performance while minimizing resource usage. The component's design trade-offs include the choice of the `SelBitsPerStage_g` generic parameter, which affects the number of stages and the complexity of each stage. The designer must also consider the trade-off between area and performance, as increasing the number of stages can improve performance but also increases area usage. Overall, the `olo_base_dyn_sft` component is a versatile and efficient digital circuit that provides dynamic shifting capabilities for a wide range of applications. Its modular architecture and flexible generic parameters make it an attractive solution for system designers. adheres to professional coding standards and follows best practices for digital design. The use of IEEE libraries and packages ensures compatibility and accuracy. The code also includes comprehensive error checking and reporting, which enhances its reliability and maintainability. The code organization and commenting facilitate readability and comprehension. The architecture and design of the `olo_base_dyn_sft` component demonstrate a thorough understanding of digital design principles and VHDL coding techniques. The component can be synthesized and implemented on a variety of digital platforms, including FPGAs and ASICs. The design can be further optimized and refined to meet specific application requirements. To ensure seamless integration into larger systems, the component's inputs and outputs are clearly defined, and its behavior is thoroughly documented. Overall, the `olo_base_dyn_sft` component is a well-designed and efficient digital circuit that provides a valuable function for a wide range of applications. The code provided implements the specifications of the `olo_base_dyn_sft` component accurately and efficiently. The analysis provided here offers a detailed and comprehensive overview of the component, covering all aspects of its design and functionality. The component is well-structured, readable, and maintainable. Its architecture and design make it suitable for a wide range of applications. is of high quality and follows best practices for digital design. The component's performance, resource usage, and design trade-offs have been thoroughly considered.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_dyn_sft is
    generic (
        Direction_g         : string;
        SelBitsPerStage_g   : positive := 4;
        MaxShift_g          : positive;
        Width_g             : positive;
        SignExtend_g        : boolean  := false
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic := '1';
        In_Shift    : in    std_logic_vector(log2ceil(MaxShift_g+1)- 1 downto 0);
        In_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_dyn_sft is

    constant Stages_c                 : integer := integer(ceil(real(In_Shift'length) / real(SelBitsPerStage_g)));
    constant SelBitsPerStageLimited_c : integer := work.olo_base_pkg_math.min(SelBitsPerStage_g, In_Shift'length);

    type Data_t is array (natural range <>) of std_logic_vector(In_Data'range);
    type Shift_t is array (natural range <>) of std_logic_vector(In_Shift'range);

    type TwoProcess_t is record
        Vld   : std_logic_vector(0 to Stages_c);
        Data  : Data_t(0 to Stages_c);
        Shift : Shift_t(0 to Stages_c);
    end record;

    signal r, r_next : TwoProcess_t;

begin

    assert Direction_g = ""LEFT"" or Direction_g = ""RIGHT""
        report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT""
        severity error;
    assert MaxShift_g <= Width_g
        report ""###ERROR###: olo_base_dyn_sft - MaxShift_g must be smaller or equal to Width_g""
        severity error;

    p_comb : process (r, In_Valid, In_Data, In_Shift) is
        variable v          : TwoProcess_t;
        variable StepSize_v : natural;
        variable Select_v   : natural range 0 to 2**SelBitsPerStage_g - 1;
        variable TempData_v : std_logic_vector(Width_g * 2 - 1 downto 0);
    begin
        v := r;

        v.Data(0)  := In_Data;
        v.Shift(0) := In_Shift;
        v.Vld(0)   := In_Valid;

        for stg in 0 to Stages_c - 1 loop
            StepSize_v := 2**(stg * SelBitsPerStageLimited_c);

            Select_v := to_integer(unsigned(r.Shift(stg)(SelBitsPerStageLimited_c - 1 downto 0)));
            if Direction_g = ""RIGHT"" then
                if SignExtend_g then
                    TempData_v := (others => r.Data(stg)(Width_g - 1));
                else
                    TempData_v := (others => '0');
                end if;
                TempData_v(2 * Width_g - 1 - Select_v * StepSize_v downto Width_g - Select_v * StepSize_v) := r.Data(stg);
                v.Data(stg + 1)                                                                            := TempData_v(2 * Width_g - 1 downto Width_g);
            elsif Direction_g = ""LEFT"" then
                TempData_v                                                                   := (others => '0');
                TempData_v(Select_v * StepSize_v + Width_g - 1 downto Select_v * StepSize_v) := r.Data(stg);
                v.Data(stg + 1)                                                              := TempData_v(Width_g - 1 downto 0);
            else
                report ""###ERROR###: olo_base_dyn_sft - Direction_g must be LEFT or RIGHT, is '"" & Direction_g & ""'"" severity error;
            end if;
            v.Shift(stg + 1) := shiftRight(r.Shift(stg), SelBitsPerStageLimited_c, '0');
            v.Vld(stg + 1)   := r.Vld(stg);
        end loop;

        Out_Data  <= r.Data(Stages_c);
        Out_Valid <= r.Vld(Stages_c);

        r_next <= v;

    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Vld <= (others => '0');
            end if;
        end if;
    end process;

end architecture;"
"The `olo_base_fifo_async` component is an asynchronous First-In-First-Out (FIFO) buffer designed in VHDL, which plays a crucial role in digital systems by providing a buffer for data transmission between two clock domains. Its primary purpose is to enable the transfer of data between two asynchronous clock domains while ensuring data integrity and providing features like full and empty flag generation, almost full and almost empty warnings, and level indication. The component has a wide range of generic parameters that allow for customization to suit specific application requirements. These parameters include `Width_g` and `Depth_g`, which define the width and depth of the FIFO, respectively. The depth must be a power of two. Other generics like `AlmFullOn_g`, `AlmFullLevel_g`, `AlmEmptyOn_g`, and `AlmEmptyLevel_g` control the almost full and almost empty flag generation. The `RamStyle_g` and `RamBehavior_g` generics determine the style and behavior of the embedded RAM, while `Optimization_g` allows for optimization between speed and latency. The `SyncStages_g` generic configures the number of synchronization stages for the clock crossing. The component has multiple input and output ports that facilitate its integration into larger systems. The input ports include `In_Clk`, `In_Rst`, `In_Data`, `In_Valid`, and `Out_Ready`. The `In_Clk` and `In_Rst` are the clock and reset inputs for the write side of the FIFO, while `In_Data` and `In_Valid` are used to write data into the FIFO. The `Out_Ready` input indicates that the read side is ready to accept data. The output ports include `Out_Data`, `Out_Valid`, `Out_Ready`, `Out_Full`, `Out_Empty`, `Out_AlmFull`, `Out_AlmEmpty`, and `Out_Level`, which provide the read data, validity, readiness, and FIFO status. Internally, the component consists of two main processes: `p_comb` and the sequential processes `p_seq_in` and `p_seq_out`. The `p_comb` process is a combinational process that calculates the next state of the FIFO based on the current state and inputs. It handles the write and read address generation, data registration, and flag generation. The `p_seq_in` and `p_seq_out` processes are sequential processes that update the internal registers on the rising edges of `In_Clk` and `Out_Clk`, respectively. The component uses a Gray code for the write and read addresses to facilitate the detection of the FIFO's full and empty conditions. The Gray code is converted to and from binary using the `binaryToGray` and `grayToBinary` functions. The `olo_base_cc_bits` and `olo_base_cc_reset` components are used for clock domain crossing of the write and read addresses and reset signals. The FIFO's data flow is managed by the `i_ram` component, which is an instance of `olo_base_ram_sdp`. This component provides a synchronous dual-port RAM that stores the FIFO data. The write address, write enable, and write data are generated based on the optimization mode, which can be set to either ""SPEED"" or ""LATENCY"". The component's control logic is distributed across several processes and components. The `p_comb` process generates the control signals for the write and read operations, while the sequential processes update the internal registers. The `olo_base_cc_bits` and `olo_base_cc_reset` components handle the clock domain crossing of the control signals. In terms of timing and synchronization, the component has specific requirements for setup and hold times, which must be met to ensure proper operation. The component also has multiple clock domains, and the clock crossing is handled using the `olo_base_cc_bits` and `olo_base_cc_reset` components. The `olo_base_fifo_async` component has several special features that make it versatile and suitable for a wide range of applications. These features include the ability to generate almost full and almost empty flags, programmable threshold levels, and support for different RAM styles and behaviors. The component can be used in various applications, including digital signal processing, data acquisition systems, and communication systems, where data needs to be transferred between asynchronous clock domains. When implementing the component, designers need to consider performance, resource usage, and design trade-offs. The component's optimization mode can be set to either ""SPEED"" or ""LATENCY"", which affects the performance and resource usage. The component's generics, such as `RamStyle_g` and `RamBehavior_g`, also impact the resource usage and performance. In conclusion, the `olo_base_fifo_async` component is a complex and versatile FIFO buffer designed in VHDL. Its comprehensive feature set, including support for clock domain crossing, almost full and almost empty flags, and programmable threshold levels, makes it suitable for a wide range of applications. The component's internal structure, control logic, and timing requirements are carefully designed to ensure proper operation and data integrity.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_fifo_async is
    generic (
        Width_g         : positive;
        Depth_g         : positive; -- must be power of two
        AlmFullOn_g     : boolean               := false;
        AlmFullLevel_g  : natural               := 0;
        AlmEmptyOn_g    : boolean               := false;
        AlmEmptyLevel_g : natural               := 0;
        RamStyle_g      : string                := ""auto"";
        RamBehavior_g   : string                := ""RBW"";
        ReadyRstState_g : std_logic             := '1';
        Optimization_g  : string                := ""SPEED""; -- SPEED or LATENCY
        SyncStages_g    : positive range 2 to 4 := 2
    );
    port (
        In_Clk          : in    std_logic;
        In_Rst          : in    std_logic;
        In_RstOut       : out   std_logic;
        In_Data         : in    std_logic_vector(Width_g-1 downto 0);
        In_Valid        : in    std_logic := '1';
        In_Ready        : out   std_logic;
        In_Full         : out   std_logic;
        In_Empty        : out   std_logic;
        In_AlmFull      : out   std_logic;
        In_AlmEmpty     : out   std_logic;
        In_Level        : out   std_logic_vector(log2ceil(Depth_g+1)-1 downto 0);
        Out_Clk         : in    std_logic;
        Out_Rst         : in    std_logic;
        Out_RstOut      : out   std_logic;
        Out_Data        : out   std_logic_vector(Width_g-1 downto 0);
        Out_Valid       : out   std_logic;
        Out_Ready       : in    std_logic := '1';
        Out_Full        : out   std_logic;
        Out_Empty       : out   std_logic;
        Out_AlmFull     : out   std_logic;
        Out_AlmEmpty    : out   std_logic;
        Out_Level       : out   std_logic_vector(log2ceil(Depth_g+1)-1 downto 0)
    );
end entity;

architecture rtl of olo_base_fifo_async is

    constant AddrWidth_c    : positive := log2ceil(Depth_g)+1;
    constant RamAddrWidth_c : positive := log2ceil(Depth_g);

    type TwoProcessIn_r is record
        WrAddr     : unsigned(AddrWidth_c-1 downto 0); -- One additional bit for full/empty detection
        WrAddrGray : std_logic_vector(AddrWidth_c-1 downto 0);
        RdAddr     : unsigned(AddrWidth_c-1 downto 0);
        WrAddrReg  : unsigned(AddrWidth_c-1 downto 0);
        RamWr      : std_logic;
        DataReg    : std_logic_vector(Width_g-1 downto 0);
    end record;

    type TwoProcessOut_r is record
        RdAddr     : unsigned(AddrWidth_c-1 downto 0); -- One additional bit for full/empty detection
        RdAddrGray : std_logic_vector(AddrWidth_c-1 downto 0);
        WrAddr     : unsigned(AddrWidth_c-1 downto 0);
        OutLevel   : unsigned(AddrWidth_c-1 downto 0);
    end record;

    signal ri, ri_next : TwoProcessIn_r := (WrAddr          => (others => '0'),
                                             WrAddrGray     => (others => '0'),
                                             RdAddr         => (others => '0'),
                                             WrAddrReg      => (others => '0'),
                                             RamWr          => '0',
                                            DataReg         => (others => '0'));

    signal ro, ro_next : TwoProcessOut_r := (RdAddr          => (others => '0'),
                                              RdAddrGray     => (others => '0'),
                                              WrAddr         => (others => '0'),
                                              OutLevel       => (others => '0'));

    signal RstInInt     : std_logic;
    signal RstOutInt    : std_logic;
    signal RamRdAddr    : std_logic_vector(RamAddrWidth_c-1 downto 0);
    signal RamWrAddr    : std_logic_vector(RamAddrWidth_c-1 downto 0);
    signal RamWr        : std_logic;
    signal RamWrData    : std_logic_vector(Width_g-1 downto 0);
    signal WrAddrGray   : std_logic_vector(AddrWidth_c-1 downto 0);
    signal RdAddrGray   : std_logic_vector(AddrWidth_c-1 downto 0);
    signal WrAddrGrayIn : std_logic_vector(AddrWidth_c-1 downto 0);
    signal RdAddrGrayIn : std_logic_vector(AddrWidth_c-1 downto 0);

begin

    assert log2(Depth_g) = log2ceil(Depth_g)
        report ""###ERROR###: olo_base_fifo_async: only power of two Depth_g is allowed""
        severity error;

    p_comb : process (In_Valid, Out_Ready, ri, ro, RstInInt, WrAddrGray, RdAddrGray, In_Data) is
        variable vi        : TwoProcessIn_r;
        variable vo        : TwoProcessOut_r;
        variable InLevel_v : unsigned(log2ceil(Depth_g) downto 0);
    begin
        vi := ri;
        vo := ro;

        In_Ready    <= '0';
        In_Full     <= '0';
        In_Empty    <= '0';
        In_AlmFull  <= '0';
        In_AlmEmpty <= '0';
        vi.RamWr    := '0';

        InLevel_v := ri.WrAddr - ri.RdAddr;
        In_Level  <= std_logic_vector(InLevel_v);

        if (ri.WrAddr(ri.WrAddr'left) /= ri.RdAddr(ri.RdAddr'left)) and
           (ri.WrAddr(ri.WrAddr'left-1 downto 0) = ri.RdAddr(ri.RdAddr'left-1 downto 0)) then
            In_Full <= '1';
        else
            In_Ready <= '1';
            if In_Valid = '1' then
                vi.WrAddr := ri.WrAddr + 1;
                vi.RamWr  := '1';
            end if;
        end if;
        if (ReadyRstState_g = '0') and (RstInInt = '1') then
            In_Ready <= '0';
        end if;

        if InLevel_v = 0 then
            In_Empty <= '1';
        end if;
        if InLevel_v >= AlmFullLevel_g and AlmFullOn_g then
            In_AlmFull <= '1';
        end if;
        if InLevel_v <= AlmEmptyLevel_g and AlmEmptyOn_g then
            In_AlmEmpty <= '1';
        end if;

        vi.WrAddrReg := ri.WrAddr;
        vi.DataReg   := In_Data;

        Out_Valid    <= '0';
        Out_Full     <= '0';
        Out_Empty    <= '0';
        Out_AlmFull  <= '0';
        Out_AlmEmpty <= '0';

        if ro.WrAddr = ro.RdAddr then
            vo.OutLevel := (others => '0');
        else
            vo.OutLevel := ro.WrAddr - ro.RdAddr;
            if (Out_Ready = '1') and (ro.OutLevel /= 0) then
                vo.OutLevel := vo.OutLevel - 1;
            end if;
        end if;
        Out_Level <= std_logic_vector(ro.OutLevel);

        if ro.OutLevel = 0 then
            Out_Empty <= '1';
        else
            Out_Valid <= '1';
            if Out_Ready = '1' then
                vo.RdAddr := ro.RdAddr + 1;
            end if;
        end if;
        RamRdAddr <= std_logic_vector(vo.RdAddr(log2ceil(Depth_g) - 1 downto 0));

        if ro.OutLevel = Depth_g then
            Out_Full <= '1';
        end if;
        if ro.OutLevel >= AlmFullLevel_g and AlmFullOn_g then
            Out_AlmFull <= '1';
        end if;
        if ro.OutLevel <= AlmEmptyLevel_g and AlmEmptyOn_g then
            Out_AlmEmpty <= '1';
        end if;

        vi.WrAddrGray := binaryToGray(std_logic_vector(vi.WrAddr));
        vo.RdAddrGray := binaryToGray(std_logic_vector(vo.RdAddr));

        vi.RdAddr := unsigned(grayToBinary(RdAddrGray));
        vo.WrAddr := unsigned(grayToBinary(WrAddrGray));

        ri_next <= vi;
        ro_next <= vo;

    end process;

    p_seq_in : process (In_Clk) is
    begin
        if rising_edge(In_Clk) then
            ri <= ri_next;
            if RstInInt = '1' then
                ri.WrAddr     <= (others => '0');
                ri.WrAddrGray <= (others => '0');
                ri.RdAddr     <= (others => '0');
                ri.RamWr      <= '0';
            end if;
        end if;
    end process;

    p_seq_out : process (Out_Clk) is
    begin
        if rising_edge(Out_Clk) then
            ro <= ro_next;
            if RstOutInt = '1' then
                ro.RdAddr     <= (others => '0');
                ro.RdAddrGray <= (others => '0');
                ro.WrAddr     <= (others => '0');
                ro.OutLevel   <= (others => '0');
            end if;
        end if;
    end process;

    RamWrAddr <= std_logic_vector(ri.WrAddr(log2ceil(Depth_g) - 1 downto 0)) when Optimization_g = ""LATENCY"" else
                 std_logic_vector(ri.WrAddrReg(log2ceil(Depth_g) - 1 downto 0));
    RamWr     <= ri_next.RamWr when Optimization_g = ""LATENCY"" else ri.RamWr;
    RamWrData <= In_Data when Optimization_g = ""LATENCY"" else ri.DataReg;

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            IsAsync_g       => true,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk         => In_Clk,
            Wr_Addr     => RamWrAddr,
            Wr_Ena      => RamWr,
            Wr_Data     => RamWrData,
            Rd_Clk      => Out_Clk,
            Rd_Addr     => RamRdAddr,
            Rd_Data     => Out_Data
        );

    WrAddrGrayIn <= ri_next.WrAddrGray when Optimization_g = ""LATENCY"" else ri.WrAddrGray; -- optional register stage

    i_cc_wr_rd : entity work.olo_base_cc_bits
        generic map (
            Width_g      => AddrWidth_c,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => In_Clk,
            In_Rst   => RstInInt,
            In_Data  => WrAddrGrayIn,
            Out_Clk  => Out_Clk,
            Out_Rst  => RstOutInt,
            Out_Data => WrAddrGray
        );

    RdAddrGrayIn <= ro_next.RdAddrGray when Optimization_g = ""LATENCY"" else ro.RdAddrGray; -- optional register stage

    i_cc_rd_wr : entity work.olo_base_cc_bits
        generic map (
            Width_g      => AddrWidth_c,
            SyncStages_g => SyncStages_g
        )
        port map (
            In_Clk   => Out_Clk,
            In_Rst   => RstOutInt,
            In_Data  => RdAddrGrayIn, -- use unregistered signal because CC contains register
            Out_Clk  => In_Clk,
            Out_Rst  => RstInInt,
            Out_Data => RdAddrGray
        );

    i_rst_cc : entity work.olo_base_cc_reset
        port map (
            A_Clk       => In_Clk,
            A_RstIn     => In_Rst,
            A_RstOut    => RstInInt,
            B_Clk       => Out_Clk,
            B_RstIn     => Out_Rst,
            B_RstOut    => RstOutInt
        );

    Out_RstOut <= RstOutInt;
    In_RstOut  <= RstInInt;

end architecture;"
"The `olo_base_fifo_packet` component is a parameterized, synchronous First-In-First-Out (FIFO) buffer designed for packet-based data transfer. Its primary purpose is to temporarily store and manage packets of data, providing a flexible and efficient way to handle packetized data streams in digital systems. **Component Overview** The component is designed to operate in a variety of applications, including network processing, data communication, and digital signal processing. It provides a configurable packet buffer with a user-defined width, depth, and RAM style, allowing designers to optimize the component for specific use cases. The FIFO packet buffer supports packet-level flow control, allowing for efficient management of packet data. **Detailed Input/Output Analysis** The component has several input and output ports that facilitate packet data transfer and control. The input ports include: * `Clk`: the system clock signal * `Rst`: the asynchronous reset signal * `In_Valid`: a valid signal indicating the presence of input data * `In_Data`: the input data bus with a width defined by the `Width_g` generic * `In_Last`: a signal indicating the last packet byte * `In_Drop`: a signal requesting packet drop The output ports include: * `In_Ready`: a ready signal indicating that the FIFO is ready to accept input data * `In_IsDropped`: a signal indicating whether the packet was dropped * `Out_Valid`: a valid signal indicating the presence of output data * `Out_Data`: the output data bus with a width defined by the `Width_g` generic * `Out_Size`: the packet size output * `Out_Last`: a signal indicating the last packet byte * `PacketLevel`: the current packet level in the FIFO * `FreeWords`: the number of free words in the FIFO **Architectural Description** The component's internal structure consists of two main processes: `p_comb` and `p_seq`. The `p_comb` process is a combinational process that implements the FIFO's control logic, while the `p_seq` process is a sequential process that updates the component's internal registers. The component uses a two-process architecture, with a register-transfer level (RTL) implementation. The internal registers include: * `r`: the current state register * `r_next`: the next state register The component also uses several internal signals, including: * `RamRdAddr`: the read address for the RAM * `FifoInReady`: a signal indicating that the FIFO is ready to accept input data * `RdPacketEnd`: the packet end address * `RdPacketEndValid`: a signal indicating that the packet end address is valid **Functional Behavior** The component's functional behavior can be described as follows: 1. When the `In_Valid` signal is asserted, the component checks if the FIFO is ready to accept input data. If it is, the component increments the write address and stores the input data in the RAM. 2. When the `In_Last` signal is asserted, the component marks the end of the packet and updates the packet level. 3. When the `Out_Ready` signal is asserted, the component checks if there is valid output data. If there is, the component outputs the data and updates the read address. 4. When the `Out_Next` signal is asserted, the component moves to the next packet. **Control Logic** The component's control logic is implemented in the `p_comb` process. The control logic manages the FIFO's state, including: * Packet level management * Packet dropping * FIFO full and empty conditions * Read and write address management The control logic also generates several control signals, including: * `RamWrEna`: the write enable signal for the RAM * `FifoInValid`: a signal indicating that the FIFO is ready to accept input data * `FifoOutRdy`: a signal indicating that the FIFO has valid output data **Data Flow** The component's data flow can be described as follows: 1. Input data is written to the RAM through the `In_Data` port. 2. The component manages the write address and stores the input data in the RAM. 3. When the `Out_Ready` signal is asserted, the component outputs the data from the RAM through the `Out_Data` port. **Timing and Synchronization** The component operates in a synchronous clock domain, with a single clock signal (`Clk`) driving all internal registers and logic. The component has several timing constraints, including: * Setup and hold times for input signals * Clock-to-output delays for output signals The component also has several synchronization requirements, including: * Reset synchronization: the `Rst` signal is synchronized with the clock signal to ensure proper reset behavior. **Special Features** The component has several special features, including: * Configurable packet buffer depth and width * Support for packet-level flow control * Packet dropping capability * Read and write address management **Applications and Use Cases** The `olo_base_fifo_packet` component is suitable for a variety of applications, including: * Network processing * Data communication * Digital signal processing The component can be used in systems that require efficient packet data transfer and management. **Implementation Considerations** The component's implementation requires careful consideration of several factors, including: * Performance: the component's performance is critical in high-speed data transfer applications. * Resource usage: the component's resource usage can be optimized by adjusting the `Width_g`, `Depth_g`, and `RamStyle_g` generics. * Design trade-offs: designers must balance performance, resource usage, and complexity when implementing the component. Overall, the `olo_base_fifo_packet` component is a versatile and efficient packet buffer that can be used in a variety of digital systems. Its configurable architecture and support for packet-level flow control make it an attractive solution","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_fifo_packet is
    generic (
        Width_g             : positive;
        Depth_g             : positive;
        RamStyle_g          : string                            := ""auto"";
        RamBehavior_g       : string                            := ""RBW"";
        SmallRamStyle_g     : string                            := ""auto"";
        SmallRamBehavior_g  : string                            := ""same"";
        MaxPackets_g        : positive range 2 to positive'high := 17
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        In_Valid      : in    std_logic := '1';
        In_Ready      : out   std_logic;
        In_Data       : in    std_logic_vector(Width_g - 1 downto 0);
        In_Last       : in    std_logic := '1';
        In_Drop       : in    std_logic := '0';
        In_IsDropped  : out   std_logic;
        Out_Valid     : out   std_logic;
        Out_Ready     : in    std_logic := '1';
        Out_Data      : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Size      : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Out_Last      : out   std_logic;
        Out_Next      : in    std_logic := '0';
        Out_Repeat    : in    std_logic := '0';
        PacketLevel   : out   std_logic_vector(log2ceil(MaxPackets_g + 1) - 1 downto 0);
        FreeWords     : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_fifo_packet is

    constant SmallRamStyle_c    : string := choose(SmallRamStyle_g = ""same"", RamStyle_g, SmallRamStyle_g);
    constant SmallRamBehavior_c : string := choose(SmallRamBehavior_g = ""same"", RamBehavior_g, SmallRamBehavior_g);

    subtype Addr_c is integer range log2ceil(Depth_g) downto 0; -- one additional bit to differentiate between full/empty
    subtype AddrApp_c is integer range log2ceil(Depth_g) - 1 downto 0; -- one additional bit to differentiate between full/empty

    type RdFsm_t is (Fetch_s, Data_s, Last_s);

    type TwoProcess_r is record
        WrAddr         : unsigned(Addr_c); -- Shifted by Depth_g to Read pointer
        WrPacketStart  : unsigned(Addr_c); -- Shifted by Depth_g to Read pointer
        WrSize         : unsigned(Addr_c);
        WrPacketActive : std_logic;
        DropLatch      : std_logic;
        Full           : std_logic;
        RdAddr         : unsigned(Addr_c);
        RdPacketStart  : unsigned(Addr_c);
        RdPacketEnd    : unsigned(Addr_c);
        RdValid        : std_logic;
        RdFsm          : RdFsm_t;
        RdRepeat       : std_logic;
        RdSize         : unsigned(log2ceil(Depth_g + 1) - 1 downto 0);
        NextLatch      : std_logic;
        PacketLevel    : unsigned(log2ceil(MaxPackets_g + 1)-1 downto 0);
    end record;


    signal r, r_next : TwoProcess_r;

    signal RamRdAddr        : std_logic_vector(Addr_c);
    signal FifoInReady      : std_logic;
    signal RdPacketEnd      : std_logic_vector(Addr_c);
    signal RdPacketEndValid : std_logic;
    signal RamWrEna         : std_logic;
    signal FifoInValid      : std_logic;
    signal FifoOutRdy       : std_logic;
    signal WrAddrStdlv      : std_logic_vector(Addr_c);

begin

    assert log2(Depth_g) = log2ceil(Depth_g)
        report ""olo_base_fifo_packet: only power of two Depth_g is allowed""
        severity error;

    p_comb : process (In_Valid, In_Data, In_Last, In_Drop, Out_Ready, Out_Next, Out_Repeat, Rst, r,
                      FifoInReady, RdPacketEnd, RdPacketEndValid) is
        variable v          : TwoProcess_r;
        variable In_Ready_v : std_logic;
        variable InDrop_v   : std_logic;
        variable OutLast_v  : std_logic;
    begin
        v := r;


        In_Ready_v  := ((not r.Full) and FifoInReady) or r.DropLatch;
        InDrop_v    := r.DropLatch;
        RamWrEna    <= '0';
        FifoInValid <= '0';

        if r.WrAddr /= r.RdPacketStart then
            v.Full := '0';
        end if;

        if In_Drop = '1' and (r.WrPacketActive = '1' or In_Valid = '1') then
            v.DropLatch := '1';
        end if;

        if In_Valid = '1' and In_Ready_v = '1' then
            v.WrPacketActive := '1';

            if r.WrAddr = r.RdPacketStart-1 then
                v.Full := '1';
            end if;

            if r.WrAddr = Depth_g*2 - 1 then
                v.WrAddr := (others => '0');
            else
                v.WrAddr := r.WrAddr + 1;
            end if;

            if In_Drop = '1' then
                InDrop_v    := '1';
                v.DropLatch := '1';
            end if;

            if r.WrSize = Depth_g then
                v.DropLatch := '1';
            else
                v.WrSize := r.WrSize + 1;
            end if;

            if In_Last = '1' then
                if InDrop_v = '1' then
                    v.WrAddr := r.WrPacketStart;
                else
                    v.WrPacketStart := r.WrAddr + 1;
                    FifoInValid     <= '1';
                end if;
                v.DropLatch      := '0';
                v.WrSize         := to_unsigned(1, r.WrSize'length);
                v.WrPacketActive := '0';
            end if;

            RamWrEna <= '1';

        end if;

        if r.DropLatch = '1' then
            v.WrAddr := r.WrPacketStart;
            v.Full   := '0';
        end if;

        In_IsDropped <= InDrop_v;
        In_Ready     <= In_Ready_v;



        FifoOutRdy <= '0';
        OutLast_v  := '0';

        case r.RdFsm is
            when Fetch_s =>
                v.RdPacketStart := r.RdAddr;

                if r.RdRepeat = '1' then
                    if r.RdPacketEnd = r.RdPacketStart then
                        v.RdFsm := Last_s;
                    else
                        v.RdFsm := Data_s;
                    end if;
                    v.RdRepeat := '0';
                    v.RdAddr   := r.RdPacketStart;
                    v.RdValid  := '1';
                    v.RdPacketStart := r.RdPacketStart;

                elsif RdPacketEndValid = '1' then
                    FifoOutRdy <= '1';
                    v.RdRepeat := '0';
                    if unsigned(RdPacketEnd) = r.RdAddr then
                        v.RdFsm := Last_s;
                    else
                        v.RdFsm := Data_s;
                    end if;
                    v.RdPacketEnd := unsigned(RdPacketEnd);
                    v.RdValid     := '1';
                    v.RdSize      := unsigned(RdPacketEnd) - r.RdAddr + 1;

                end if;

            when Data_s =>
                if Out_Ready = '1' then
                    if v.RdAddr = Depth_g*2 - 1 then
                        v.RdAddr := (others => '0');
                    else
                        v.RdAddr := v.RdAddr + 1;
                    end if;

                    if r.RdAddr = r.RdPacketEnd - 1 then
                        v.RdFsm := Last_s;
                    end if;

                    if Out_Next = '1' or r.NextLatch = '1' then
                        OutLast_v := '1';
                        v.RdValid := '0';
                        v.RdFsm   := Fetch_s;
                        v.RdAddr  := r.RdPacketEnd + 1;
                    end if;

                end if;

            when Last_s =>
                OutLast_v := '1';

                if Out_Ready = '1' then
                    if v.RdAddr = Depth_g*2 - 1 then
                        v.RdAddr := (others => '0');
                    else
                        v.RdAddr := v.RdAddr + 1;
                    end if;


                    v.RdValid := '0';
                    v.RdFsm   := Fetch_s;
                end if;

            when others => null; -- unreacable code

        end case;

        RamRdAddr <= std_logic_vector(v.RdAddr);
        Out_Valid <= r.RdValid;
        Out_Last  <= OutLast_v;
        Out_Size  <= std_logic_vector(r.RdSize);

        if r.RdValid = '1' and Out_Ready = '1' and OutLast_v = '1' then
            v.NextLatch := '0';
        elsif r.RdValid = '1' and Out_Next = '1' then
            v.NextLatch := '1';
        end if;

        if In_Valid = '1' and In_Ready_v = '1' and In_Last = '1' and InDrop_v = '0' then
            v.PacketLevel := r.PacketLevel + 1;
        end if;
        if r.RdValid = '1' and Out_Ready = '1' and OutLast_v = '1' and r.RdRepeat = '0' and Out_Repeat = '0' then
            v.PacketLevel := v.PacketLevel - 1;
        end if;
        PacketLevel <= std_logic_vector(r.PacketLevel);

        FreeWords <= std_logic_vector(r.RdPacketStart(FreeWords'range) - r.WrAddr(FreeWords'range));

        if Out_Repeat = '1' and r.RdValid = '1' then
            v.RdRepeat := '1';
        end if;

        r_next <= v;

    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.WrAddr         <= to_unsigned(Depth_g, r.WrAddr'length);
                r.WrPacketStart  <= to_unsigned(Depth_g, r.WrPacketStart'length);
                r.WrSize         <= to_unsigned(1, r.WrSize'length);
                r.WrPacketActive <= '0';
                r.DropLatch      <= '0';
                r.Full           <= '0';
                r.RdAddr         <= (others => '0');
                r.RdPacketStart  <= (others => '0');
                r.RdFsm          <= Fetch_s;
                r.RdRepeat       <= '0';
                r.RdValid        <= '0';
                r.NextLatch      <= '0';
                r.PacketLevel    <= (others => '0');
            end if;
        end if;
    end process;


    WrAddrStdlv(AddrApp_c)        <= std_logic_vector(r.WrAddr(AddrApp_c));
    WrAddrStdlv(WrAddrStdlv'high) <= not r.WrAddr(r.WrAddr'high);

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk     => Clk,
            Wr_Addr => WrAddrStdlv(AddrApp_c), -- Additional bit for full/empty differentiation is stripped
            Wr_Ena  => RamWrEna,
            Wr_Data => In_Data,
            Rd_Addr => RamRdAddr(AddrApp_c),   -- Additional bit for full/empty differentiation is stripped
            Rd_Data => Out_Data
        );

    i_pktend_fifo : entity work.olo_base_fifo_sync
        generic map (
            Width_g         => log2ceil(Depth_g)+1,
            Depth_g         => MaxPackets_g-1,     -- One packet is currently read out (not in the FIFO anymore)
            RamStyle_g      => SmallRamStyle_c,
            RamBehavior_g   => SmallRamBehavior_c,
            ReadyRstState_g => '0'
        )
        port map (
            Clk           => Clk,
            Rst           => Rst,
            In_Data       => WrAddrStdlv,
            In_Valid      => FifoInValid,
            In_Ready      => FifoInReady,
            Out_Data      => RdPacketEnd,
            Out_Valid     => RdPacketEndValid,
            Out_Ready     => FifoOutRdy
        );

end architecture;"
"The `olo_base_fifo_sync` component is a synchronous First-In-First-Out (FIFO) buffer designed to manage data transfer between two clock-synchronous domains. Its primary purpose is to provide a reliable and efficient data buffering mechanism, ensuring that data is properly synchronized and transferred without loss or corruption. The component features a generic design, allowing users to configure its width (`Width_g`), depth (`Depth_g`), and other parameters to suit specific application requirements. The FIFO's width and depth are defined by the `Width_g` and `Depth_g` generics, respectively. Additional generics, such as `AlmFullOn_g`, `AlmFullLevel_g`, `AlmEmptyOn_g`, and `AlmEmptyLevel_g`, enable users to customize the FIFO's almost full and almost empty threshold detection. The `RamStyle_g` and `RamBehavior_g` generics determine the RAM implementation and behavior, while `ReadyRstState_g` sets the initial state of the `In_Ready` signal. The component's input ports include `Clk`, `Rst`, `In_Data`, `In_Valid`, and `Out_Ready`. The `Clk` and `Rst` ports are used for clocking and resetting the component, respectively. The `In_Data` port accepts input data, while `In_Valid` indicates the validity of the input data. The `Out_Ready` port is used to signal the readiness of the downstream circuitry to accept data. The output ports comprise `In_Ready`, `In_Level`, `Out_Data`, `Out_Valid`, `Out_Level`, `Full`, `AlmFull`, `Empty`, and `AlmEmpty`. The `In_Ready` port indicates whether the FIFO is ready to accept new input data, while `In_Level` reports the current fill level of the FIFO. The `Out_Data` port provides the output data, and `Out_Valid` indicates its validity. The `Out_Level` port reports the current fill level of the FIFO as seen by the output port. The `Full` and `Empty` ports signal when the FIFO is full or empty, respectively. The `AlmFull` and `AlmEmpty` ports indicate when the FIFO is almost full or almost empty, based on the configured threshold levels. Internally, the component employs a two-process architecture, comprising a combinational process (`p_comb`) and a sequential process (`p_seq`). The `p_comb` process is responsible for updating the internal state variables and generating control signals, while the `p_seq` process synchronizes these updates with the clock edge. The internal state variables are encapsulated within the `TwoProcess_r` record, which includes `WrLevel`, `RdLevel`, `RdUp`, `WrDown`, `WrAddr`, and `RdAddr`. These variables track the FIFO's fill level, read and write addresses, and other control signals. The `p_comb` process updates the internal state variables based on the input signals and the current state. It checks for valid input data, updates the write address and level, and generates the `RamWr` signal to control data writing to the RAM. The process also updates the read address and level, and generates the `Out_Valid` and `Empty` signals. The `p_seq` process synchronizes the internal state updates with the clock edge and resets the component when the `Rst` signal is asserted. It also updates the output ports based on the internal state variables. The component utilizes a synchronous RAM (`i_ram`) to store the data. The RAM's write address, write enable, and write data are controlled by the `WrAddr`, `RamWr`, and `In_Data` signals, respectively. The RAM's read address is controlled by the `RamRdAddr` signal, and the read data is output on the `Out_Data` port. In terms of functional behavior, the component operates as a standard synchronous FIFO. When valid input data is presented, the component checks if there is available space in the FIFO. If space is available, the data is written to the RAM, and the write level is updated. When the downstream circuitry is ready to accept data, the component reads data from the RAM, updates the read level, and asserts the `Out_Valid` signal. The component's control logic is based on the internal state variables and the input signals. The `In_Ready` signal is asserted when there is available space in the FIFO, and the `Out_Valid` signal is asserted when there is valid data available at the output. The `Full` and `Empty` signals are generated based on the FIFO's fill level. The component's data flow is straightforward, with input data being written to the RAM and then read out to the output port. The RAM's write and read addresses are updated based on the internal state variables, ensuring that data is properly synchronized and transferred. In terms of timing and synchronization, the component operates within a single clock domain. The `Clk` signal is used to synchronize the internal state updates and data transfers. The component's setup and hold requirements are determined by the clock period and the RAM's access time. The component features several special features, including almost full and almost empty threshold detection, which can be used to trigger interrupts or other control actions. The component also supports a range of RAM styles and behaviors, allowing users to optimize the design for their specific application. The `olo_base_fifo_sync` component is suitable for a wide range of applications, including data buffering, rate adaptation, and clock domain crossing. It can be used in various digital systems, such as communication protocols, data acquisition systems, and digital signal processing. When implementing the component, designers should consider performance, resource usage, and design trade-offs. The component's performance is determined by the clock frequency, RAM access time, and the number of bits being transferred. The resource","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_fifo_sync is
    generic (
        Width_g         : positive;
        Depth_g         : positive;
        AlmFullOn_g     : boolean   := false;
        AlmFullLevel_g  : natural   := 0;
        AlmEmptyOn_g    : boolean   := false;
        AlmEmptyLevel_g : natural   := 0;
        RamStyle_g      : string    := ""auto"";
        RamBehavior_g   : string    := ""RBW"";
        ReadyRstState_g : std_logic := '1'
    );
    port (
        Clk           : in    std_logic;
        Rst           : in    std_logic;
        In_Data       : in    std_logic_vector(Width_g - 1 downto 0);
        In_Valid      : in    std_logic := '1';
        In_Ready      : out   std_logic;
        In_Level      : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Out_Data      : out   std_logic_vector(Width_g - 1 downto 0);
        Out_Valid     : out   std_logic;
        Out_Ready     : in    std_logic := '1';
        Out_Level     : out   std_logic_vector(log2ceil(Depth_g + 1) - 1 downto 0);
        Full          : out   std_logic;
        AlmFull       : out   std_logic;
        Empty         : out   std_logic;
        AlmEmpty      : out   std_logic
    );
end entity;

architecture rtl of olo_base_fifo_sync is

    type TwoProcess_r is record
        WrLevel : std_logic_vector(In_Level'range);
        RdLevel : std_logic_vector(Out_Level'range);
        RdUp    : std_logic;
        WrDown  : std_logic;
        WrAddr  : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        RdAddr  : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

    signal RamWr     : std_logic;
    signal RamRdAddr : std_logic_vector(log2ceil(Depth_g) - 1 downto 0);

begin

    p_comb : process (In_Valid, Out_Ready, Rst, r) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.RdUp := '0';
        RamWr  <= '0';
        if unsigned(r.WrLevel) /= Depth_g and In_Valid = '1' then
            if unsigned(r.WrAddr) /= Depth_g - 1 then
                v.WrAddr := std_logic_vector(unsigned(r.WrAddr) + 1);
            else
                v.WrAddr := (others => '0');
            end if;
            RamWr  <= '1';
            v.RdUp := '1';
            if r.WrDown = '0' then
                v.WrLevel := std_logic_vector(unsigned(r.WrLevel) + 1);
            end if;
        elsif r.WrDown = '1' then
            v.WrLevel := std_logic_vector(unsigned(r.WrLevel) - 1);
        end if;

        if unsigned(r.WrLevel) = Depth_g then
            In_Ready <= '0';
            Full     <= '1';
        else
            In_Ready <= '1';
            Full     <= '0';
        end if;
        if (ReadyRstState_g = '0') and (Rst = '1') then
            In_Ready <= '0';
        end if;

        if AlmFullOn_g and unsigned(r.WrLevel) >= AlmFullLevel_g then
            AlmFull <= '1';
        else
            AlmFull <= '0';
        end if;

        v.WrDown := '0';
        if unsigned(r.RdLevel) /= 0 and Out_Ready = '1' then
            if unsigned(r.RdAddr) /= Depth_g - 1 then
                v.RdAddr := std_logic_vector(unsigned(r.RdAddr) + 1);
            else
                v.RdAddr := (others => '0');
            end if;
            v.WrDown := '1';
            if r.RdUp = '0' then
                v.RdLevel := std_logic_vector(unsigned(r.RdLevel) - 1);
            end if;
        elsif r.RdUp = '1' then
            v.RdLevel := std_logic_vector(unsigned(r.RdLevel) + 1);
        end if;
        RamRdAddr <= v.RdAddr;

        if unsigned(r.RdLevel) > 0 then
            Out_Valid <= '1';
            Empty     <= '0';
        else
            Out_Valid <= '0';
            Empty     <= '1';
        end if;

        if AlmEmptyOn_g and unsigned(r.RdLevel) <= AlmEmptyLevel_g then
            AlmEmpty <= '1';
        else
            AlmEmpty <= '0';
        end if;

        r_next <= v;

    end process;

    Out_Level <= r.RdLevel;
    In_Level  <= r.WrLevel;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.WrLevel <= (others => '0');
                r.RdLevel <= (others => '0');
                r.RdUp    <= '0';
                r.WrDown  <= '0';
                r.WrAddr  <= (others => '0');
                r.RdAddr  <= (others => '0');
            end if;
        end if;
    end process;

    i_ram : entity work.olo_base_ram_sdp
        generic map (
            Depth_g         => Depth_g,
            Width_g         => Width_g,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk         => Clk,
            Wr_Addr     => r.WrAddr,
            Wr_Ena      => RamWr,
            Wr_Data     => In_Data,
            Rd_Addr     => RamRdAddr,
            Rd_Data     => Out_Data
        );

end architecture;"
"The `olo_base_flowctrl_handler` is a VHDL component designed to manage data flow between two processing stages, providing a buffering mechanism to absorb transient backpressure. Its primary purpose is to ensure smooth data transmission between the two stages, handling situations where one stage may not be able to accept data at the same rate as the other. This component is likely used in digital signal processing (DSP) or data acquisition systems where data rates may vary. The component has several input and output ports that facilitate its primary function. The `In_Data` port, with a width of `InWidth_g` bits, accepts incoming data, while `In_Valid` indicates whether the data is valid. The `In_Ready` output port signals whether the component is ready to accept more data. On the output side, `Out_Data` and `Out_Valid` provide the processed data and its validity, respectively. The `Out_Ready` input port indicates whether the downstream component is ready to accept the data. Additionally, `ToProc_Data` and `ToProc_Valid` output ports forward data to the processing stage, while `FromProc_Data` and `FromProc_Valid` input ports receive data from the processing stage. Internally, the component consists of a synchronous FIFO (First-In-First-Out) buffer, instantiated as `i_fifo`, which plays a crucial role in managing the data flow. The FIFO's depth is determined by the `FifoDepth_c` constant, which is calculated based on the `SamplesToAbsorb_g` generic parameter. This parameter allows the designer to specify the number of samples the FIFO should be able to absorb, ensuring that the component can handle transient backpressure. The FIFO's width is set to `OutWidth_g` bits, matching the output data width. The component's architectural description reveals a straightforward internal structure. The FIFO is controlled by the `Clk` and `Rst` signals, and its inputs and outputs are connected to the corresponding ports of the component. The `Fifo_InReady` signal indicates whether the FIFO is ready to accept more data, while `Fifo_HalfEmpty` signals whether the FIFO has more than half of its depth remaining. These signals are crucial in controlling the data flow. The functional behavior of the component can be described as follows: when the FIFO is not full, it accepts data from the processing stage through the `FromProc_Data` and `FromProc_Valid` ports. The data is then stored in the FIFO until it can be forwarded to the output. The component monitors the FIFO's occupancy level and asserts the `In_Ready` signal when there is enough space to accept more data. Similarly, it asserts the `Out_Valid` signal when there is valid data available at the output. The control logic of the component relies on the FIFO's status signals, such as `Fifo_InReady` and `Fifo_HalfEmpty`. The `In_Ready` signal is asserted when the FIFO is not full, allowing the component to accept more data. The `ToProc_Valid` signal is asserted when the FIFO has enough space to accept more data, ensuring that the processing stage can provide data without overflowing the FIFO. Data flow through the component involves minimal transformations, as the component primarily acts as a buffer. However, the data is forwarded from the input to the output through the FIFO, ensuring that it is properly synchronized and buffered. The component's timing and synchronization are critical to its operation. The FIFO is clocked by the `Clk` signal, and its inputs and outputs are synchronized to this clock. The component has setup and hold requirements for the input signals, which must be met to ensure proper operation. One special feature of the component is its ability to handle transient backpressure by absorbing a specified number of samples. This is achieved through the FIFO, which can store data temporarily until the downstream component is ready to accept it. The `olo_base_flowctrl_handler` component is typically used in digital signal processing (DSP) or data acquisition systems where data rates may vary. It can be used in a wide range of applications, including audio and video processing, medical imaging, and industrial control systems. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The FIFO's depth and width can be adjusted based on the specific requirements of the system, and the component's generics provide flexibility in configuring its behavior. However, the designer must balance the FIFO's size with the available resources, such as logic cells and memory, to ensure optimal performance. Additionally, the component's clock frequency and data rates must be carefully considered to ensure that the setup and hold requirements are met. In conclusion, the `olo_base_flowctrl_handler` is a versatile component designed to manage data flow between two processing stages. Its internal FIFO buffer provides a flexible and efficient way to absorb transient backpressure, ensuring smooth data transmission. By understanding the component's architecture, behavior, and control logic, designers can effectively utilize it in a wide range of digital systems.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_base_flowctrl_handler is
    generic (
        InWidth_g           : positive;
        OutWidth_g          : positive;
        SamplesToAbsorb_g   : positive;
        RamStyle_g          : string := ""auto"";
        RamBehavior_g       : string := ""RBW""
    );
    port (
        Clk            : in    std_logic;
        Rst            : in    std_logic;
        In_Data        : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Valid       : in    std_logic := '1';
        In_Ready       : out   std_logic;
        Out_Data       : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Valid      : out   std_logic;
        Out_Ready      : in    std_logic := '1';
        ToProc_Data    : out   std_logic_vector(InWidth_g - 1 downto 0);
        ToProc_Valid   : out   std_logic;
        FromProc_Data  : in    std_logic_vector(OutWidth_g - 1 downto 0);
        FromProc_Valid : in    std_logic
    );
end entity;

architecture rtl of olo_base_flowctrl_handler is

    constant FifoDepth_c  : positive := 2*(SamplesToAbsorb_g+2);
    signal Fifo_InReady   : std_logic;
    signal Fifo_HalfEmpty : std_logic;

begin

    In_Ready     <= Fifo_HalfEmpty;
    ToProc_Data  <= In_Data;
    ToProc_Valid <= In_Valid and Fifo_HalfEmpty; -- Only forward data when FIFO is guaranteed to accept result

    i_fifo : entity work.olo_base_fifo_sync
        generic map (
            Width_g         => OutWidth_g,
            Depth_g         => FifoDepth_c,
            AlmEmptyOn_g    => true,
            AlmEmptyLevel_g => FifoDepth_c/2,
            RamStyle_g      => RamStyle_g,
            RamBehavior_g   => RamBehavior_g
        )
        port map (
            Clk           => Clk,
            Rst           => Rst,
            In_Data       => FromProc_Data,
            In_Valid      => FromProc_Valid,
            In_Ready      => Fifo_InReady,
            Out_Data      => Out_Data,
            Out_Valid     => Out_Valid,
            Out_Ready     => Out_Ready,
            AlmEmpty      => Fifo_HalfEmpty

        );

    p_assert : process (Clk) is
    begin
        if rising_edge(Clk) then
            assert (Fifo_InReady = '1' or FromProc_Valid /= '1')
                report ""olo_base_flowctrl_handler: FIFO is full upon FromProc_Valid = '1'""
                severity error;
        end if;
    end process;

end architecture;"
"defines a package named `olo_base_pkg_array`, which contains a collection of array types and functions for manipulating these arrays. The primary purpose of this package is to provide a set of reusable, parameterized array types and functions that can be utilized in various digital design projects. The package defines several array types, including `StlvArray2_t` to `StlvArray512_t`, which are arrays of `std_logic_vector` with varying bit widths, ranging from 2 to 512 bits. Additionally, it defines `IntegerArray_t`, `RealArray_t`, and `BoolArray_t` types, which are arrays of integer, real, and boolean values, respectively. These array types can be used to represent a wide range of data structures, from narrow bit vectors to wide buses. The package also includes three functions: `arrayInteger2Real`, `arrayStdl2Bool`, and `arrayBool2Stdl`. The `arrayInteger2Real` function converts an array of integers to an array of real numbers, performing a simple type conversion. The `arrayStdl2Bool` function converts a `std_logic_vector` to an array of boolean values, where each boolean value corresponds to a bit in the input vector. The `arrayBool2Stdl` function performs the inverse operation, converting an array of boolean values to a `std_logic_vector`. Internally, the functions utilize loops to iterate over the input arrays, performing the necessary conversions. For example, the `arrayInteger2Real` function uses a loop to iterate over the input `IntegerArray_t`, converting each integer value to a real number using the `real()` function. The resulting array of real numbers is then returned. The operation of these functions can be described step-by-step. For instance, when calling `arrayStdl2Bool`, the input `std_logic_vector` is iterated over, and for each bit, a corresponding boolean value is generated based on whether the bit is '1' or not. The resulting array of boolean values is then returned. Control logic is minimal in this package, as the functions primarily perform simple type conversions. However, the functions do rely on the input arrays being properly sized and aligned. The package does not include any explicit control signals, enable conditions, or reset behavior. Data flow through the component is straightforward, with input arrays being passed to the functions, which then produce output arrays. The functions do not modify the input data; instead, they generate new output arrays. In terms of timing and synchronization, the package does not explicitly define any clock domains, setup/hold requirements, or timing constraints. However, as a VHDL package, it is intended to be used in a synchronous design environment, where clocked operations are managed by the surrounding circuitry. One special feature of this package is its comprehensive set of array types, which can be used to represent a wide range of data structures. The functions provided also offer a convenient way to perform type conversions between different data types. This package would typically be used in digital design projects that require manipulating arrays of various types. For example, it could be used in a data processing module, a communication interface, or a testbench. When implementing this package, designers should consider performance, resource usage, and design trade-offs. The package's functions are relatively simple and should not consume significant resources. However, the array types defined in the package may impact the overall resource utilization, depending on how they are used in the larger design. Designers should carefully evaluate the required array types and functions to ensure that they align with the project's specific needs. appears to be well-structured and readable. The use of a package to encapsulate the array types and functions promotes code reusability and maintainability. Overall, the `olo_base_pkg_array` package offers a useful set of array types and functions that can simplify the development of digital designs. The code adheres to professional VHDL terminology and standards, making it easy to integrate into existing projects. The detailed analysis provided here covers all aspects of the design, from the component overview to implementation considerations. The component can be used as a building block for more complex designs, and its functionality can be easily verified through simulation. The provided functions can be used as-is or modified to suit specific project requirements. The code does not contain any syntax errors and can be compiled without issues. The functions are properly described, and their behavior is well-defined. The component overview indicates that the primary purpose of this package is to provide reusable array types and functions. The detailed input/output analysis shows that each function has a clear and well-defined interface. The architectural description explains the internal structure of the package, including the array types and functions. The functional behavior of the package is well-defined, and the step-by-step operation of the functions is clear. The control logic is minimal, and the data flow through the component is straightforward. The timing and synchronization aspects of the package are not explicitly defined but are assumed to be managed by the surrounding circuitry. The special features of the package include its comprehensive set of array types and functions. The package can be used in a variety of applications, including data processing, communication interfaces, and testbenches. The implementation considerations include performance, resource usage, and design trade-offs. Overall, the `olo_base_pkg_array` package provides a useful set of array types and functions that can simplify the development of digital designs. The code is well-structured, readable, and adheres to professional VHDL standards. The analysis provided here covers all aspects of the design, from the component overview to implementation considerations. The component can be used as a building block for more complex designs, and its functionality can be easily verified through simulation. The package's functionality can be easily extended or modified to suit specific project requirements. is a valuable resource for digital designers, providing a set","
library ieee;
    use ieee.std_logic_1164.all;

package olo_base_pkg_array is

    type StlvArray2_t   is array (natural range <>) of std_logic_vector( 1 downto 0);
    type StlvArray3_t   is array (natural range <>) of std_logic_vector( 2 downto 0);
    type StlvArray4_t   is array (natural range <>) of std_logic_vector( 3 downto 0);
    type StlvArray5_t   is array (natural range <>) of std_logic_vector( 4 downto 0);
    type StlvArray6_t   is array (natural range <>) of std_logic_vector( 5 downto 0);
    type StlvArray7_t   is array (natural range <>) of std_logic_vector( 6 downto 0);
    type StlvArray8_t   is array (natural range <>) of std_logic_vector( 7 downto 0);
    type StlvArray9_t   is array (natural range <>) of std_logic_vector( 8 downto 0);
    type StlvArray10_t  is array (natural range <>) of std_logic_vector( 9 downto 0);
    type StlvArray11_t  is array (natural range <>) of std_logic_vector(10 downto 0);
    type StlvArray12_t  is array (natural range <>) of std_logic_vector(11 downto 0);
    type StlvArray13_t  is array (natural range <>) of std_logic_vector(12 downto 0);
    type StlvArray14_t  is array (natural range <>) of std_logic_vector(13 downto 0);
    type StlvArray15_t  is array (natural range <>) of std_logic_vector(14 downto 0);
    type StlvArray16_t  is array (natural range <>) of std_logic_vector(15 downto 0);
    type StlvArray17_t  is array (natural range <>) of std_logic_vector(16 downto 0);
    type StlvArray18_t  is array (natural range <>) of std_logic_vector(17 downto 0);
    type StlvArray19_t  is array (natural range <>) of std_logic_vector(18 downto 0);
    type StlvArray20_t  is array (natural range <>) of std_logic_vector(19 downto 0);
    type StlvArray21_t  is array (natural range <>) of std_logic_vector(20 downto 0);
    type StlvArray22_t  is array (natural range <>) of std_logic_vector(21 downto 0);
    type StlvArray23_t  is array (natural range <>) of std_logic_vector(22 downto 0);
    type StlvArray24_t  is array (natural range <>) of std_logic_vector(23 downto 0);
    type StlvArray25_t  is array (natural range <>) of std_logic_vector(24 downto 0);
    type StlvArray26_t  is array (natural range <>) of std_logic_vector(25 downto 0);
    type StlvArray27_t  is array (natural range <>) of std_logic_vector(26 downto 0);
    type StlvArray28_t  is array (natural range <>) of std_logic_vector(27 downto 0);
    type StlvArray29_t  is array (natural range <>) of std_logic_vector(28 downto 0);
    type StlvArray30_t  is array (natural range <>) of std_logic_vector(29 downto 0);
    type StlvArray32_t  is array (natural range <>) of std_logic_vector(31 downto 0);
    type StlvArray36_t  is array (natural range <>) of std_logic_vector(35 downto 0);
    type StlvArray48_t  is array (natural range <>) of std_logic_vector(47 downto 0);
    type StlvArray64_t  is array (natural range <>) of std_logic_vector(63 downto 0);
    type StlvArray512_t is array (natural range <>) of std_logic_vector(511 downto 0);

    type IntegerArray_t is array (natural range <>) of integer;
    type RealArray_t is array (natural range <>) of real;
    type BoolArray_t is array (natural range <>) of boolean;

    function arrayInteger2Real (a : in IntegerArray_t) return RealArray_t;
    function arrayStdl2Bool (a : in std_logic_vector) return BoolArray_t;
    function arrayBool2Stdl (a : in BoolArray_t) return std_logic_vector;

end package;

package body olo_base_pkg_array is

    function arrayInteger2Real (a : in IntegerArray_t) return RealArray_t is
        variable Array_v : RealArray_t(a'range);
    begin

        for i in a'low to a'high loop
            Array_v(i) := real(a(i));
        end loop;

        return Array_v;
    end function;

    function arrayStdl2Bool (a : in std_logic_vector) return BoolArray_t is
        variable Array_v : BoolArray_t(a'range);
    begin

        for i in a'low to a'high loop
            Array_v(i) := (a(i) = '1');
        end loop;

        return Array_v;
    end function;

    function arrayBool2Stdl (a : in BoolArray_t) return std_logic_vector is
        variable Array_v : std_logic_vector(a'range);
    begin

        for i in a'low to a'high loop
            if a(i) then
                Array_v(i) := '1';
            else
                Array_v(i) := '0';
            end if;
        end loop;

        return Array_v;
    end function;

end package body;"
"defines a package named `olo_base_pkg_attribute` along with its body. This package appears to be a collection of attribute definitions and constants used for synthesis and optimization directives in VHDL designs. The primary purpose of this package is to standardize and centralize the definition of various attributes that influence the synthesis, optimization, and implementation of VHDL components. In the context of larger systems, components utilizing this package can leverage these attributes to guide the synthesis tool in making design decisions, such as how to implement shift registers, asynchronous registers, and RAM structures, as well as controlling optimization strategies like merging, preserving, and keeping specific design elements. The package defines several attributes and their respective constants. For instance, `shreg_extract` with constants `ShregExtract_SuppressExtraction_c` and `ShregExtract_AllowExtraction_c` seems to control the extraction of shift registers, allowing designers to dictate whether shift registers should be extracted or not. Similarly, `srl_style` and `syn_srlstyle` attributes with their constants influence how shift registers are implemented, either as flip-flops or as LUT-based shift registers. The `async_reg` attribute determines how asynchronous registers are treated during synthesis, with `AsyncReg_TreatAsync_c` set to `true`, indicating that asynchronous registers should be treated as such. Other attributes like `dont_merge`, `preserve`, `syn_keep`, `syn_preserve`, and `dont_touch` are used to control optimization strategies, essentially giving designers fine-grained control over which parts of their design should be left unchanged or preserved during the synthesis process. The `keep` attribute with its constant `Keep_SuppressChanges_c` set to `""yes""` suggests that certain signals or components should be kept in the design, suppressing any potential changes or optimizations that might alter them. Additionally, attributes like `ram_style`, `ramstyle`, and `syn_ramstyle` are declared but not defined with specific constants within this package, implying their use in specifying the implementation style for RAM structures within designs. The internal structure of this package does not reveal specific state machines, counters, or registers, as it primarily serves as a repository for attribute definitions. However, the attributes defined here can significantly impact the architectural description of components that use these attributes, by guiding the synthesis tool on how to implement certain design elements. In terms of functional behavior, this package does not dictate a step-by-step operation since it's more about providing directives for synthesis rather than describing a component's operational flow. However, the presence and setting of these attributes can profoundly affect the timing relationships and behavioral patterns of the design, especially concerning how registers and memory structures are implemented and optimized. Control logic, in this case, relates to how these attributes influence the synthesis and optimization process. The settings for these attributes can act as control signals to the synthesis tool, determining enable conditions for certain optimizations, reset behavior for registers, and state transitions in more complex designs. Data flow within components utilizing this package would be influenced by the attributes defined here, particularly in how data is stored, shifted, or processed within registers and RAM structures. The transformations applied to data would depend on the implementation choices guided by these attributes. Regarding timing and synchronization, the attributes defined can impact clock domains, setup/hold requirements, and overall timing constraints. For instance, the implementation of asynchronous registers and the style of shift registers can have significant implications on the timing characteristics of the design. A special feature of this package is its ability to provide a standardized way of controlling synthesis and optimization directives across a design. This can be particularly useful in large projects where consistency in design and optimization strategies is crucial. This package would typically be used in projects where fine-grained control over synthesis and optimization is necessary. It could be utilized in a wide range of applications, from digital signal processing and communication systems to complex digital systems that require specific implementation strategies for performance, area, or power optimization. When implementing components that use this package, designers must consider performance, resource usage, and design trade-offs. The settings chosen for the attributes can significantly impact the area utilization, speed, and power consumption of the design. Therefore, careful consideration of these factors is essential during the design and synthesis process. In conclusion, the `olo_base_pkg_attribute` package provides a comprehensive set of attributes and constants aimed at guiding the synthesis and optimization of VHDL designs. Its role in larger systems is to ensure consistency and control over design implementation, optimization strategies, and performance characteristics. By understanding and utilizing these attributes effectively, designers can achieve better control over their designs, leading to more efficient and optimized implementations.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

package olo_base_pkg_attribute is


    attribute shreg_extract : string;
    constant ShregExtract_SuppressExtraction_c : string := ""no"";
    constant ShregExtract_AllowExtraction_c    : string := ""yes"";


    attribute srl_style : string;
    constant SrlStyle_FlipFlops_c : string := ""registers"";
    constant SrlStyle_Srl_c       : string := ""srl""; -- Use LUT as shift register

    attribute syn_srlstyle : string;
    constant SynSrlstyle_FlipFlops_c : string := ""registers"";


    attribute async_reg : boolean;
    constant AsyncReg_TreatAsync_c : boolean := true;


    attribute dont_merge : boolean;
    constant DontMerge_SuppressChanges_c : boolean := true;

    attribute preserve : boolean;
    constant Preserve_SuppressChanges_c : boolean := true;

    attribute syn_keep : integer;
    constant SynKeep_SuppressChanges_c : integer := 1;

    attribute syn_preserve : integer;
    constant SynPreserve_SuppressChanges_c : integer := 1;

    attribute dont_touch : boolean;
    constant DontTouch_SuppressChanges_c : boolean := true;

    attribute keep : string;
    constant Keep_SuppressChanges_c : string := ""yes"";


    attribute ram_style : string;

    attribute ramstyle : string;

    attribute syn_ramstyle : string;

end package;

package body olo_base_pkg_attribute is

end package body;"
"defines a package named `olo_base_pkg_logic` which contains a collection of functions for performing various logical operations on binary data. This package appears to be a part of a larger library, likely used for digital logic design and implementation. The primary purpose of this package is to provide a set of reusable functions for manipulating binary data, which can be used in a wide range of digital systems, such as digital signal processing, data transmission, and storage. These functions can be used to perform tasks such as data shifting, conversion between binary and gray codes, and data transformation. The package contains several functions, each with its own specific purpose. The `zerosVector` and `onesVector` functions generate vectors of a specified size, filled with zeros or ones, respectively. The `shiftLeft` and `shiftRight` functions perform left and right shifts on a binary vector by a specified number of bits, with an optional fill value. The `binaryToGray` and `grayToBinary` functions convert between binary and gray codes. The `ppcOr` function performs a parallel-prefix OR operation on a binary vector. The `to01X` and `to01` functions convert a binary value to a two-valued logic signal, with `to01X` producing an unknown value for invalid inputs, and `to01` producing a zero for invalid inputs. The `invertBitOrder` and `invertByteOrder` functions invert the bit and byte orders of a binary vector, respectively. From an input/output perspective, each function has a well-defined set of inputs and outputs. The inputs are typically binary vectors of varying sizes, and the outputs are also binary vectors. The functions do not have any timing requirements, as they are purely combinational logic. However, the inputs and outputs may have specific bit widths, which must be taken into account when using these functions. Internally, the package uses a combination of logical operations, such as XOR, AND, and OR, to perform the desired transformations. The functions are implemented using a mix of simple logical operations and more complex algorithms, such as the parallel-prefix OR operation. The functional behavior of each function can be described step-by-step. For example, the `shiftLeft` function first checks if the shift amount is negative, in which case it calls the `shiftRight` function with the absolute shift amount. Otherwise, it performs the left shift by filling the most significant bits with the specified fill value. The `binaryToGray` function performs the conversion by XORing the binary input with a shifted version of itself. The control logic of the package is relatively simple, as most functions are purely combinational. However, some functions, such as the `ppcOr` function, use a staged approach to perform the parallel-prefix OR operation. The package does not have any explicit reset behavior, as it is designed to be used in a digital system with its own reset and clocking infrastructure. In terms of data flow, the package functions can be seen as a series of transformations applied to the input binary data. The data flows through each function, being transformed and manipulated according to the specific operation being performed. The package does not have any specific timing constraints, as it is designed to be used in a synchronous digital system with its own clocking and timing infrastructure. However, the functions do have specific setup and hold requirements, which must be taken into account when using them in a larger system. One special feature of the package is the use of a staged approach for the parallel-prefix OR operation, which allows for efficient computation of the OR of all bits in a binary vector. Another special feature is the use of a gray code conversion, which can be used in applications where a gray code is required. The package can be used in a wide range of applications, including digital signal processing, data transmission, and storage. It can also be used in the implementation of digital systems, such as field-programmable gate arrays (FPGAs) and application-specific integrated circuits (ASICs). In terms of implementation considerations, the package is designed to be efficient in terms of resource usage. The functions are implemented using a combination of logical operations and simple arithmetic, which can be easily mapped onto a digital system. However, the performance of the package may depend on the specific implementation and the target technology. Overall, the `olo_base_pkg_logic` package provides a useful collection of functions for manipulating binary data, which can be used in a wide range of digital systems. Its internal structure, functional behavior, and control logic are well-suited for digital logic design and implementation. The resource usage and performance of the package can be optimized by careful selection of the target technology and implementation. The package can be used in a variety of applications, including digital signal processing, data transmission, and storage. The design trade-offs involved in creating the package include balancing resource usage, performance, and functionality. The package provides a good balance of these factors, making it a useful tool for digital system designers. is well-structured and readable. The use of a package and package body is a good practice, as it separates the interface from the implementation. The functions are well-documented, and the code is easy to understand. The code can be improved by adding more comments and documentation, as well as by optimizing the implementation for specific target technologies. Additionally, the package can be extended to include more functions and features, making it an even more useful tool for digital system designers. The component can be used as a building block for more complex digital systems, such as digital filters, data compression algorithms, and encryption schemes. Its flexibility and reusability make it a valuable asset in digital system design. The component's behavior can be verified through simulation and testing, using a variety of input stimuli and test cases. This can help ensure that the component functions correctly and meets the required specifications. The component can be used in a variety of","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

package olo_base_pkg_logic is

    function zerosVector (size : in natural) return std_logic_vector;

    function onesVector (size : in natural) return std_logic_vector;

    function shiftLeft (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector;

    function shiftRight (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector;

    function binaryToGray (binary : in std_logic_vector) return std_logic_vector;

    function grayToBinary (gray : in std_logic_vector) return std_logic_vector;

    function ppcOr (inp : in std_logic_vector) return std_logic_vector;

    function to01X (inp : in std_logic) return std_logic;

    function to01X (inp : in std_logic_vector) return std_logic_vector;

    function to01 (inp : in std_logic) return std_logic;

    function to01 (inp : in std_logic_vector) return std_logic_vector;

    function invertBitOrder (inp : in std_logic_vector) return std_logic_vector;

    function invertByteOrder (inp : in std_logic_vector) return std_logic_vector;

    constant Polynomial_Prbs2_c  : std_logic_vector( 1 downto 0) := ""11"";
    constant Polynomial_Prbs3_c  : std_logic_vector( 2 downto 0) := ""110"";
    constant Polynomial_Prbs4_c  : std_logic_vector( 3 downto 0) := ""1100"";
    constant Polynomial_Prbs5_c  : std_logic_vector( 4 downto 0) := ""10100"";
    constant Polynomial_Prbs6_c  : std_logic_vector( 5 downto 0) := ""110000"";
    constant Polynomial_Prbs7_c  : std_logic_vector( 6 downto 0) := ""1100000"";
    constant Polynomial_Prbs8_c  : std_logic_vector( 7 downto 0) := ""10111000"";
    constant Polynomial_Prbs9_c  : std_logic_vector( 8 downto 0) := ""100010000"";
    constant Polynomial_Prbs10_c : std_logic_vector( 9 downto 0) := ""1001000000"";
    constant Polynomial_Prbs11_c : std_logic_vector(10 downto 0) := ""10100000000"";
    constant Polynomial_Prbs12_c : std_logic_vector(11 downto 0) := ""100000101001"";
    constant Polynomial_Prbs13_c : std_logic_vector(12 downto 0) := ""1000000001101"";
    constant Polynomial_Prbs14_c : std_logic_vector(13 downto 0) := ""10000000010101"";
    constant Polynomial_Prbs15_c : std_logic_vector(14 downto 0) := ""110000000000000"";
    constant Polynomial_Prbs16_c : std_logic_vector(15 downto 0) := ""1101000000001000"";
    constant Polynomial_Prbs17_c : std_logic_vector(16 downto 0) := ""10010000000000000"";
    constant Polynomial_Prbs18_c : std_logic_vector(17 downto 0) := ""100000010000000000"";
    constant Polynomial_Prbs19_c : std_logic_vector(18 downto 0) := ""1000000000000100011"";
    constant Polynomial_Prbs20_c : std_logic_vector(19 downto 0) := ""10010000000000000000"";
    constant Polynomial_Prbs21_c : std_logic_vector(20 downto 0) := ""101000000000000000000"";
    constant Polynomial_Prbs22_c : std_logic_vector(21 downto 0) := ""1100000000000000000000"";
    constant Polynomial_Prbs23_c : std_logic_vector(22 downto 0) := ""10000100000000000000000"";
    constant Polynomial_Prbs24_c : std_logic_vector(23 downto 0) := ""111000010000000000000000"";
    constant Polynomial_Prbs25_c : std_logic_vector(24 downto 0) := ""1001000000000000000000000"";
    constant Polynomial_Prbs26_c : std_logic_vector(25 downto 0) := ""10000000000000000000100011"";
    constant Polynomial_Prbs27_c : std_logic_vector(26 downto 0) := ""100000000000000000000010011"";
    constant Polynomial_Prbs28_c : std_logic_vector(27 downto 0) := ""1001000000000000000000000000"";
    constant Polynomial_Prbs29_c : std_logic_vector(28 downto 0) := ""10100000000000000000000000000"";
    constant Polynomial_Prbs30_c : std_logic_vector(29 downto 0) := ""100000000000000000000000101001"";
    constant Polynomial_Prbs31_c : std_logic_vector(30 downto 0) := ""1001000000000000000000000000000"";
    constant Polynomial_Prbs32_c : std_logic_vector(31 downto 0) := ""10000000001000000000000000000011"";

end package;

package body olo_base_pkg_logic is

    function zerosVector (size : in natural) return std_logic_vector is
        constant Vector_c : std_logic_vector(size - 1 downto 0) := (others => '0');
    begin
        return Vector_c;
    end function;

    function onesVector (size : in natural) return std_logic_vector is
        constant Vector_c : std_logic_vector(size - 1 downto 0) := (others => '1');
    begin
        return Vector_c;
    end function;

    function shiftLeft (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector is
        constant ArgDownto_c : std_logic_vector(arg'high downto arg'low) := arg;
        variable Vector_v    : std_logic_vector(ArgDownto_c'range);
    begin
        if bits < 0 then
            return shiftRight(ArgDownto_c, -bits, fill);
        else
            Vector_v(Vector_v'left downto bits)      := ArgDownto_c(ArgDownto_c'left - bits downto ArgDownto_c'right);
            Vector_v(bits - 1 downto Vector_v'right) := (others => fill);
            return Vector_v;
        end if;
    end function;

    function shiftRight (
        arg  : in std_logic_vector;
        bits : in integer;
        fill : in std_logic := '0') return std_logic_vector is
        constant ArgDownto_c : std_logic_vector(arg'high downto arg'low) := arg;
        variable Vector_v    : std_logic_vector(ArgDownto_c'range);
    begin
        if bits < 0 then
            return shiftLeft(ArgDownto_c, -bits, fill);
        else
            Vector_v(Vector_v'left - bits downto Vector_v'right)    := ArgDownto_c(ArgDownto_c'left downto bits);
            Vector_v(Vector_v'left downto Vector_v'left - bits + 1) := (others => fill);
            return Vector_v;
        end if;
    end function;

    function binaryToGray (binary : in std_logic_vector) return std_logic_vector is
        variable Gray_v : std_logic_vector(binary'range);
    begin
        Gray_v := binary xor ('0' & binary(binary'high downto binary'low + 1));
        return Gray_v;
    end function;

    function grayToBinary (gray : in std_logic_vector) return std_logic_vector is
        variable Binary_v : std_logic_vector(gray'range);
    begin
        Binary_v(Binary_v'high) := gray(gray'high);

        for b in gray'high - 1 downto gray'low loop
            Binary_v(b) := gray(b) xor Binary_v(b + 1);
        end loop;

        return Binary_v;
    end function;

    function ppcOr (inp : in std_logic_vector) return std_logic_vector is
        constant Stages_c    : integer := log2ceil(inp'length);
        constant Pwr2Width_c : integer := 2**Stages_c;

        type StageOut_t is array (natural range <>) of std_logic_vector(Pwr2Width_c - 1 downto 0);

        variable StageOut_v : StageOut_t(0 to Stages_c);
        variable BinCnt_v   : unsigned(Pwr2Width_c - 1 downto 0);
    begin
        StageOut_v(0)                          := (others => '0');
        StageOut_v(0)(inp'length - 1 downto 0) := inp;

        for stage in 0 to Stages_c - 1 loop
            BinCnt_v := (others => '0');

            for idx in 0 to Pwr2Width_c - 1 loop
                if BinCnt_v(stage) = '0' then
                    StageOut_v(stage + 1)(idx) := StageOut_v(stage)(idx) or StageOut_v(stage)((idx / (2**stage) + 1) * 2**stage);
                else
                    StageOut_v(stage + 1)(idx) := StageOut_v(stage)(idx);
                end if;
                BinCnt_v := BinCnt_v + 1;
            end loop;

        end loop;

        return StageOut_v(Stages_c)(inp'length - 1 downto 0);
    end function;

    function to01X (inp : in std_logic) return std_logic is
    begin

        case inp is
            when '0' | 'L' => return '0';
            when '1' | 'H' => return '1';
            when others => return 'X';
        end case;

    end function;

    function to01X (inp : in std_logic_vector) return std_logic_vector is
        variable Result_v : std_logic_vector(inp'range);
    begin

        for i in inp'low to inp'high loop
            Result_v(i) := to01X(inp(i));
        end loop;

        return Result_v;
    end function;

    function to01 (inp : in std_logic) return std_logic is
    begin

        case inp is
            when '0' | 'L' => return '0';
            when '1' | 'H' => return '1';
            when others => return '0';
        end case;

    end function;

    function to01 (inp : in std_logic_vector) return std_logic_vector is
        variable Result_v : std_logic_vector(inp'range);
    begin

        for i in inp'low to inp'high loop
            Result_v(i) := to01(inp(i));
        end loop;

        return Result_v;
    end function;

    function invertBitOrder (inp : in std_logic_vector) return std_logic_vector is
        variable Inp_v    : std_logic_vector(inp'length-1 downto 0);
        variable Result_v : std_logic_vector(Inp_v'range);
    begin
        Inp_v := inp;

        for i in 0 to Inp_v'high loop
            Result_v(Result_v'high - i) := Inp_v(i);
        end loop;

        return Result_v;
    end function;

    function invertByteOrder (inp : in std_logic_vector) return std_logic_vector is
        constant Inp_c    : std_logic_vector(inp'length-1 downto 0) := inp;
        constant Bytes_c  : natural                                 := inp'length/8;
        variable Result_v : std_logic_vector(Inp_c'range);
        variable InByte_v : natural;
    begin

        assert inp'length mod 8 = 0
            report ""invertByteOrder(): Number of bits must be a multiple of 8""
            severity error;

        for byte in 0 to Bytes_c-1 loop
            InByte_v                         := Bytes_c - 1 - byte;
            Result_v(byte*8+7 downto byte*8) := Inp_c(InByte_v*8+7 downto InByte_v*8);
        end loop;

        return Result_v;
    end function;

end package body;"
"defines a package named `olo_base_pkg_math` which contains a collection of mathematical functions for use in digital design. This package is designed to provide a range of utility functions for performing various mathematical operations, and its primary purpose is to support the development of more complex digital systems. The package provides a range of functions for performing mathematical operations, including calculations for logarithms, greatest common factors, and least common multiples. Additionally, it provides functions for comparing values, counting the occurrences of specific values within arrays, and converting between different data types. The functions within this package can be used in a wide range of applications, from simple arithmetic operations to more complex calculations. In terms of input/output analysis, the package does not have any ports, as it is a collection of functions rather than a digital component with inputs and outputs. However, each function within the package has its own set of input parameters and return values. For example, the `log2` function takes a single natural number as input and returns the base-2 logarithm of that number. The `fromString` function, on the other hand, takes a string as input and returns a real number. The internal structure of the package is composed of a series of functions, each with its own specific implementation. The functions are implemented using a combination of arithmetic operations, loops, and conditional statements. For example, the `log2` function uses a while loop to iteratively divide the input value by 2 until it reaches 1, counting the number of divisions required. The `fromString` function, on the other hand, uses a combination of loops and conditional statements to parse the input string and extract the numeric value. The functional behavior of the package is determined by the specific functions it contains. Each function performs a specific mathematical operation, and the package as a whole provides a range of utility functions for use in digital design. The step-by-step operation of each function is determined by its implementation, with each function executing a specific sequence of operations to produce its result. The control logic within the package is distributed across the individual functions, with each function containing its own control flow. The functions use a combination of conditional statements and loops to control the flow of execution, and the package as a whole does not have a centralized control mechanism. In terms of data flow, the package does not have a complex data flow, as each function operates independently and does not interact with other functions in a data-dependent manner. However, the package does provide a range of functions for converting between different data types, such as converting a string to a real number. The timing and synchronization of the package are not explicitly defined, as it is a collection of functions rather than a digital component with clocked inputs and outputs. However, the package is designed to be used in a digital design context, and the functions within it are intended to be used in a synchronous manner. One special feature of the package is its use of a range of mathematical functions to support the development of complex digital systems. The package provides a range of utility functions for performing mathematical operations, and its functions can be used in a wide range of applications. The package can be used in a variety of applications, including digital signal processing, data analysis, and control systems. It provides a range of utility functions for performing mathematical operations, and its functions can be used to support the development of more complex digital systems. In terms of implementation considerations, the package is designed to be synthesized and used in a digital design context. The functions within the package are intended to be used in a synchronous manner, and the package as a whole is designed to be used in a digital design flow. The package does not have any specific performance or resource usage requirements, as its functions can be used in a wide range of applications with varying performance and resource constraints. The design trade-offs associated with the package include the balance between area and performance, as well as the trade-off between accuracy and complexity. The package provides a range of utility functions for performing mathematical operations, and its functions can be used to support the development of more complex digital systems. However, the package does not have any specific design trade-offs, as its functions can be used in a wide range of applications with varying design constraints. Overall, the `olo_base_pkg_math` package provides a range of utility functions for performing mathematical operations in digital design. Its functions can be used in a wide range of applications, from simple arithmetic operations to more complex calculations. The package is designed to be used in a digital design context, and its functions are intended to be used in a synchronous manner.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_array.all;

package olo_base_pkg_math is

    function log2 (arg : in natural) return natural;

    function log2ceil (arg : in natural) return natural;

    function isPower2 (arg : in natural) return boolean;

    function greatestCommonFactor (
        a : in positive;
        b : in positive) return positive;

    function leastCommonMultiple (
        a : in positive;
        b : in positive) return positive;

    function max (
        a : in integer;
        b : in integer) return integer;

    function min (
        a : in integer;
        b : in integer) return integer;

    function max (
        a : in real;
        b : in real) return real;

    function min (
        a : in real;
        b : in real) return real;

    function choose (
        s : in boolean;
        t : in std_logic;
        f : in std_logic) return std_logic;

    function choose (
        s : in boolean;
        t : in std_logic_vector;
        f : in std_logic_vector) return std_logic_vector;

    function choose (
        s : in boolean;
        t : in integer;
        f : in integer) return integer;

    function choose (
        s : in boolean;
        t : in string;
        f : in string) return string;

    function choose (
        s : in boolean;
        t : in real;
        f : in real) return real;

    function choose (
        s : in boolean;
        t : in unsigned;
        f : in unsigned) return unsigned;

    function choose (
        s : in boolean;
        t : in boolean;
        f : in boolean) return boolean;

    function choose (
        s : in boolean;
        t : in RealArray_t;
        f : in RealArray_t) return RealArray_t;

    function count (
        a : in IntegerArray_t;
        v : in integer) return integer;

    function count (
        a : in BoolArray_t;
        v : in boolean) return integer;

    function count (
        a : in std_logic_vector;
        v : in std_logic) return integer;

    function toUslv (
        input : integer;
        len   : integer) return std_logic_vector;

    function toSslv (
        input : integer;
        len   : integer) return std_logic_vector;

    function toStdl (input : integer range 0 to 1) return std_logic;

    function fromUslv (input : std_logic_vector) return integer;

    function fromSslv (input : std_logic_vector) return integer;

    function fromStdl (input : std_logic) return integer;

    function fromString (input : string) return real;

    function fromString (input : string) return RealArray_t;

    function maxArray (a : in IntegerArray_t) return integer;

    function maxArray (a : in RealArray_t) return real;

    function minArray (a : in IntegerArray_t) return integer;

    function minArray (a : in RealArray_t) return real;

end package;

package body olo_base_pkg_math is

    function countCommaSepElems (input : string) return natural is
        variable Count_v : natural := 1;
        variable Idx_v   : integer := input'low;
    begin

        while Idx_v <= input'high loop
            if input(Idx_v) = ',' then
                Count_v := Count_v + 1;
            end if;
            Idx_v := Idx_v + 1;
        end loop;

        return Count_v;
    end function;


    function log2 (arg : in natural) return natural is
        variable ArgShift_v : natural := arg;
        variable Log2_v     : natural := 0;
    begin

        while ArgShift_v > 1 loop
            ArgShift_v := ArgShift_v / 2;
            Log2_v     := Log2_v + 1;
        end loop;

        return Log2_v;
    end function;

    function log2ceil (arg : in natural) return natural is
    begin
        if arg = 0 then
            return 0;
        end if;
        return log2(arg * 2 - 1);
    end function;

    function isPower2 (arg : in natural) return boolean is
    begin
        if log2(arg) = log2ceil(arg) then
            return true;
        else
            return false;
        end if;
    end function;

    function greatestCommonFactor (
        a : in positive;
        b : in positive) return positive is
        variable Gcd_v : positive := min(a, b);
    begin

        while Gcd_v > 1 loop
            if a mod Gcd_v = 0 and b mod Gcd_v = 0 then
                return Gcd_v;
            end if;
            Gcd_v := Gcd_v - 1;
        end loop;

        return Gcd_v;
    end function;

    function leastCommonMultiple (
        a : in positive;
        b : in positive) return positive is
    begin
        return a * b / greatestCommonFactor(a, b);
    end function;

    function max (
        a : in integer;
        b : in integer) return integer is
    begin
        if a > b then
            return a;
        else
            return b;
        end if;
    end function;

    function max (
        a : in real;
        b : in real) return real is
    begin
        if a > b then
            return a;
        else
            return b;
        end if;
    end function;

    function min (
        a : in integer;
        b : in integer) return integer is
    begin
        if a > b then
            return b;
        else
            return a;
        end if;
    end function;

    function min (
        a : in real;
        b : in real) return real is
    begin
        if a > b then
            return b;
        else
            return a;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in std_logic;
        f : in std_logic) return std_logic is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in std_logic_vector;
        f : in std_logic_vector) return std_logic_vector is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in integer;
        f : in integer) return integer is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in string;
        f : in string) return string is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in real;
        f : in real) return real is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in unsigned;
        f : in unsigned) return unsigned is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in boolean;
        f : in boolean) return boolean is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function choose (
        s : in boolean;
        t : in RealArray_t;
        f : in RealArray_t) return RealArray_t is
    begin
        if s then
            return t;
        else
            return f;
        end if;
    end function;

    function count (
        a : in IntegerArray_t;
        v : in integer) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function count (
        a : in BoolArray_t;
        v : in boolean) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function count (
        a : in std_logic_vector;
        v : in std_logic) return integer is
        variable Cnt_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if a(idx) = v then
                Cnt_v := Cnt_v + 1;
            end if;
        end loop;

        return Cnt_v;
    end function;

    function toUslv (
        input : integer;
        len   : integer) return std_logic_vector is
    begin
        return std_logic_vector(to_unsigned(input, len));
    end function;

    function toSslv (
        input : integer;
        len   : integer) return std_logic_vector is
    begin
        return std_logic_vector(to_signed(input, len));
    end function;

    function toStdl (input : integer range 0 to 1) return std_logic is
    begin
        if input = 1 then
            return '1';
        else
            return '0';
        end if;
    end function;

    function fromUslv (input : std_logic_vector) return integer is
    begin
        return to_integer(unsigned(input));
    end function;

    function fromSslv (input : std_logic_vector) return integer is
    begin
        return to_integer(signed(input));
    end function;

    function fromStdl (input : std_logic) return integer is
    begin
        assert input = '0' or input = '1'
            report ""fromStdl(): Illegal argument""
            severity error;
        if input = '0' then
            return 0;
        else
            return 1;
        end if;
    end function;

    function fromString (input : string) return real is
        constant Nbsp_c       : character := character'val(160);
        variable Idx_v        : integer   := input'low;
        variable IsNeg_v      : boolean   := false;
        variable ValInt_v     : integer   := 0;
        variable ValFrac_v    : real      := 0.0;
        variable FracDigits_v : integer   := 0;
        variable Exp_v        : integer   := 0;
        variable ExpNeg_v     : boolean   := false;
        variable ValAbs_v     : real      := 0.0;
    begin

        while (Idx_v <= input'high) and (input(Idx_v) = ' ' or input(Idx_v) = Nbsp_c or input(Idx_v) = HT) loop
            Idx_v := Idx_v + 1;
        end loop;

        if (Idx_v <= input'high) and ((input(Idx_v) = '-') or (input(Idx_v) = '+')) then
            IsNeg_v := (input(Idx_v) = '-');
            Idx_v   := Idx_v + 1;
        end if;

        while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
            ValInt_v := ValInt_v * 10 + (character'pos(input(Idx_v)) - character'pos('0'));
            Idx_v    := Idx_v + 1;
        end loop;

        if (Idx_v <= input'high) then
            if input(Idx_v) = '.' then
                Idx_v := Idx_v + 1;

                while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
                    ValFrac_v    := ValFrac_v * 10.0 + real((character'pos(input(Idx_v)) - character'pos('0')));
                    FracDigits_v := FracDigits_v + 1;
                    Idx_v        := Idx_v + 1;
                end loop;

            end if;
        end if;

        if (Idx_v <= input'high) then
            if (input(Idx_v) = 'E') or (input(Idx_v) = 'e') then
                Idx_v := Idx_v + 1;
                if (Idx_v <= input'high) and ((input(Idx_v) = '-') or (input(Idx_v) = '+')) then
                    ExpNeg_v := (input(Idx_v) = '-');
                    Idx_v    := Idx_v + 1;
                end if;

                while (Idx_v <= input'high) and (input(Idx_v) <= '9') and (input(Idx_v) >= '0') loop
                    Exp_v := Exp_v * 10 + (character'pos(input(Idx_v)) - character'pos('0'));
                    Idx_v := Idx_v + 1;
                end loop;

                if ExpNeg_v then
                    Exp_v := -Exp_v;
                end if;
            end if;
        end if;

        ValAbs_v := (real(ValInt_v) + ValFrac_v / 10.0**real(FracDigits_v)) * 10.0**real(Exp_v);
        if IsNeg_v then
            return -ValAbs_v;
        else
            return ValAbs_v;
        end if;
    end function;

    function fromString (input : string) return RealArray_t is
        variable Array_v    : RealArray_t(0 to countCommaSepElems(input) - 1) := (others => 0.0);
        variable ArrayIdx_v : natural                                         := 0;
        variable StartIdx_v : natural                                         := 1;
        variable EndIdx_v   : natural                                         := 1;
        variable CharIdx_v  : natural                                         := input'low;
    begin

        while CharIdx_v <= input'high loop
            if input(CharIdx_v) = ',' then
                EndIdx_v            := CharIdx_v - 1;
                Array_v(ArrayIdx_v) := fromString(input(StartIdx_v to EndIdx_v));
                ArrayIdx_v          := ArrayIdx_v + 1;
                StartIdx_v          := CharIdx_v + 1;
            end if;
            CharIdx_v := CharIdx_v + 1;
        end loop;

        if StartIdx_v <= input'high then
            Array_v(ArrayIdx_v) := fromString(input(StartIdx_v to input'high));
        end if;

        return Array_v;
    end function;

    function maxArray (a : in IntegerArray_t) return integer is
        variable Max_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if max(Max_v, a(idx)) > Max_v then
                Max_v := a(idx);
            end if;
        end loop;

        return Max_v;
    end function;

    function maxArray (a : in RealArray_t) return real is
        variable Max_v : real := 0.0;
    begin

        for idx in a'low to a'high loop
            if max(Max_v, a(idx)) > Max_v then
                Max_v := a(idx);
            end if;
        end loop;

        return Max_v;
    end function;

    function minArray (a : in IntegerArray_t) return integer is
        variable Min_v : integer := 0;
    begin

        for idx in a'low to a'high loop
            if min(Min_v, a(idx)) < Min_v then
                Min_v := a(idx);
            end if;
        end loop;

        return Min_v;
    end function;

    function minArray (a : in RealArray_t) return real is
        variable Min_v : real := 0.0;
    begin

        for idx in a'low to a'high loop
            if min(Min_v, a(idx)) < Min_v then
                Min_v := a(idx);
            end if;
        end loop;

        return Min_v;
    end function;

end package body;"
"defines a package named `olo_base_pkg_string` which contains a set of string manipulation and conversion functions. This package is designed to be used in digital system design, particularly in the context of FPGA or ASIC development, where string processing is required. The primary purpose of this package is to provide a set of reusable functions for string manipulation, conversion, and analysis. These functions can be used in a wide range of applications, from simple text processing to complex data analysis. The package is designed to be a part of a larger library, as indicated by the `use work.olo_base_pkg_math.all;` statement, suggesting that it is intended to be used in conjunction with other packages. The package contains five functions: `toUpper`, `toLower`, `trim`, `hex2StdLogicVector`, and `countOccurence`. Each of these functions serves a specific purpose. The `toUpper` and `toLower` functions convert a given string to uppercase or lowercase, respectively. The `trim` function removes leading and trailing whitespace characters from a string. The `hex2StdLogicVector` function converts a hexadecimal string to a `std_logic_vector`, which is a common data type in digital system design. The `countOccurence` function counts the number of occurrences of a specified character in a string. From an input/output perspective, each function has specific requirements. The `toUpper` and `toLower` functions take a string as input and return a string. The `trim` function also takes a string as input and returns a string. The `hex2StdLogicVector` function takes a string, a natural number representing the bit width of the output `std_logic_vector`, and an optional boolean indicating whether the input string has a hexadecimal prefix (e.g., ""0x""). The function returns a `std_logic_vector` of the specified bit width. The `countOccurence` function takes a string and a character as input and returns a natural number representing the count of occurrences. Internally, the package uses a combination of loops, conditional statements, and type conversions to implement the desired functionality. For example, the `hex2StdLogicVector` function uses a loop to iterate over the input string, converting each hexadecimal character to a 4-bit `std_logic_vector` using a case statement. The function then concatenates these vectors to form the final output. The functional behavior of each function can be described step-by-step. For instance, the `toUpper` function iterates over each character in the input string, checks if it is a lowercase letter, and if so, converts it to uppercase by subtracting a fixed value from its ASCII code. The `hex2StdLogicVector` function, on the other hand, first trims the input string and checks for a hexadecimal prefix. It then iterates over the string, converting each character to a 4-bit `std_logic_vector` and concatenating them to form the final output. Control logic is implemented using conditional statements and loops. For example, the `hex2StdLogicVector` function uses an assert statement to check for an invalid prefix and report an error if necessary. The function also uses a case statement to handle invalid characters in the input string. Data flow through the component is primarily in the form of function calls and returns. Each function takes input data, processes it internally, and returns the result. The `hex2StdLogicVector` function, for instance, takes a string and a bit width as input, processes the string internally, and returns a `std_logic_vector` of the specified bit width. In terms of timing and synchronization, the package does not appear to have any specific requirements. The functions are designed to operate on strings and do not have any clock-domain or setup/hold requirements. One special feature of the package is its use of VHDL-2008 features, such as the `string` type and the `character` type. The package also uses a consistent naming convention and coding style, making it easy to read and understand. The package can be used in a wide range of applications, from simple text processing to complex data analysis. For example, it can be used in a digital system that requires string manipulation, such as a UART or a network protocol analyzer. When implementing this package, designers should consider performance, resource usage, and design trade-offs. For instance, the `hex2StdLogicVector` function uses a loop to iterate over the input string, which may impact performance. Designers may need to optimize the function for performance or resource usage, depending on the specific requirements of their application. In conclusion, the `olo_base_pkg_string` package provides a set of useful string manipulation and conversion functions for digital system design. The package is well-structured, easy to read, and follows a consistent naming convention and coding style. Its functions can be used in a wide range of applications, and designers should consider performance, resource usage, and design trade-offs when implementing the package.","
library ieee;
    use ieee.std_logic_1164.all;

library work;
    use work.olo_base_pkg_math.all;

package olo_base_pkg_string is

    function toUpper (a : in string) return string;
    function toLower (a : in string) return string;

    function trim (a : in string) return string;

    function hex2StdLogicVector (
        a         : in string;
        bits      : in natural;
        hasPrefix : in boolean := false) return std_logic_vector;

    function countOccurence (
        a : in string;
        c : in character) return natural;

end package;

package body olo_base_pkg_string is

    function toUpper (a : in string) return string is
        variable Res_v        : string(a'range);
        variable CharIdx_v    : natural;
        constant LowerUpper_c : natural := character'pos('a') - character'pos('A');
    begin

        for i in a'range loop
            CharIdx_v := character'pos(a(i));
            if CharIdx_v >= character'pos('a') and CharIdx_v <= character'pos('z') then
                CharIdx_v := CharIdx_v - LowerUpper_c;
            end if;
            Res_v(i) := character'val(CharIdx_v);
        end loop;

        return Res_v;
    end function;

    function toLower (a : in string) return string is
        variable Res_v        : string(a'range);
        variable CharIdx_v    : natural;
        constant LowerUpper_c : natural := character'pos('a') - character'pos('A');
    begin

        for i in a'range loop
            CharIdx_v := character'pos(a(i));
            if CharIdx_v >= character'pos('A') and CharIdx_v <= character'pos('Z') then
                CharIdx_v := CharIdx_v + LowerUpper_c;
            end if;
            Res_v(i) := character'val(CharIdx_v);
        end loop;

        return Res_v;
    end function;

    function trim (a : in string) return string is
        variable StartIdx_v : natural := a'left;
        variable EndIdx_v   : natural := a'right;
    begin

        while StartIdx_v < a'right and a(StartIdx_v) = ' ' loop
            StartIdx_v := StartIdx_v + 1;
        end loop;

        while EndIdx_v > a'left and a(EndIdx_v) = ' ' loop
            EndIdx_v := EndIdx_v - 1;
        end loop;

        return a(StartIdx_v to EndIdx_v);
    end function;

    function hex2StdLogicVector (
        a         : in string;
        bits      : in natural;
        hasPrefix : in boolean := false) return std_logic_vector is
        constant Trimmed_c   : string                                   := trim(toLower(a));
        constant MaxBits_c   : natural                                  := max(choose(hasPrefix, (Trimmed_c'length-2) * 4, Trimmed_c'length * 4), 0);
        variable StdlvFull_v : std_logic_vector(MaxBits_c - 1 downto 0) := (others => '0');
        variable Result_v    : std_logic_vector(bits - 1 downto 0)      := (others => '0');
        variable LowIdx_v    : natural                                  := 0;
        variable Nibble_v    : std_logic_vector(3 downto 0);
    begin
        if Trimmed_c'length = 0 then
            return Result_v;
        end if;

        if hasPrefix then
            assert Trimmed_c(Trimmed_c'left to Trimmed_c'left+1) = ""0x""
                report ""Invalid prefix in hex2StdLogicVector() - expected prefix is 0x - string: "" & a
                severity error;
            LowIdx_v := LowIdx_v + 2;
        end if;

        for i in Trimmed_c'left+LowIdx_v to Trimmed_c'right loop

            case Trimmed_c(i) is
                when '0' => Nibble_v := x""0"";
                when '1' => Nibble_v := x""1"";
                when '2' => Nibble_v := x""2"";
                when '3' => Nibble_v := x""3"";
                when '4' => Nibble_v := x""4"";
                when '5' => Nibble_v := x""5"";
                when '6' => Nibble_v := x""6"";
                when '7' => Nibble_v := x""7"";
                when '8' => Nibble_v := x""8"";
                when '9' => Nibble_v := x""9"";
                when 'a' => Nibble_v := x""A"";
                when 'b' => Nibble_v := x""B"";
                when 'c' => Nibble_v := x""C"";
                when 'd' => Nibble_v := x""D"";
                when 'e' => Nibble_v := x""E"";
                when 'f' => Nibble_v := x""F"";
                when others =>
                    report ""Invalid character in hex2StdLogicVector() - only 0-9, a-f, A-F are allowed - string: "" & a
                        severity error;
                    return Result_v;
            end case;

            StdlvFull_v := StdlvFull_v(StdlvFull_v'left - 4 downto 0) & Nibble_v;
        end loop;

        if bits > MaxBits_c then
            Result_v(MaxBits_c - 1 downto 0) := StdlvFull_v;
        else
            Result_v := StdlvFull_v(bits-1 downto 0);
        end if;
        return Result_v;
    end function;

    function countOccurence (
        a : in string;
        c : in character) return natural is
        variable Count_v : natural := 0;
    begin

        for i in a'range loop
            if a(i) = c then
                Count_v := Count_v + 1;
            end if;
        end loop;

        return Count_v;
    end function;

end package body;"
"describes a parameterized, pipelined stage component, referred to as `olo_base_pl_stage`, which can be used to construct a multi-stage pipeline. This component is designed to handle data streaming, providing a flexible and efficient way to manage data flow in digital systems. **Component Overview** The `olo_base_pl_stage` entity is a generic, synchronous component that can be configured to have a variable number of pipeline stages (`Stages_g`). Its primary purpose is to manage data flow through the pipeline, handling data validity and readiness signals. The component can be used in larger systems, such as digital signal processing (DSP) architectures, data acquisition systems, or high-speed data transmission systems. **Detailed Input/Output Analysis** The component has several input and output ports that facilitate data flow and control: * `Clk`: The clock input, which drives the internal sequential logic. * `Rst`: The asynchronous reset input, used to initialize the component. * `In_Valid`: The input data validity signal, indicating whether the input data is valid. * `In_Ready`: The output signal indicating whether the component is ready to accept input data. * `In_Data`: The input data bus, with a width defined by the `Width_g` generic parameter. * `Out_Valid`: The output data validity signal, indicating whether the output data is valid. * `Out_Ready`: The input signal indicating whether the downstream component is ready to accept output data. * `Out_Data`: The output data bus, with the same width as `In_Data`. The `In_Valid`, `Out_Valid`, `In_Ready`, and `Out_Ready` signals manage data flow and indicate the readiness of the component and its downstream counterpart. **Architectural Description** The internal structure of `olo_base_pl_stage` consists of a series of `olo_private_pl_stage_single` components, which are instantiated based on the value of the `Stages_g` generic parameter. Each `olo_private_pl_stage_single` component represents a single pipeline stage. The `olo_private_pl_stage_single` component has two main architectures: one with ready signal support (`g_rdy`) and one without (`g_nrdy`). The `g_rdy` architecture uses a two-process approach, with one process handling the combinatorial logic and another managing the sequential logic. This allows for efficient data flow control and readiness management. **Functional Behavior** The component's functional behavior can be described as follows: 1. When `Stages_g` is greater than 0, the component instantiates multiple `olo_private_pl_stage_single` components, connecting them in series to form a multi-stage pipeline. 2. Data flows through the pipeline stages, with each stage managing data validity and readiness. 3. The `In_Ready` signal is asserted when the component is ready to accept input data, and the `Out_Valid` signal indicates whether the output data is valid. 4. When `Stages_g` is 0, the component simply bypasses the input data to the output, with the `In_Ready` signal always asserted. **Control Logic** The control logic within `olo_private_pl_stage_single` manages data flow based on the `UseReady_g` generic parameter. When `UseReady_g` is true, the component uses a two-process approach to handle data flow control and readiness management. The `In_Ready` signal is asserted or deasserted based on the readiness of the downstream component and the validity of the input data. **Data Flow** Data moves through the component as follows: * Input data is accepted when `In_Ready` is asserted and `In_Valid` is high. * The data is then processed and propagated through the pipeline stages. * At each stage, the data validity and readiness are evaluated, and the data is either forwarded or stalled. * The output data is presented when `Out_Valid` is asserted, and it is accepted by the downstream component when `Out_Ready` is high. **Timing and Synchronization** The component operates based on the rising edge of the `Clk` signal. The `Rst` signal asynchronously resets the component. The timing relationships between the input and output signals are as follows: * `In_Data` and `In_Valid` are sampled on the rising edge of `Clk`. * `Out_Data` and `Out_Valid` are updated on the rising edge of `Clk`. * `In_Ready` and `Out_Ready` are evaluated based on the current state of the component and the downstream component. The component has specific setup and hold requirements for the input signals, which must be met to ensure proper operation. **Special Features** The component has several special features: * **Parameterized pipeline stages**: The `Stages_g` generic parameter allows the user to configure the number of pipeline stages. * **Ready signal support**: The `UseReady_g` generic parameter enables or disables ready signal support. * **Bypass mode**: When `Stages_g` is 0, the component bypasses the input data to the output. **Applications and Use Cases** The `olo_base_pl_stage` component can be used in various applications, such as: * Digital signal processing (DSP) architectures * Data acquisition systems * High-speed data transmission systems * Data processing pipelines **Implementation Considerations** When implementing this component, designers should consider: * **Performance**: The component's performance is influenced by the number of pipeline stages, the clock frequency, and the input data rate. * **Resource usage**: The component's resource usage depends on the number of pipeline stages, the width of the data bus, and the target technology. * **Design trade-offs**: Designers must balance the number of pipeline stages, the clock frequency, and the","


library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

entity olo_base_pl_stage is
    generic (
        Width_g     : positive;
        UseReady_g  : boolean := true;
        Stages_g    : natural := 1
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic := '1';
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_base_pl_stage is

    component olo_private_pl_stage_single is
        generic (
            Width_g     : positive;
            UseReady_g  : boolean   := true
        );
        port (
            Clk         : in    std_logic;
            Rst         : in    std_logic;
            In_Valid    : in    std_logic;
            In_Ready    : out   std_logic;
            In_Data     : in    std_logic_vector(Width_g-1 downto 0);
            Out_Valid   : out   std_logic;
            Out_Ready   : in    std_logic := '1';
            Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
        );
    end component;

    type Data_t is array (natural range <>) of std_logic_vector(Width_g - 1 downto 0);

    signal Data  : Data_t(0 to Stages_g);
    signal Valid : std_logic_vector(0 to Stages_g);
    signal Ready : std_logic_vector(0 to Stages_g);

begin

    g_nonzero : if Stages_g > 0 generate
        Valid(0) <= In_Valid;
        In_Ready <= Ready(0);
        Data(0)  <= In_Data;

        g_stages : for i in 0 to Stages_g - 1 generate

            i_stg : component olo_private_pl_stage_single
                generic map (
                    Width_g    => Width_g,
                    UseReady_g => UseReady_g
                )
                port map (
                    Clk       => Clk,
                    Rst       => Rst,
                    In_Valid  => Valid(i),
                    In_Ready  => Ready(i),
                    In_Data   => Data(i),
                    Out_Valid => Valid(i + 1),
                    Out_Ready => Ready(i + 1),
                    Out_Data  => Data(i + 1)
                );

        end generate;

        Out_Valid       <= Valid(Stages_g);
        Ready(Stages_g) <= Out_Ready;
        Out_Data        <= Data(Stages_g);
    end generate;

    g_zero : if Stages_g = 0 generate
        Out_Valid <= In_Valid;
        Out_Data  <= In_Data;
        In_Ready  <= Out_Ready;
    end generate;

end architecture;


library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_attribute.all;

entity olo_private_pl_stage_single is
    generic (
        Width_g     : positive;
        UseReady_g  : boolean := true
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1';
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0)
    );
end entity;

architecture rtl of olo_private_pl_stage_single is

    type TwoProcess_r is record
        DataMain    : std_logic_vector(Width_g - 1 downto 0);
        DataMainVld : std_logic;
        DataShad    : std_logic_vector(Width_g - 1 downto 0);
        DataShadVld : std_logic;
        In_Ready    : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    g_rdy : if UseReady_g generate

        p_comb : process (In_Valid, In_Data, Out_Ready, r) is
            variable v         : TwoProcess_r;
            variable IsStuck_v : boolean;
        begin
            v := r;

            IsStuck_v := (r.DataMainVld = '1' and Out_Ready = '0' and (In_Valid = '1' or r.DataShadVld = '1'));

            if r.DataMainVld = '1' and Out_Ready = '1' then
                v.DataMainVld := r.DataShadVld;
                v.DataMain    := r.DataShad;
                v.DataShadVld := '0';
            end if;

            if r.In_Ready = '1' and In_Valid = '1' then
                if IsStuck_v then
                    v.DataShadVld := '1';
                    v.DataShad    := In_Data;
                else
                    v.DataMainVld := '1';
                    v.DataMain    := In_Data;
                end if;
            end if;

            if IsStuck_v then
                v.In_Ready := '0';
            else
                v.In_Ready := '1';
            end if;

            r_next <= v;
        end process;

        In_Ready  <= r.In_Ready;
        Out_Valid <= r.DataMainVld;
        Out_Data  <= r.DataMain;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.DataMainVld <= '0';
                    r.DataShadVld <= '0';
                    r.In_Ready    <= '1';
                end if;
            end if;
        end process;

    end generate;

    g_nrdy : if not UseReady_g generate
        signal VldReg  : std_logic;
        signal DataReg : std_logic_vector(Width_g-1 downto 0);

        attribute shreg_extract of VldReg  : signal is ShregExtract_SuppressExtraction_c;
        attribute shreg_extract of DataReg : signal is ShregExtract_SuppressExtraction_c;

        attribute syn_srlstyle of VldReg  : signal is SynSrlstyle_FlipFlops_c;
        attribute syn_srlstyle of DataReg : signal is SynSrlstyle_FlipFlops_c;

        attribute dont_merge of VldReg  : signal is DontMerge_SuppressChanges_c;
        attribute dont_merge of DataReg : signal is DontMerge_SuppressChanges_c;

        attribute preserve of VldReg  : signal is Preserve_SuppressChanges_c;
        attribute preserve of DataReg : signal is Preserve_SuppressChanges_c;

        attribute syn_keep of VldReg  : signal is SynKeep_SuppressChanges_c;
        attribute syn_keep of DataReg : signal is SynKeep_SuppressChanges_c;

        attribute syn_preserve of VldReg  : signal is SynPreserve_SuppressChanges_c;
        attribute syn_preserve of DataReg : signal is SynPreserve_SuppressChanges_c;

    begin

        p_stg : process (Clk) is
        begin
            if rising_edge(Clk) then
                DataReg <= In_Data;
                VldReg  <= In_Valid;
                if Rst = '1' then
                    VldReg <= '0';
                end if;
            end if;
        end process;

        In_Ready  <= '1'; -- Not used!
        Out_Data  <= DataReg;
        Out_Valid <= VldReg;

    end generate;

end architecture;"
"The `olo_base_prbs` component is a VHDL implementation of a Pseudo-Random Bit Sequence (PRBS) generator, which is a type of Linear Feedback Shift Register (LFSR) used to produce a sequence of pseudo-random bits. The primary purpose of this component is to generate a PRBS sequence based on a given polynomial, seed value, and number of bits per symbol. The component has several input and output ports that facilitate its operation. The `Clk` and `Rst` ports are used for clocking and resetting the component, respectively. The `Out_Data` port outputs the generated PRBS sequence, with a bit width determined by the `BitsPerSymbol_g` generic parameter. The `Out_Ready` port is an input that enables the generation of new PRBS bits, while `Out_Valid` indicates whether the output data is valid. The `State_Current` and `State_New` ports provide access to the current and new LFSR states, respectively, allowing for external control and monitoring. The `State_Set` port enables the setting of a new LFSR state. Internally, the component consists of a single process, `p_lfsr`, which is sensitive to the clock signal. This process implements the LFSR update logic, which is based on the provided polynomial and seed value. The LFSR update function, `lfsrUpdate`, performs the necessary bitwise operations to generate the next LFSR state. The `lfsrInitValue` function initializes the LFSR register with the seed value and performs any necessary updates to ensure that the LFSR state is properly aligned. The component's architectural description reveals a simple, yet efficient design. The LFSR register, `LfsrReg`, is the central storage element, and its value is updated based on the `Out_Ready` and `State_Set` inputs. The `lfsrUpdate` function is used to generate new LFSR states, which are then stored in the `LfsrReg`. The component also includes several assertions to ensure that the provided generic parameters meet specific requirements, such as polynomial width, seed value width, and bits per symbol. The functional behavior of the component can be described as follows: when the `Out_Ready` input is high, the component generates a new PRBS bit sequence based on the current LFSR state and outputs it on the `Out_Data` port. The `Out_Valid` output is always high, indicating that the output data is valid. When the `State_Set` input is high, the component sets the LFSR state to the value provided on the `State_New` port. During reset, the LFSR register is reinitialized with the seed value. The control logic of the component is primarily governed by the `Out_Ready` and `State_Set` inputs. When `Out_Ready` is high, the LFSR register is updated, and a new PRBS bit sequence is generated. When `State_Set` is high, the LFSR state is updated with the new value provided on the `State_New` port. The reset input, `Rst`, reinitializes the LFSR register with the seed value. The data flow within the component is straightforward: the LFSR register is updated based on the `Out_Ready` and `State_Set` inputs, and the generated PRBS bit sequence is output on the `Out_Data` port. The `lfsrUpdate` function performs the necessary bitwise operations to generate new LFSR states. In terms of timing and synchronization, the component operates within a single clock domain, with the `Clk` input governing the update of the LFSR register. The component has no specific setup or hold requirements, as it is designed to operate within a standard synchronous design flow. One special feature of this component is its support for an external LFSR state, which can be set using the `State_New` and `State_Set` ports. This allows for flexible control over the PRBS sequence generation. The `olo_base_prbs` component is typically used in digital communication systems, such as bit error rate testers, data transmission systems, and digital signal processing applications. Its primary advantage is its ability to generate a pseudo-random bit sequence that can be used to simulate real-world data transmission scenarios. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The component's resource usage is primarily determined by the width of the LFSR register and the complexity of the polynomial. Designers may need to optimize the component's architecture to meet specific area and performance requirements. Additionally, careful consideration should be given to the selection of the polynomial and seed value, as these parameters significantly impact the characteristics of the generated PRBS sequence.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.std_logic_misc.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_logic.all;
    use work.olo_base_pkg_math.all;

entity olo_base_prbs is
    generic (
        Polynomial_g    : std_logic_vector;
        Seed_g          : std_logic_vector;
        BitsPerSymbol_g : positive := 1;
        LfsrWidth_g     : natural  := 0 -- Deprecated, not used
    );
    port (
        Clk              : in    std_logic;
        Rst              : in    std_logic;
        Out_Data         : out   std_logic_vector(BitsPerSymbol_g-1 downto 0);
        Out_Ready        : in    std_logic                                        := '1';
        Out_Valid        : out   std_logic;
        State_Current    : out   std_logic_vector(Polynomial_g'length-1 downto 0);
        State_New        : in    std_logic_vector(Polynomial_g'length-1 downto 0) := (others => '0');
        State_Set        : in    std_logic                                        := '0'
    );
end entity;


architecture rtl of olo_base_prbs is

    constant LfsrLenght_c : natural := max(BitsPerSymbol_g, Polynomial_g'length);

    signal LfsrReg : std_logic_vector(LfsrLenght_c-1 downto 0);

    function lfsrUpdate (
        lfsrReg : std_logic_vector(LfsrLenght_c-1 downto 0);
        bits    : positive) return std_logic_vector is
        variable Lfsr_v       : std_logic_vector(LfsrLenght_c-1 downto 0) := lfsrReg;
        variable LfsrMasked_v : std_logic_vector(Polynomial_g'length-1 downto 0);
        variable NextBit_v    : std_logic;
    begin

        for bit in 0 to bits - 1 loop
            LfsrMasked_v := Lfsr_v(Polynomial_g'length-1 downto 0) and Polynomial_g;
            NextBit_v    := xor_reduce(LfsrMasked_v);
            Lfsr_v       := Lfsr_v(Lfsr_v'high-1 downto 0) & NextBit_v;
        end loop;

        return Lfsr_v;
    end function;

    function lfsrInitValue return std_logic_vector is
        variable Lfsr_v : std_logic_vector(LfsrLenght_c-1 downto 0) := (others => '0');
    begin
        Lfsr_v(Polynomial_g'length-1 downto 0) := Seed_g;

        if LfsrLenght_c > Polynomial_g'length then
            Lfsr_v := lfsrUpdate(Lfsr_v, LfsrLenght_c - Polynomial_g'length);
        end if;

        return Lfsr_v;

    end function;

begin

    assert Polynomial_g'length >= 2
        report ""###ERROR###: olo_base_prbs - Polynomial_g width must be at least 2""
        severity error;
    assert Seed_g'length = Polynomial_g'length
        report ""###ERROR###: olo_base_prbs - Seed_g width must match Polynomial_g width""
        severity error;
    assert fromUslv(Seed_g) /= 0
        report ""###ERROR###: olo_base_prbs - Seed_g MUST NOT be zero""
        severity error;
    assert BitsPerSymbol_g >= 1
        report ""###ERROR###: olo_base_prbs - BitsPerSymbol_g width must be larger or equal to 1""
        severity error;

    Out_Valid     <= '1';
    Out_Data      <= invertBitOrder(LfsrReg(LfsrReg'high downto LfsrReg'length-BitsPerSymbol_g));
    State_Current <= LfsrReg(State_Current'high downto 0);

    p_lfsr : process (Clk) is
        variable Lfsr_v : std_logic_vector(LfsrReg'range);
    begin
        if rising_edge(Clk) then
            if Out_Ready = '1' then
                LfsrReg <= lfsrUpdate(LfsrReg, BitsPerSymbol_g);
            end if;

            if State_Set = '1' then
                Lfsr_v                                 := (others => '0');
                Lfsr_v(Polynomial_g'length-1 downto 0) := State_New;
                if LfsrLenght_c > Polynomial_g'length then
                    Lfsr_v := lfsrUpdate(Lfsr_v, LfsrLenght_c - Polynomial_g'length);
                end if;
                LfsrReg <= Lfsr_v;
            end if;

            if Rst = '1' then
                LfsrReg <= lfsrInitValue;
            end if;

        end if;

    end process;

end architecture;"
"The `olo_base_ram_sdp` component is a synchronous or asynchronous single-port RAM (SPRAM) module designed for use in digital systems. Its primary purpose is to provide a configurable memory storage element with flexible read and write operations. This component plays a crucial role in larger systems by enabling efficient data storage and retrieval. The component features a range of generics that allow for customization of its behavior and configuration. These generics include `Depth_g`, which specifies the memory depth; `Width_g`, which sets the data width; `IsAsync_g`, which determines whether the RAM operates in synchronous or asynchronous mode; `RdLatency_g`, which controls the read latency; `RamStyle_g` and `RamBehavior_g`, which influence the RAM's architecture and behavior; `UseByteEnable_g`, which enables or disables byte-level write enables; and `InitString_g` and `InitFormat_g`, which facilitate initialization of the memory. The component's ports can be categorized into two primary groups: write and read ports. The write port consists of `Wr_Addr`, which provides the write address; `Wr_Ena`, which enables write operations; `Wr_Be`, which supplies byte-level write enables when `UseByteEnable_g` is true; and `Wr_Data`, which carries the data to be written. The read port comprises `Rd_Clk`, which clocks read operations in asynchronous mode; `Rd_Addr`, which specifies the read address; `Rd_Ena`, which enables read operations; and `Rd_Data`, which outputs the read data. Internally, the component employs a shared variable `Mem_v` to model the memory array. The `getInitContent` function initializes this memory based on the provided `InitString_g` and `InitFormat_g`. The component uses a generate statement to instantiate either a single `olo_private_ram_sdp_nobe` module or multiple instances of it, depending on whether byte enables are used. In the case of byte enables, the module is instantiated multiple times, with each instance handling a byte of data. The `olo_private_ram_sdp_nobe` module implements the actual memory functionality. It features a process statement that handles write and read operations based on the configured mode (synchronous or asynchronous). In synchronous mode, write and read operations are performed on the same clock edge. In asynchronous mode, write operations are performed on the write clock, while read operations are performed on the read clock. The module uses a pipelined architecture to achieve the specified read latency. The control logic of the component is primarily determined by the generics and the port inputs. The `Wr_Ena` and `Rd_Ena` signals control write and read operations, respectively. The `UseByteEnable_g` generic enables or disables byte-level write enables. The component also includes assertions to ensure that the `Width_g` is a multiple of 8 when byte enables are used and that the `InitFormat_g` and `RamBehavior_g` generics are set to valid values. Data flow through the component is straightforward. Write data is provided on the `Wr_Data` port and is stored in the memory array at the address specified by `Wr_Addr`. Read data is retrieved from the memory array at the address specified by `Rd_Addr` and is output on the `Rd_Data` port. The component supports flexible data widths and depths, making it suitable for a wide range of applications. The component's timing and synchronization are primarily determined by the clock inputs (`Clk` and `Rd_Clk`) and the configured read latency. In synchronous mode, the component operates on the rising edge of the clock. In asynchronous mode, write and read operations are performed on separate clocks. The component requires careful consideration of setup and hold times to ensure reliable operation. One of the special features of this component is its support for flexible initialization through the `InitString_g` and `InitFormat_g` generics. This allows designers to easily initialize the memory with specific values or patterns. Additionally, the component's byte-enable feature enables efficient use of memory bandwidth. The `olo_base_ram_sdp` component is suitable for a wide range of applications, including digital signal processing, embedded systems, and communication systems. Its flexibility and configurability make it an attractive choice for designers seeking to optimize memory usage and performance. When implementing this component, designers should carefully consider performance, resource usage, and design trade-offs. The component's architecture and generics offer various optimization opportunities, such as selecting the optimal memory style, configuring the read latency, and using byte enables. However, these optimizations may come at the cost of increased complexity or resource usage. A thorough analysis of the system's requirements and constraints is essential to ensure that the component is used effectively. Overall, the `olo_base_ram_sdp` component provides a versatile and efficient solution for memory storage and retrieval in digital systems. Its configurability, flexibility, and performance make it a valuable component in a wide range of applications.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_sdp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        IsAsync_g       : boolean  := false;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );
    port (
        Clk         : in    std_logic;
        Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Wr_Ena      : in    std_logic                                  := '1';
        Wr_Be       : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Rd_Clk      : in    std_logic                                  := '0';
        Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Rd_Ena      : in    std_logic                                  := '1';
        Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_sdp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_sdp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            IsAsync_g       : boolean  := false;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            Clk         : in    std_logic;
            Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            Wr_Ena      : in    std_logic                                  := '1';
            Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
            Rd_Clk      : in    std_logic                                  := '0';
            Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            Rd_Ena      : in    std_logic                                  := '1';
            Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_sdp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_sdp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                IsAsync_g       => IsAsync_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                Clk         => Clk,
                Wr_Addr     => Wr_Addr,
                Wr_Ena      => Wr_Ena,
                Wr_Data     => Wr_Data,
                Rd_Clk      => Rd_Clk,
                Rd_Addr     => Rd_Addr,
                Rd_Ena      => Rd_Ena,
                Rd_Data     => Rd_Data
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal Wr_Ena_Byte : std_logic;
        begin
            Wr_Ena_Byte <= Wr_Ena and Wr_Be(byte);

            i_ram : component olo_private_ram_sdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    IsAsync_g       => IsAsync_g,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk         => Clk,
                    Wr_Addr     => Wr_Addr,
                    Wr_Ena      => Wr_Ena_Byte,
                    Wr_Data     => Wr_Data(byte*8+7 downto byte*8),
                    Rd_Clk      => Rd_Clk,
                    Rd_Addr     => Rd_Addr,
                    Rd_Ena      => Rd_Ena,
                    Rd_Data     => Rd_Data(byte*8+7 downto byte*8)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_sdp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        IsAsync_g       : boolean  := false;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        Clk         : in    std_logic;
        Wr_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Wr_Ena      : in    std_logic := '1';
        Wr_Data     : in    std_logic_vector(Width_g - 1 downto 0);
        Rd_Clk      : in    std_logic := '0';
        Rd_Addr     : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        Rd_Ena      : in    std_logic := '1';
        Rd_Data     : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_sdp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipe : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipe : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_sdp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_sdp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    g_sync : if not IsAsync_g generate

        p_ram : process (Clk) is
        begin
            if rising_edge(Clk) then
                if RamBehavior_g = ""RBW"" then
                    if Rd_Ena = '1' then
                        RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                    end if;
                end if;
                if Wr_Ena = '1' then
                    Mem_v(to_integer(unsigned(Wr_Addr))) := Wr_Data;
                end if;
                if RamBehavior_g = ""WBR"" then
                    if Rd_Ena = '1' then
                        RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                    end if;
                end if;

                RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    g_async : if IsAsync_g generate

        p_write : process (Clk) is
        begin
            if rising_edge(Clk) then
                if Wr_Ena = '1' then
                    Mem_v(to_integer(unsigned(Wr_Addr))) := Wr_Data;
                end if;
            end if;
        end process;

        p_read : process (Rd_Clk) is
        begin
            if rising_edge(Rd_Clk) then
                if Rd_Ena = '1' then
                    RdPipe(1) <= Mem_v(to_integer(unsigned(Rd_Addr)));
                end if;

                RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    Rd_Data <= RdPipe(RdLatency_g);

end architecture;"
"The `olo_base_ram_sp` component is a single-port RAM (Random Access Memory) module designed for use in digital systems. Its primary purpose is to provide a flexible and configurable memory storage element that can be used in a variety of applications. The component's role in larger systems is to serve as a memory block that can be used to store and retrieve data. The component has several input and output ports that facilitate its operation. The `Clk` port is a clock input that drives the internal operation of the component. The `Addr` port is an address input that specifies the location in memory where data should be written or read. The `Be` port is a byte enable input that allows for selective writing of bytes within a word, but only when the `UseByteEnable_g` generic is set to `true`. The `WrEna` port is a write enable input that controls whether data is written to memory. The `WrData` port is a write data input that provides the data to be written to memory. The `RdData` port is a read data output that provides the data retrieved from memory. The component's internal structure consists of a memory array (`Mem_v`) and a read pipeline (`RdPipe`). The memory array is a shared variable that stores the data written to the component. The read pipeline is a signal array that stores the data being read from the memory array, and is used to implement the read latency specified by the `RdLatency_g` generic. The component's architectural description reveals a complex internal structure. The `getInitContent` function is used to initialize the memory array with data specified by the `InitString_g` and `InitFormat_g` generics. The `olo_private_ram_sp_nobe` component is instantiated multiple times, depending on the value of the `UseByteEnable_g` generic. When `UseByteEnable_g` is `false`, a single instance of `olo_private_ram_sp_nobe` is used, and the `Be` port is ignored. When `UseByteEnable_g` is `true`, multiple instances of `olo_private_ram_sp_nobe` are used, one for each byte in the word, and the `Be` port is used to selectively enable writes to each byte. The component's functional behavior can be described step-by-step. When the `Clk` input rises, the component checks the `WrEna` input and writes data to the memory array if it is high. The component then reads data from the memory array and stores it in the read pipeline. The read pipeline is used to implement the read latency, and the data is retrieved from the pipeline after the specified number of clock cycles. The component's control logic is implemented using a combination of generics, inputs, and internal signals. The `RamBehavior_g` generic controls the order in which reads and writes are performed. The `RdLatency_g` generic controls the number of clock cycles that data takes to propagate from the memory array to the output. The `UseByteEnable_g` generic controls whether byte enables are used to selectively write bytes within a word. The component's data flow can be described as follows. Data is written to the component through the `WrData` port and is stored in the memory array. Data is read from the component through the `RdData` port and is retrieved from the read pipeline. The component's timing and synchronization are critical to its operation. The `Clk` input drives the internal operation of the component, and all data transfers occur on the rising edge of the clock. The component has specific setup and hold requirements for the `Addr`, `WrEna`, and `WrData` inputs, which must be met to ensure reliable operation. The component has several special features that make it versatile and useful in a variety of applications. The `InitString_g` and `InitFormat_g` generics allow for initialization of the memory array with data specified in a string format. The `RamStyle_g` generic allows for specification of the RAM style, which can affect the component's performance and resource usage. The component can be used in a variety of applications, including digital signal processing, data storage, and communication systems. It is particularly useful in systems that require flexible and configurable memory storage elements. In terms of implementation considerations, the component's performance and resource usage can be affected by the values chosen for the generics. For example, increasing the value of `RdLatency_g` can increase the component's latency, but may also reduce its resource usage. The `RamStyle_g` generic can also affect the component's performance and resource usage, and must be chosen carefully to meet the requirements of the target system. Overall, the `olo_base_ram_sp` component is a versatile and configurable memory storage element that can be used in a variety of digital systems. Its flexible architecture and range of generics make it suitable for use in applications that require high performance, low power consumption, and efficient resource usage. The entity `olo_private_ram_sp_nobe` acts as a sub-component to `olo_base_ram_sp`, providing a basic single-port RAM functionality. Its functionality can be viewed as a subset of `olo_base_ram_sp`, omitting the byte enable logic. A thorough analysis would reveal comparable internal structure and behavior with some generics having default values. implements a highly versatile and generic single-port RAM module with optional byte enables, configurable read latency, and flexible initialization. The component's architecture and behavior are thoroughly described, and its performance and resource usage can be optimized through careful selection of the generics. The component can be used in a wide range of digital systems, and its flexibility and configurability make it a valuable component in many applications.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_sp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );
    port (
        Clk             : in    std_logic;
        Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
        Be              : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        WrEna           : in    std_logic                                  := '1';
        WrData          : in    std_logic_vector(Width_g - 1 downto 0);
        RdData          : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_sp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_sp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            Clk             : in    std_logic;
            Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
            WrEna           : in    std_logic := '1';
            WrData          : in    std_logic_vector(Width_g - 1 downto 0);
            RdData          : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_sp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_sp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                Clk             => Clk,
                Addr            => Addr,
                WrEna           => WrEna,
                WrData          => WrData,
                RdData          => RdData
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal WrEna_Byte : std_logic;
        begin
            WrEna_Byte <= WrEna and Be(byte);

            i_ram : component olo_private_ram_sp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => byte*8
                )
                port map (
                    Clk             => Clk,
                    Addr            => Addr,
                    WrEna           => WrEna_Byte,
                    WrData          => WrData(byte*8+7 downto byte*8),
                    RdData          => RdData(byte*8+7 downto byte*8)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_sp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        Clk             : in    std_logic;
        Addr            : in    std_logic_vector(log2ceil(Depth_g)-1 downto 0);
        WrEna           : in    std_logic := '1';
        WrData          : in    std_logic_vector(Width_g - 1 downto 0);
        RdData          : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_sp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipe : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipe : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_sp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_sp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    p_ram : process (Clk) is
    begin
        if rising_edge(Clk) then
            if RamBehavior_g = ""RBW"" then
                RdPipe(1) <= Mem_v(to_integer(unsigned(Addr)));
            end if;
            if WrEna = '1' then
                Mem_v(to_integer(unsigned(Addr))) := WrData;
            end if;
            if RamBehavior_g = ""WBR"" then
                RdPipe(1) <= Mem_v(to_integer(unsigned(Addr)));
            end if;

            RdPipe(2 to RdLatency_g) <= RdPipe(1 to RdLatency_g-1);
        end if;
    end process;

    RdData <= RdPipe(RdLatency_g);

end architecture;"
"The `olo_base_ram_tdp` component is a dual-port RAM (Random Access Memory) module designed for use in digital systems. Its primary purpose is to provide a flexible and efficient memory storage solution that allows for simultaneous read and write operations from two separate ports, A and B. This component is particularly useful in systems requiring high-speed data processing and storage, such as digital signal processing, data acquisition systems, and complex digital designs. The component has several generic parameters that allow for customization to suit specific application requirements. These include `Depth_g`, which defines the number of memory locations; `Width_g`, which specifies the width of each memory location in bits; `RdLatency_g`, which determines the read latency in clock cycles; `RamStyle_g` and `RamBehavior_g`, which control the RAM implementation style and behavior, respectively; `UseByteEnable_g`, which enables or disables byte-level write enables; and initialization parameters `InitString_g` and `InitFormat_g` for setting initial memory content. The component has a comprehensive set of input and output ports to facilitate dual-port operation. Port A and port B each have their own clock inputs (`A_Clk` and `B_Clk`), address inputs (`A_Addr` and `B_Addr`), write enable inputs (`A_WrEna` and `B_WrEna`), write data inputs (`A_WrData` and `B_WrData`), and read data outputs (`A_RdData` and `B_RdData`). When `UseByteEnable_g` is true, byte-level write enables (`A_Be` and `B_Be`) are also available, allowing for selective writing of bytes within a word. Internally, the component may use a single-port RAM or a combination of smaller RAM blocks, depending on the configuration and the value of `UseByteEnable_g`. If byte enables are not used, the design instantiates a single `olo_private_ram_tdp_nobe` component, which handles the complete width of the memory in a straightforward manner. When byte enables are used, the design divides the memory into byte-wide segments, each handled by a separate instance of `olo_private_ram_tdp_nobe`, allowing for efficient use of byte enables. The `olo_private_ram_tdp_nobe` component implements the actual RAM functionality. It uses a variable `Mem_v` to model the memory content and processes `p_porta` and `p_portb` to handle the write and read operations from ports A and B, respectively. The RAM behavior, defined by `RamBehavior_g`, can be either ""RBW"" (read-before-write) or ""WBR"" (write-before-read), affecting how read and write operations interact. The component supports pipelined read operations, with the read latency defined by `RdLatency_g`. The output data is registered in pipelines `RdPipeA` and `RdPipeB`, allowing for flexible timing and synchronization with the rest of the system. Control logic within the component manages the interaction between the ports, memory, and pipelined read data. Write enables and byte enables (when used) dictate which memory locations can be written, while the read operations are controlled by the address inputs and the read latency. Data flow through the component is straightforward: write data is input through `A_WrData` and `B_WrData` and stored in the memory at the locations specified by `A_Addr` and `B_Addr`, respectively. Read data is retrieved from memory based on the current addresses and appears at `A_RdData` and `B_RdData` after the specified read latency. The component adheres to standard timing and synchronization practices. It uses clock domains for each port to manage data flow and relies on the system's clock infrastructure for synchronization. The design assumes that the clocks are properly constrained and related to ensure reliable operation. A notable feature of this component is its flexibility in configuration. It supports different RAM styles and behaviors, initialization from a string, and the use of byte enables for fine-grained control over write operations. This versatility makes it suitable for a wide range of applications. In terms of applications and use cases, the `olo_base_ram_tdp` component can be used in any digital system requiring a dual-port RAM with flexible configuration options. This includes but is not limited to, digital signal processing systems, embedded systems, and complex digital designs where high-speed data storage and retrieval are critical. Implementation considerations include optimizing for performance, minimizing resource usage, and making design trade-offs based on the specific requirements of the target system. The component's generic parameters allow for a high degree of customization, enabling designers to balance performance, area, and power consumption according to their needs. However, careful attention must be paid to the configuration of RAM style, behavior, and initialization to ensure that the component meets the system's specifications and performs reliably.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_base_ram_tdp is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        UseByteEnable_g : boolean  := false;
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE""
    );                                                      -- ""RBW"" = read-before-write, ""WBR"" = write-before-read
    port (
        A_Clk     : in    std_logic;
        A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        A_Be      : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        A_WrEna   : in    std_logic                                  := '0';
        A_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
        A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
        B_Clk     : in    std_logic;
        B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        B_Be      : in    std_logic_vector(Width_g / 8 - 1 downto 0) := (others => '1');
        B_WrEna   : in    std_logic                                  := '0';
        B_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
        B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_ram_tdp is

    constant BeCount_c : integer := Width_g / 8;

    component olo_private_ram_tdp_nobe is
        generic (
            Depth_g         : positive;
            Width_g         : positive;
            RdLatency_g     : positive := 1;
            RamStyle_g      : string   := ""auto"";
            RamBehavior_g   : string   := ""RBW"";
            InitString_g    : string   := """";
            InitFormat_g    : string   := ""NONE"";
            InitWidth_g     : positive;
            InitShift_g     : natural  := 0
        );
        port (
            A_Clk     : in    std_logic;
            A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            A_WrEna   : in    std_logic                                  := '0';
            A_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
            A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
            B_Clk     : in    std_logic;
            B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
            B_WrEna   : in    std_logic                                  := '0';
            B_WrData  : in    std_logic_vector(Width_g - 1 downto 0)     := (others => '0');
            B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
        );
    end component;

begin

    assert (Width_g mod 8 = 0) or (not UseByteEnable_g)
        report ""olo_base_ram_tdp: Width_g must be a multiple of 8, otherwise byte-enables must be disabled""
        severity error;

    g_nobe : if not UseByteEnable_g generate

        i_ram : component olo_private_ram_tdp_nobe
            generic map (
                Depth_g         => Depth_g,
                Width_g         => Width_g,
                RdLatency_g     => RdLatency_g,
                RamStyle_g      => RamStyle_g,
                RamBehavior_g   => RamBehavior_g,
                InitString_g    => InitString_g,
                InitFormat_g    => InitFormat_g,
                InitWidth_g     => Width_g
            )
            port map (
                A_Clk     => A_Clk,
                A_Addr    => A_Addr,
                A_WrEna   => A_WrEna,
                A_WrData  => A_WrData,
                A_RdData  => A_RdData,
                B_Clk     => B_Clk,
                B_Addr    => B_Addr,
                B_WrEna   => B_WrEna,
                B_WrData  => B_WrData,
                B_RdData  => B_RdData
            );

    end generate;

    g_be : if UseByteEnable_g generate

        g_byte : for byte in 0 to BeCount_c-1 generate
            signal A_WrEna_Byte : std_logic;
            signal B_WrEna_Byte : std_logic;
        begin
            A_WrEna_Byte <= A_WrEna and A_Be(byte);
            B_WrEna_Byte <= B_WrEna and B_Be(byte);

            i_ram : component olo_private_ram_tdp_nobe
                generic map (
                    Depth_g         => Depth_g,
                    Width_g         => 8,
                    RdLatency_g     => RdLatency_g,
                    RamStyle_g      => RamStyle_g,
                    RamBehavior_g   => RamBehavior_g,
                    InitString_g    => InitString_g,
                    InitFormat_g    => InitFormat_g,
                    InitWidth_g     => Width_g,
                    InitShift_g     => 8*byte
                )
                port map (
                    A_Clk     => A_Clk,
                    A_Addr    => A_Addr,
                    A_WrEna   => A_WrEna_Byte,
                    A_WrData  => A_WrData(8*(byte+1)-1 downto 8*byte),
                    A_RdData  => A_RdData(8*(byte+1)-1 downto 8*byte),
                    B_Clk     => B_Clk,
                    B_Addr    => B_Addr,
                    B_WrEna   => B_WrEna_Byte,
                    B_WrData  => B_WrData(8*(byte+1)-1 downto 8*byte),
                    B_RdData  => B_RdData(8*(byte+1)-1 downto 8*byte)
                );

        end generate;

    end generate;

end architecture;

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;
    use work.olo_base_pkg_string.all;

entity olo_private_ram_tdp_nobe is
    generic (
        Depth_g         : positive;
        Width_g         : positive;
        RdLatency_g     : positive := 1;
        RamStyle_g      : string   := ""auto"";
        RamBehavior_g   : string   := ""RBW"";
        InitString_g    : string   := """";
        InitFormat_g    : string   := ""NONE"";
        InitWidth_g     : positive;
        InitShift_g     : natural  := 0
    );
    port (
        A_Clk     : in    std_logic;
        A_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        A_WrEna   : in    std_logic                              := '0';
        A_WrData  : in    std_logic_vector(Width_g - 1 downto 0) := (others => '0');
        A_RdData  : out   std_logic_vector(Width_g - 1 downto 0);
        B_Clk     : in    std_logic;
        B_Addr    : in    std_logic_vector(log2ceil(Depth_g) - 1 downto 0);
        B_WrEna   : in    std_logic                              := '0';
        B_WrData  : in    std_logic_vector(Width_g - 1 downto 0) := (others => '0');
        B_RdData  : out   std_logic_vector(Width_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_private_ram_tdp_nobe is

    type Data_t is array (natural range<>) of std_logic_vector(Width_g - 1 downto 0);

    function getInitContent return Data_t is
        variable Data_v         : Data_t(Depth_g - 1 downto 0)               := (others => (others => '0'));
        constant InitElements_c : natural                                    := countOccurence(InitString_g, ',')+1;
        variable StartIdx_v     : natural                                    := InitString_g'left;
        variable EndIdx_v       : natural;
        variable FullInitVal_v  : std_logic_vector(InitWidth_g - 1 downto 0) := (others => '0');
    begin
        if InitFormat_g /= ""NONE"" then

            for i in 0 to InitElements_c - 1 loop
                EndIdx_v := StartIdx_v;

                loop
                    if InitString_g(EndIdx_v) = ',' then
                        EndIdx_v := EndIdx_v - 1;
                        exit;
                    end if;
                    if EndIdx_v = InitString_g'right then
                        exit;
                    end if;
                    EndIdx_v := EndIdx_v + 1;
                end loop;

                FullInitVal_v := hex2StdLogicVector(InitString_g(StartIdx_v to EndIdx_v), InitWidth_g, hasPrefix => true);
                Data_v(i)     := FullInitVal_v(InitShift_g + Width_g - 1 downto InitShift_g);
                StartIdx_v    := EndIdx_v + 2;

            end loop;

        end if;
        return Data_v;
    end function;

    shared variable Mem_v : Data_t(Depth_g - 1 downto 0) := getInitContent;

    signal RdPipeA, RdPipeB : Data_t(1 to RdLatency_g);

    attribute shreg_extract of RdPipeA : signal is ShregExtract_SuppressExtraction_c;
    attribute shreg_extract of RdPipeB : signal is ShregExtract_SuppressExtraction_c;

    attribute ram_style of Mem_v    : variable is RamStyle_g;
    attribute ramstyle of Mem_v     : variable is RamStyle_g;
    attribute syn_ramstyle of Mem_v : variable is RamStyle_g;

begin

    assert InitFormat_g = ""NONE"" or InitFormat_g = ""HEX""
        report ""olo_base_ram_tdp: InitFormat_g must be NONE or HEX. Got: "" & InitFormat_g
        severity error;
    assert RamBehavior_g = ""RBW"" or RamBehavior_g = ""WBR""
        report ""olo_base_ram_tdp: RamBehavior_g must Be RBW or WBR. Got: "" & RamBehavior_g
        severity error;

    g_wbr : if RamBehavior_g = ""WBR"" generate

        p_porta : process (A_Clk) is
        begin
            if rising_edge(A_Clk) then
                if A_WrEna = '1' then
                    Mem_v(to_integer(unsigned(A_Addr))) := A_WrData;
                end if;
                RdPipeA(1) <= Mem_v(to_integer(unsigned(A_Addr)));

                RdPipeA(2 to RdLatency_g) <= RdPipeA(1 to RdLatency_g-1);
            end if;
        end process;

        p_portb : process (B_Clk) is
        begin
            if rising_edge(B_Clk) then
                if B_WrEna = '1' then
                    Mem_v(to_integer(unsigned(B_Addr))) := B_WrData;
                end if;
                RdPipeB(1) <= Mem_v(to_integer(unsigned(B_Addr)));

                RdPipeB(2 to RdLatency_g) <= RdPipeB(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    g_rbw : if RamBehavior_g = ""RBW"" generate

        p_porta : process (A_Clk) is
        begin
            if rising_edge(A_Clk) then
                RdPipeA(1) <= Mem_v(to_integer(unsigned(A_Addr)));
                if A_WrEna = '1' then
                    Mem_v(to_integer(unsigned(A_Addr))) := A_WrData;
                end if;

                RdPipeA(2 to RdLatency_g) <= RdPipeA(1 to RdLatency_g-1);
            end if;
        end process;

        p_portb : process (B_Clk) is
        begin
            if rising_edge(B_Clk) then
                RdPipeB(1) <= Mem_v(to_integer(unsigned(B_Addr)));
                if B_WrEna = '1' then
                    Mem_v(to_integer(unsigned(B_Addr))) := B_WrData;
                end if;

                RdPipeB(2 to RdLatency_g) <= RdPipeB(1 to RdLatency_g-1);
            end if;
        end process;

    end generate;

    A_RdData <= RdPipeA(RdLatency_g);
    B_RdData <= RdPipeB(RdLatency_g);

end architecture;"
"The `olo_base_reset_gen` component is a reset generator module designed to produce a reset signal for digital systems. Its primary purpose is to create a reliable and synchronized reset signal that can be used to reset various parts of a system. This component is typically used in larger systems where a reset signal needs to be generated and distributed to multiple modules. The component has three main ports: `Clk`, `RstIn`, and `RstOut`. The `Clk` port is a clock input that drives the internal synchronization logic, while `RstIn` is an asynchronous reset input that can be used to reset the component. The `RstOut` port is the generated reset output signal. The `RstIn` port has a polarity generic `RstInPolarity_g` associated with it, which allows the user to specify the active level of the reset input. The component has several generics that control its behavior. `RstPulseCycles_g` determines the length of the reset pulse generated on the `RstOut` port. `AsyncResetOutput_g` controls whether the reset output is asynchronous or synchronous with respect to the clock. `SyncStages_g` specifies the number of synchronization stages used to synchronize the reset signal. Internally, the component consists of several registers and logic blocks. The `RstSyncChain` signal is a shift register that synchronizes the `RstIn` signal with the clock. The `RstSync` signal is the synchronized reset signal, which is then used to generate the `RstOut` signal. The `DsSync` signal is a synchronization chain used when the reset output is synchronous. The component's architectural description reveals a complex interplay of registers, counters, and logic gates. The `p_rstsync` process synchronizes the `RstIn` signal with the clock, while the `g_async` and `g_sync` generate statements implement the asynchronous and synchronous reset output paths, respectively. The `p_prolong` process generates a prolonged reset pulse when `RstPulseCycles_g` is greater than 3. The component's functional behavior can be described as follows: when the `RstIn` signal is asserted, the `RstSyncChain` register is reset, and the `RstSync` signal is asserted. This causes the `RstOut` signal to be asserted, either asynchronously or synchronously, depending on the value of `AsyncResetOutput_g`. The `RstOut` signal remains asserted for a duration determined by `RstPulseCycles_g`. The control logic of the component is primarily driven by the `RstIn` signal and the clock. The `RstSyncChain` register and the `p_rstsync` process control the synchronization of the reset signal, while the `p_prolong` process controls the duration of the reset pulse. Data flow through the component is straightforward: the `RstIn` signal is synchronized with the clock, and the resulting `RstSync` signal is used to generate the `RstOut` signal. No data transformations occur within the component. The component's timing and synchronization are critical to its operation. The `Clk` input is used to synchronize the reset signal, and the `RstIn` signal is synchronized with the clock using the `RstSyncChain` register. The component has specific setup and hold requirements to ensure proper synchronization. One special feature of the component is its ability to generate a prolonged reset pulse. When `RstPulseCycles_g` is greater than 3, the `p_prolong` process generates a reset pulse that lasts for a specified number of clock cycles. The `olo_base_reset_gen` component is typically used in digital systems where a reliable reset signal is required. It can be used in a wide range of applications, from simple digital circuits to complex systems-on-chip (SoCs). In terms of implementation considerations, the component's performance is primarily determined by the clock frequency and the values of the generics. The component's resource usage is moderate, as it requires a small number of registers and logic gates. Design trade-offs include balancing the reset pulse duration with the clock frequency and optimizing the component's resource usage. The VHDL code uses various attributes to control synthesis and optimization. The `shreg_extract` attribute suppresses extraction of the `DsSync` signal, while the `syn_srlstyle` attribute specifies the style of the synchronization registers. The `dont_merge`, `preserve`, `syn_preserve`, and `syn_keep` attributes ensure that the `DsSync` signal is not optimized away. Overall, the `olo_base_reset_gen` component is a versatile and reliable reset generator that can be used in a wide range of digital systems. Its internal structure, functional behavior, and control logic are carefully designed to ensure proper reset signal generation and distribution.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_attribute.all;

entity olo_base_reset_gen is
    generic (
        RstPulseCycles_g    : positive range 3 to positive'high := 3;
        RstInPolarity_g     : std_logic                         := '1';
        AsyncResetOutput_g  : boolean                           := false;
        SyncStages_g        : positive range 2 to 4             := 2
    );
    port (
        Clk         : in    std_logic;
        RstOut      : out   std_logic;
        RstIn       : in    std_logic := not RstInPolarity_g
    );
end entity;

architecture struct of olo_base_reset_gen is

    signal RstSyncChain : std_logic_vector(2 downto 0)              := ""111"";
    signal RstSync      : std_logic;
    signal DsSync       : std_logic_vector(SyncStages_g-1 downto 0) := (others => '1');

    constant PulseCntMax_c : natural                          := max(RstPulseCycles_g-4, 0);
    signal PulseCnt        : integer range 0 to PulseCntMax_c := 0;
    signal RstPulse        : std_logic                        := '1';

    attribute shreg_extract of DsSync : signal is ShregExtract_SuppressExtraction_c;
    attribute syn_srlstyle of DsSync  : signal is SynSrlstyle_FlipFlops_c;

    attribute dont_merge of DsSync   : signal is DontMerge_SuppressChanges_c;
    attribute preserve of DsSync     : signal is Preserve_SuppressChanges_c;
    attribute syn_preserve of DsSync : signal is SynPreserve_SuppressChanges_c;
    attribute syn_keep of DsSync     : signal is SynKeep_SuppressChanges_c;

    attribute async_reg of DsSync : signal is AsyncReg_TreatAsync_c;

begin

    p_rstsync : process (Clk, RstIn) is
    begin
        if RstIn = RstInPolarity_g then
            RstSyncChain <= (others => '1');
        elsif rising_edge(Clk) then
            RstSyncChain <= RstSyncChain(RstSyncChain'left - 1 downto 0) & '0';
        end if;
    end process;

    g_async : if AsyncResetOutput_g generate
        RstSync <= RstSyncChain(RstSyncChain'left);
    end generate;

    g_sync : if not AsyncResetOutput_g generate

        p_sync : process (Clk) is
        begin
            if rising_edge(Clk) then
                DsSync <= DsSync(DsSync'left - 1 downto 0) & RstSyncChain(RstSyncChain'left);
            end if;
        end process;

        RstSync <= DsSync(DsSync'left);
    end generate;

    g_prolong : if RstPulseCycles_g > 3 generate

        p_prolong : process (Clk) is
        begin
            if rising_edge(Clk) then
                if RstSync = '1' then
                    PulseCnt <= 0;
                    RstPulse <= '1';
                else
                    if PulseCnt = PulseCntMax_c then
                        RstPulse <= '0';
                    else
                        PulseCnt <= PulseCnt + 1;
                    end if;
                end if;
            end if;
        end process;

        g_async : if AsyncResetOutput_g generate
            RstOut <= RstPulse or RstSync;

        end generate;

        g_sync : if not AsyncResetOutput_g generate
            RstOut <= RstPulse;
        end generate;

    end generate;

    g_direct : if RstPulseCycles_g <= 3 generate
        RstOut <= RstSync;
    end generate;

end architecture;"
"The `olo_base_strobe_div` component is a digital circuit designed to divide an input strobe signal by a programmable ratio, generating an output strobe signal with a lower frequency. Its primary purpose is to enable the synchronization of data streams with different clock rates or to reduce the frequency of a strobe signal in digital systems. This component plays a crucial role in larger systems where data needs to be transmitted or processed at different rates, ensuring that the data and control signals are properly aligned. The component has several input and output ports that facilitate its operation. The `Clk` port is a clock input that drives the internal sequential logic, while the `Rst` port is an asynchronous reset signal used to initialize the component to a known state. The `In_Ratio` port is a vector that specifies the division ratio, with a bit width determined by the `MaxRatio_g` generic parameter. The `In_Valid` port is an input strobe signal that indicates the presence of valid data, and the `Out_Valid` port is an output strobe signal that indicates when the divided strobe is valid. The `Out_Ready` port is an input signal that indicates whether the downstream circuitry is ready to accept the output strobe. Internally, the component consists of a two-process architecture, with one process (`p_comb`) implementing the combinational logic and the other (`p_seq`) implementing the sequential logic. The `p_comb` process calculates the next state of the internal registers based on the current state and input signals. It uses a record type `TwoProcess_r` to store the internal state, which consists of a counter (`Count`) and an output valid flag (`OutValid`). The process updates the internal state based on the input strobe, division ratio, and output ready signals. The `p_seq` process implements the sequential logic, updating the internal registers on the rising edge of the clock. It also handles the asynchronous reset, resetting the internal state to its initial values when the reset signal is asserted. The component uses a registered output approach, where the output strobe is generated based on the internal state and output ready signal. The component's functional behavior can be described as follows: when the input strobe is asserted, the counter is incremented, and when the counter reaches the programmed division ratio, the output strobe is asserted, and the counter is reset. The output strobe remains asserted until the output ready signal is deasserted. The component also provides a latency option, allowing the output strobe to be delayed by one clock cycle. The control logic of the component is primarily implemented in the `p_comb` process, where the internal state is updated based on the input signals and the current state. The component uses a simple state machine with two states: one where the counter is incremented, and another where the output strobe is asserted. The state transitions are controlled by the input strobe, division ratio, and output ready signals. The data flow through the component is straightforward, with the input strobe and division ratio being used to generate the output strobe. The component does not perform any data transformations; instead, it generates a control signal (the output strobe) based on the input signals. The component has specific timing and synchronization requirements. The clock domain is defined by the `Clk` port, and the component assumes that the input signals are synchronous to the clock. The component has setup and hold requirements for the input signals, which must be met to ensure proper operation. One of the special features of this component is its programmable division ratio, which allows for flexible frequency division. The component also provides a latency option, which can be used to delay the output strobe by one clock cycle. The `olo_base_strobe_div` component is typically used in digital systems where data needs to be transmitted or processed at different rates. It can be used in a variety of applications, such as data transmission interfaces, clock domain crossing, or frequency synthesis. In terms of implementation considerations, the component's performance is primarily determined by the clock frequency and the division ratio. The component's resource usage is relatively low, as it only requires a small amount of combinational logic and a few registers. However, the design trade-offs include the choice of division ratio, latency, and clock frequency, which must be carefully balanced to meet the system's performance and functionality requirements. Overall, the `olo_base_strobe_div` component is a versatile and efficient digital circuit that provides a flexible frequency division solution for a wide range of applications. Its programmability, low resource usage, and flexibility make it an attractive solution for many digital system design problems.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_strobe_div is
    generic (
        MaxRatio_g  : positive;
        Latency_g   : natural range 0 to 1 := 1
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Ratio    : in    std_logic_vector(log2ceil(MaxRatio_g)-1 downto 0) := toUslv(MaxRatio_g-1, log2ceil(MaxRatio_g));
        In_Valid    : in    std_logic;
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic                                         := '1'
    );
end entity;

architecture rtl of olo_base_strobe_div is

    type TwoProcess_r is record
        Count    : natural range 0 to MaxRatio_g-1;
        OutValid : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    p_comb : process (r, In_Valid, In_Ratio, Out_Ready) is
        variable OutValid_v : std_logic;
        variable v          : TwoProcess_r;
    begin
        v := r;

        if In_Valid = '1' then
            if r.Count >= unsigned(In_Ratio) or MaxRatio_g = 1 then
                v.Count    := 0;
                v.OutValid := '1';
            else
                v.Count := r.Count + 1;
            end if;
        end if;

        if Latency_g = 0 then
            OutValid_v := v.OutValid;
        else
            OutValid_v := r.OutValid;
        end if;

        if OutValid_v = '1' and Out_Ready = '1' then
            v.OutValid := '0';
        end if;

        Out_Valid <= OutValid_v;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.Count    <= 0;
                r.OutValid <= '0';
            end if;
        end if;
    end process;

end architecture;"
"The `olo_base_strobe_gen` component is a digital strobe generator designed to produce a periodic strobe signal, commonly used in digital systems for synchronization and timing purposes. Its primary role is to generate a precise timing signal based on a given clock frequency and a target strobe frequency, which can be utilized in larger systems for coordinating data transfers, enabling/disabling functional blocks, or triggering specific actions. The component accepts several inputs that dictate its operation: `Clk` serves as the clock input, providing the timing reference for the strobe generation; `Rst` is the asynchronous reset signal, used to initialize the component to a known state; `In_Sync` is an optional synchronization input that can reset the strobe generator to a synchronized state; and `Out_Ready` is an optional input that can inhibit the strobe output when deasserted. The component produces two outputs: `Out_Valid`, which represents the strobe signal generated based on the input frequencies and synchronization conditions. Internally, the component utilizes a counter-based architecture to generate the strobe signal. The counter's period is determined by the ratio of the clock frequency (`FreqClkHz_g`) to the desired strobe frequency (`FreqStrobeHz_g`), with support for both integer and fractional frequency ratios controlled by the `FractionalMode_g` generic. The `PeriodCounts_c` constant represents the total count value that corresponds to one period of the strobe signal, with `Increment_c` defining the counter increment value, which is either 1 for integer mode or 100 for fractional mode to allow for fractional frequency representation. The core logic of the strobe generator is implemented within the `p_strobe` process. On every rising edge of the clock, the process checks for reset conditions, synchronization inputs, and the current state of the counter to determine whether to assert the `Out_Valid` signal. When a synchronization event occurs (i.e., `In_Sync` goes high and was previously low), the counter is reset to zero, and `Out_Valid` is immediately asserted. The strobe signal is periodically asserted based on the counter reaching a predefined threshold (`WrapBorder_c`), at which point the counter is reset or incremented based on the operational mode. The `Out_Valid` signal can be deasserted when `Out_Ready` is low, effectively gating the strobe output. The control logic within the component manages the state transitions of the strobe generator. The reset condition (`Rst = '1'`) clears the counter and deasserts `Out_Valid`, ensuring a defined state at startup or upon reset. The synchronization input (`In_Sync`) allows for dynamic resynchronization of the strobe generator, enabling flexible system integration. The use of `Out_Ready` as an enable for `Out_Valid` provides a mechanism for external control over the strobe output. Data flow through the component primarily involves the manipulation of the internal counter and the `Out_Valid` signal based on the inputs and the defined operational parameters. The transformation of the input frequencies into a precise strobe signal involves calculations based on the generic parameters and the dynamic inputs. In terms of timing and synchronization, the component operates within a single clock domain defined by `Clk`. The setup and hold requirements for the inputs are implicitly defined by the clock's timing characteristics, as the inputs are sampled on the rising edge of `Clk`. The design does not explicitly specify timing constraints but relies on the clock frequency and the chosen synthesis and implementation tools to meet the necessary timing requirements. A special feature of this component is its support for fractional frequency modes, allowing for more precise control over the strobe frequency when the ratio of the clock frequency to the strobe frequency is not an integer. This flexibility makes the component suitable for a wide range of applications, from simple timing and synchronization tasks to more complex data transfer control. The `olo_base_strobe_gen` component can be used in various applications requiring precise timing and synchronization signals, such as digital data acquisition systems, communication interfaces, and complex digital systems where timing coordination is critical. Implementation considerations include the selection of the clock frequency, strobe frequency, and operational mode, which directly impact the component's performance and resource usage. The design's simplicity and parameterization make it efficient in terms of resource utilization, particularly when implemented on FPGA platforms or as part of larger ASIC designs. However, the actual performance and resource usage can vary based on the target technology, the specific synthesis and implementation tools used, and the chosen design constraints. Careful consideration of the target technology's capabilities and limitations is necessary to optimize the component's integration into a larger system.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_strobe_gen is
    generic (
        FreqClkHz_g      : real;
        FreqStrobeHz_g   : real;
        FractionalMode_g : boolean := false
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Sync     : in    std_logic := '0';
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic := '1'
    );
end entity;

architecture rtl of olo_base_strobe_gen is

    constant PeriodCountsFractional_c : integer := integer(round(FreqClkHz_g*100.0 / FreqStrobeHz_g));
    constant PeriodCountsInteger_c    : integer := integer(round(FreqClkHz_g / FreqStrobeHz_g));
    constant PeriodCounts_c           : integer := choose(FractionalMode_g, PeriodCountsFractional_c, PeriodCountsInteger_c);

    constant Increment_c  : integer := choose(FractionalMode_g, 100, 1);
    constant WrapBorder_c : integer := PeriodCounts_c - Increment_c;

    signal Count    : integer range 0 to PeriodCounts_c-1;
    signal SyncLast : std_logic;

begin

    p_strobe : process (Clk) is
    begin
        if rising_edge(Clk) then
            if (In_Sync = '1') and (SyncLast = '0') then
                Count     <= 0;
                Out_Valid <= '1';
            elsif Count >= WrapBorder_c then
                Out_Valid <= '1';
                if FractionalMode_g then
                    Count <= Count - WrapBorder_c;
                else
                    Count <= 0;
                end if;
            else
                if Out_Ready = '1' then
                    Out_Valid <= '0';
                end if;
                Count <= Count + Increment_c;
            end if;
            SyncLast <= In_Sync;

            if Rst = '1' then
                Count     <= 0;
                Out_Valid <= '0';
                SyncLast  <= '0';
            end if;
        end if;
    end process;

end architecture;"
"The `olo_base_tdm_mux` component is a time-division multiplexing (TDM) multiplexer designed to select and output data from multiple input channels based on a channel selection signal. Its primary purpose is to efficiently manage data transmission from multiple sources over a shared communication medium. This component plays a crucial role in larger systems, such as digital communication systems, data acquisition systems, and network processing units, where multiple data streams need to be multiplexed and transmitted over a single channel. The component has several input ports, each serving a distinct purpose. The `Clk` port is a clock signal that drives the internal operation of the component, while the `Rst` port is an asynchronous reset signal used to initialize the component to a known state. The `In_ChSel` port is a channel selection signal that determines which input channel's data is to be output; its bit width is `log2ceil(Channels_g)`, where `Channels_g` is a generic parameter specifying the number of input channels. The `In_Valid` port indicates whether the input data is valid, and the `In_Data` port carries the actual data being transmitted, with a bit width of `Width_g`, another generic parameter. The `In_Last` port is a flag indicating whether the input data is the last in a sequence or packet. On the output side, the component has three ports: `Out_Valid`, `Out_Data`, and `Out_Last`. The `Out_Valid` port indicates whether the output data is valid, while the `Out_Data` port carries the multiplexed data, with the same bit width as `In_Data`. The `Out_Last` port indicates whether the output data is the last in a sequence or packet. Internally, the component consists of several registers and counters that work together to manage the TDM multiplexing process. The `Count_0` signal is an integer counter that keeps track of the current channel being processed, ranging from 0 to `Channels_g-1`. The `SelLatched_1` signal latches the channel selection value when the counter is at 0. The `Data_1`, `Vld_1`, and `Last_1` signals are registers that store the input data, validity, and last flags, respectively. The `Count_1` signal is another counter that mirrors the value of `Count_0`. The `Data_2`, `Vld_2`, and `Last_2` signals are output registers that store the final multiplexed data, validity, and last flags. The component's operation can be described as follows: on every clock cycle, the input data and channel selection are latched, and the counters are updated. When the counter reaches the value specified by the channel selection signal, the corresponding data is selected and stored in the output registers. The output validity and last flags are also updated accordingly. The component's control logic is primarily governed by the `p_decode` process, which implements a state machine-like behavior to manage the internal counters, data registers, and output signals. The control logic relies on several enable conditions and reset behaviors. The `Rst` signal asynchronously resets the counters and output registers to their initial values. The `In_Valid` signal enables the input data to be processed and stored in the internal registers. The `Count_0` and `Count_1` counters are incremented on every clock cycle, and their values determine which channel's data is being processed. Data flow through the component involves several transformations. The input data is first stored in the `Data_1` register, and then selected based on the channel selection signal. The selected data is then stored in the `Data_2` register and output as `Out_Data`. The validity and last flags are also propagated through the component and output as `Out_Valid` and `Out_Last`, respectively. The component operates in a single clock domain, with the clock signal driving all internal operations. The setup and hold requirements for the input signals are not explicitly specified, but it is assumed that the input data and control signals are properly synchronized with the clock signal. The component's timing constraints are primarily determined by the clock frequency and the input data rate. One special feature of this component is its ability to handle a variable number of input channels, specified by the `Channels_g` generic parameter. This allows the component to be easily adapted to different system configurations. Additionally, the component supports a configurable data width, specified by the `Width_g` generic parameter. The `olo_base_tdm_mux` component is typically used in digital communication systems, data acquisition systems, and network processing units, where multiple data streams need to be multiplexed and transmitted over a shared medium. Its applications include telecommunication systems, industrial control systems, and embedded systems. In terms of implementation considerations, the component's performance is primarily determined by the clock frequency and the input data rate. The resource usage is relatively low, as the component only requires a small number of registers and counters. However, the design trade-offs involve balancing the component's flexibility, as offered by the generic parameters, with the area and power consumption. Overall, the `olo_base_tdm_mux` component provides an efficient and flexible solution for TDM multiplexing in a wide range of digital systems.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;

entity olo_base_tdm_mux is
    generic (
        Channels_g  : natural;
        Width_g     : natural
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_ChSel    : in    std_logic_vector(log2ceil(Channels_g)-1 downto 0);
        In_Valid    : in    std_logic := '1';
        In_Data     : in    std_logic_vector(Width_g-1 downto 0);
        In_Last     : in    std_logic := '0';
        Out_Valid   : out   std_logic;
        Out_Data    : out   std_logic_vector(Width_g-1 downto 0);
        Out_Last    : out   std_logic
    );
end entity;

architecture rtl of olo_base_tdm_mux is

    signal Count_0      : integer range 0 to Channels_g-1 := 0;
    signal SelLatched_1 : std_logic_vector(In_ChSel'range);
    signal Data_1       : std_logic_vector(In_Data'range);
    signal Count_1      : integer range 0 to Channels_g-1;
    signal Vld_1        : std_logic;
    signal Last_1       : std_logic;
    signal Data_2       : std_logic_vector(In_Data'range);
    signal Vld_2        : std_logic;
    signal Last_2       : std_logic;

begin

    p_decode : process (Clk) is
    begin
        if rising_edge(Clk) then

            if In_Valid = '1' then
                if Count_0 = 0 then
                    SelLatched_1 <= In_ChSel;
                end if;
                if (Count_0 = Channels_g-1) or (In_Last = '1') then
                    Count_0 <= 0;
                else
                    Count_0 <= Count_0 + 1;
                end if;
            end if;
            Data_1  <= In_Data;
            Vld_1   <= In_Valid;
            Count_1 <= Count_0;
            Last_1  <= In_Last;

            if Count_1 = unsigned(SelLatched_1) then
                Data_2 <= Data_1;
            end if;
            Vld_2 <= '0';
            if Vld_1 = '1' and Count_1 = Channels_g-1 then
                Vld_2 <= '1';
            end if;
            Last_2 <= Last_1;

            if Rst = '1' then
                Count_0 <= 0;
                Vld_2   <= '0';
                Vld_1   <= '0';
            end if;
        end if;
    end process;

    Out_Valid <= Vld_2;
    Out_Data  <= Data_2;
    Out_Last  <= Last_2;

end architecture;"
"The `olo_base_wconv_n2m` component is a digital design entity that performs a width conversion on input data, specifically designed to handle cases where the input and output widths are not equal. Its primary purpose is to facilitate data transfer between systems or modules with different data widths, ensuring seamless communication and minimizing data loss. The component has several input ports, including `Clk`, `Rst`, `In_Valid`, `In_Data`, `In_Be`, and `In_Last`, which provide the necessary control and data signals for the conversion process. The `Clk` and `Rst` ports are used for clocking and resetting the component, respectively. The `In_Valid` port indicates the validity of the input data, while `In_Data` carries the actual data to be converted. The `In_Be` port, which is optional, provides byte enables for the input data, allowing for more granular control over the data transfer. The `In_Last` port signals the last beat of the input data. On the output side, the component has ports `Out_Valid`, `Out_Ready`, `Out_Data`, `Out_Be`, and `Out_Last`, which provide the converted data and control signals. The `Out_Valid` port indicates the validity of the output data, while `Out_Data` carries the converted data. The `Out_Be` port, also optional, provides byte enables for the output data. The `Out_Last` port signals the last beat of the output data, and `Out_Ready` is used to indicate the readiness of the output. Internally, the component consists of a state machine that manages the conversion process. The state machine is implemented using two processes: `p_comb` and `p_seq`. The `p_comb` process is a combinational process that calculates the next state and output values based on the current state and input values. The `p_seq` process is a sequential process that updates the state registers on the rising edge of the clock. The component uses a shift register (`ShiftReg`) to store the converted data and a counter (`ChunkCnt`) to keep track of the number of chunks processed. The `LastChunk` register stores information about the last chunk of each beat, and the `LastPending` flag indicates whether the last beat is pending. The component's operation can be described as follows: when the input data is valid and the output is ready, the component checks if the current chunk count is less than the number of output chunks. If so, it enables the input ready signal and captures the input data into the shift register. The component also updates the last chunk information and chunk count accordingly. When the output is valid and ready, the component shifts the converted data out of the shift register and updates the output byte enables. The component has several configuration options, including the input and output widths (`InWidth_g` and `OutWidth_g`) and the use of byte enables (`UseBe_g`). The `UseBe_g` option allows the component to handle byte enables for input and output data, which is useful in systems where data is transferred in byte-aligned chunks. The component also includes several assertions to ensure correct operation. For example, when byte enables are used, the component checks that the input and output widths are byte-aligned and that incomplete byte enables are only supported for the last beat. In terms of data flow, the component can be viewed as a pipeline that processes the input data in chunks. The chunk size is determined by the greatest common factor of the input and output widths or by the byte size (8 bits), depending on the `UseBe_g` option. The component handles data width conversion by shifting the data into and out of the shift register. The component's timing and synchronization are critical to its correct operation. The component uses a single clock domain and requires the input data to be synchronized with the clock. The component also has setup and hold requirements for the input data, which must be met to ensure correct capture. The `olo_base_wconv_n2m` component is a versatile and efficient solution for width conversion in digital systems. Its ability to handle different input and output widths, as well as byte enables, makes it suitable for a wide range of applications, including data transfer between systems with different data widths, data alignment, and data formatting. In terms of implementation considerations, the component's performance and resource usage depend on the specific technology and synthesis settings used. However, the component's architecture is designed to minimize resource usage while maximizing performance. The component's area and power consumption can be optimized by adjusting the chunk size and the number of registers used. The component can be used in various applications, including data interfaces, network protocols, and digital signal processing. Its ability to handle byte enables and different data widths makes it particularly useful in systems where data is transferred in byte-aligned chunks or where data alignment is critical. Overall, the `olo_base_wconv_n2m` component is a well-designed and efficient solution for width conversion in digital systems. Its versatility, performance, and configurability make it a valuable component in a wide range of applications. The design trade-offs considered during the development of this component include area vs. performance, flexibility vs. complexity, and generality vs. specificity. The component's architecture and functionality reflect a careful balance of these trade-offs, resulting in a highly versatile and efficient solution for width conversion. The component's architecture also reflects considerations for testability, maintainability, and scalability. The use of a modular and hierarchical design approach facilitates the testing and maintenance of the component. The component's scalability is ensured by its configurability, which allows it to be easily adapted to different applications and use cases. In conclusion, the `olo_base_wconv_n2m` component is a comprehensive and efficient solution for width conversion in digital systems. Its detailed analysis reveals a well-designed and highly versatile component that can be used in a wide","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;
    use ieee.std_logic_misc.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_n2m is
    generic (
        InWidth_g  : positive := 16;
        OutWidth_g : positive := 24;
        UseBe_g    : boolean  := false
    );
    port (
        Clk          : in    std_logic;
        Rst          : in    std_logic;
        In_Valid     : in    std_logic                                    := '1';
        In_Ready     : out   std_logic;
        In_Data      : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Be        : in    std_logic_vector(InWidth_g / 8 - 1 downto 0) := (others => '1');
        In_Last      : in    std_logic                                    := '0';
        Out_Valid    : out   std_logic;
        Out_Ready    : in    std_logic                                    := '1';
        Out_Data     : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Be       : out   std_logic_vector(OutWidth_g / 8 - 1 downto 0);
        Out_Last     : out   std_logic
    );
end entity;

architecture rtl of olo_base_wconv_n2m is

    constant MaxChunkSize_c : positive := greatestCommonFactor(InWidth_g, OutWidth_g);
    constant ChunkSize_c    : positive := choose(UseBe_g, 8, MaxChunkSize_c);
    constant SrWidth_c      : positive := choose(OutWidth_g > InWidth_g, 2*OutWidth_g, OutWidth_g+InWidth_g);
    constant OutChunks_c    : positive := OutWidth_g / ChunkSize_c;
    constant InChunks_c     : positive := InWidth_g / ChunkSize_c;

    type TwoProcess_r is record
        ChunkCnt    : integer range 0 to SrWidth_c / ChunkSize_c - 1;
        ShiftReg    : std_logic_vector(SrWidth_c - 1 downto 0);
        LastChunk   : std_logic_vector(SrWidth_c / ChunkSize_c - 1 downto 0);
        LastPending : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert (UseBe_g = false) or ((InWidth_g mod 8 = 0) and (OutWidth_g mod 8 = 0))
        report ""olo_base_wconv_n2m: Byte Enables are only supported for byte-aligned InWidht_g and OutWidth_g""
        severity failure;

    g_convert : if OutWidth_g /= InWidth_g generate

        p_comb : process (r, In_Valid, In_Data, Out_Ready, In_Last, In_Be, Rst) is
            variable v            : TwoProcess_r;
            variable Out_Valid_v  : std_logic;
            variable Offset_v     : natural range 0 to SrWidth_c - 1;
            variable IsLastBeat_v : std_logic;
        begin
            v := r;

            Out_Valid_v  := '0';
            IsLastBeat_v := or_reduce(r.LastChunk(OutChunks_c - 1 downto 0));
            if (r.ChunkCnt >= OutChunks_c) or (IsLastBeat_v = '1') then
                Out_Valid_v := '1';
            end if;
            if Out_Valid_v = '1' and Out_Ready = '1' then
                if IsLastBeat_v = '1' then
                    v.ChunkCnt    := 0;
                    v.ShiftReg    := (others => '0');
                    v.LastChunk   := (others => '0');
                    v.LastPending := '0';
                else
                    v.ChunkCnt  := r.ChunkCnt - OutChunks_c;
                    v.ShiftReg  := zerosVector(OutWidth_g) & r.ShiftReg(r.ShiftReg'high downto OutWidth_g);
                    v.LastChunk := zerosVector(OutChunks_c) & r.LastChunk(r.LastChunk'high downto OutChunks_c);
                end if;
            end if;
            Out_Valid <= Out_Valid_v;
            Out_Data  <= r.ShiftReg(OutWidth_g - 1 downto 0);
            Out_Last  <= IsLastBeat_v;
            if UseBe_g = true then
                Out_Be <= (others => '0');

                for byte in 0 to OutChunks_c-1 loop
                    Out_Be(byte) <= '1';
                    if r.LastChunk(byte) = '1' then
                        exit;
                    end if;
                end loop;

            else
                Out_Be <= (others => '1');
            end if;

            In_Ready <= '0';
            if (v.ChunkCnt < OutChunks_c) and (v.LastPending = '0') then

                In_Ready <= not Rst;
                if In_Valid = '1' then
                    Offset_v                                             := v.ChunkCnt*ChunkSize_c;
                    v.ShiftReg(Offset_v + InWidth_g - 1 downto Offset_v) := In_Data;

                    if UseBe_g = true then
                        assert (In_Last = '1') or (In_Be = onesVector(In_Be'length))
                            report ""olo_base_wconv_n2m: Incomplete byte enables are only supported for last beat""
                            severity failure;
                        v.LastChunk(v.ChunkCnt + InChunks_c-1) := In_Last;

                        for byte in 0 to InChunks_c-2 loop
                            if In_Be(byte) = '1' and In_Be(byte+1) = '0' then
                                v.LastChunk(v.ChunkCnt + byte)         := In_Last; -- set last chunk
                                v.LastChunk(v.ChunkCnt + InChunks_c-1) := '0'; -- override default
                                exit;
                            end if;
                        end loop;

                    else
                        v.LastChunk(v.ChunkCnt + InChunks_c-1) := In_Last;
                    end if;
                    v.ChunkCnt    := v.ChunkCnt + InChunks_c;
                    v.LastPending := In_Last;
                end if;
            end if;

            r_next <= v;
        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.ShiftReg    <= (others => '0');
                    r.ChunkCnt    <= 0;
                    r.LastChunk   <= (others => '0');
                    r.LastPending <= '0';
                end if;
            end if;
        end process;

    end generate;

    g_equalwidth : if OutWidth_g = InWidth_g generate
        Out_Valid <= In_Valid;
        Out_Data  <= In_Data;
        Out_Last  <= In_Last;
        In_Ready  <= Out_Ready;

    end generate;

end architecture;"
"The VHDL component `olo_base_wconv_n2xn` is a digital circuit designed for width conversion of input data streams, specifically to convert data from a narrower input width to a wider output width. Its primary purpose is to facilitate data transfer between systems or modules with different data widths, ensuring seamless communication and data integrity. The component has several input and output ports that play crucial roles in its operation. The input ports include `Clk` for the clock signal, `Rst` for the reset signal, `In_Valid` to indicate the validity of the input data, `In_Data` for the actual input data, and `In_Last` to mark the last data in a packet or frame. The output ports comprise `In_Ready` to indicate readiness to accept input data, `Out_Valid` and `Out_Ready` for handshake signals, `Out_Data` for the converted output data, `Out_Last` to signal the last data in a packet or frame, and `Out_WordEna` to enable word outputs. Internally, the component employs a state machine-like structure, managed through two processes: `p_comb` for combinational logic and `p_seq` for sequential logic. The `p_comb` process computes the next state based on the current state and inputs, while the `p_seq` process updates the state registers on the clock edge. A key internal signal is `r`, a record type `TwoProcess_r`, which holds the current state, including data validity flags, data, last data indication, output validity, output data, output last indication, word enable, and a counter. The component's architectural description reveals a sophisticated mechanism for handling data width conversion. It calculates the ratio of output width to input width and asserts an error if this ratio is not an integer or if the output width is not greater than or equal to the input width. For cases where the output width exceeds the input width, it uses a counter to accumulate input data until it fills the output data width, then asserts output validity. The `Out_WordEna` signal is generated based on the data validity flags to enable output words. The functional behavior of `olo_base_wconv_n2xn` can be described step-by-step. Upon receiving valid input data and not being in a stalled state (i.e., not waiting for output readiness), it accumulates input data. Once enough input data is collected to fill the output width, or when the last input data is received, it prepares the output data and asserts output validity. The output data is then transferred when the output is ready, and the process resets to accumulate new input data. Control logic within the component manages the enable conditions for data flow, reset behavior, and state transitions. The `In_Ready` signal is controlled by an `IsStuck_v` variable, which checks if the component is stalled waiting for output readiness. Reset behavior reinitializes key state variables to prepare for new data. Data flow through the component involves minimal transformation; it merely rearranges and possibly zero-stretches the input data to fit the wider output width. The timing and synchronization are critical, with the component operating within a single clock domain. Setup and hold requirements are implicitly managed through the handshake signals (`In_Valid`, `Out_Ready`). A special feature of this component is its ability to handle different data widths and its parameterization through generics (`InWidth_g` and `OutWidth_g`). It also supports backpressure through the `Out_Ready` input, allowing for flow control. This component finds applications in data transmission and storage systems where data width compatibility is a concern, such as in network interfaces, data acquisition systems, and between different parts of complex digital systems. Implementation considerations include performance optimization through efficient use of resources, such as registers and logic, and design trade-offs between latency and throughput. The component's resource usage depends on the input and output widths, with wider conversions requiring more resources. Designers must balance these factors based on the specific requirements of their systems.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_n2xn is
    generic (
        InWidth_g  : positive;
        OutWidth_g : positive
    );
    port (
        Clk          : in    std_logic;
        Rst          : in    std_logic;
        In_Valid     : in    std_logic := '1';
        In_Ready     : out   std_logic;
        In_Data      : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Last      : in    std_logic := '0';
        Out_Valid    : out   std_logic;
        Out_Ready    : in    std_logic := '1';
        Out_Data     : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last     : out   std_logic;
        Out_WordEna  : out   std_logic_vector(OutWidth_g / InWidth_g - 1 downto 0)
    );
end entity;

architecture rtl of olo_base_wconv_n2xn is

    constant RatioReal_c : real    := real(OutWidth_g) / real(InWidth_g);
    constant RatioInt_c  : integer := integer(RatioReal_c);

    type TwoProcess_r is record
        DataVld     : std_logic_vector(RatioInt_c - 1 downto 0);
        Data        : std_logic_vector(OutWidth_g - 1 downto 0);
        DataLast    : std_logic;
        Out_Valid   : std_logic;
        Out_Data    : std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last    : std_logic;
        Out_WordEna : std_logic_vector(RatioInt_c - 1 downto 0);
        Cnt         : integer range 0 to RatioInt_c;
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert floor(RatioReal_c) = ceil(RatioReal_c)
        report ""olo_base_wconv_n2xn: Ratio OutWidth_g/InWidth_g must be an integer number""
        severity error;
    assert OutWidth_g >= InWidth_g
        report ""olo_base_wconv_n2xn: OutWidth_g must be bigger or equal than InWidth_g""
        severity error;

    g_convert : if OutWidth_g > InWidth_g generate

        p_comb : process (r, In_Valid, In_Data, Out_Ready, In_Last) is
            variable v           : TwoProcess_r;
            variable IsStuck_v   : std_logic;
            variable ShiftDone_v : boolean;
        begin
            v := r;

            ShiftDone_v := (r.DataVld(r.DataVld'high) = '1') or (r.DataLast = '1');
            if ShiftDone_v and (r.Out_Valid = '1') and (Out_Ready = '0') then
                IsStuck_v := '1';
            else
                IsStuck_v := '0';
            end if;

            if (r.Out_Valid = '1') and (Out_Ready = '1') then
                v.Out_Valid := '0';
            end if;

            if ShiftDone_v and ((r.Out_Valid = '0') or (Out_Ready = '1')) then
                v.Out_Valid   := '1';
                v.Out_Data    := r.Data;
                v.Out_Last    := r.DataLast;
                v.Out_WordEna := r.DataVld;
                v.DataVld     := (others => '0');
                v.DataLast    := '0';
            end if;
            if In_Valid = '1' and IsStuck_v = '0' then
                v.Data((r.Cnt + 1) * InWidth_g - 1 downto r.Cnt * InWidth_g) := In_Data;
                v.DataVld(r.Cnt)                                             := '1';
                if In_Last = '1' then
                    v.DataLast := '1';
                end if;
                if (r.Cnt = RatioInt_c - 1) or (In_Last = '1') then
                    v.Cnt := 0;
                else
                    v.Cnt := r.Cnt + 1;
                end if;
            end if;

            In_Ready    <= not IsStuck_v;
            Out_Valid   <= r.Out_Valid;
            Out_Data    <= r.Out_Data;
            Out_Last    <= r.Out_Last;
            Out_WordEna <= r.Out_WordEna;

            r_next <= v;
        end process;

        p_seq : process (Clk) is
        begin
            if rising_edge(Clk) then
                r <= r_next;
                if Rst = '1' then
                    r.DataVld   <= (others => '0');
                    r.Out_Valid <= '0';
                    r.Cnt       <= 0;
                    r.DataLast  <= '0';
                end if;
            end if;
        end process;

    end generate;

    g_equalwidth : if OutWidth_g = InWidth_g generate
        Out_Valid   <= In_Valid;
        Out_Data    <= In_Data;
        Out_Last    <= In_Last;
        Out_WordEna <= (others => '1');
        In_Ready    <= Out_Ready;

    end generate;

end architecture;"
"The `olo_base_wconv_xn2n` component is a digital signal processing (DSP) module designed for word-width conversion, specifically to convert input data from a wider bus to a narrower bus. Its primary purpose is to facilitate data transmission between systems with different data widths, ensuring efficient and accurate data transfer. This component plays a crucial role in larger systems, such as data acquisition, processing, and transmission systems, where data width compatibility is essential. The component has several input and output ports, each with specific purposes and requirements. The input ports include `Clk`, a clock signal that drives the component's sequential logic; `Rst`, an asynchronous reset signal used to initialize the component; `In_Valid`, a control signal indicating the validity of the input data; `In_Data`, the input data bus with a width of `InWidth_g` bits; `In_Last`, a flag indicating the last word of a data packet; and `In_WordEna`, a word enable signal that selects which input words are processed. The output ports comprise `Out_Valid`, a signal indicating the validity of the output data; `Out_Ready`, a readiness signal that can be used to throttle output data; `Out_Data`, the output data bus with a width of `OutWidth_g` bits; and `Out_Last`, a flag indicating the last word of a data packet. Internally, the component consists of two main processes: `p_comb` and `p_seq`. The `p_comb` process is a combinational logic block that performs the primary data processing and control logic. It uses a record type `TwoProcess_r` to store the component's internal state, which includes the input data, data validity flags, and data last flags. The process continuously monitors the input signals and updates the internal state based on the input conditions. The `p_seq` process is a sequential logic block that updates the component's internal state on every clock cycle. It uses the `r` and `r_next` signals to store the current and next states, respectively. On every rising edge of the clock, the process updates the internal state with the next state value. Additionally, when the reset signal is asserted, the process resets the data validity flags to zero. The component's functional behavior can be described as follows: when the input data is valid and the component is ready, the input data is stored in the internal state, and the data validity flags are set according to the word enable signal. When the output is ready and there is valid data available, the component shifts the internal data by the output width, updates the data validity flags, and sets the output data and flags accordingly. The control logic of the component is primarily handled by the `p_comb` process, which generates the internal state updates based on the input conditions. The process uses a variable `IsReady_v` to determine whether the component is ready to accept new input data. The readiness condition is based on the data validity flags and the output readiness signal. The data flow through the component can be described as follows: the input data is stored in the internal state when the input data is valid and the component is ready. The data is then shifted and processed based on the output readiness signal and the data validity flags. The output data is generated by taking a slice of the internal data, and the output flags are generated based on the internal data last flags. The component has specific timing and synchronization requirements. The input data and control signals are assumed to be synchronous to the clock signal. The component has setup and hold requirements for the input signals, which must be met to ensure proper operation. The component also has a clock domain associated with the clock signal. One of the special features of this component is its ability to handle integer word-width conversion ratios. The component uses a constant `RatioReal_c` to store the ratio of the input width to the output width, which must be an integer. The component also uses assertions to check for invalid configurations, such as non-integer ratios or output widths larger than or equal to the input width. The `olo_base_wconv_xn2n` component can be used in various applications, such as data acquisition systems, digital signal processing systems, and data transmission systems, where data width conversion is necessary. The component's flexibility and configurability make it suitable for a wide range of use cases. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The component's resource usage is primarily determined by the input and output widths, as well as the complexity of the internal logic. Designers can optimize the component's performance by minimizing the number of logic levels and using efficient synthesis and place-and-route strategies. Additionally, designers should carefully evaluate the component's timing and synchronization requirements to ensure proper operation in the target system.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.math_real.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_base_wconv_xn2n is
    generic (
        InWidth_g  : positive;
        OutWidth_g : positive
    );
    port (
        Clk         : in    std_logic;
        Rst         : in    std_logic;
        In_Valid    : in    std_logic;
        In_Ready    : out   std_logic;
        In_Data     : in    std_logic_vector(InWidth_g - 1 downto 0);
        In_Last     : in    std_logic                                             := '0';
        In_WordEna  : in    std_logic_vector(InWidth_g / OutWidth_g - 1 downto 0) := (others => '1');
        Out_Valid   : out   std_logic;
        Out_Ready   : in    std_logic                                             := '1';
        Out_Data    : out   std_logic_vector(OutWidth_g - 1 downto 0);
        Out_Last    : out   std_logic
    );
end entity;

architecture rtl of olo_base_wconv_xn2n is

    constant RatioReal_c : real    := real(InWidth_g) / real(OutWidth_g);
    constant RatioInt_c  : integer := integer(RatioReal_c);

    type TwoProcess_r is record
        Data     : std_logic_vector(InWidth_g - 1 downto 0);
        DataVld  : std_logic_vector(RatioInt_c - 1 downto 0);
        DataLast : std_logic_vector(RatioInt_c - 1 downto 0);
    end record;

    signal r, r_next : TwoProcess_r;

begin

    assert floor(RatioReal_c) = ceil(RatioReal_c)
        report ""olo_base_wconv_xn2n: Ratio OutWidth_g/InWidth_g must be an integer number""
        severity error;
    assert OutWidth_g < InWidth_g
        report ""olo_base_wconv_n2xn: OutWidth_g must be smaller than InWidth_g""
        severity error;

    p_comb : process (r, In_Valid, In_Data, Out_Ready, In_WordEna, In_Last) is
        variable v         : TwoProcess_r;
        variable IsReady_v : std_logic;
    begin
        v := r;

        IsReady_v := '1';
        if unsigned(r.DataVld(r.DataVld'high downto 1)) /= 0 then
            IsReady_v := '0';
        elsif r.DataVld(0) = '1' and Out_Ready = '0' then
            IsReady_v := '0';
        end if;

        if IsReady_v = '1' and In_Valid = '1' then
            v.Data    := In_Data;
            v.DataVld := In_WordEna;
            v.DataLast := (others => '0');

            for i in RatioInt_c-1 downto 0 loop
                if In_WordEna(i) = '1' and In_Last = '1' then
                    v.DataLast(i) := '1';
                    exit;
                end if;
            end loop;

        elsif (Out_Ready = '1') and (unsigned(r.DataVld) /= 0) then
            v.Data     := zerosVector(OutWidth_g) & r.Data(r.Data'left downto OutWidth_g);
            v.DataVld  := '0' & r.DataVld(r.DataVld'left downto 1);
            v.DataLast := '0' & r.DataLast(r.DataLast'left downto 1);
        end if;

        Out_Data  <= r.Data(OutWidth_g - 1 downto 0);
        In_Ready  <= IsReady_v;
        Out_Valid <= r.DataVld(0);
        Out_Last  <= r.DataLast(0);

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.DataVld <= (others => '0');
            end if;
        end if;
    end process;

end architecture;"
"The `olo_axi_lite_slave` component is a VHDL implementation of a lightweight AXI (Advanced eXtensible Interface) slave module, designed to facilitate communication between an AXI master and a peripheral device. Its primary purpose is to provide a bridge between the AXI interface and a register-based interface, enabling the master to access the peripheral device's registers. The component has several input and output ports that play a crucial role in its operation. The AXI interface consists of several ports, including `S_AxiLite_ArAddr`, `S_AxiLite_ArValid`, and `S_AxiLite_ArReady`, which are used for read address channel communication. Similarly, `S_AxiLite_AwAddr`, `S_AxiLite_AwValid`, and `S_AxiLite_AwReady` are used for write address channel communication. The `S_AxiLite_WData`, `S_AxiLite_WStrb`, and `S_AxiLite_WValid` ports are used for write data channel communication. The `S_AxiLite_BResp`, `S_AxiLite_BValid`, and `S_AxiLite_BReady` ports are used for write response channel communication, while `S_AxiLite_RData`, `S_AxiLite_RResp`, `S_AxiLite_RValid`, and `S_AxiLite_RReady` are used for read data channel communication. Internally, the component consists of a finite state machine (FSM) that manages the AXI interface and a register-based interface. The FSM has seven states: `Idle`, `WrCmd`, `WrData`, `WrResp`, `RdCmd`, `RdData`, and `RdResp`. The `Idle` state is the reset state, where the component waits for incoming AXI transactions. The `WrCmd` and `RdCmd` states handle write and read command decoding, respectively. The `WrData` state handles write data, while `WrResp` and `RdResp` states handle write and read responses, respectively. The component uses several registers to store the current state, address, byte enable, write data, and read data. The `TwoProcess_r` record type is used to declare these registers. The `p_comb` process is a combinational process that updates the registers based on the current state and input signals. The `p_seq` process is a sequential process that updates the registers on the rising edge of the clock. The component's control logic is primarily implemented using the FSM and the combinational process. The FSM generates control signals, such as `ArReady`, `AwReady`, `WReady`, `BValid`, and `RValid`, based on the current state and input signals. The `p_comb` process also generates the `Rb_Addr`, `Rb_ByteEna`, `Rb_WrData`, `Rb_Wr`, and `Rb_Rd` signals, which are used to access the peripheral device's registers. The component's data flow can be described as follows: during a write transaction, the AXI master's write address and data are captured, and the write data is forwarded to the peripheral device's registers. During a read transaction, the AXI master's read address is captured, and the peripheral device's register data is read and forwarded to the AXI master. The component has specific timing requirements, including setup and hold times for the AXI interface signals. The `Clk` input is used to synchronize the component's operation, and the `Rst` input is used to reset the component. One of the special features of this component is its ability to handle read timeouts. If a read transaction takes longer than the specified `ReadTimeoutClks_g` cycles, the component generates a slave error response. The `olo_axi_lite_slave` component is typically used in systems where a peripheral device needs to be accessed through an AXI interface. It can be used in a variety of applications, including system-on-chip (SoC) design, field-programmable gate array (FPGA) design, and application-specific integrated circuit (ASIC) design. In terms of implementation considerations, the component's performance is dependent on the AXI interface frequency and the peripheral device's register access time. The component's resource usage is relatively low, as it only requires a small number of registers and combinational logic. However, the component's design trade-offs include the need to balance between area and performance, as well as the need to ensure that the component meets the required timing constraints. The component's generic parameters, such as `AxiAddrWidth_g`, `AxiDataWidth_g`, and `ReadTimeoutClks_g`, provide flexibility in terms of configuration. The `AxiAddrWidth_g` parameter determines the width of the AXI address bus, while the `AxiDataWidth_g` parameter determines the width of the AXI data bus. The `ReadTimeoutClks_g` parameter determines the read timeout period. Overall, the `olo_axi_lite_slave` component provides a efficient and flexible solution for interfacing a peripheral device to an AXI master, enabling seamless communication between the two. Its modular design and generic parameters make it suitable for a wide range of applications.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_axi_pkg_protocol.all;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_axi_lite_slave is
    generic (
        AxiAddrWidth_g      : positive := 8;
        AxiDataWidth_g      : positive := 32;
        ReadTimeoutClks_g   : positive := 100
    );
    port (
        Clk               : in    std_logic;
        Rst               : in    std_logic;
        S_AxiLite_ArAddr  : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        S_AxiLite_ArValid : in    std_logic;
        S_AxiLite_ArReady : out   std_logic;
        S_AxiLite_AwAddr  : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        S_AxiLite_AwValid : in    std_logic;
        S_AxiLite_AwReady : out   std_logic;
        S_AxiLite_WData   : in    std_logic_vector(AxiDataWidth_g - 1 downto 0);
        S_AxiLite_WStrb   : in    std_logic_vector((AxiDataWidth_g/8) - 1 downto 0);
        S_AxiLite_WValid  : in    std_logic;
        S_AxiLite_WReady  : out   std_logic;
        S_AxiLite_BResp   : out   std_logic_vector(1 downto 0);
        S_AxiLite_BValid  : out   std_logic;
        S_AxiLite_BReady  : in    std_logic;
        S_AxiLite_RData   : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        S_AxiLite_RResp   : out   std_logic_vector(1 downto 0);
        S_AxiLite_RValid  : out   std_logic;
        S_AxiLite_RReady  : in    std_logic;
        Rb_Addr           : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        Rb_Wr             : out   std_logic;
        Rb_ByteEna        : out   std_logic_vector((AxiDataWidth_g/8) - 1 downto 0);
        Rb_WrData         : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        Rb_Rd             : out   std_logic;
        Rb_RdData         : in    std_logic_vector(AxiDataWidth_g - 1 downto 0);
        Rb_RdValid        : in    std_logic
    );
end entity;

architecture rtl of olo_axi_lite_slave is

    type Fsm_t is (Idle, WrCmd, WrData, WrResp, RdCmd, RdData, RdResp);

    type TwoProcess_r is record
        State   : Fsm_t;
        ArReady : std_logic;
        AwReady : std_logic;
        WReady  : std_logic;
        BValid  : std_logic;
        RValid  : std_logic;
        RData   : std_logic_vector(Rb_RdData'range);
        Addr    : std_logic_vector(Rb_Addr'range);
        ByteEna : std_logic_vector(Rb_ByteEna'range);
        WrData  : std_logic_vector(Rb_WrData'range);
        Wr      : std_logic;
        Rd      : std_logic;
        RResp   : Resp_t;
        ToCnt   : natural range 0 to ReadTimeoutClks_g-1;
    end record;

    signal r, r_next : TwoProcess_r;

    constant UnusedBits_c : natural := log2(AxiDataWidth_g/8);

begin

    assert AxiDataWidth_g mod 8 = 0
        report ""###ERROR###: olo_axi_lite_slave AxiDataWidth_g must be a multiple of 8""
        severity failure;
    assert isPower2(AxiDataWidth_g/8)
        report ""###ERROR###: olo_axi_lite_slave AxiDataWidth_g must be 2^X bytes""
        severity failure;

    p_comb : process (r, S_AxiLite_ArAddr, S_AxiLite_ArValid, S_AxiLite_AwAddr, S_AxiLite_AwValid,
                      S_AxiLite_WData, S_AxiLite_WStrb, S_AxiLite_WValid, S_AxiLite_BReady,
                      S_AxiLite_RReady, Rb_RdData, Rb_RdValid) is
        variable v : TwoProcess_r;
    begin
        v := r;

        v.ArReady := '0';
        v.AwReady := '0';
        v.Wr      := '0';
        v.Rd      := '0';

        case r.State is
            when Idle =>
                if S_AxiLite_ArValid = '1' then
                    v.State   := RdCmd;
                    v.ArReady := '1';
                elsif S_AxiLite_AwValid = '1' then
                    v.State   := WrCmd;
                    v.AwReady := '1';
                end if;

            when WrCmd =>
                v.Addr := S_AxiLite_AwAddr(S_AxiLite_AwAddr'high downto UnusedBits_c) & zerosVector(UnusedBits_c);
                v.WReady := '1';
                v.State  := WrData;

            when WrData =>
                if S_AxiLite_WValid = '1' then
                    v.State   := WrResp;
                    v.WReady  := '0';
                    v.ByteEna := S_AxiLite_WStrb;
                    v.WrData  := S_AxiLite_WData;
                    v.Wr      := '1';
                    v.BValid  := '1';
                end if;

            when WrResp =>
                if S_AxiLite_BReady = '1' then
                    v.State  := Idle;
                    v.BValid := '0';
                end if;

            when RdCmd =>
                v.Addr  := S_AxiLite_ArAddr;
                v.Rd    := '1';
                v.State := RdData;
                v.ToCnt := ReadTimeoutClks_g-1;

            when RdData =>
                if Rb_RdValid = '1' then
                    v.RData  := Rb_RdData;
                    v.RValid := '1';
                    v.RResp  := AxiResp_Okay_c;
                    v.State  := RdResp;
                end if;
                if v.ToCnt = 0 then
                    v.RValid := '1';
                    v.RResp  := AxiResp_SlvErr_c;
                    v.State  := RdResp;
                else
                    v.ToCnt := v.ToCnt - 1;
                end if;

            when RdResp =>
                if S_AxiLite_RReady = '1' then
                    v.State  := Idle;
                    v.RValid := '0';
                end if;

            when others => null; -- unreachable

        end case;

        S_AxiLite_ArReady <= r.ArReady;
        S_AxiLite_AwReady <= r.AwReady;
        S_AxiLite_WReady  <= r.WReady;
        S_AxiLite_BResp   <= AxiResp_Okay_c; -- Writes can't fail
        S_AxiLite_BValid  <= r.BValid;
        S_AxiLite_RData   <= r.RData;
        S_AxiLite_RResp   <= r.RResp;
        S_AxiLite_RValid  <= r.RValid;

        Rb_Addr    <= r.Addr;
        Rb_ByteEna <= r.ByteEna;
        Rb_WrData  <= r.WrData;
        Rb_Wr      <= r.Wr;
        Rb_Rd      <= r.Rd;

        r_next <= v;
    end process;

    p_seq : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                r.State   <= Idle;
                r.ArReady <= '0';
                r.AwReady <= '0';
                r.WReady  <= '0';
                r.Wr      <= '0';
                r.BValid  <= '0';
                r.Rd      <= '0';
                r.RValid  <= '0';
            end if;
        end if;
    end process;

end architecture;"
"The `olo_axi_master_full` component is a comprehensive AXI master interface designed to facilitate high-speed data transfers between a user logic and an AXI bus. This module serves as a bridge, enabling the user logic to initiate and manage data transactions on the AXI bus, supporting both write and read operations. **Component Overview** The `olo_axi_master_full` component is a versatile AXI master interface that can be configured to support a wide range of AXI bus widths and user data widths. It provides a flexible and efficient way to transfer data between the user logic and the AXI bus, handling the complexities of the AXI protocol. **Detailed Input/Output Analysis** The component features a multitude of input and output ports, each serving a specific purpose: * **Clk and Rst**: The clock and reset inputs that control the component's operation. * **CmdWr_Addr, CmdWr_Size, CmdWr_LowLat, and CmdWr_Valid**: These inputs provide the write command address, size, low latency, and validity, respectively. * **CmdRd_Addr, CmdRd_Size, CmdRd_LowLat, and CmdRd_Valid**: Similarly, these inputs provide the read command address, size, low latency, and validity. * **Wr_Data, Wr_Valid, and Wr_Ready**: The write data input, validity, and readiness signals. * **Rd_Data, Rd_Last, Rd_Valid, and Rd_Ready**: The read data output, last byte signal, validity, and readiness signals. * **M_Axi_* signals**: These outputs connect directly to the AXI bus, providing the address, data, and control signals for write and read transactions. **Architectural Description** The internal architecture of the `olo_axi_master_full` component consists of several key modules: * **Finite State Machines (FSMs)**: The component employs multiple FSMs to manage the write and read command generation, data conversion, and alignment. These FSMs ensure that the AXI protocol is followed accurately and efficiently. * **Registers and Counters**: Various registers and counters are used to track the transaction progress, data alignment, and byte enables. * **Data Alignment and Conversion**: The component features data alignment and conversion logic to handle different user data widths and AXI bus widths. **Functional Behavior** The `olo_axi_master_full` component operates as follows: 1. **Write Operation**: * The user logic provides a write command with address, size, and validity. * The component generates the AXI write command and sends it to the AXI bus. * The write data is aligned and converted to match the AXI bus width. * The component handles the write data transfer, ensuring that the AXI protocol is followed. 2. **Read Operation**: * The user logic provides a read command with address, size, and validity. * The component generates the AXI read command and sends it to the AXI bus. * The component receives the read data from the AXI bus and aligns it to match the user data width. * The aligned read data is then provided to the user logic. **Control Logic** The control logic within the `olo_axi_master_full` component manages the flow of data and commands between the user logic and the AXI bus. It generates the necessary control signals to ensure that the AXI protocol is followed accurately. * **Write Control Logic**: Manages the write command generation, data alignment, and transfer. * **Read Control Logic**: Handles the read command generation, data reception, and alignment. **Data Flow** The data flow within the component can be described as follows: * **Write Data Flow**: The user logic provides write data, which is then aligned and converted to match the AXI bus width. The aligned data is then sent to the AXI bus. * **Read Data Flow**: The component receives read data from the AXI bus, aligns it to match the user data width, and then provides it to the user logic. **Timing and Synchronization** The `olo_axi_master_full` component is designed to operate in a synchronous manner, with the clock and reset signals controlling its operation. * **Clock Domain**: The component operates within a single clock domain, ensuring that all operations are synchronized to the clock. * **Setup and Hold Requirements**: The component is designed to meet the setup and hold requirements of the AXI bus, ensuring reliable data transfer. **Special Features** The `olo_axi_master_full` component features several special functions: * **Configurable AXI Bus Width and User Data Width**: The component can be configured to support a wide range of AXI bus widths and user data widths. * **Support for Low-Latency Transactions**: The component supports low-latency transactions, allowing for efficient data transfer. **Applications and Use Cases** The `olo_axi_master_full` component is suitable for a variety of applications, including: * **AXI Bus Masters**: The component can be used to implement AXI bus masters in a wide range of systems, including SoCs, FPGAs, and ASICs. * **Data Transfer Interfaces**: The component can be used to implement data transfer interfaces between different subsystems or components. **Implementation Considerations** When implementing the `olo_axi_master_full` component, several factors should be considered: * **Performance**: The component's performance is influenced by the AXI bus width, user data width, and clock frequency. * **Resource Usage**: The component's resource usage depends on the specific implementation, including the FPGA or ASIC technology used. * **Design Trade-Offs**: The component's design involves trade-offs between performance, resource usage, and complexity.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.std_logic_misc.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;

entity olo_axi_master_full is
    generic (
        AxiAddrWidth_g             : natural range 12 to 64  := 32;
        AxiDataWidth_g             : natural range 8 to 1024 := 32;
        AxiMaxBeats_g              : natural range 1 to 256  := 256;
        AxiMaxOpenTransactions_g   : natural range 1 to 8    := 8;
        UserTransactionSizeBits_g  : natural                 := 32;
        DataFifoDepth_g            : natural                 := 1024;
        UserDataWidth_g            : natural                 := 32;
        ImplRead_g                 : boolean                 := true;
        ImplWrite_g                : boolean                 := true;
        RamBehavior_g              : string                  := ""RBW""
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        CmdWr_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdWr_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdWr_LowLat    : in    std_logic                                                := '0';
        CmdWr_Valid     : in    std_logic                                                := '0';
        CmdWr_Ready     : out   std_logic;
        CmdRd_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdRd_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdRd_LowLat    : in    std_logic                                                := '0';
        CmdRd_Valid     : in    std_logic                                                := '0';
        CmdRd_Ready     : out   std_logic;
        Wr_Data         : in    std_logic_vector(UserDataWidth_g - 1 downto 0)           := (others => '0');
        Wr_Valid        : in    std_logic                                                := '0';
        Wr_Ready        : out   std_logic;
        Rd_Data         : out   std_logic_vector(UserDataWidth_g - 1 downto 0);
        Rd_Last         : out   std_logic;
        Rd_Valid        : out   std_logic;
        Rd_Ready        : in    std_logic                                                := '1';
        Wr_Done         : out   std_logic;
        Wr_Error        : out   std_logic;
        Rd_Done         : out   std_logic;
        Rd_Error        : out   std_logic;
        M_Axi_AwAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_AwLen     : out   std_logic_vector(7 downto 0);
        M_Axi_AwSize    : out   std_logic_vector(2 downto 0);
        M_Axi_AwBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_AwLock    : out   std_logic;
        M_Axi_AwCache   : out   std_logic_vector(3 downto 0);
        M_Axi_AwProt    : out   std_logic_vector(2 downto 0);
        M_Axi_AwValid   : out   std_logic;
        M_Axi_AwReady   : in    std_logic                                                := '0';
        M_Axi_WData     : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        M_Axi_WStrb     : out   std_logic_vector(AxiDataWidth_g / 8 - 1 downto 0);
        M_Axi_WLast     : out   std_logic;
        M_Axi_WValid    : out   std_logic;
        M_Axi_WReady    : in    std_logic                                                := '0';
        M_Axi_BResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_BValid    : in    std_logic                                                := '0';
        M_Axi_BReady    : out   std_logic;
        M_Axi_ArAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_ArLen     : out   std_logic_vector(7 downto 0);
        M_Axi_ArSize    : out   std_logic_vector(2 downto 0);
        M_Axi_ArBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_ArLock    : out   std_logic;
        M_Axi_ArCache   : out   std_logic_vector(3 downto 0);
        M_Axi_ArProt    : out   std_logic_vector(2 downto 0);
        M_Axi_ArValid   : out   std_logic;
        M_Axi_ArReady   : in    std_logic                                                := '0';
        M_Axi_RData     : in    std_logic_vector(AxiDataWidth_g - 1 downto 0)            := (others => '0');
        M_Axi_RResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_RLast     : in    std_logic                                                := '0';
        M_Axi_RValid    : in    std_logic                                                := '0';
        M_Axi_RReady    : out   std_logic
    );
end entity;

architecture rtl of olo_axi_master_full is

    constant AxiBytes_c  : natural := AxiDataWidth_g / 8;
    constant DataBytes_c : natural := UserDataWidth_g / 8;

    type WriteCmdFsm_t is (Idle_s, Apply_s);
    type WriteWconvFsm_t is (Idle_s, Transfer_s);
    type WriteAlignFsm_t is (Idle_s, Transfer_s, Last_s);
    type ReadCmdFsm_t is (Idle_s, Apply_s, WaitDataFsm_s);
    type ReadDataFsm_t is (Idle_s, Transfer_s, Wait_s);

    function alignedAddr (Addr : in unsigned(AxiAddrWidth_g-1 downto 0))
    return unsigned is
        variable Addr_v : unsigned(Addr'range) := (others => '0');
    begin
        Addr_v(Addr'left downto log2(AxiBytes_c)) := Addr(Addr'left downto log2(AxiBytes_c));
        return Addr_v;
    end function;

    type TwoProcess_r is record
        WrCmdFsm        : WriteCmdFsm_t;
        WrLastAddr      : unsigned(AxiAddrWidth_g - 1 downto 0);
        CmdWr_Ready     : std_logic;
        AxiWrCmd_Addr   : std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        AxiWrCmd_Size   : std_logic_vector(UserTransactionSizeBits_g - 1 downto 0);
        WrAlignCmdSize  : std_logic_vector(UserTransactionSizeBits_g - 1 downto 0);
        AxiWrCmd_LowLat : std_logic;
        AxiWrCmd_Vld    : std_logic;
        WrWconvFsm      : WriteWconvFsm_t;
        WrStartTf       : std_logic;
        WrWordsDone     : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrDataWordsCmd  : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrDataWordsWc   : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrAlignFsm      : WriteAlignFsm_t;
        WrAlignReg      : std_logic_vector(AxiDataWidth_g * 2 - 1 downto 0);
        WrAlignBe       : std_logic_vector(AxiBytes_c * 2 - 1 downto 0);
        WrShift         : unsigned(log2(AxiBytes_c) - 1 downto 0);
        WrAlignShift    : unsigned(log2(AxiBytes_c) - 1 downto 0);
        WrAlignVld      : std_logic;
        AxiWordCnt      : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        WrLastBe        : std_logic_vector(AxiBytes_c - 1 downto 0);
        WrAlignLastBe   : std_logic_vector(AxiBytes_c - 1 downto 0);
        WrAlignLast     : std_logic;

        RdCmdFsm        : ReadCmdFsm_t;
        RdLastAddr      : unsigned(AxiAddrWidth_g - 1 downto 0);
        RdFirstAddrOffs : unsigned(log2(AxiBytes_c) - 1 downto 0);
        CmdRd_Ready     : std_logic;
        AxiRdCmd_Addr   : std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        AxiRdCmd_LowLat : std_logic;
        AxiRdCmd_Vld    : std_logic;
        AxiRdCmd_Size   : std_logic_vector(UserTransactionSizeBits_g - 1 downto 0);
        RdFirstBe       : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdLastBe        : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdDataFsm       : ReadDataFsm_t;
        RdStartTf       : std_logic;
        RdDataEna       : std_logic;
        RdDatFirstBe    : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdDatLastBe     : std_logic_vector(AxiBytes_c - 1 downto 0);
        RdDataWords     : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        RdCurrentWord   : unsigned(UserTransactionSizeBits_g - 1 downto 0);
        RdShift         : unsigned(log2(AxiBytes_c) - 1 downto 0);
        RdLowIdx        : unsigned(log2(AxiBytes_c) downto 0);
        RdAlignShift    : unsigned(log2(AxiBytes_c) - 1 downto 0);
        RdAlignLowIdx   : unsigned(log2(AxiBytes_c) downto 0);
        RdAlignByteVld  : std_logic_vector(AxiBytes_c * 2 - 1 downto 0);
        RdAlignReg      : std_logic_vector(AxiDataWidth_g * 2 - 1 downto 0);
        RdAlignLast     : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal WrPl_Data     : std_logic_vector(Wr_Data'range);
    signal WrPl_Vld      : std_logic;
    signal AxiWrCmd_Rdy  : std_logic;
    signal AxiWrDat_Rdy  : std_logic;
    signal AxiWrDat_Data : std_logic_vector(AxiDataWidth_g - 1 downto 0);
    signal WrPl_Rdy      : std_logic;
    signal AxiWrDat_Be   : std_logic_vector(AxiBytes_c - 1 downto 0);
    signal WrWconvEna    : std_logic;
    signal WrWconv_Vld   : std_logic;
    signal WrWconv_Rdy   : std_logic;
    signal WrWconv_Last  : std_logic;
    signal WrData_Vld    : std_logic;
    signal WrData_Data   : std_logic_vector(AxiDataWidth_g - 1 downto 0);
    signal WrData_Last   : std_logic;
    signal WrData_We     : std_logic_vector(AxiBytes_c / DataBytes_c - 1 downto 0);
    signal WrData_Rdy    : std_logic;
    signal WrDataEna     : std_logic;
    signal AxiRdCmd_Rdy  : std_logic;
    signal AxiRdDat_Rdy  : std_logic;
    signal AxiRdDat_Vld  : std_logic;
    signal AxiRdDat_Data : std_logic_vector(AxiDataWidth_g - 1 downto 0);
    signal AxiRdDat_Last : std_logic;
    signal RdPl_Rdy      : std_logic;
    signal RdPl_Data     : std_logic_vector(UserDataWidth_g - 1 downto 0);
    signal RdPl_Vld      : std_logic;
    signal RdPl_Last     : std_logic;

begin

    assert isPower2(AxiDataWidth_g/8)
        report ""olo_axi_master_full - AxiDataWidth_g must be a power of two of bytes""
        severity failure;
    assert UserDataWidth_g mod 8 = 0
        report ""olo_axi_master_full UserDataWidth_g must be a multiple of 8""
        severity failure;
    assert AxiDataWidth_g mod UserDataWidth_g = 0
        report ""olo_axi_master_full AxiDataWidth_g must be a multiple of UserDataWidth_g""
        severity failure;
    assert UserTransactionSizeBits_g <= AxiAddrWidth_g
        report ""olo_axi_master_full UserTransactionSizeBits_g must be smaller or equal to AxiAddrWidth_g""
        severity failure;

    p_comb : process (r,
                      CmdWr_Addr, CmdWr_Size, CmdWr_Valid, CmdWr_LowLat, CmdRd_Addr, CmdRd_Size, CmdRd_Valid, CmdRd_LowLat,
                      AxiWrCmd_Rdy, AxiWrDat_Rdy, AxiRdCmd_Rdy, AxiRdDat_Vld, AxiRdDat_Data,
                      WrWconv_Rdy, WrPl_Vld, WrData_Vld, WrData_Data, WrData_Last, WrData_We, RdPl_Rdy) is
        variable v              : TwoProcess_r;
        variable WriteBe_v      : std_logic_vector(AxiBytes_c - 1 downto 0);
        variable RdAlignReady_v : std_logic;
        variable RdLowIdxInt_v  : integer range 0 to AxiBytes_c;
        variable RdDatBe_v      : std_logic_vector(AxiBytes_c - 1 downto 0);
    begin
        v := r;

        if ImplWrite_g then

            v.WrStartTf    := '0';
            v.AxiWrCmd_Vld := '0';

            case r.WrCmdFsm is

                when Idle_s =>
                    v.CmdWr_Ready := '1';
                    v.WrLastAddr  := unsigned(CmdWr_Addr) + unsigned(CmdWr_Size) - 1;
                    if unsigned(CmdWr_Size(log2(DataBytes_c) - 1 downto 0)) = 0 then
                        v.WrDataWordsCmd := resize(unsigned(CmdWr_Size(CmdWr_Size'high downto log2(DataBytes_c))), UserTransactionSizeBits_g);
                    else
                        v.WrDataWordsCmd := resize(unsigned(CmdWr_Size(CmdWr_Size'high downto log2(DataBytes_c))) + 1, UserTransactionSizeBits_g);
                    end if;
                    v.AxiWrCmd_Addr   := std_logic_vector(alignedAddr(unsigned(CmdWr_Addr)));
                    v.WrShift         := unsigned(CmdWr_Addr(v.WrShift'range));
                    v.AxiWrCmd_LowLat := CmdWr_LowLat;
                    if CmdWr_Valid = '1' then
                        v.CmdWr_Ready := '0';
                        v.WrCmdFsm    := Apply_s;
                    end if;

                when Apply_s =>
                    if (AxiWrCmd_Rdy = '1') and (r.WrWconvFsm = Idle_s) and (r.WrAlignFsm = Idle_s) then
                        v.AxiWrCmd_Vld  := '1';
                        v.WrStartTf     := '1';
                        v.WrCmdFsm      := Idle_s;
                        v.CmdWr_Ready   := '1';
                        v.AxiWrCmd_Size := std_logic_vector(resize(shift_right(alignedAddr(r.WrLastAddr) - unsigned(r.AxiWrCmd_Addr), log2(AxiBytes_c)) + 1,
                                                                   UserTransactionSizeBits_g));

                        for byte in 0 to AxiBytes_c - 1 loop
                            if r.WrLastAddr(log2(AxiBytes_c) - 1 downto 0) >= byte then
                                v.WrLastBe(byte) := '1';
                            else
                                v.WrLastBe(byte) := '0';
                            end if;
                        end loop;

                    end if;

                when others => null;    -- unreachable code

            end case;

            WrWconvEna   <= '0';
            WrWconv_Last <= '0';

            case r.WrWconvFsm is
                when Idle_s =>
                    v.WrWordsDone   := to_unsigned(1, v.WrWordsDone'length);
                    v.WrDataWordsWc := r.WrDataWordsCmd;
                    if r.WrStartTf = '1' then
                        v.WrWconvFsm := Transfer_s;
                    end if;

                when Transfer_s =>
                    WrWconvEna <= '1';
                    if r.WrWordsDone = r.WrDataWordsWc then
                        WrWconv_Last <= '1';
                    end if;
                    if (WrWconv_Rdy = '1') and (WrPl_Vld = '1') then
                        v.WrWordsDone := r.WrWordsDone + 1;
                        if r.WrWordsDone = r.WrDataWordsWc then
                            v.WrWconvFsm := Idle_s;
                        end if;
                    end if;

                when others => null; -- unreachable code
            end case;

            WrDataEna <= '0';

            for i in 0 to AxiBytes_c - 1 loop
                WriteBe_v(i) := WrData_We(i / UserDataWidth_g);
            end loop;

            case r.WrAlignFsm is
                when Idle_s =>
                    v.WrAlignReg     := (others => '0');
                    v.WrAlignBe      := (others => '0');
                    v.AxiWordCnt     := to_unsigned(1, v.AxiWordCnt'length);
                    v.WrAlignLast    := '0';
                    v.WrAlignShift   := r.WrShift;
                    v.WrAlignCmdSize := r.AxiWrCmd_Size;
                    v.WrAlignLastBe  := r.WrLastBe;
                    v.WrAlignVld     := '0';
                    if r.WrStartTf = '1' then
                        v.WrAlignFsm := Transfer_s;
                    end if;

                when Transfer_s =>
                    WrDataEna <= '1';
                    if (AxiWrDat_Rdy = '1') and ((WrData_Vld = '1') or (r.WrAlignLast = '1')) then
                        if r.WrAlignLast = '1' then
                            WriteBe_v := (others => '0');
                        end if;
                        v.WrAlignReg(AxiDataWidth_g - 1 downto 0) := r.WrAlignReg(r.WrAlignReg'left downto AxiDataWidth_g);
                        v.WrAlignBe(AxiBytes_c - 1 downto 0)      := r.WrAlignBe(r.WrAlignBe'left downto AxiBytes_c);
                        v.WrAlignReg((to_integer(r.WrAlignShift) + AxiBytes_c) * 8 - 1 downto to_integer(r.WrAlignShift) * 8) := WrData_Data;
                        v.WrAlignBe(to_integer(r.WrAlignShift) + AxiBytes_c - 1 downto to_integer(r.WrAlignShift))            := WriteBe_v;
                        v.WrAlignVld := '1';
                        if r.AxiWordCnt = unsigned(r.WrAlignCmdSize) then
                            v.WrAlignFsm                         := Last_s;
                            v.WrAlignBe(AxiBytes_c - 1 downto 0) := v.WrAlignBe(AxiBytes_c - 1 downto 0) and r.WrAlignLastBe;
                        end if;
                        v.AxiWordCnt := r.AxiWordCnt + 1;
                        v.WrAlignLast := WrData_Last;
                    elsif AxiWrDat_Rdy = '1' then
                        v.WrAlignVld := '0';
                    end if;

                when Last_s =>
                    v.WrAlignVld := '1';
                    if AxiWrDat_Rdy = '1' then
                        v.WrAlignVld := '0';
                        v.WrAlignFsm := Idle_s;
                    end if;

                when others => null; -- unreachable code
            end case;

        end if;

        if ImplRead_g then

            RdLowIdxInt_v  := to_integer(r.RdAlignLowIdx);
            RdAlignReady_v := r.RdDataEna;

            for i in 0 to AxiBytes_c loop
                if i = RdLowIdxInt_v then
                    if (DataBytes_c < AxiBytes_c) and (unsigned(r.RdAlignByteVld(r.RdAlignByteVld'high downto i + DataBytes_c)) /= 0) then
                        RdAlignReady_v := '0';
                    elsif unsigned(r.RdAlignByteVld(r.RdAlignByteVld'high downto i)) /= 0 and RdPl_Rdy = '0' then
                        RdAlignReady_v := '0';
                    end if;
                end if;
            end loop;

            v.RdStartTf    := '0';
            v.AxiRdCmd_Vld := '0';

            case r.RdCmdFsm is
                when Idle_s =>
                    v.CmdRd_Ready     := '1';
                    v.RdLastAddr      := unsigned(CmdRd_Addr) + unsigned(CmdRd_Size) - 1;
                    v.RdFirstAddrOffs := unsigned(CmdRd_Addr(v.RdFirstAddrOffs'range));
                    v.AxiRdCmd_Addr   := std_logic_vector(alignedAddr(unsigned(CmdRd_Addr)));
                    v.AxiRdCmd_LowLat := CmdRd_LowLat;
                    v.RdShift         := unsigned(CmdRd_Addr(v.RdShift'range));
                    v.RdLowIdx        := to_unsigned(AxiBytes_c, v.RdLowIdx'length) - unsigned(CmdRd_Addr(v.RdShift'range));
                    if CmdRd_Valid = '1' then
                        v.CmdRd_Ready := '0';
                        v.RdCmdFsm    := Apply_s;
                    end if;

                when Apply_s =>
                    if AxiRdCmd_Rdy = '1' then
                        v.AxiRdCmd_Vld  := '1';
                        v.RdCmdFsm      := WaitDataFsm_s;
                        v.RdStartTf     := '1';
                        v.AxiRdCmd_Size := std_logic_vector(resize(shift_right(alignedAddr(r.RdLastAddr) - unsigned(r.AxiRdCmd_Addr), log2(AxiBytes_c)) + 1,
                                                                   UserTransactionSizeBits_g));

                        for byte in 0 to AxiBytes_c - 1 loop
                            if r.RdLastAddr(log2(AxiBytes_c) - 1 downto 0) >= byte then
                                v.RdLastBe(byte) := '1';
                            else
                                v.RdLastBe(byte) := '0';
                            end if;
                        end loop;

                        for byte in 0 to AxiBytes_c - 1 loop
                            if r.RdFirstAddrOffs <= byte then
                                v.RdFirstBe(byte) := '1';
                            else
                                v.RdFirstBe(byte) := '0';
                            end if;
                        end loop;

                    end if;

                when WaitDataFsm_s =>
                    v.RdStartTf := '1';
                    if r.RdDataFsm = Idle_s then
                        v.RdCmdFsm    := Idle_s;
                        v.CmdRd_Ready := '1';
                        v.RdStartTf   := '0';
                    end if;

                when others => null;    -- unreachable code
            end case;

            v.RdDataEna := '0';
            RdDatBe_v   := (others => '1');

            case r.RdDataFsm is
                when Idle_s =>
                    v.RdDatFirstBe  := r.RdFirstBe;
                    v.RdDatLastBe   := r.RdLastBe;
                    v.RdDataWords   := unsigned(r.AxiRdCmd_Size);
                    v.RdCurrentWord := to_unsigned(1, v.RdCurrentWord'length);
                    v.RdAlignShift  := r.RdShift;
                    v.RdAlignLowIdx := r.RdLowIdx;
                    if r.RdStartTf = '1' then
                        v.RdDataFsm := Transfer_s;
                        v.RdDataEna := '1';
                    end if;

                when Transfer_s =>
                    v.RdDataEna := '1';
                    if r.RdCurrentWord = 1 then
                        RdDatBe_v := RdDatBe_v and r.RdDatFirstBe;
                    end if;
                    if r.RdCurrentWord = r.RdDataWords then
                        RdDatBe_v := RdDatBe_v and r.RdDatLastBe;
                    end if;
                    if (RdAlignReady_v = '1') and (AxiRdDat_Vld = '1') and (r.RdDataEna = '1') then
                        v.RdCurrentWord := r.RdCurrentWord + 1;
                        if r.RdCurrentWord = r.RdDataWords then
                            v.RdDataEna := '0';
                            v.RdDataFsm := Wait_s;
                        end if;
                    end if;

                when Wait_s =>
                    if unsigned(r.RdAlignByteVld) = 0 then
                        v.RdDataFsm := Idle_s;
                    end if;

                when others => null; -- unreachable code
            end case;

            AxiRdDat_Rdy <= RdAlignReady_v;
            RdPl_Vld     <= '0';
            if (RdPl_Rdy = '1') and (RdAlignReady_v = '0' or AxiRdDat_Vld = '1' or r.RdAlignLast = '1') then
                v.RdAlignReg     := zerosVector(UserDataWidth_g) & r.RdAlignReg(r.RdAlignReg'left downto UserDataWidth_g);
                v.RdAlignByteVld := zerosVector(DataBytes_c) & r.RdAlignByteVld(r.RdAlignByteVld'left downto DataBytes_c);
                if r.RdAlignLast = '1' then
                    RdPl_Vld <= or_reduce(r.RdAlignByteVld(DataBytes_c - 1 downto 0));
                else
                    RdPl_Vld <= and_reduce(r.RdAlignByteVld(DataBytes_c - 1 downto 0));
                end if;
            end if;
            if RdAlignReady_v = '1' and AxiRdDat_Vld = '1' then
                v.RdAlignReg(RdLowIdxInt_v * 8 + AxiDataWidth_g - 1 downto RdLowIdxInt_v * 8) := AxiRdDat_Data;
                v.RdAlignByteVld(RdLowIdxInt_v + AxiBytes_c - 1 downto RdLowIdxInt_v)         := RdDatBe_v;
                v.RdAlignLast                                                                 := AxiRdDat_Last;
            end if;

            RdPl_Last <= r.RdAlignLast and not (or_reduce(r.RdAlignByteVld(r.RdAlignByteVld'high downto DataBytes_c)));
            RdPl_Data <= r.RdAlignReg(UserDataWidth_g - 1 downto 0);

        end if;

        r_next <= v;
    end process;

    p_reg : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                if ImplWrite_g then
                    r.WrCmdFsm     <= Idle_s;
                    r.CmdWr_Ready  <= '0';
                    r.AxiWrCmd_Vld <= '0';
                    r.WrWconvFsm   <= Idle_s;
                    r.WrStartTf    <= '0';
                    r.WrAlignFsm   <= Idle_s;
                    r.WrAlignVld   <= '0';
                end if;
                if ImplRead_g then
                    r.RdCmdFsm       <= Idle_s;
                    r.CmdRd_Ready    <= '0';
                    r.AxiRdCmd_Vld   <= '0';
                    r.RdDataFsm      <= Idle_s;
                    r.RdStartTf      <= '0';
                    r.RdDataEna      <= '0';
                    r.RdAlignByteVld <= (others => '0');
                end if;
            end if;
        end if;
    end process;

    CmdWr_Ready <= r.CmdWr_Ready;
    CmdRd_Ready <= r.CmdRd_Ready;

    AxiWrDat_Data <= r.WrAlignReg(AxiWrDat_Data'range);
    AxiWrDat_Be   <= r.WrAlignBe(AxiWrDat_Be'range);

    i_axi : entity work.olo_axi_master_simple
        generic map (
            AxiAddrWidth_g              => AxiAddrWidth_g,
            AxiDataWidth_g              => AxiDataWidth_g,
            AxiMaxBeats_g               => AxiMaxBeats_g,
            AxiMaxOpenTransactions_g    => AxiMaxOpenTransactions_g,
            UserTransactionSizeBits_g   => UserTransactionSizeBits_g,
            DataFifoDepth_g             => DataFifoDepth_g,
            ImplRead_g                  => ImplRead_g,
            ImplWrite_g                 => ImplWrite_g,
            RamBehavior_g               => RamBehavior_g
        )
        port map (
            Clk             => Clk,
            Rst             => Rst,
            CmdWr_Addr      => r.AxiWrCmd_Addr,
            CmdWr_Size      => r.AxiWrCmd_Size,
            CmdWr_LowLat    => r.AxiWrCmd_LowLat,
            CmdWr_Valid     => r.AxiWrCmd_Vld,
            CmdWr_Ready     => AxiWrCmd_Rdy,
            CmdRd_Addr      => r.AxiRdCmd_Addr,
            CmdRd_Size      => r.AxiRdCmd_Size,
            CmdRd_LowLat    => r.AxiRdCmd_LowLat,
            CmdRd_Valid     => r.AxiRdCmd_Vld,
            CmdRd_Ready     => AxiRdCmd_Rdy,
            Wr_Data         => AxiWrDat_Data,
            Wr_Be           => AxiWrDat_Be,
            Wr_Valid        => r.WrAlignVld,
            Wr_Ready        => AxiWrDat_Rdy,
            Rd_Data         => AxiRdDat_Data,
            Rd_Valid        => AxiRdDat_Vld,
            Rd_Ready        => AxiRdDat_Rdy,
            Rd_Last         => AxiRdDat_Last,
            Wr_Done         => Wr_Done,
            Wr_Error        => Wr_Error,
            Rd_Done         => Rd_Done,
            Rd_Error        => Rd_Error,
            M_Axi_AwAddr    => M_Axi_AwAddr,
            M_Axi_AwLen     => M_Axi_AwLen,
            M_Axi_AwSize    => M_Axi_AwSize,
            M_Axi_AwBurst   => M_Axi_AwBurst,
            M_Axi_AwLock    => M_Axi_AwLock,
            M_Axi_AwCache   => M_Axi_AwCache,
            M_Axi_AwProt    => M_Axi_AwProt,
            M_Axi_AwValid   => M_Axi_AwValid,
            M_Axi_AwReady   => M_Axi_AwReady,
            M_Axi_WData     => M_Axi_WData,
            M_Axi_WStrb     => M_Axi_WStrb,
            M_Axi_WLast     => M_Axi_WLast,
            M_Axi_WValid    => M_Axi_WValid,
            M_Axi_WReady    => M_Axi_WReady,
            M_Axi_BResp     => M_Axi_BResp,
            M_Axi_BValid    => M_Axi_BValid,
            M_Axi_BReady    => M_Axi_BReady,
            M_Axi_ArAddr    => M_Axi_ArAddr,
            M_Axi_ArLen     => M_Axi_ArLen,
            M_Axi_ArSize    => M_Axi_ArSize,
            M_Axi_ArBurst   => M_Axi_ArBurst,
            M_Axi_ArLock    => M_Axi_ArLock,
            M_Axi_ArCache   => M_Axi_ArCache,
            M_Axi_ArProt    => M_Axi_ArProt,
            M_Axi_ArValid   => M_Axi_ArValid,
            M_Axi_ArReady   => M_Axi_ArReady,
            M_Axi_RData     => M_Axi_RData,
            M_Axi_RResp     => M_Axi_RResp,
            M_Axi_RLast     => M_Axi_RLast,
            M_Axi_RValid    => M_Axi_RValid,
            M_Axi_RReady    => M_Axi_RReady
        );

    g_write : if ImplWrite_g generate

        WrPl_Rdy <= WrWconv_Rdy and WrWconvEna;

        i_pl_wr_data : entity work.olo_base_pl_stage
            generic map (
                Width_g        => UserDataWidth_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data     => Wr_Data,
                In_Valid    => Wr_Valid,
                In_Ready    => Wr_Ready,
                Out_Data    => WrPl_Data,
                Out_Valid   => WrPl_Vld,
                Out_Ready   => WrPl_Rdy
            );

        WrWconv_Vld <= WrWconvEna and WrPl_Vld;
        WrData_Rdy  <= AxiWrDat_Rdy and WrDataEna;

        i_wc_wr : entity work.olo_base_wconv_n2xn
            generic map (
                InWidth_g   => UserDataWidth_g,
                OutWidth_g  => AxiDataWidth_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Valid    => WrWconv_Vld,
                In_Ready    => WrWconv_Rdy,
                In_Data     => WrPl_Data,
                In_Last     => WrWconv_Last,
                Out_Valid   => WrData_Vld,
                Out_Ready   => WrData_Rdy,
                Out_Data    => WrData_Data,
                Out_Last    => WrData_Last,
                Out_WordEna => WrData_We
            );

    end generate;

    g_nwrite : if not ImplWrite_g generate
        Wr_Ready <= '0';
    end generate;

    g_read : if ImplRead_g generate
        signal InData, OutData : std_logic_vector(UserDataWidth_g downto 0);
    begin
        InData <= RdPl_Last & RdPl_Data;

        i_pl_rd_data : entity work.olo_base_pl_stage
            generic map (
                Width_g     => UserDataWidth_g+1
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data     => InData,
                In_Valid    => RdPl_Vld,
                In_Ready    => RdPl_Rdy,
                Out_Data    => OutData,
                Out_Valid   => Rd_Valid,
                Out_Ready   => Rd_Ready
            );

        Rd_Last <= OutData(UserDataWidth_g);
        Rd_Data <= OutData(UserDataWidth_g-1 downto 0);

    end generate;

    g_nread : if not ImplRead_g generate
        Rd_Valid <= '0';
        Rd_Data  <= (others => '0');
        Rd_Last  <= '0';
    end generate;

end architecture;"
"describes an AXI (Advanced eXtensible Interface) master component, specifically designed for simple read and write transactions. This component, named `olo_axi_master_simple`, acts as a bridge between a user interface and the AXI interface, facilitating data transfers between a system and an AXI slave device. **Component Overview** The `olo_axi_master_simple` component is designed to operate in both write and read modes, supporting AXI version 4. The component's primary purpose is to manage the AXI interface's complexity, providing a simpler interface for users to perform read and write transactions. It supports parameterized data widths, address widths, and maximum transaction sizes, making it versatile for various applications. **Detailed Input/Output Analysis** The component features multiple input and output ports that facilitate interaction with both the user logic and the AXI interface: - **User Interface Inputs/Outputs**: The component receives command inputs for write (`CmdWr_Addr`, `CmdWr_Size`, `CmdWr_LowLat`, `CmdWr_Valid`) and read (`CmdRd_Addr`, `CmdRd_Size`, `CmdRd_LowLat`, `CmdRd_Valid`) transactions. It also receives write data (`Wr_Data`, `Wr_Be`, `Wr_Valid`) and provides outputs for write done (`Wr_Done`), write error (`Wr_Error`), read done (`Rd_Done`), and read error (`Rd_Error`). - **AXI Interface Inputs/Outputs**: On the AXI side, the component outputs address, length, size, burst, lock, cache, protection, and valid signals for both write (`M_Axi_AwAddr`, `M_Axi_AwLen`, etc.) and read (`M_Axi_ArAddr`, `M_Axi_ArLen`, etc.) channels. It also handles write data (`M_Axi_WData`, `M_Axi_WStrb`, `M_Axi_WLast`, `M_Axi_WValid`) and receives or sends response signals (`M_Axi_BResp`, `M_Axi_BValid`, `M_Axi_RResp`, `M_Axi_RValid`). **Architectural Description** The component's architecture involves several state machines and counters to manage the AXI transactions: - **Write Transaction Generation (`WriteTfGen_t`)**: Manages the generation of write transactions, including calculating the maximum beats per transaction and generating the write transfer beats. - **Read Transaction Generation (`ReadTfGen_t`)**: Similar to the write generation but for read transactions. - **Write FSM (`WrFsm_t`)**: Controls the write data transfer, including handling non-last and last beats of a write transaction. - **Read FSM (`ArFsm_t`, `AwFsm_t`)**: Manages the read and write address channel handshakes. The design utilizes several FIFOs for storing write and read data and transaction information, ensuring smooth data flow and compliance with AXI protocol constraints. **Functional Behavior** The component operates by first receiving transaction commands from the user interface. It then initiates the AXI transaction by sending the address and command information. For write transactions, it sends data following the AXI write protocol. For read transactions, it receives data and responses from the AXI slave. **Control Logic** The control logic involves several enable conditions, reset behaviors, and state transitions managed through the state machines. The design ensures that all AXI signals adhere to the AXI protocol, including correct timing and handshake procedures. **Data Flow** Data moves through the component from the user interface to the AXI interface for writes and vice versa for reads. The component handles data in beats, with the size of each beat determined by the AXI data width. **Timing and Synchronization** The component operates based on the clock (`Clk`) and reset (`Rst`) signals. It adheres to AXI timing constraints, including setup and hold times for signals. **Special Features** The component supports parameterized features such as adjustable data width, address width, and maximum transaction size. It also includes options for implementing read and write functionalities separately. **Applications and Use Cases** The `olo_axi_master_simple` component can be used in a wide range of applications requiring AXI interface support, such as SoC (System-on-Chip) designs, FPGA (Field-Programmable Gate Array) implementations, and other digital systems interfacing with AXI slaves. **Implementation Considerations** The component's implementation considers performance optimization through the use of FIFOs for data and transactions. Design trade-offs include balancing resource usage (e.g., flip-flops, LUTs) against performance requirements. The component's design and verification involve extensive simulation and formal verification techniques to ensure compliance with the AXI protocol and to validate its functionality across a range of scenarios and configurations.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

library work;
    use work.olo_base_pkg_math.all;
    use work.olo_base_pkg_logic.all;
    use work.olo_axi_pkg_protocol.all;

entity olo_axi_master_simple is
    generic (
        AxiAddrWidth_g              : positive range 12 to 64  := 32;
        AxiDataWidth_g              : positive range 8 to 1024 := 32;
        AxiMaxBeats_g               : positive range 1 to 256  := 256;
        AxiMaxOpenTransactions_g    : positive range 1 to 8    := 8;
        UserTransactionSizeBits_g   : positive                 := 24;
        DataFifoDepth_g             : positive                 := 1024;
        ImplRead_g                  : boolean                  := true;
        ImplWrite_g                 : boolean                  := true;
        RamBehavior_g               : string                   := ""RBW""
    );
    port (
        Clk             : in    std_logic;
        Rst             : in    std_logic;
        CmdWr_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdWr_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdWr_LowLat    : in    std_logic                                                := '0';
        CmdWr_Valid     : in    std_logic                                                := '0';
        CmdWr_Ready     : out   std_logic;
        CmdRd_Addr      : in    std_logic_vector(AxiAddrWidth_g - 1 downto 0)            := (others => '0');
        CmdRd_Size      : in    std_logic_vector(UserTransactionSizeBits_g - 1 downto 0) := (others => '0');
        CmdRd_LowLat    : in    std_logic                                                := '0';
        CmdRd_Valid     : in    std_logic                                                := '0';
        CmdRd_Ready     : out   std_logic;
        Wr_Data         : in    std_logic_vector(AxiDataWidth_g - 1 downto 0)            := (others => '0');
        Wr_Be           : in    std_logic_vector(AxiDataWidth_g / 8 - 1 downto 0)        := (others => '0');
        Wr_Valid        : in    std_logic                                                := '0';
        Wr_Ready        : out   std_logic;
        Rd_Data         : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        Rd_Last         : out   std_logic;
        Rd_Valid        : out   std_logic;
        Rd_Ready        : in    std_logic                                                := '1';
        Wr_Done         : out   std_logic;
        Wr_Error        : out   std_logic;
        Rd_Done         : out   std_logic;
        Rd_Error        : out   std_logic;
        M_Axi_AwAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_AwLen     : out   std_logic_vector(7 downto 0);
        M_Axi_AwSize    : out   std_logic_vector(2 downto 0);
        M_Axi_AwBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_AwLock    : out   std_logic;
        M_Axi_AwCache   : out   std_logic_vector(3 downto 0);
        M_Axi_AwProt    : out   std_logic_vector(2 downto 0);
        M_Axi_AwValid   : out   std_logic;
        M_Axi_AwReady   : in    std_logic                                                := '0';
        M_Axi_WData     : out   std_logic_vector(AxiDataWidth_g - 1 downto 0);
        M_Axi_WStrb     : out   std_logic_vector(AxiDataWidth_g / 8 - 1 downto 0);
        M_Axi_WLast     : out   std_logic;
        M_Axi_WValid    : out   std_logic;
        M_Axi_WReady    : in    std_logic                                                := '0';
        M_Axi_BResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_BValid    : in    std_logic                                                := '0';
        M_Axi_BReady    : out   std_logic;
        M_Axi_ArAddr    : out   std_logic_vector(AxiAddrWidth_g - 1 downto 0);
        M_Axi_ArLen     : out   std_logic_vector(7 downto 0);
        M_Axi_ArSize    : out   std_logic_vector(2 downto 0);
        M_Axi_ArBurst   : out   std_logic_vector(1 downto 0);
        M_Axi_ArLock    : out   std_logic;
        M_Axi_ArCache   : out   std_logic_vector(3 downto 0);
        M_Axi_ArProt    : out   std_logic_vector(2 downto 0);
        M_Axi_ArValid   : out   std_logic;
        M_Axi_ArReady   : in    std_logic                                                := '0';
        M_Axi_RData     : in    std_logic_vector(AxiDataWidth_g - 1 downto 0)            := (others => '0');
        M_Axi_RResp     : in    std_logic_vector(1 downto 0)                             := (others => '0');
        M_Axi_RLast     : in    std_logic                                                := '0';
        M_Axi_RValid    : in    std_logic                                                := '0';
        M_Axi_RReady    : out   std_logic
    );
end entity;

architecture rtl of olo_axi_master_simple is

    constant UnusedAddrBits_c : natural := log2(AxiDataWidth_g / 8);

    constant BeatsBits_c     : natural := log2ceil(AxiMaxBeats_g + 1);
    constant MaxBeatsNoCmd_c : natural := max(AxiMaxBeats_g * AxiMaxOpenTransactions_g, DataFifoDepth_g);

    type WriteTfGen_t is (Idle_s, MaxCalc_s, GenTf_s, WriteTf_s);
    type ReadTfGen_t is (Idle_s, MaxCalc_s, GenTf_s, WriteTf_s);
    type AwFsm_t is (Idle_s, Wait_s);
    type ArFsm_t is (Idle_s, Wait_s);
    type WrFsm_t is (Idle_s, NonLast_s, Last_s);

    function addrMasked (Addr : in std_logic_vector) return std_logic_vector is
        variable Masked_v : std_logic_vector(Addr'range);
    begin
        Masked_v                                := Addr;
        Masked_v(UnusedAddrBits_c - 1 downto 0) := (others => '0');
        return Masked_v;
    end function;

    type TwoProcess_r is record
        CmdWr_Ready     : std_logic;
        Wr_Error        : std_logic;
        Wr_Done         : std_logic;
        WriteTfGenState : WriteTfGen_t;
        WrAddr          : unsigned(CmdWr_Addr'range);
        WrBeats         : unsigned(CmdWr_Size'range);
        WrLowLat        : std_logic;
        WrMaxBeats      : unsigned(BeatsBits_c - 1 downto 0);
        WrTfBeats       : unsigned(BeatsBits_c - 1 downto 0);
        WrTfVld         : std_logic;
        WrTfIsLast      : std_logic;
        AwFsm           : AwFsm_t;
        AwFsmRdy        : std_logic;
        AwCmdSent       : std_logic;
        AwCmdSize       : unsigned(BeatsBits_c - 1 downto 0);
        AwCmdSizeMin1   : unsigned(BeatsBits_c - 1 downto 0); -- AwCmdSize-1 for timing optimization reasons
        WDataFifoWrite  : std_logic;
        WFsm            : WrFsm_t;
        WDataFifoRd     : std_logic;
        WDataEna        : std_logic;
        WDataBeats      : unsigned(BeatsBits_c - 1 downto 0);
        WrRespError     : std_logic;
        WrOpenTrans     : integer range -1 to AxiMaxOpenTransactions_g;
        WrBeatsNoCmd    : signed(log2ceil(MaxBeatsNoCmd_c + 1) downto 0);
        M_Axi_AwAddr    : std_logic_vector(M_Axi_AwAddr'range);
        M_Axi_AwLen     : std_logic_vector(M_Axi_AwLen'range);
        M_Axi_AwValid   : std_logic;
        M_Axi_WLast     : std_logic;

        CmdRd_Ready     : std_logic;
        Rd_Error        : std_logic;
        Rd_Done         : std_logic;
        ReadTfGenState  : ReadTfGen_t;
        RdAddr          : unsigned(CmdRd_Addr'range);
        RdBeats         : unsigned(CmdRd_Size'range);
        RdLowLat        : std_logic;
        RdMaxBeats      : unsigned(BeatsBits_c - 1 downto 0);
        RdTfBeats       : unsigned(BeatsBits_c - 1 downto 0);
        RdTfVld         : std_logic;
        RdTfIsLast      : std_logic;
        ArFsm           : ArFsm_t;
        ArFsmRdy        : std_logic;
        ArCmdSent       : std_logic;
        ArCmdSize       : unsigned(BeatsBits_c - 1 downto 0);
        ArCmdSizeMin1   : unsigned(BeatsBits_c - 1 downto 0); -- ArCmdSize-1 for timing optimization reasons
        RDataFifoRead   : std_logic;
        RdRespError     : std_logic;
        RdOpenTrans     : unsigned(log2ceil(AxiMaxOpenTransactions_g + 1) - 1 downto 0);
        RdFifoSpaceFree : signed(log2ceil(MaxBeatsNoCmd_c + 1) downto 0);
        M_Axi_ArAddr    : std_logic_vector(M_Axi_ArAddr'range);
        M_Axi_ArLen     : std_logic_vector(M_Axi_ArLen'range);
        M_Axi_ArValid   : std_logic;
    end record;

    signal r, r_next : TwoProcess_r;

    signal WrDataFifoORdy    : std_logic;
    signal WrDataFifoOVld    : std_logic;
    signal WrTransFifoInVld  : std_logic;
    signal WrTransFifoBeats  : std_logic_vector(BeatsBits_c - 1 downto 0);
    signal WrTransFifoOutVld : std_logic;
    signal WrRespIsLast      : std_logic;
    signal WrRespFifoVld     : std_logic;
    signal WrData_Rdy_I      : std_logic;
    signal RdTransFifoInVld  : std_logic;
    signal RdRespIsLast      : std_logic;
    signal RdRespFifoVld     : std_logic;
    signal RdDat_Vld_I       : std_logic;
    signal RdRespLast        : std_logic;
    signal M_Axi_RReady_I    : std_logic;

begin

    assert AxiDataWidth_g mod 8 = 0
        report ""###ERROR###: olo_axi_master_simple AxiDataWidth_g must be a multiple of 8""
        severity failure;
    assert isPower2(AxiDataWidth_g/8)
        report ""###ERROR###: olo_axi_master_simple AxiDataWidth_g must be 2^X bytes""
        severity failure;
    assert UserTransactionSizeBits_g < AxiAddrWidth_g-log2(AxiDataWidth_g/8)
        report ""###ERROR###: olo_axi_master_simple UserTransactionSizeBits_g must be smaller than AxiAddrWidth_g-log2(AxiDataWidth_g/8), see documentation""
        severity failure;

    p_assert : process (Clk) is
    begin
        if rising_edge(Clk) then
            if ImplRead_g and RdRespLast = '1' then
                assert RdRespFifoVld = '1'
                    report ""###ERROR###: olo_axi_master_simple: Unexpected Read Response (RdRespFifo Empty)""
                    severity error;
            end if;
            if ImplWrite_g and M_Axi_BValid = '1' then
                assert WrRespFifoVld = '1'
                    report ""###ERROR###: olo_axi_master_simple: Unexpected Write Response (WrRespFifo Empty)""
                    severity error;
            end if;
        end if;
    end process;

    p_comb : process (r, M_Axi_AwReady, M_Axi_BValid, M_Axi_BResp, WrDataFifoORdy, WrDataFifoOVld, WrTransFifoOutVld,
                      WrTransFifoBeats, WrRespIsLast, WrRespFifoVld, CmdWr_Addr, CmdWr_Size, CmdWr_LowLat, CmdWr_Valid,
                      Wr_Valid, WrData_Rdy_I, M_Axi_ArReady, RdRespIsLast, RdRespFifoVld, RdRespLast, CmdRd_Addr,
                      CmdRd_Size, CmdRd_LowLat, CmdRd_Valid, Rd_Ready, RdDat_Vld_I, M_Axi_RResp) is
        variable v               : TwoProcess_r;
        variable WrMax4kBeats_v  : unsigned(13 - UnusedAddrBits_c downto 0);
        variable RdMax4kBeats_v  : unsigned(13 - UnusedAddrBits_c downto 0);
        variable Stdlv9Bit_v     : std_logic_vector(8 downto 0);
        variable WDataTransfer_v : boolean;
        variable StartWBurst_v   : boolean := true;
    begin
        v := r;

        if ImplWrite_g then

            WrMax4kBeats_v := (others => '0');

            case r.WriteTfGenState is
                when Idle_s =>
                    v.CmdWr_Ready := '1';
                    if (r.CmdWr_Ready = '1') and (CmdWr_Valid = '1') then
                        v.CmdWr_Ready     := '0';
                        v.WrAddr          := unsigned(addrMasked(CmdWr_Addr));
                        v.WrBeats         := unsigned(CmdWr_Size);
                        v.WrLowLat        := CmdWr_LowLat;
                        v.WriteTfGenState := MaxCalc_s;
                    end if;

                when MaxCalc_s =>
                    WrMax4kBeats_v := resize(unsigned('0' & not r.WrAddr(11 downto UnusedAddrBits_c)) + 1, WrMax4kBeats_v'length);
                    if WrMax4kBeats_v > AxiMaxBeats_g then
                        v.WrMaxBeats := to_unsigned(AxiMaxBeats_g, BeatsBits_c);
                    else
                        v.WrMaxBeats := WrMax4kBeats_v(BeatsBits_c - 1 downto 0);
                    end if;
                    v.WriteTfGenState := GenTf_s;

                when GenTf_s =>
                    if (r.WrMaxBeats < r.WrBeats) then
                        v.WrTfBeats  := r.WrMaxBeats;
                        v.WrTfIsLast := '0';
                    else
                        v.WrTfBeats  := r.WrBeats(BeatsBits_c - 1 downto 0);
                        v.WrTfIsLast := '1';
                    end if;
                    v.WrTfVld         := '1';
                    v.WriteTfGenState := WriteTf_s;

                when WriteTf_s =>
                    if (r.WrTfVld = '1') and (r.AwFsmRdy = '1') then
                        v.WrTfVld := '0';
                        v.WrBeats := r.WrBeats - r.WrTfBeats;
                        v.WrAddr  := r.WrAddr + resize(2**UnusedAddrBits_c * r.WrTfBeats, v.WrAddr'length);
                        if r.WrTfIsLast = '1' then
                            v.WriteTfGenState := Idle_s;
                        else
                            v.WriteTfGenState := MaxCalc_s;
                        end if;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.AwCmdSent := '0';

            case r.AwFsm is
                when Idle_s =>
                    if ((r.WrLowLat = '1') or (r.WrBeatsNoCmd >= signed('0' & r.WrTfBeats))) and
                       (r.WrOpenTrans < AxiMaxOpenTransactions_g) and (r.WrTfVld = '1') then
                        v.AwFsmRdy := '1';
                    end if;
                    if (r.AwFsmRdy = '1') and (r.WrTfVld = '1') then
                        v.AwFsmRdy      := '0';
                        v.M_Axi_AwAddr  := std_logic_vector(r.WrAddr);
                        Stdlv9Bit_v     := std_logic_vector(resize(r.WrTfBeats - 1, 9));
                        v.M_Axi_AwLen   := Stdlv9Bit_v(7 downto 0);
                        v.M_Axi_AwValid := '1';
                        v.AwFsm         := Wait_s;
                        v.AwCmdSent     := '1';
                        v.AwCmdSize     := r.WrTfBeats;
                        v.AwCmdSizeMin1 := r.WrTfBeats - 1;
                    end if;

                when Wait_s =>
                    if M_Axi_AwReady = '1' then
                        v.WrOpenTrans   := r.WrOpenTrans + 1;
                        v.M_Axi_AwValid := '0';
                        v.AwFsm         := Idle_s;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.WDataFifoWrite := WrData_Rdy_I and Wr_Valid;
            if r.AwCmdSent = '1' then
                if r.WDataFifoWrite = '1' then
                    v.WrBeatsNoCmd := r.WrBeatsNoCmd - signed('0' & r.AwCmdSizeMin1); -- Decrement by size and increment by one (timing opt)
                else
                    v.WrBeatsNoCmd := r.WrBeatsNoCmd - signed('0' & r.AwCmdSize);
                end if;
            elsif r.WDataFifoWrite = '1' then
                v.WrBeatsNoCmd := r.WrBeatsNoCmd + 1;
            end if;

            WDataTransfer_v := (r.WDataEna = '1') and (WrDataFifoOVld = '1') and (WrDataFifoORdy = '1');
            v.WDataFifoRd   := '0';
            StartWBurst_v   := false;

            case r.WFsm is
                when Idle_s =>
                    if WrTransFifoOutVld = '1' then
                        StartWBurst_v := true;      -- shared code
                    end if;

                when NonLast_s =>
                    if WDataTransfer_v then
                        if r.WDataBeats = 2 then
                            v.M_Axi_WLast := '1';
                            v.WFsm        := Last_s;
                        end if;
                        v.WDataBeats := r.WDataBeats - 1;
                    end if;

                when Last_s =>
                    if WDataTransfer_v then
                        if (WrTransFifoOutVld = '1') and (r.WDataFifoRd = '0') then
                            StartWBurst_v := true;    -- shared code
                        else
                            v.WDataEna    := '0';
                            v.WFsm        := Idle_s;
                            v.M_Axi_WLast := '0';
                        end if;
                    end if;

                when others => null; -- unreachable code

            end case;

            if StartWBurst_v then
                v.WDataFifoRd := '1';
                v.WDataEna    := '1';
                v.WDataBeats  := unsigned(WrTransFifoBeats);
                if unsigned(WrTransFifoBeats) = 1 then
                    v.M_Axi_WLast := '1';
                    v.WFsm        := Last_s;
                else
                    v.M_Axi_WLast := '0';
                    v.WFsm        := NonLast_s;
                end if;
            end if;

            v.Wr_Done  := '0';
            v.Wr_Error := '0';

            if M_Axi_BValid = '1' then
                v.WrOpenTrans := v.WrOpenTrans - 1; -- Use v. because it may have been modified above and this modification has not to be overriden
                if WrRespIsLast = '1' then
                    if (M_Axi_BResp /= AxiResp_Okay_c) then
                        v.Wr_Error := '1';
                    else
                        v.Wr_Error    := r.WrRespError;
                        v.Wr_Done     := not r.WrRespError;
                        v.WrRespError := '0';
                    end if;
                elsif M_Axi_BResp /= AxiResp_Okay_c then
                    v.WrRespError := '1';
                end if;
            end if;

        end if;

        if ImplRead_g then

            RdMax4kBeats_v := (others => '0');

            case r.ReadTfGenState is
                when Idle_s =>
                    v.CmdRd_Ready := '1';
                    if (r.CmdRd_Ready = '1') and (CmdRd_Valid = '1') then
                        v.CmdRd_Ready    := '0';
                        v.RdAddr         := unsigned(addrMasked(CmdRd_Addr));
                        v.RdBeats        := unsigned(CmdRd_Size);
                        v.RdLowLat       := CmdRd_LowLat;
                        v.ReadTfGenState := MaxCalc_s;
                    end if;

                when MaxCalc_s =>
                    RdMax4kBeats_v := resize(unsigned('0' & not r.RdAddr(11 downto UnusedAddrBits_c)) + 1, RdMax4kBeats_v'length);
                    if RdMax4kBeats_v > AxiMaxBeats_g then
                        v.RdMaxBeats := to_unsigned(AxiMaxBeats_g, BeatsBits_c);
                    else
                        v.RdMaxBeats := RdMax4kBeats_v(BeatsBits_c - 1 downto 0);
                    end if;
                    v.ReadTfGenState := GenTf_s;

                when GenTf_s =>
                    if (r.RdMaxBeats < r.RdBeats) then
                        v.RdTfBeats  := r.RdMaxBeats;
                        v.RdTfIsLast := '0';
                    else
                        v.RdTfBeats  := r.RdBeats(BeatsBits_c - 1 downto 0);
                        v.RdTfIsLast := '1';
                    end if;
                    v.RdTfVld        := '1';
                    v.ReadTfGenState := WriteTf_s;

                when WriteTf_s =>
                    if (r.RdTfVld = '1') and (r.ArFsmRdy = '1') then
                        v.RdTfVld := '0';
                        v.RdBeats := r.RdBeats - r.RdTfBeats;
                        v.RdAddr  := r.RdAddr + resize(2**UnusedAddrBits_c * r.RdTfBeats, v.RdAddr'length);
                        if r.RdTfIsLast = '1' then
                            v.ReadTfGenState := Idle_s;
                        else
                            v.ReadTfGenState := MaxCalc_s;
                        end if;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.ArCmdSent := '0';

            case r.ArFsm is
                when Idle_s =>
                    if ((r.RdLowLat = '1') or (r.RdFifoSpaceFree >= signed('0' & r.RdTfBeats))) and
                       (r.RdOpenTrans < AxiMaxOpenTransactions_g) and (r.RdTfVld = '1') then
                        v.ArFsmRdy := '1';
                    end if;
                    if (r.ArFsmRdy = '1') and (r.RdTfVld = '1') then
                        v.ArFsmRdy      := '0';
                        v.M_Axi_ArAddr  := std_logic_vector(r.RdAddr);
                        Stdlv9Bit_v     := std_logic_vector(resize(r.RdTfBeats - 1, 9));
                        v.M_Axi_ArLen   := Stdlv9Bit_v(7 downto 0);
                        v.M_Axi_ArValid := '1';
                        v.ArFsm         := Wait_s;
                        v.ArCmdSent     := '1';
                        v.ArCmdSize     := r.RdTfBeats;
                        v.ArCmdSizeMin1 := r.RdTfBeats - 1;
                    end if;

                when Wait_s =>
                    if M_Axi_ArReady = '1' then
                        v.RdOpenTrans   := r.RdOpenTrans + 1;
                        v.M_Axi_ArValid := '0';
                        v.ArFsm         := Idle_s;
                    end if;

                when others => null; -- unreachable code

            end case;

            v.RDataFifoRead := Rd_Ready and RdDat_Vld_I;
            if r.ArCmdSent = '1' then
                if r.RDataFifoRead = '1' then
                    v.RdFifoSpaceFree := r.RdFifoSpaceFree - signed('0' & r.ArCmdSizeMin1); -- Decrement by size and increment by one (timing opt)
                else
                    v.RdFifoSpaceFree := r.RdFifoSpaceFree - signed('0' & r.ArCmdSize);
                end if;
            elsif r.RDataFifoRead = '1' then
                v.RdFifoSpaceFree := r.RdFifoSpaceFree + 1;
            end if;

            v.Rd_Done  := '0';
            v.Rd_Error := '0';

            if RdRespLast = '1' then
                v.RdOpenTrans := v.RdOpenTrans - 1; -- Use v. because it may have been modified above and this modification has not to be overriden
                if RdRespIsLast = '1' then
                    if (M_Axi_RResp /= AxiResp_Okay_c) then
                        v.Rd_Error := '1';
                    else
                        v.Rd_Error    := r.RdRespError;
                        v.Rd_Done     := not r.RdRespError;
                        v.RdRespError := '0';
                    end if;
                elsif M_Axi_RResp /= AxiResp_Okay_c then
                    v.RdRespError := '1';
                end if;
            end if;

        end if;

        r_next <= v;
    end process;

    p_reg : process (Clk) is
    begin
        if rising_edge(Clk) then
            r <= r_next;
            if Rst = '1' then
                if ImplWrite_g then
                    r.CmdWr_Ready     <= '0';
                    r.WriteTfGenState <= Idle_s;
                    r.WrTfVld         <= '0';
                    r.AwFsm           <= Idle_s;
                    r.AwFsmRdy        <= '0';
                    r.AwCmdSent       <= '0';
                    r.M_Axi_AwValid   <= '0';
                    r.WDataFifoRd     <= '0';
                    r.WDataEna        <= '0';
                    r.WrOpenTrans     <= 0;
                    r.WrRespError     <= '0';
                    r.Wr_Done         <= '0';
                    r.Wr_Error        <= '0';
                    r.WrBeatsNoCmd    <= (others => '0');
                    r.WFsm            <= Idle_s;
                    r.WDataFifoWrite  <= '0';
                end if;
                if ImplRead_g then
                    r.CmdRd_Ready     <= '0';
                    r.ReadTfGenState  <= Idle_s;
                    r.RdTfVld         <= '0';
                    r.ArFsmRdy        <= '0';
                    r.ArCmdSent       <= '0';
                    r.M_Axi_ArValid   <= '0';
                    r.ArFsm           <= Idle_s;
                    r.RdOpenTrans     <= (others => '0');
                    r.RdRespError     <= '0';
                    r.Rd_Done         <= '0';
                    r.Rd_Error        <= '0';
                    r.RdFifoSpaceFree <= to_signed(DataFifoDepth_g, r.RdFifoSpaceFree'length);
                    r.RDataFifoRead   <= '0';
                end if;
            end if;
        end if;
    end process;

    CmdWr_Ready   <= r.CmdWr_Ready;
    M_Axi_AwAddr  <= r.M_Axi_AwAddr;
    M_Axi_AwLen   <= r.M_Axi_AwLen;
    M_Axi_AwValid <= r.M_Axi_AwValid;
    M_Axi_WLast   <= r.M_Axi_WLast;
    Wr_Done       <= r.Wr_Done;
    Wr_Error      <= r.Wr_Error;
    CmdRd_Ready   <= r.CmdRd_Ready;
    M_Axi_ArAddr  <= r.M_Axi_ArAddr;
    M_Axi_ArLen   <= r.M_Axi_ArLen;
    M_Axi_ArValid <= r.M_Axi_ArValid;
    Rd_Done       <= r.Rd_Done;
    Rd_Error      <= r.Rd_Error;

    M_Axi_AwSize  <= std_logic_vector(to_unsigned(log2(AxiDataWidth_g / 8), 3));
    M_Axi_ArSize  <= std_logic_vector(to_unsigned(log2(AxiDataWidth_g / 8), 3));
    M_Axi_AwBurst <= AxiBurst_Incr_c;
    M_Axi_ArBurst <= AxiBurst_Incr_c;
    M_Axi_AwCache <= ""0011"";              -- According AXI reference guide
    M_Axi_ArCache <= ""0011"";              -- According AXI reference guide
    M_Axi_AwProt  <= ""000"";               -- According AXI reference guide
    M_Axi_ArProt  <= ""000"";               -- According AXI reference guide
    M_Axi_AwLock  <= '0';                 -- Exclusive access support not implemented
    M_Axi_ArLock  <= '0';                 -- Exclusive access support not implemented
    M_Axi_BReady  <= '1' when ImplWrite_g else '0';


    g_write : if ImplWrite_g generate

        WrTransFifoInVld <= r.AwFsmRdy and r.WrTfVld;

        i_fifo_wr_trans : entity work.olo_base_fifo_sync
            generic map (
                Width_g        => BeatsBits_c,
                Depth_g        => AxiMaxOpenTransactions_g,
                RamBehavior_g  => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data     => std_logic_vector(r.WrTfBeats),
                In_Valid    => WrTransFifoInVld,
                In_Ready    => open,                  -- Not required since maximum of open transactions is limitted
                Out_Data    => WrTransFifoBeats,
                Out_Valid   => WrTransFifoOutVld,
                Out_Ready   => r.WDataFifoRd
            );

        b_fifo_wr_data : block is
            signal InData  : std_logic_vector(Wr_Data'length + Wr_Be'length - 1 downto 0);
            signal OutData : std_logic_vector(InData'range);
        begin
            InData(Wr_Data'high downto Wr_Data'low)                     <= Wr_Data;
            InData(Wr_Data'high + Wr_Be'length downto Wr_Data'high + 1) <= Wr_Be;

            i_fifo_wr_data : entity work.olo_base_fifo_sync
                generic map (
                    Width_g         => Wr_Data'length + Wr_Be'length,
                    Depth_g         => DataFifoDepth_g,
                    RamBehavior_g   => RamBehavior_g
                )
                port map (
                    Clk         => Clk,
                    Rst         => Rst,
                    In_Data     => InData,
                    In_Valid    => Wr_Valid,
                    In_Ready    => WrData_Rdy_I,
                    Out_Data    => OutData,
                    Out_Valid   => WrDataFifoOVld,
                    Out_Ready   => WrDataFifoORdy
                );

            M_Axi_WData    <= OutData(Wr_Data'high downto Wr_Data'low);
            M_Axi_WStrb    <= OutData(Wr_Data'high + Wr_Be'length downto Wr_Data'high + 1);
            M_Axi_WValid   <= WrDataFifoOVld and r.WDataEna;
            WrDataFifoORdy <= M_Axi_WReady and r.WDataEna;
            Wr_Ready       <= WrData_Rdy_I;
        end block;

        i_fifo_wr_resp : entity work.olo_base_fifo_sync
            generic map (
                Width_g        => 1,
                Depth_g        => AxiMaxOpenTransactions_g,
                RamBehavior_g  => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data(0)  => r.WrTfIsLast,
                In_Valid    => WrTransFifoInVld,
                In_Ready    => open,               -- Not required since maximum of open transactions is limitted
                Out_Data(0) => WrRespIsLast,
                Out_Valid   => WrRespFifoVld,
                Out_Ready   => M_Axi_BValid
            );

    end generate;

    g_nwrite : if not ImplWrite_g generate
        M_Axi_WStrb  <= (others => '0');
        M_Axi_WData  <= (others => '0');
        M_Axi_WValid <= '0';
        Wr_Ready     <= '0';
    end generate;

    g_read : if ImplRead_g generate

        b_fifo_rd_data : block is
            signal InData, OutData : std_logic_vector(Rd_Data'length downto 0);
        begin
            InData(M_Axi_RData'high downto 0) <= M_Axi_RData;
            InData(M_Axi_RData'high + 1) <= M_Axi_RLast and RdRespIsLast;

            i_fifo_rd_data : entity work.olo_base_fifo_sync
                generic map (
                    Width_g        => Rd_Data'length+1,
                    Depth_g        => DataFifoDepth_g,
                    RamBehavior_g  => RamBehavior_g
                )
                port map (
                    Clk         => Clk,
                    Rst         => Rst,
                    In_Data     => InData,
                    In_Valid    => M_Axi_RValid,
                    In_Ready    => M_Axi_RReady_I,
                    Out_Data    => OutData,
                    Out_Valid   => RdDat_Vld_I,
                    Out_Ready   => Rd_Ready
                );

            Rd_Data      <= OutData(Rd_Data'high downto 0);
            Rd_Last      <= OutData(Rd_Data'high+1);
            Rd_Valid     <= RdDat_Vld_I;
            M_Axi_RReady <= M_Axi_RReady_I;
        end block;

        RdTransFifoInVld <= r.ArFsmRdy and r.RdTfVld;
        RdRespLast       <= M_Axi_RValid and M_Axi_RReady_I and M_Axi_RLast;

        i_fifo_rd_resp : entity work.olo_base_fifo_sync
            generic map (
                Width_g        => 1,
                Depth_g        => AxiMaxOpenTransactions_g,
                RamBehavior_g  => RamBehavior_g
            )
            port map (
                Clk         => Clk,
                Rst         => Rst,
                In_Data(0)  => r.RdTfIsLast,
                In_Valid    => RdTransFifoInVld,
                In_Ready    => open,               -- Not required since maximum of open transactions is limitted
                Out_Data(0) => RdRespIsLast,
                Out_Valid   => RdRespFifoVld,
                Out_Ready   => RdRespLast
            );

    end generate;

    g_nread : if not ImplRead_g generate
        M_Axi_RReady <= '0';
        Rd_Data      <= (others => '0');
        Rd_Valid     <= '0';
    end generate;

end architecture;"
"defines a package and its body for AXI (Advanced eXtensible Interface) protocol constants. Although it does not describe a specific component, it provides essential definitions for working with AXI interfaces. This analysis will cover the package's contents, its role in larger systems, and the implications of its definitions on component design. The package, `olo_axi_pkg_protocol`, is a collection of type definitions and constants for AXI protocol signals. Its primary purpose is to standardize and simplify the use of AXI-related types and values across a design. The package is likely used in the development of AXI-compliant components, such as masters, slaves, or interconnects, to ensure adherence to the AXI protocol. The package defines several subtypes and constants for AXI response, burst, and size signals. The `Resp_t` subtype, a 2-bit vector, represents the response type from a slave to a master. The defined constants, such as `AxiResp_Okay_c`, `AxiResp_ExOkay_c`, `AxiResp_SlvErr_c`, and `AxiResp_DecErr_c`, correspond to the AXI protocol's response values, indicating successful completion, exclusive access completion, slave error, and decode error, respectively. These constants help ensure that components communicate correctly and respond appropriately to transactions. The `Burst_t` subtype, also a 2-bit vector, defines the burst type for AXI transactions. The constants `AxiBurst_Fixed_c`, `AxiBurst_Incr_c`, and `AxiBurst_Wrap_c` represent fixed, incrementing, and wrapping burst types, respectively. These burst types determine how the address changes during a burst transaction, affecting how components interact with memory or other slaves. The `Size_t` subtype, a 3-bit vector, represents the size of a transaction in bytes. The defined constants, ranging from `AxiSize_1_c` to `AxiSize_128_c`, correspond to transaction sizes of 1 to 128 bytes. These size values are crucial for determining the data transfer width and the number of beats in a burst transaction. The internal structure of this package is straightforward, consisting of type definitions and constant declarations. There are no state machines, counters, or registers, as this package is primarily a collection of constants and types. The functional behavior of components using this package is influenced by the defined constants and types. When designing an AXI master or slave, for example, the `Resp_t` and `Burst_t` types, along with their associated constants, dictate how the component responds to and initiates transactions. The `Size_t` type and its constants determine the data transfer size and the number of beats in a burst. Control logic in components utilizing this package would rely on the defined constants to generate control signals, enable conditions, and manage state transitions. For instance, a slave component might use the `Resp_t` constants to generate response signals based on the outcome of a transaction. Data flow through components using this package is influenced by the transaction size and burst type. The `Size_t` and `Burst_t` types determine how data is transferred and how addresses are incremented or wrapped during a burst. Timing and synchronization in components are critical when working with AXI interfaces. The package does not directly address clock domains, setup/hold requirements, or timing constraints, but components designed using these types and constants must adhere to AXI protocol timing requirements. A special feature of this package is its focus on AXI protocol constants, making it a valuable resource for designers working with AXI interfaces. The package's definitions enable designers to create components that seamlessly interact with other AXI-compliant components. This package is typically used in the development of AXI-compliant components, such as system-on-chip (SoC) designs, peripherals, or interconnects. Its use cases include the creation of AXI masters, slaves, and bridges, which are essential in complex digital systems. When implementing components using this package, designers must consider performance, resource usage, and design trade-offs. The use of standardized types and constants can improve design efficiency and reduce errors. However, the specific implementation details depend on the component's requirements and the target technology. In conclusion, the `olo_axi_pkg_protocol` package provides a comprehensive set of type definitions and constants for working with AXI interfaces. Its contents enable designers to create AXI-compliant components that interact correctly and efficiently. By understanding the implications of these definitions on component design, designers can develop high-performance, AXI-compliant systems.","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

package olo_axi_pkg_protocol is

    subtype Resp_t is std_logic_vector(1 downto 0);
    constant AxiResp_Okay_c   : Resp_t := ""00"";
    constant AxiResp_ExOkay_c : Resp_t := ""01"";
    constant AxiResp_SlvErr_c : Resp_t := ""10"";
    constant AxiResp_DecErr_c : Resp_t := ""11"";

    subtype Burst_t is std_logic_vector(1 downto 0);
    constant AxiBurst_Fixed_c : Burst_t := ""00"";
    constant AxiBurst_Incr_c  : Burst_t := ""01"";
    constant AxiBurst_Wrap_c  : Burst_t := ""10"";

    subtype Size_t is std_logic_vector(2 downto 0);
    constant AxiSize_1_c   : Size_t := ""000"";
    constant AxiSize_2_c   : Size_t := ""001"";
    constant AxiSize_4_c   : Size_t := ""010"";
    constant AxiSize_8_c   : Size_t := ""011"";
    constant AxiSize_16_c  : Size_t := ""100"";
    constant AxiSize_32_c  : Size_t := ""101"";
    constant AxiSize_64_c  : Size_t := ""110"";
    constant AxiSize_128_c : Size_t := ""111"";

end package;

package body olo_axi_pkg_protocol is

end package body;"
"defines an AXI (Advanced eXtensible Interface) pipeline stage component, specifically designed to handle the complexities of AXI protocol. This component, referred to as `olo_axi_pl_stage`, acts as a bridge between the slave and master interfaces of an AXI system, facilitating the pipelining of AXI transactions. **Component Overview** The `olo_axi_pl_stage` component is a generic, synchronous AXI pipeline stage designed to handle AXI4 and AXI4-Lite protocols. It provides a configurable number of pipeline stages for various AXI channels, including AW (Address Write), W (Write Data), B (Write Response), AR (Address Read), and R (Read Data). The component's primary purpose is to decouple the timing requirements of the AXI slave and master interfaces, enabling the design of complex systems with multiple clock domains. **Detailed Input/Output Analysis** The component features a comprehensive set of input and output ports, each serving a specific purpose: * **Clock and Reset**: The component receives a clock signal (`Clk`) and an asynchronous reset signal (`Rst`), which control the pipeline's operation and data flow. * **AXI Slave Interface**: The component receives AXI transactions from the slave interface through ports such as `S_AwId`, `S_AwAddr`, `S_AwValid`, `S_WData`, `S_WValid`, and `S_ArId`, `S_ArAddr`, `S_ArValid`. These ports are associated with the AW, W, and AR channels. * **AXI Master Interface**: The component transmits AXI transactions to the master interface through ports such as `M_AwId`, `M_AwAddr`, `M_AwValid`, `M_WData`, `M_WValid`, and `M_ArId`, `M_ArAddr`, `M_ArValid`. These ports are associated with the AW, W, and AR channels. * **Response and Data**: The component handles response and data signals for both the slave and master interfaces, including `S_BId`, `S_BResp`, `S_BValid`, `M_BId`, `M_BResp`, `M_BValid`, `S_RId`, `S_RData`, `S_RValid`, and `M_RId`, `M_RData`, `M_RValid`. Each port has specific bit widths and timing requirements based on the AXI protocol and the component's configuration. **Architectural Description** The component's architecture consists of several blocks, each dedicated to a specific AXI channel or function: * **Blocks for AW, W, B, AR, and R Channels**: The architecture comprises blocks `b_aw`, `b_w`, `b_b`, `b_ar`, and `b_r`, each handling a specific AXI channel. These blocks contain: * Subtype declarations for signal ranges, defining the bit positions for various signal fields. * Signal declarations for input and output data. * Assignments to connect input signals to internal signals. * Instantiations of the `olo_base_pl_stage` entity, which implements the pipelining logic. * Assignments to connect internal signals to output ports. The `olo_base_pl_stage` entity is a key component in the design, providing a generic pipeline stage implementation. **Functional Behavior** The component operates as follows: 1. **Pipeline Stages**: The component provides a configurable number of pipeline stages (`Stages_g`) for each AXI channel. This allows for flexible timing control and decoupling of the slave and master interfaces. 2. **Data Flow**: Data flows through the component's blocks, which are associated with specific AXI channels. Each block processes the input data, applies pipelining, and generates output signals. 3. **Ready and Valid Handshake**: The component uses the ready and valid handshake protocol to control data flow between the slave and master interfaces. **Control Logic** The component's control logic is primarily implemented within the `olo_base_pl_stage` entity. This entity likely contains state machines, counters, and registers to manage the pipelining process. The control logic handles: * **Enable Conditions**: The component generates enable signals to control data flow through the pipeline stages. * **Reset Behavior**: The component responds to the asynchronous reset signal (`Rst`) by resetting internal state machines and registers. * **State Transitions**: The component's state machines manage the pipeline stages, transitioning between states based on input signals and the current state. **Data Flow** Data flows through the component as follows: * **Input Data**: The component receives input data from the slave interface. * **Pipelining**: The data is processed and pipelined through the component's blocks. * **Output Data**: The pipelined data is transmitted to the master interface. **Timing and Synchronization** The component operates in a synchronous clock domain, with the clock signal (`Clk`) controlling the pipeline's operation. The component's timing constraints include: * **Setup and Hold Requirements**: The component adheres to standard setup and hold requirements for synchronous logic. * **Clock Domains**: The component is designed to handle multiple clock domains, enabling the design of complex systems. **Special Features** The component features: * **Configurable Pipeline Stages**: The component allows for a configurable number of pipeline stages (`Stages_g`), enabling flexible design optimization. * **Support for AXI4 and AXI4-Lite**: The component is designed to handle both AXI4 and AXI4-Lite protocols. **Applications and Use Cases** The `olo_axi_pl_stage` component is suitable for various applications, including: * **AXI-Based SoC Design**: The component can be used in the design of complex Systems-on-Chip (SoCs) that utilize AXI as the","

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity olo_axi_pl_stage is
    generic (
        AddrWidth_g : positive := 32;
        DataWidth_g : positive := 32;
        IdWidth_g   : natural  := 0;
        UserWidth_g : natural  := 0;
        Stages_g    : positive := 1
    );
    port (
        Clk        : in    std_logic;
        Rst        : in    std_logic;

        S_AwId     : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        S_AwAddr   : in    std_logic_vector(AddrWidth_g - 1 downto 0);
        S_AwValid  : in    std_logic;
        S_AwReady  : out   std_logic;
        S_AwLen    : in    std_logic_vector(7 downto 0)               := (others => '0');
        S_AwSize   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_AwBurst  : in    std_logic_vector(1 downto 0)               := (others => '0');
        S_AwLock   : in    std_logic                                  := '0';
        S_AwCache  : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_AwProt   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_AwQos    : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_AwUser   : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        S_AwRegion : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_WData    : in    std_logic_vector(DataWidth_g - 1 downto 0);
        S_WStrb    : in    std_logic_vector(DataWidth_g / 8 - 1 downto 0);
        S_WValid   : in    std_logic;
        S_WReady   : out   std_logic;
        S_WLast    : in    std_logic                                  := '1';
        S_WUser    : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        S_BId      : out   std_logic_vector(IdWidth_g - 1 downto 0);
        S_BResp    : out   std_logic_vector(1 downto 0);
        S_BValid   : out   std_logic;
        S_BReady   : in    std_logic;
        S_BUser    : out   std_logic_vector(UserWidth_g - 1 downto 0);
        S_ArId     : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        S_ArAddr   : in    std_logic_vector(AddrWidth_g - 1 downto 0);
        S_ArValid  : in    std_logic;
        S_ArReady  : out   std_logic;
        S_ArLen    : in    std_logic_vector(7 downto 0)               := (others => '0');
        S_ArSize   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_ArBurst  : in    std_logic_vector(1 downto 0)               := (others => '0');
        S_ArLock   : in    std_logic;
        S_ArCache  : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_ArProt   : in    std_logic_vector(2 downto 0)               := (others => '0');
        S_ArQos    : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_ArUser   : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        S_ArRegion : in    std_logic_vector(3 downto 0)               := (others => '0');
        S_RId      : out   std_logic_vector(IdWidth_g - 1 downto 0);
        S_RData    : out   std_logic_vector(DataWidth_g - 1 downto 0);
        S_RValid   : out   std_logic;
        S_RReady   : in    std_logic;
        S_RResp    : out   std_logic_vector(1 downto 0);
        S_RLast    : out   std_logic;
        S_RUser    : out   std_logic_vector(UserWidth_g - 1 downto 0);

        M_AwId     : out   std_logic_vector(IdWidth_g - 1 downto 0);
        M_AwAddr   : out   std_logic_vector(AddrWidth_g - 1 downto 0);
        M_AwValid  : out   std_logic;
        M_AwReady  : in    std_logic;
        M_AwLen    : out   std_logic_vector(7 downto 0);
        M_AwSize   : out   std_logic_vector(2 downto 0);
        M_AwBurst  : out   std_logic_vector(1 downto 0);
        M_AwLock   : out   std_logic;
        M_AwCache  : out   std_logic_vector(3 downto 0);
        M_AwProt   : out   std_logic_vector(2 downto 0);
        M_AwQos    : out   std_logic_vector(3 downto 0);
        M_AwUser   : out   std_logic_vector(UserWidth_g - 1 downto 0);
        M_AwRegion : out   std_logic_vector(3 downto 0);
        M_WData    : out   std_logic_vector(DataWidth_g - 1 downto 0);
        M_WStrb    : out   std_logic_vector(DataWidth_g / 8 - 1 downto 0);
        M_WValid   : out   std_logic;
        M_WReady   : in    std_logic;
        M_WLast    : out   std_logic;
        M_WUser    : out   std_logic_vector(UserWidth_g - 1 downto 0);
        M_BId      : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        M_BResp    : in    std_logic_vector(1 downto 0);
        M_BValid   : in    std_logic;
        M_BReady   : out   std_logic;
        M_BUser    : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0');
        M_ArId     : out   std_logic_vector(IdWidth_g - 1 downto 0);
        M_ArAddr   : out   std_logic_vector(AddrWidth_g - 1 downto 0);
        M_ArValid  : out   std_logic;
        M_ArReady  : in    std_logic;
        M_ArLen    : out   std_logic_vector(7 downto 0);
        M_ArSize   : out   std_logic_vector(2 downto 0);
        M_ArBurst  : out   std_logic_vector(1 downto 0);
        M_ArLock   : out   std_logic;
        M_ArCache  : out   std_logic_vector(3 downto 0);
        M_ArProt   : out   std_logic_vector(2 downto 0);
        M_ArQos    : out   std_logic_vector(3 downto 0);
        M_ArUser   : out   std_logic_vector(UserWidth_g - 1 downto 0);
        M_ArRegion : out   std_logic_vector(3 downto 0);
        M_RId      : in    std_logic_vector(IdWidth_g - 1 downto 0)   := (others => '0');
        M_RData    : in    std_logic_vector(DataWidth_g - 1 downto 0);
        M_RValid   : in    std_logic;
        M_RReady   : out   std_logic;
        M_RResp    : in    std_logic_vector(1 downto 0);
        M_RLast    : in    std_logic                                  := '1';
        M_RUser    : in    std_logic_vector(UserWidth_g - 1 downto 0) := (others => '0')
    );
end entity;

architecture rtl of olo_axi_pl_stage is

begin

    b_aw : block is
        subtype  AwProtRng_c   is natural range S_AwProt'length-1                   downto 0;
        subtype  AwCacheRng_c  is natural range S_AwCache'length+AwProtRng_c'high   downto AwProtRng_c'high+1;
        constant AwLockIdx_C : natural := AwCacheRng_c'high+1;
        subtype  AwBurstRng_c  is natural range S_AwBurst'length+AwLockIdx_C          downto AwLockIdx_C+1;
        subtype  AwSizeRng_c   is natural range S_AwSize'length+AwBurstRng_c'high   downto AwBurstRng_c'high+1;
        subtype  AwLenRng_c    is natural range S_AwLen'length+AwSizeRng_c'high     downto AwSizeRng_c'high+1;
        subtype  AwAddrRng_c   is natural range S_AwAddr'length+AwLenRng_c'high     downto AwLenRng_c'high+1;
        subtype  AwIdRng_c     is natural range S_AwId'length+AwAddrRng_c'high      downto AwAddrRng_c'high+1;
        subtype  AwQosRng_c    is natural range S_AwQos'length+AwIdRng_c'high       downto AwIdRng_c'high+1;
        subtype  AwUserRng_c   is natural range S_AwUser'length+AwQosRng_c'high     downto AwQosRng_c'high+1;
        subtype  AwRegionRng_c is natural range S_AwRegion'length+AwUserRng_c'high  downto AwUserRng_c'high+1;

        signal AwDataIn, AwDataOut : std_logic_vector(AwRegionRng_c'high downto 0);
    begin
        AwDataIn(AwProtRng_c)   <= S_AwProt;
        AwDataIn(AwCacheRng_c)  <= S_AwCache;
        AwDataIn(AwLockIdx_C)   <= S_AwLock;
        AwDataIn(AwBurstRng_c)  <= S_AwBurst;
        AwDataIn(AwSizeRng_c)   <= S_AwSize;
        AwDataIn(AwLenRng_c)    <= S_AwLen;
        AwDataIn(AwAddrRng_c)   <= S_AwAddr;
        AwDataIn(AwIdRng_c)     <= S_AwId;
        AwDataIn(AwQosRng_c)    <= S_AwQos;
        AwDataIn(AwUserRng_c)   <= S_AwUser;
        AwDataIn(AwRegionRng_c) <= S_AwRegion;

        i_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => AwDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => S_AwValid,
                In_Ready   => S_AwReady,
                In_Data    => AwDataIn,
                Out_Valid  => M_AwValid,
                Out_Ready  => M_AwReady,
                Out_Data   => AwDataOut
            );

        M_AwProt   <= AwDataOut(AwProtRng_c);
        M_AwCache  <= AwDataOut(AwCacheRng_c);
        M_AwLock   <= AwDataOut(AwLockIdx_C);
        M_AwBurst  <= AwDataOut(AwBurstRng_c);
        M_AwSize   <= AwDataOut(AwSizeRng_c);
        M_AwLen    <= AwDataOut(AwLenRng_c);
        M_AwAddr   <= AwDataOut(AwAddrRng_c);
        M_AwId     <= AwDataOut(AwIdRng_c);
        M_AwQos    <= AwDataOut(AwQosRng_c);
        M_AwUser   <= AwDataOut(AwUserRng_c);
        M_AwRegion <= AwDataOut(AwRegionRng_c);
    end block;

    b_w : block is
        subtype  WDataRng_c is natural range S_WData'length-1              downto 0;
        subtype  WStrbRng_c is natural range S_WStrb'length+WDataRng_c'high  downto WDataRng_c'high+1;
        constant WLastIdx_c : natural := WStrbRng_c'high+1;
        subtype  WUserRng_c is natural range S_WUser'length+WLastIdx_c       downto WLastIdx_c+1;

        signal WDataIn, WDataOut : std_logic_vector(WUserRng_c'high downto 0);
    begin

        WDataIn(WDataRng_c) <= S_WData;
        WDataIn(WStrbRng_c) <= S_WStrb;
        WDataIn(WLastIdx_c) <= S_WLast;
        WDataIn(WUserRng_c) <= S_WUser;

        i_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => WDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => S_WValid,
                In_Ready   => S_WReady,
                In_Data    => WDataIn,
                Out_Valid  => M_WValid,
                Out_Ready  => M_WReady,
                Out_Data   => WDataOut
            );

        M_WLast <= WDataOut(WLastIdx_c);
        M_WStrb <= WDataOut(WStrbRng_c);
        M_WData <= WDataOut(WDataRng_c);
        M_WUser <= WDataOut(WUserRng_c);
    end block;

    b_b : block is
        subtype BRespRng_c is natural range S_BResp'length-1           downto 0;
        subtype BIdRng_c   is natural range S_BId'length+BRespRng_c'high downto BRespRng_c'high+1;
        subtype BuserRng_c is natural range S_BUser'length+BIdRng_c'high downto BIdRng_c'high+1;

        signal BDataIn, BDataOut : std_logic_vector(BuserRng_c'high downto 0);
    begin
        BDataIn(BIdRng_c)   <= M_BId;
        BDataIn(BRespRng_c) <= M_BResp;
        BDataIn(BuserRng_c) <= M_BUser;

        i_bch_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => BDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => M_BValid,
                In_Ready   => M_BReady,
                In_Data    => BDataIn,
                Out_Valid  => S_BValid,
                Out_Ready  => S_BReady,
                Out_Data   => BDataOut
            );

        S_BId   <= BDataOut(BIdRng_c);
        S_BResp <= BDataOut(BRespRng_c);
        S_BUser <= BDataOut(BuserRng_c);
    end block;

    b_ar : block is
        subtype  ArProtRng_c   is natural range S_ArProt'length-1                 downto 0;
        subtype  ArCacheRng_c  is natural range S_ArCache'length+ArProtRng_c'high   downto ArProtRng_c'high+1;
        constant ArLockIdx_c : natural := ArCacheRng_c'high+1;
        subtype  ArBurstRng_c  is natural range S_ArBurst'length+ArLockIdx_c        downto ArLockIdx_c+1;
        subtype  ArSizeRng_c   is natural range S_ArSize'length+ArBurstRng_c'high   downto ArBurstRng_c'high+1;
        subtype  ArLenRng_c    is natural range S_ArLen'length+ArSizeRng_c'high     downto ArSizeRng_c'high+1;
        subtype  ArAddrRng_c   is natural range S_ArAddr'length+ArLenRng_c'high     downto ArLenRng_c'high+1;
        subtype  ArIdRng_c     is natural range S_ArId'length+ArAddrRng_c'high      downto ArAddrRng_c'high+1;
        subtype  ArQosRng_c    is natural range S_ArQos'length+ArIdRng_c'high       downto ArIdRng_c'high+1;
        subtype  ArUserRng_c   is natural range S_ArUser'length+ArQosRng_c'high     downto ArQosRng_c'high+1;
        subtype  ArRegionRng_c is natural range S_ArRegion'length+ArUserRng_c'high  downto ArUserRng_c'high+1;

        signal ArDataIn, ArDataOut : std_logic_vector(ArRegionRng_c'high downto 0);
    begin

        ArDataIn(ArProtRng_c)   <= S_ArProt;
        ArDataIn(ArCacheRng_c)  <= S_ArCache;
        ArDataIn(ArLockIdx_c)   <= S_ArLock;
        ArDataIn(ArBurstRng_c)  <= S_ArBurst;
        ArDataIn(ArSizeRng_c)   <= S_ArSize;
        ArDataIn(ArLenRng_c)    <= S_ArLen;
        ArDataIn(ArAddrRng_c)   <= S_ArAddr;
        ArDataIn(ArIdRng_c)     <= S_ArId;
        ArDataIn(ArQosRng_c)    <= S_ArQos;
        ArDataIn(ArUserRng_c)   <= S_ArUser;
        ArDataIn(ArRegionRng_c) <= S_ArRegion;

        i_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => ArDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => S_ArValid,
                In_Ready   => S_ArReady,
                In_Data    => ArDataIn,
                Out_Valid  => M_ArValid,
                Out_Ready  => M_ArReady,
                Out_Data   => ArDataOut
            );

        M_ArProt   <= ArDataOut(ArProtRng_c);
        M_ArCache  <= ArDataOut(ArCacheRng_c);
        M_ArLock   <= ArDataOut(ArLockIdx_c);
        M_ArBurst  <= ArDataOut(ArBurstRng_c);
        M_ArSize   <= ArDataOut(ArSizeRng_c);
        M_ArLen    <= ArDataOut(ArLenRng_c);
        M_ArAddr   <= ArDataOut(ArAddrRng_c);
        M_ArId     <= ArDataOut(ArIdRng_c);
        M_ArQos    <= ArDataOut(ArQosRng_c);
        M_ArUser   <= ArDataOut(ArUserRng_c);
        M_ArRegion <= ArDataOut(ArRegionRng_c);
    end block;

    b_r : block is
        subtype  RDataRng_c is natural range S_RData'length-1             downto 0;
        constant RLastIdx_c : natural := RDataRng_c'high+1;
        subtype  RRespRng_c is natural range S_RResp'length+RLastIdx_c    downto RLastIdx_c+1;
        subtype  RIdRng_c   is natural range S_RId'length+RRespRng_c'high downto RRespRng_c'high+1;
        subtype  RUserRng_c is natural range S_RUser'length+RIdRng_c'high downto RIdRng_c'high+1;

        signal RDataIn, RDataOut : std_logic_vector(RUserRng_c'high downto 0);
    begin
        RDataIn(RDataRng_c) <= M_RData;
        RDataIn(RRespRng_c) <= M_RResp;
        RDataIn(RLastIdx_c) <= M_RLast;
        RDataIn(RIdRng_c)   <= M_RId;
        RDataIn(RUserRng_c) <= M_RUser;

        i_rch_pl : entity work.olo_base_pl_stage
            generic map (
                Width_g    => RDataIn'length,
                UseReady_g => true,
                Stages_g   => Stages_g
            )
            port map (
                Clk        => Clk,
                Rst        => Rst,
                In_Valid   => M_RValid,
                In_Ready   => M_RReady,
                In_Data    => RDataIn,
                Out_Valid  => S_RValid,
                Out_Ready  => S_RReady,
                Out_Data   => RDataOut
            );

        S_RData <= RDataOut(RDataRng_c);
        S_RResp <= RDataOut(RRespRng_c);
        S_RLast <= RDataOut(RLastIdx_c);
        S_RId   <= RDataOut(RIdRng_c);
        S_RUser <= RDataOut(RUserRng_c);
    end block;

end architecture;"
"describes a coprocessor component designed for the LXP32 test platform. This component's primary purpose is to perform a simple arithmetic operation and utilize an interrupt to wake up the CPU. The coprocessor is not intended for synthesis but rather for simulation purposes. The coprocessor is a digital component that interacts with the CPU through a Wishbone interface, a standard for system-on-chip (SoC) design. It has a simple architecture, comprising a few registers, counters, and basic arithmetic logic. The component's main function is to perform a calculation based on input data and generate an interrupt signal to notify the CPU. The coprocessor has several input ports, including `clk_i`, `rst_i`, `wbs_cyc_i`, `wbs_stb_i`, `wbs_we_i`, `wbs_sel_i`, `wbs_adr_i`, `wbs_dat_i`. The `clk_i` and `rst_i` ports are used for clocking and resetting the component, respectively. The Wishbone interface signals, `wbs_cyc_i`, `wbs_stb_i`, `wbs_we_i`, `wbs_sel_i`, `wbs_adr_i`, and `wbs_dat_i`, facilitate data transfer between the coprocessor and the CPU. The `wbs_ack_o`, `wbs_dat_o`, and `irq_o` ports are outputs that provide acknowledgement, data, and interrupt signals to the CPU. Internally, the coprocessor has several signals, including `value`, `result`, `cnt`, and `irq`. The `value` signal is a 32-bit unsigned integer that stores input data, while the `result` signal stores the calculated result. The `cnt` signal is an integer counter used to generate an interrupt signal after a certain number of clock cycles. The `irq` signal is a flag that indicates whether an interrupt should be generated. The coprocessor has two main processes. The first process is clocked by `clk_i` and handles reset, data input, and interrupt generation. When the component is reset, `value` is cleared, and the counter `cnt` is set to zero. When data is written to the component through the Wishbone interface, it is stored in the `value` signal. The counter `cnt` is used to generate an interrupt signal after a certain number of clock cycles. When `cnt` reaches 1, the `irq` signal is set to '1', indicating that an interrupt should be generated. The second process is also clocked by `clk_i` and performs the arithmetic operation. It calculates the result by shifting the `value` signal left by one bit and adding it to itself. The result is stored in the `result` signal. The control logic of the coprocessor is straightforward. The component generates an acknowledgement signal `wbs_ack_o` when both `wbs_cyc_i` and `wbs_stb_i` are high. The output data `wbs_dat_o` is determined by the address `wbs_adr_i`. If the address is ""00""&X""000000"", the output data is the current `value`; if the address is ""00""&X""000001"", the output data is the calculated `result`. Otherwise, the output data is a don't-care value. The data flow through the component is simple. Input data is stored in the `value` signal through the Wishbone interface. The arithmetic operation is performed on the `value` signal, and the result is stored in the `result` signal. The output data is determined by the address and the current values of `value` and `result`. In terms of timing and synchronization, the coprocessor has a single clock domain, and all operations are synchronized to the `clk_i` signal. The component has setup and hold requirements for the Wishbone interface signals, which must be met to ensure proper data transfer. One special feature of the coprocessor is its ability to generate an interrupt signal `irq_o` to notify the CPU that the calculation is complete. This allows the CPU to sleep or perform other tasks while the coprocessor performs the calculation. The coprocessor is typically used in SoC designs where a simple arithmetic operation needs to be offloaded to a separate component, allowing the CPU to focus on more critical tasks. This component can be used in a variety of applications, such as embedded systems, microcontrollers, and digital signal processing. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The component's simplicity makes it suitable for small, low-power designs. However, the use of a counter and interrupt generation may add complexity to the design. Designers should carefully evaluate the component's resource usage and performance to ensure it meets the requirements of the target application. In conclusion, the coprocessor is a simple digital component designed to perform a basic arithmetic operation and generate an interrupt signal to notify the CPU. Its architecture, functional behavior, and control logic are straightforward, making it suitable for a variety of SoC designs. The component's simplicity and low-power nature make it an attractive solution for embedded systems and other applications where resources are limited.","---------------------------------------------------------------------
-- Coprocessor
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Performs a simple arithmetic operation, uses interrupt to wake
-- up the CPU.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity coprocessor is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(27 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		irq_o: out std_logic
	);
end entity;

architecture rtl of coprocessor is

signal value: unsigned(31 downto 0):=(others=>'0');
signal result: unsigned(31 downto 0):=(others=>'0');
signal cnt: integer range 0 to 50:=0;
signal irq: std_logic:='0';

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			value<=(others=>'0');
			cnt<=0;
			irq<='0';
		else
			if cnt>0 then
				cnt<=cnt-1;
			end if;
			
			if cnt=1 then
				irq<='1';
			else
				irq<='0';
			end if;
			
			if wbs_cyc_i='1' and wbs_stb_i='1' and wbs_we_i='1' then
				for i in wbs_sel_i'range loop
					if wbs_sel_i(i)='1' then
						if wbs_adr_i=""00""&X""000000"" then
							value(i*8+7 downto i*8)<=
								unsigned(wbs_dat_i(i*8+7 downto i*8));
							cnt<=50;
						end if;
					end if;
				end loop;
			end if;
		end if;
	end if;
end process;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			result<=(others=>'0');
		else
			result<=shift_left(value,1)+value;
		end if;
	end if;
end process;

wbs_ack_o<=wbs_cyc_i and wbs_stb_i;
wbs_dat_o<=std_logic_vector(value) when wbs_adr_i=""00""&X""000000"" else
	std_logic_vector(result) when wbs_adr_i=""00""&X""000001"" else
	(others=>'-');

irq_o<=irq;

end architecture;
"
"The DBUS monitor is a digital component designed to observe and potentially throttle data bus transactions within the LXP32 test platform. Its primary purpose is to monitor the data bus and control signals, ensuring proper handshake and data transfer between the CPU interface and the interconnect interface. The component can operate in two modes, determined by the THROTTLE generic: with or without throttling. The DBUS monitor has multiple input and output ports that facilitate its operation. The clock input, `clk_i`, and reset input, `rst_i`, control the component's internal state and synchronization. The CPU interface inputs, `wbs_cyc_i`, `wbs_stb_i`, `wbs_we_i`, `wbs_sel_i`, `wbs_adr_i`, and `wbs_dat_i`, receive signals from the CPU, while the outputs `wbs_ack_o` and `wbs_dat_o` provide feedback to the CPU. The interconnect interface outputs, `wbm_cyc_o`, `wbm_stb_o`, `wbm_we_o`, `wbm_sel_o`, `wbm_adr_o`, and `wbm_dat_o`, drive the signals to the interconnect, and the inputs `wbm_ack_i` and `wbm_dat_i` receive handshake and data signals from the interconnect. Internally, the DBUS monitor consists of several key components. A scrambler, instantiated when throttling is enabled, generates a pseudo-random bit stream, `prbs`, used to control data flow. Two flip-flops, `cyc_ff` and `ack_ff`, are used to track the cycle and acknowledge signals, ensuring proper handshake. The architectural description reveals a design that balances simplicity with the required functionality. The DBUS monitor's functional behavior can be described as follows: when the CPU initiates a cycle, the component checks the throttling condition. If throttling is enabled and the pseudo-random bit stream indicates a '1', the cycle is allowed to proceed; otherwise, it is delayed. The component then generates the necessary control signals for the interconnect interface. The handshake between the CPU and interconnect interfaces is continuously monitored, and assertions are used to verify that the cycle and acknowledge signals are properly coordinated. The control logic within the DBUS monitor manages the throttling function, enables or disables the cycle based on the pseudo-random bit stream, and handles reset behavior. The state transitions are primarily dictated by the clock, reset, and throttling condition. The component's data flow is straightforward, with data passing from the CPU interface to the interconnect interface with minimal transformation. Timing and synchronization are critical aspects of the DBUS monitor's design. The component operates within a single clock domain, with the clock input driving all sequential logic. The design adheres to standard timing constraints, with the requirement that the acknowledge signal, `wbm_ack_i`, must be asserted only when the cycle signal, `wbs_cyc_i`, and the throttling condition allow it. A notable feature of the DBUS monitor is its ability to operate in two distinct modes, based on the THROTTLE generic. When throttling is enabled, the component introduces randomness into the data flow, allowing for simulation of real-world bus contention scenarios. This feature is particularly useful for testing and verification purposes. The DBUS monitor is typically used in environments where data bus transactions need to be observed and potentially controlled, such as in system-on-chip (SoC) verification and testing. Its applications include simulation and emulation platforms, where it can help in identifying potential issues with data bus handshaking and data transfer. In terms of implementation considerations, the DBUS monitor's performance and resource usage are influenced by the choice of throttling mode and the specific technology used for implementation. When throttling is enabled, additional logic is required for the scrambler, which may increase resource utilization. However, the component's design allows for a relatively straightforward implementation, making it suitable for a wide range of applications. Design trade-offs may involve balancing the level of throttling with the required performance and resource constraints. Overall, the DBUS monitor is a versatile component that provides valuable functionality for the observation and control of data bus transactions.","---------------------------------------------------------------------
-- DBUS monitor
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Monitors LXP32 data bus transactions, optionally throttles them.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity dbus_monitor is
	generic(
		THROTTLE: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(31 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		wbm_cyc_o: out std_logic;
		wbm_stb_o: out std_logic;
		wbm_we_o: out std_logic;
		wbm_sel_o: out std_logic_vector(3 downto 0);
		wbm_ack_i: in std_logic;
		wbm_adr_o: out std_logic_vector(31 downto 2);
		wbm_dat_o: out std_logic_vector(31 downto 0);
		wbm_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of dbus_monitor is

signal prbs: std_logic;
signal cycle: std_logic:='0';

signal cyc_ff: std_logic:='0';
signal ack_ff: std_logic:='0';

begin

-- Manage throttling

gen_throttling: if THROTTLE generate
	throttle_inst: entity work.scrambler(rtl)
		generic map(TAP1=>6,TAP2=>7)
		port map(clk_i=>clk_i,rst_i=>rst_i,ce_i=>'1',d_o=>prbs);
end generate;

gen_no_throttling: if not THROTTLE generate
	prbs<='0';
end generate;

-- CPU interface

wbs_ack_o<=wbm_ack_i;
wbs_dat_o<=wbm_dat_i when wbm_ack_i='1' else (others=>'-');

-- Interconnect interface

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			cycle<='0';
		elsif prbs='0' and wbs_cyc_i='1' then
			cycle<='1';
		elsif wbs_cyc_i='0' then
			cycle<='0';
		end if;
	end if;
end process;

wbm_cyc_o<=wbs_cyc_i and (not prbs or cycle);
wbm_stb_o<=wbs_stb_i and (not prbs or cycle);
wbm_we_o<=wbs_we_i;
wbm_sel_o<=wbs_sel_i;
wbm_adr_o<=wbs_adr_i;
wbm_dat_o<=wbs_dat_i;

-- Check handshake correctness

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			cyc_ff<='0';
			ack_ff<='0';
		else
			cyc_ff<=wbs_cyc_i;
			ack_ff<=wbm_ack_i;
			
			assert wbm_ack_i='0' or (wbs_cyc_i and (not prbs or cycle))='1'
				report ""DBUS error: ACK asserted without CYC""
				severity failure;
			
			assert not (wbs_cyc_i='0' and cyc_ff='1' and ack_ff/='1')
				report ""DBUS error: cycle terminated prematurely""
				severity failure;
		end if;
	end if;
end process;

end architecture;
"
"The VHDL code provided describes a generic dual-port RAM (DPRAM) component, which is a fundamental building block in digital system design. This component serves as a configurable memory block that allows for simultaneous read and write operations through two separate ports, A and B. The primary purpose of this DPRAM is to provide flexible and efficient data storage and retrieval in a wide range of applications, from simple digital circuits to complex system-on-chip (SoC) designs. The DPRAM component has several key parameters that define its functionality and capacity: `DATA_WIDTH`, `ADDR_WIDTH`, `SIZE`, and `MODE`. The `DATA_WIDTH` and `ADDR_WIDTH` generics determine the width of the data and address buses, respectively, while `SIZE` specifies the total number of memory locations. The `MODE` generic controls the read/write synchronization behavior for port A, offering four distinct modes: `DONTCARE`, `WR_FIRST`, `RD_FIRST`, and `NOCHANGE`. These modes dictate how the output of port A behaves during write operations. From an input/output perspective, the component has several ports that facilitate its operation. Port A consists of a clock input `clka_i`, an enable signal `cea_i`, a write enable `wea_i`, an address input `addra_i`, a data input `da_i`, and a data output `da_o`. Port B, which is read-only, includes a clock input `clkb_i`, an enable signal `ceb_i`, an address input `addrb_i`, and a data output `db_o`. The bit widths of these ports are directly influenced by the `DATA_WIDTH` and `ADDR_WIDTH` generics. The timing requirements for these ports are critical, as they dictate when data is sampled, written, or read. For instance, the write operation on port A is triggered on the rising edge of `clka_i` when `cea_i` and `wea_i` are asserted. Internally, the DPRAM is structured around a synchronous RAM (SRAM) array, which is implemented using a type declaration `ram_type` that defines an array of `std_logic_vector` elements. The `ram` signal, which represents the memory array, is subject to certain attributes that guide its synthesis, such as `syn_ramstyle` and `ram_style`, which are set to optimize the memory implementation for the target FPGA. The architecture of the DPRAM is divided into several sections based on the `MODE` generic. For each mode, a separate process is generated that describes the behavior of port A during read and write operations. In the `DONTCARE` mode, for example, when a write occurs, the output `da_o` is set to a don't-care state ('-'), while in `WR_FIRST` mode, the written value is immediately fed to the output. The `RD_FIRST` and `NOCHANGE` modes exhibit different behaviors, where `RD_FIRST` reads the old value before writing the new one, and `NOCHANGE` maintains the output unchanged during writes. The control logic of the DPRAM is primarily governed by the `MODE` generic and the enable signals (`cea_i` and `ceb_i`). The write enable signal `wea_i` plays a crucial role in determining whether a write operation is performed on port A. The component also includes assertions to ensure that the generics have valid values, preventing incorrect configurations that could lead to malfunctions. In terms of data flow, the DPRAM allows data to be written into the memory array through port A and read from the same or different locations through both ports A and B. The data output on port B is always the value stored at the specified address, without any dependency on write operations. The timing and synchronization of the DPRAM are critical aspects, as they ensure that data is correctly written and read according to the clock edges and enable signals. The component operates in a multi-clock domain, with separate clocks for ports A and B (`clka_i` and `clkb_i`), which necessitates careful consideration of setup and hold times to prevent timing violations. A notable feature of this DPRAM is its configurability, particularly through the `MODE` generic, which allows designers to tailor the component's behavior to specific application requirements. Additionally, the component's ability to operate in different synchronization modes makes it versatile for use in a variety of digital systems. This generic DPRAM component finds applications in a wide range of digital designs, including but not limited to, digital signal processing (DSP) systems, embedded processors, and data acquisition systems, where efficient and flexible data storage and retrieval are crucial. When implementing this component, designers must consider performance, resource usage, and design trade-offs. The choice of `MODE`, for instance, can impact the component's behavior and efficiency. Moreover, optimizing the memory style attributes can influence the area and speed of the component on the target FPGA. Careful analysis of the component's timing requirements and data flow is essential to ensure reliable operation in the larger system context.","---------------------------------------------------------------------
-- Generic FPGA memory block
--
-- Copyright (c) 2015 by Alex I. Kuznetsov
--
-- Portable description of a dual-port memory block with one write
-- port.
--
-- Parameters:
--     * DATA_WIDTH:  data port width
--     * ADDR_WIDTH:  address port width
--     * SIZE:        memory size
--     * MODE:        read/write synchronization mode for port A
--                      DONTCARE: choose the most efficient design
--                      WR_FIRST: feed written value to the output
--                      RD_FIRST: read old value 
--                      NOCHANGE: don't change output during write
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity generic_dpram is
	generic(
		DATA_WIDTH: integer;
		ADDR_WIDTH: integer;
		SIZE: integer;
		MODE: string:=""DONTCARE""
	);
	port(
		clka_i: in std_logic;
		cea_i: in std_logic;
		wea_i: in std_logic;
		addra_i: in std_logic_vector(ADDR_WIDTH-1 downto 0);
		da_i: in std_logic_vector(DATA_WIDTH-1 downto 0);
		da_o: out std_logic_vector(DATA_WIDTH-1 downto 0);
		
		clkb_i: in std_logic;
		ceb_i: in std_logic;
		addrb_i: in std_logic_vector(ADDR_WIDTH-1 downto 0);
		db_o: out std_logic_vector(DATA_WIDTH-1 downto 0)
	);
end entity;

architecture rtl of generic_dpram is

type ram_type is array(SIZE-1 downto 0) of std_logic_vector(DATA_WIDTH-1 downto 0);
signal ram: ram_type;

attribute syn_ramstyle: string;
attribute syn_ramstyle of ram: signal is ""no_rw_check"";
attribute ram_style: string; -- for Xilinx
attribute ram_style of ram: signal is ""block"";

begin

-- Ensure that generics have valid values

assert SIZE<=2**ADDR_WIDTH
	report ""SIZE must be less or equal than 2^ADDR_WIDTH""
	severity failure;

assert MODE=""DONTCARE"" or MODE=""WR_FIRST"" or MODE=""RD_FIRST"" or MODE=""NOCHANGE""
	report ""Unrecognized MODE value (DONTCARE, WR_FIRST, RD_FIRST or NOCHANGE expected)""
	severity failure;

-- Port A (read/write)

port_a_dont_care_gen: if MODE=""DONTCARE"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
					da_o<=(others=>'-');
				else
					if is_x(addra_i) then
						da_o<=(others=>'X');
					else
						da_o<=ram(to_integer(unsigned(addra_i)));
					end if;
				end if;
			end if;
		end if;
	end process;
end generate;

port_a_write_first_gen: if MODE=""WR_FIRST"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
					da_o<=da_i;
				else
					if is_x(addra_i) then
						da_o<=(others=>'X');
					else
						da_o<=ram(to_integer(unsigned(addra_i)));
					end if;
				end if;
			end if;
		end if;
	end process;
end generate;

port_a_read_first_gen: if MODE=""RD_FIRST"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
				end if;
				if is_x(addra_i) then
					da_o<=(others=>'X');
				else
					da_o<=ram(to_integer(unsigned(addra_i)));
				end if;
			end if;
		end if;
	end process;
end generate;

port_a_no_change_gen: if MODE=""NOCHANGE"" generate
	process (clka_i) is
	begin
		if rising_edge(clka_i) then
			if cea_i='1' then
				if wea_i='1' then
					ram(to_integer(unsigned(addra_i)))<=da_i;
				else
					if is_x(addra_i) then
						da_o<=(others=>'X');
					else
						da_o<=ram(to_integer(unsigned(addra_i)));
					end if;
				end if;
			end if;
		end if;
	end process;
end generate;

-- Port B (read only)

process (clkb_i) is
begin
	if rising_edge(clkb_i) then
		if ceb_i='1' then
			if is_x(addrb_i) then
				db_o<=(others=>'X');
			else
				db_o<=ram(to_integer(unsigned(addrb_i)));
			end if;
		end if;
	end if;
end process;

end architecture;
"
"The IBUS adapter is a digital component designed to convert the Low Latency Interface (LLI) to WISHBONE registered feedback protocol, facilitating communication between the LXP32 test platform and external devices. This adapter plays a crucial role in bridging the gap between the LLI and WISHBONE protocols, enabling seamless data transfer between the two. The IBUS adapter has several input and output ports that facilitate its operation. The clock input, `clk_i`, drives the internal logic of the adapter, while the reset input, `rst_i`, initializes the component to its default state. The `ibus_cyc_i`, `ibus_stb_i`, `ibus_cti_i`, and `ibus_bte_i` inputs are derived from the WISHBONE protocol and indicate the cycle type, strobe, cycle type identifier, and burst termination, respectively. The `ibus_adr_i` input provides the address for the current transaction. The adapter outputs the `ibus_ack_o` signal, which acknowledges the completion of a transaction, and `ibus_dat_o`, which provides the data for the current transaction. On the LLI side, the adapter outputs the `lli_re_o` signal, which indicates a read request, and `lli_adr_o`, which provides the address for the LLI transaction. The `lli_dat_i` input provides the data for the LLI transaction, and `lli_busy_i` indicates whether the LLI interface is busy. Internally, the IBUS adapter consists of several registers and counters that manage the flow of data between the WISHBONE and LLI interfaces. A burst delay counter, `burst_delay_cnt`, is used to insert a programmable delay between bursts of data. The `delay_burst` signal is generated based on the value of the burst delay counter and is used to control the generation of the `re` signal, which indicates a read request. The adapter's architectural description reveals a state machine-like behavior, where the internal logic is driven by the clock and reset inputs. The `re` signal is generated based on the WISHBONE inputs and the `delay_burst` signal. The `adr` signal, which represents the address for the LLI transaction, is updated based on the `re` signal and the `ack` signal, which indicates whether the LLI interface has acknowledged the read request. The functional behavior of the IBUS adapter can be described as follows: when the WISHBONE interface initiates a cycle, the adapter checks whether the LLI interface is busy. If it is not, the adapter generates a read request to the LLI interface. The LLI interface responds with the data, which is then forwarded to the WISHBONE interface. The adapter manages the timing relationships between the WISHBONE and LLI interfaces, ensuring that data is transferred correctly and efficiently. The control logic of the IBUS adapter is primarily driven by the clock and reset inputs. The `ack` signal is generated based on the `requested` signal and the `lli_busy_i` input. The `requested` signal is updated based on the `re` signal and the `lli_busy_i` input. The `re` signal is generated based on the WISHBONE inputs and the `delay_burst` signal. Data flow through the IBUS adapter is straightforward. On the WISHBONE side, the adapter receives the address and control signals, generates the read request to the LLI interface, and receives the data from the LLI interface. The data is then forwarded to the WISHBONE interface. On the LLI side, the adapter receives the data and generates the address and control signals for the LLI transaction. The IBUS adapter operates in a single clock domain, with the clock input driving the internal logic. The setup and hold requirements for the inputs are not explicitly specified, but it is assumed that the inputs are properly synchronized to the clock. One special feature of the IBUS adapter is the programmable burst delay, which allows for flexible control over the timing of the LLI transactions. This feature enables the adapter to be used in a variety of applications, including high-speed data transfer and low-latency communication. The IBUS adapter is typically used in systems that require communication between WISHBONE and LLI interfaces. This may include systems-on-chip (SoCs), field-programmable gate arrays (FPGAs), and other digital systems. In terms of implementation considerations, the IBUS adapter is designed to be efficient in terms of resource usage. The adapter's internal logic is relatively simple, consisting of a few counters and registers. However, the performance of the adapter may be impacted by the programmable burst delay, which can introduce additional latency into the system. Design trade-offs may need to be made between latency, throughput, and resource usage, depending on the specific application requirements. Overall, the IBUS adapter is a critical component in systems that require communication between WISHBONE and LLI interfaces. Its flexible architecture and programmable burst delay make it suitable for a wide range of applications, from high-speed data transfer to low-latency communication.","---------------------------------------------------------------------
-- IBUS adapter
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Converts the Low Latency Interface to WISHBONE registered
-- feedback protocol.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity ibus_adapter is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		ibus_cyc_i: in std_logic;
		ibus_stb_i: in std_logic;
		ibus_cti_i: in std_logic_vector(2 downto 0);
		ibus_bte_i: in std_logic_vector(1 downto 0);
		ibus_ack_o: out std_logic;
		ibus_adr_i: in std_logic_vector(29 downto 0);
		ibus_dat_o: out std_logic_vector(31 downto 0);
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic
	);
end entity;

architecture rtl of ibus_adapter is

constant burst_delay: integer:=5;
signal burst_delay_cnt: integer:=0;
signal delay_burst: std_logic;

signal re: std_logic;
signal requested: std_logic:='0';
signal adr: unsigned(29 downto 0);
signal ack: std_logic;

begin

-- Insert burst delay

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			burst_delay_cnt<=0;
		elsif ibus_cyc_i='0' then
			burst_delay_cnt<=burst_delay;
		elsif burst_delay_cnt/=0 then
			burst_delay_cnt<=burst_delay_cnt-1;
		end if;
	end if;
end process;

delay_burst<='1' when burst_delay_cnt/=0 else '0';

-- Generate ACK signal

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			requested<='0';
		elsif lli_busy_i='0' then
			requested<=re;
		end if;
	end if;
end process;

ack<=requested and not lli_busy_i;

-- Generate LLI signals

re<=(ibus_cyc_i and ibus_stb_i and not delay_burst) when ack='0' or
	(ibus_cti_i=""010"" and ibus_bte_i=""00"") else '0';

adr<=unsigned(ibus_adr_i) when re='1' and ack='0' else
	unsigned(ibus_adr_i)+1 when re='1' and ack='1' else
	(others=>'-');

lli_re_o<=re;
lli_adr_o<=std_logic_vector(adr);

-- Generate IBUS signals

ibus_ack_o<=ack;
ibus_dat_o<=lli_dat_i when ack='1' else (others=>'-');

end architecture;
"
"describes a simple WISHBONE interconnect, a type of system-on-chip (SoC) component that enables communication between multiple masters and slaves in a digital system. This interconnect serves as a bridge, facilitating data exchange between two masters and five slaves, with a configurable architecture to accommodate varying system requirements. The primary purpose of this component is to manage data transactions between the masters and slaves, ensuring that each master can access the required slave without conflicts. The WISHBONE interconnect is a widely used standard in SoC design, providing a flexible and scalable solution for complex digital systems. The component has several input and output ports that facilitate communication with the masters and slaves. The inputs include clock (`clk_i`) and reset (`rst_i`) signals, as well as the master interface signals (`s0_cyc_i`, `s0_stb_i`, `s0_we_i`, `s0_sel_i`, `s0_adr_i`, `s0_dat_i`) and (`s1_cyc_i`, `s1_stb_i`, `s1_we_i`, `s1_sel_i`, `s1_adr_i`, `s1_dat_i`) for the two masters. The outputs include the slave interface signals (`m0_cyc_o`, `m0_stb_o`, `m0_we_o`, `m0_sel_o`, `m0_adr_o`, `m0_dat_o`) and similar signals for the other four slaves (`m1_cyc_o` to `m4_cyc_o`, `m1_stb_o` to `m4_stb_o`, etc.). Additionally, there are acknowledge (`s0_ack_o`, `s1_ack_o`) and data output (`s0_dat_o`, `s1_dat_o`) signals for the masters. Internally, the component consists of several key modules. The arbiter module prioritizes access to the slaves based on the master's request signals (`s0_cyc_i` and `s1_cyc_i`). It uses a simple priority scheme, where the master with the lower port number has higher priority. The arbiter generates grant signals (`grant`) that indicate which master has access to the slaves. The master-slave multiplexers (MUX) direct the data and control signals from the masters to the selected slave. The `cyc_mux`, `stb_mux`, `we_mux`, `sel_mux`, `adr_mux`, and `wdata_mux` signals are generated by combining the corresponding master signals with the grant signals. These multiplexed signals are then routed to the slaves. The slave select logic determines which slave is being accessed based on the address bits (`adr_mux`) and generates the `select_slave` signal. This signal is used to demultiplex the data and control signals to the correct slave. The slave-master multiplexers (MUX) combine the data and acknowledge signals from the slaves to the corresponding masters. The `ack_mux` and `rdata_mux` signals are generated by combining the slave signals with the `select_slave` signal. The component's functional behavior can be described as follows: When a master requests access to a slave, the arbiter grants access based on priority. The master-slave MUX directs the data and control signals to the selected slave. The slave performs the requested operation and returns the data and acknowledge signal. The slave-master MUX then directs the data and acknowledge signal back to the requesting master. The control logic is primarily handled by the arbiter and the slave select logic. The arbiter generates the grant signals based on the master's request signals and the current state of the system. The slave select logic determines which slave is being accessed based on the address bits. Data flow through the component involves several transformations. The data and control signals from the masters are multiplexed and directed to the selected slave. The slave performs the requested operation, and the data and acknowledge signal are then demultiplexed back to the requesting master. The component operates in a single clock domain, with the clock signal (`clk_i`) driving all internal logic. The reset signal (`rst_i`) is used to initialize the component's state. The timing and synchronization of the component are critical to its correct operation. The component assumes that the input signals are synchronous to the clock signal. The setup and hold times for the input signals are not explicitly specified, but it is assumed that they meet the standard requirements for digital logic. One special feature of this component is its support for a fallback slave. If the address bits do not match any of the defined slaves, the component will select the fallback slave. This WISHBONE interconnect component is typically used in SoC designs where multiple masters need to access multiple slaves. It can be used in a wide range of applications, from simple embedded systems to complex SoCs. In terms of implementation considerations, the component's performance is primarily determined by the clock frequency and the complexity of the logic. The resource usage is moderate, with a reasonable number of logic gates and flip-flops required to implement the arbiter, multiplexers, and slave select logic. Design trade-offs include optimizing the arbiter's priority scheme, minimizing the number of multiplexers, and balancing the component's performance and resource usage. Overall, the provided VHDL code describes a well-structured and efficient WISHBONE interconnect component that can be used in a variety of SoC designs. Its modular architecture and standard interface make it easy to integrate with other components and reuse in different systems.","---------------------------------------------------------------------
-- Simple WISHBONE interconnect
--
-- Generated by wigen at Sat Nov  2 11:45:49 2024
--
-- Configuration:
--     Number of masters:     2
--     Number of slaves:      5
--     Master address width:  32
--     Slave address width:   28
--     Port size:             32
--     Port granularity:      8
--     Entity name:           intercon
--     Pipelined arbiter:     no
--     Registered feedback:   no
--     Unsafe slave decoder:  no
--
-- Command line:
--     wigen -e intercon 2 5 32 28 32 8
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity intercon is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;

		s0_cyc_i: in std_logic;
		s0_stb_i: in std_logic;
		s0_we_i: in std_logic;
		s0_sel_i: in std_logic_vector(3 downto 0);
		s0_ack_o: out std_logic;
		s0_adr_i: in std_logic_vector(31 downto 2);
		s0_dat_i: in std_logic_vector(31 downto 0);
		s0_dat_o: out std_logic_vector(31 downto 0);

		s1_cyc_i: in std_logic;
		s1_stb_i: in std_logic;
		s1_we_i: in std_logic;
		s1_sel_i: in std_logic_vector(3 downto 0);
		s1_ack_o: out std_logic;
		s1_adr_i: in std_logic_vector(31 downto 2);
		s1_dat_i: in std_logic_vector(31 downto 0);
		s1_dat_o: out std_logic_vector(31 downto 0);

		m0_cyc_o: out std_logic;
		m0_stb_o: out std_logic;
		m0_we_o: out std_logic;
		m0_sel_o: out std_logic_vector(3 downto 0);
		m0_ack_i: in std_logic;
		m0_adr_o: out std_logic_vector(27 downto 2);
		m0_dat_o: out std_logic_vector(31 downto 0);
		m0_dat_i: in std_logic_vector(31 downto 0);

		m1_cyc_o: out std_logic;
		m1_stb_o: out std_logic;
		m1_we_o: out std_logic;
		m1_sel_o: out std_logic_vector(3 downto 0);
		m1_ack_i: in std_logic;
		m1_adr_o: out std_logic_vector(27 downto 2);
		m1_dat_o: out std_logic_vector(31 downto 0);
		m1_dat_i: in std_logic_vector(31 downto 0);

		m2_cyc_o: out std_logic;
		m2_stb_o: out std_logic;
		m2_we_o: out std_logic;
		m2_sel_o: out std_logic_vector(3 downto 0);
		m2_ack_i: in std_logic;
		m2_adr_o: out std_logic_vector(27 downto 2);
		m2_dat_o: out std_logic_vector(31 downto 0);
		m2_dat_i: in std_logic_vector(31 downto 0);

		m3_cyc_o: out std_logic;
		m3_stb_o: out std_logic;
		m3_we_o: out std_logic;
		m3_sel_o: out std_logic_vector(3 downto 0);
		m3_ack_i: in std_logic;
		m3_adr_o: out std_logic_vector(27 downto 2);
		m3_dat_o: out std_logic_vector(31 downto 0);
		m3_dat_i: in std_logic_vector(31 downto 0);

		m4_cyc_o: out std_logic;
		m4_stb_o: out std_logic;
		m4_we_o: out std_logic;
		m4_sel_o: out std_logic_vector(3 downto 0);
		m4_ack_i: in std_logic;
		m4_adr_o: out std_logic_vector(27 downto 2);
		m4_dat_o: out std_logic_vector(31 downto 0);
		m4_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of intercon is

signal request: std_logic_vector(1 downto 0);
signal grant_next: std_logic_vector(1 downto 0);
signal grant: std_logic_vector(1 downto 0);
signal grant_reg: std_logic_vector(1 downto 0):=(others=>'0');

signal select_slave: std_logic_vector(5 downto 0);

signal cyc_mux: std_logic;
signal stb_mux: std_logic;
signal we_mux: std_logic;
signal sel_mux: std_logic_vector(3 downto 0);
signal adr_mux: std_logic_vector(31 downto 2);
signal wdata_mux: std_logic_vector(31 downto 0);

signal ack_mux: std_logic;
signal rdata_mux: std_logic_vector(31 downto 0);

begin

-- ARBITER
-- Selects the active master. Masters with lower port numbers
-- have higher priority. Ongoing cycles are not interrupted.

request<=s1_cyc_i&s0_cyc_i;

grant_next<=""01"" when request(0)='1' else
	""10"" when request(1)='1' else
	(others=>'0');

grant<=grant_reg when (request and grant_reg)/=""00"" else grant_next;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			grant_reg<=(others=>'0');
		else
			grant_reg<=grant;
		end if;
	end if;
end process;

-- MASTER->SLAVE MUX

cyc_mux<=(s0_cyc_i and grant(0)) or
	(s1_cyc_i and grant(1));

stb_mux<=(s0_stb_i and grant(0)) or
	(s1_stb_i and grant(1));

we_mux<=(s0_we_i and grant(0)) or
	(s1_we_i and grant(1));

sel_mux_gen: for i in sel_mux'range generate
	sel_mux(i)<=(s0_sel_i(i) and grant(0)) or
		(s1_sel_i(i) and grant(1));
end generate;

adr_mux_gen: for i in adr_mux'range generate
	adr_mux(i)<=(s0_adr_i(i) and grant(0)) or
		(s1_adr_i(i) and grant(1));
end generate;

wdata_mux_gen: for i in wdata_mux'range generate
	wdata_mux(i)<=(s0_dat_i(i) and grant(0)) or
		(s1_dat_i(i) and grant(1));
end generate;

-- MASTER->SLAVE DEMUX

select_slave<=""000001"" when adr_mux(31 downto 28)=""0000"" else
	""000010"" when adr_mux(31 downto 28)=""0001"" else
	""000100"" when adr_mux(31 downto 28)=""0010"" else
	""001000"" when adr_mux(31 downto 28)=""0011"" else
	""010000"" when adr_mux(31 downto 28)=""0100"" else
	""100000""; -- fallback slave

m0_cyc_o<=cyc_mux and select_slave(0);
m0_stb_o<=stb_mux and select_slave(0);
m0_we_o<=we_mux;
m0_sel_o<=sel_mux;
m0_adr_o<=adr_mux(m0_adr_o'range);
m0_dat_o<=wdata_mux;

m1_cyc_o<=cyc_mux and select_slave(1);
m1_stb_o<=stb_mux and select_slave(1);
m1_we_o<=we_mux;
m1_sel_o<=sel_mux;
m1_adr_o<=adr_mux(m1_adr_o'range);
m1_dat_o<=wdata_mux;

m2_cyc_o<=cyc_mux and select_slave(2);
m2_stb_o<=stb_mux and select_slave(2);
m2_we_o<=we_mux;
m2_sel_o<=sel_mux;
m2_adr_o<=adr_mux(m2_adr_o'range);
m2_dat_o<=wdata_mux;

m3_cyc_o<=cyc_mux and select_slave(3);
m3_stb_o<=stb_mux and select_slave(3);
m3_we_o<=we_mux;
m3_sel_o<=sel_mux;
m3_adr_o<=adr_mux(m3_adr_o'range);
m3_dat_o<=wdata_mux;

m4_cyc_o<=cyc_mux and select_slave(4);
m4_stb_o<=stb_mux and select_slave(4);
m4_we_o<=we_mux;
m4_sel_o<=sel_mux;
m4_adr_o<=adr_mux(m4_adr_o'range);
m4_dat_o<=wdata_mux;

-- SLAVE->MASTER MUX

ack_mux<=(m0_ack_i and select_slave(0)) or
	(m1_ack_i and select_slave(1)) or
	(m2_ack_i and select_slave(2)) or
	(m3_ack_i and select_slave(3)) or
	(m4_ack_i and select_slave(4)) or
	(cyc_mux and stb_mux and select_slave(5)); -- fallback slave

rdata_mux_gen: for i in rdata_mux'range generate
	rdata_mux(i)<=(m0_dat_i(i) and select_slave(0)) or
		(m1_dat_i(i) and select_slave(1)) or
		(m2_dat_i(i) and select_slave(2)) or
		(m3_dat_i(i) and select_slave(3)) or
		(m4_dat_i(i) and select_slave(4));
end generate;

-- SLAVE->MASTER DEMUX

s0_ack_o<=ack_mux and grant(0);
s0_dat_o<=rdata_mux;

s1_ack_o<=ack_mux and grant(1);
s1_dat_o<=rdata_mux;

end architecture;
"
"describes a top-level design unit for the LXP32 platform, a System-on-Chip (SoC) simulation platform for the LXP32 CPU. This platform incorporates several peripherals, including program RAM, a timer, and a coprocessor. The design is intended exclusively for simulation purposes. **Component Overview** The LXP32 platform is a complex digital system that integrates various components to facilitate the simulation and testing of the LXP32 CPU. The platform's primary purpose is to provide a comprehensive environment for verifying the functionality of the LXP32 CPU in conjunction with its peripherals. The platform's role in larger systems is to serve as a testbench for the LXP32 CPU, allowing designers to validate the CPU's behavior in a controlled and simulated environment. **Detailed Input/Output Analysis** The platform has several input and output ports that facilitate communication with the LXP32 CPU and other external components. The clock input (`clk_i`) and reset input (`rst_i`) are used to synchronize and reset the platform's internal state. The CPU reset input (`cpu_rst_i`) is used to reset the LXP32 CPU specifically. The platform has two Wishbone Master interfaces (`wbm_cyc_o`, `wbm_stb_o`, `wbm_we_o`, `wbm_sel_o`, `wbm_ack_i`, `wbm_adr_o`, `wbm_dat_o`, and `wbm_dat_i`) and two Wishbone Slave interfaces (`wbs_cyc_i`, `wbs_stb_i`, `wbs_we_i`, `wbs_sel_i`, `wbs_ack_o`, `wbs_adr_i`, `wbs_dat_i`, and `wbs_dat_o`). These interfaces enable the platform to interact with external components and peripherals. The `gp_io` port is a 32-bit bidirectional port that provides general-purpose input/output functionality. **Architectural Description** The platform's internal structure consists of several components, including the LXP32 CPU, program RAM, a timer, a coprocessor, and an interconnect module. The interconnect module (`intercon_inst`) serves as the platform's backbone, facilitating communication between the various components. The LXP32 CPU is instantiated in one of two versions, depending on the value of the `MODEL_LXP32C` generic: either `lxp32u_top_inst` or `lxp32c_top_inst`. The CPU's interface includes a Local Link interface (`lli_re_o`, `lli_adr_o`, `lli_dat_i`, and `lli_busy_i`) and a Wishbone Master interface (`dbus_cyc_o`, `dbus_stb_o`, `dbus_we_o`, `dbus_sel_o`, `dbus_ack_i`, `dbus_adr_o`, `dbus_dat_o`, and `dbus_dat_i`). The program RAM (`program_ram_inst`) provides storage for the CPU's program code and data. The timer (`timer_inst`) and coprocessor (`coprocessor_inst`) are peripherals that provide additional functionality to the platform. **Functional Behavior** The platform's operation can be described as follows: the LXP32 CPU executes instructions from the program RAM, generating memory and I/O requests that are transmitted through the Wishbone Master interface. The interconnect module routes these requests to the appropriate peripherals or external components. The timer and coprocessor peripherals generate interrupts that are routed to the CPU through the `cpu_irq` signal. The CPU responds to these interrupts by executing interrupt handling routines. The platform's behavior is also influenced by the `THROTTLE_DBUS` and `THROTTLE_IBUS` generics, which control the rate at which data is transferred on the Wishbone Master and Local Link interfaces, respectively. **Control Logic** The platform's control logic is distributed across several components. The interconnect module (`intercon_inst`) manages the routing of signals between components. The LXP32 CPU's control logic is responsible for executing instructions and generating memory and I/O requests. The timer and coprocessor peripherals have their own control logic, which manages their respective operations and generates interrupts. **Data Flow** Data flows through the platform as follows: the LXP32 CPU executes instructions from the program RAM, generating memory and I/O requests that are transmitted through the Wishbone Master interface. The interconnect module routes these requests to the appropriate peripherals or external components. The program RAM provides data to the CPU through the Local Link interface. The timer and coprocessor peripherals transmit data to the CPU through the Wishbone Slave interface. **Timing and Synchronization** The platform operates in a single clock domain, with all components synchronized to the `clk_i` clock input. The `rst_i` reset input is used to reset the platform's internal state. The platform's timing constraints are determined by the clock frequency and the requirements of the LXP32 CPU and its peripherals. **Special Features** The platform has several special features, including: * Support for two LXP32 CPU models: LXP32U and LXP32C * Configurable timer and coprocessor peripherals * Programmable interrupt handling * Support for throttling data transfers on the Wishbone Master and Local Link interfaces **Applications and Use Cases** The LXP32 platform is typically used in the development and testing of the LXP32 CPU. The platform provides a comprehensive environment for verifying the CPU's functionality in conjunction with its peripherals. The platform can also be used in the development of embedded systems that utilize the LXP32 CPU. **Implementation Considerations** The platform's implementation requires careful consideration of several factors, including: * Performance: The platform's performance is determined by the clock frequency and the efficiency of the LXP32 CPU and its peripherals. * Resource usage: The platform's resource usage is determined by the complexity of the LXP32 CPU and its peripherals","---------------------------------------------------------------------
-- LXP32 platform top-level design unit
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A SoC-like simulation platform for the LXP32 CPU, containing
-- a few peripherals such as program RAM, timer and coprocessor.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity platform is
	generic(
		CPU_DBUS_RMW: boolean;
		CPU_MUL_ARCH: string;
		MODEL_LXP32C: boolean;
		THROTTLE_DBUS: boolean;
		THROTTLE_IBUS: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		cpu_rst_i: in std_logic;
		
		wbm_cyc_o: out std_logic;
		wbm_stb_o: out std_logic;
		wbm_we_o: out std_logic;
		wbm_sel_o: out std_logic_vector(3 downto 0);
		wbm_ack_i: in std_logic;
		wbm_adr_o: out std_logic_vector(27 downto 2);
		wbm_dat_o: out std_logic_vector(31 downto 0);
		wbm_dat_i: in std_logic_vector(31 downto 0);
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(31 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		gp_io: inout std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of platform is

type wbm_type is record
	cyc: std_logic;
	stb: std_logic;
	we: std_logic;
	sel: std_logic_vector(3 downto 0);
	ack: std_logic;
	adr: std_logic_vector(31 downto 2);
	wdata: std_logic_vector(31 downto 0);
	rdata: std_logic_vector(31 downto 0);
end record;

type wbs_type is record
	cyc: std_logic;
	stb: std_logic;
	we: std_logic;
	sel: std_logic_vector(3 downto 0);
	ack: std_logic;
	adr: std_logic_vector(27 downto 2);
	wdata: std_logic_vector(31 downto 0);
	rdata: std_logic_vector(31 downto 0);
end record;

type ibus_type is record
	cyc: std_logic;
	stb: std_logic;
	cti: std_logic_vector(2 downto 0);
	bte: std_logic_vector(1 downto 0);
	ack: std_logic;
	adr: std_logic_vector(29 downto 0);
	dat: std_logic_vector(31 downto 0);
end record;

signal cpu_rst: std_logic;
signal cpu_irq: std_logic_vector(7 downto 0);
signal cpu_dbus: wbm_type;
signal cpu_ibus: ibus_type;

signal lli_re: std_logic;
signal lli_adr: std_logic_vector(29 downto 0);
signal lli_dat: std_logic_vector(31 downto 0);
signal lli_busy: std_logic;

signal monitor_dbus: wbm_type;

signal ram_wb: wbs_type;

signal timer_wb: wbs_type;
signal timer_elapsed: std_logic;

signal coprocessor_wb: wbs_type;
signal coprocessor_irq: std_logic;

signal timer2_wb: wbs_type;
signal timer2_irq: std_logic;

begin

-- Interconnect

intercon_inst: entity work.intercon(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,

		s0_cyc_i=>wbs_cyc_i,
		s0_stb_i=>wbs_stb_i,
		s0_we_i=>wbs_we_i,
		s0_sel_i=>wbs_sel_i,
		s0_ack_o=>wbs_ack_o,
		s0_adr_i=>wbs_adr_i,
		s0_dat_i=>wbs_dat_i,
		s0_dat_o=>wbs_dat_o,

		s1_cyc_i=>monitor_dbus.cyc,
		s1_stb_i=>monitor_dbus.stb,
		s1_we_i=>monitor_dbus.we,
		s1_sel_i=>monitor_dbus.sel,
		s1_ack_o=>monitor_dbus.ack,
		s1_adr_i=>monitor_dbus.adr,
		s1_dat_i=>monitor_dbus.wdata,
		s1_dat_o=>monitor_dbus.rdata,

		m0_cyc_o=>ram_wb.cyc,
		m0_stb_o=>ram_wb.stb,
		m0_we_o=>ram_wb.we,
		m0_sel_o=>ram_wb.sel,
		m0_ack_i=>ram_wb.ack,
		m0_adr_o=>ram_wb.adr,
		m0_dat_o=>ram_wb.wdata,
		m0_dat_i=>ram_wb.rdata,

		m1_cyc_o=>wbm_cyc_o,
		m1_stb_o=>wbm_stb_o,
		m1_we_o=>wbm_we_o,
		m1_sel_o=>wbm_sel_o,
		m1_ack_i=>wbm_ack_i,
		m1_adr_o=>wbm_adr_o,
		m1_dat_o=>wbm_dat_o,
		m1_dat_i=>wbm_dat_i,
		
		m2_cyc_o=>timer_wb.cyc,
		m2_stb_o=>timer_wb.stb,
		m2_we_o=>timer_wb.we,
		m2_sel_o=>timer_wb.sel,
		m2_ack_i=>timer_wb.ack,
		m2_adr_o=>timer_wb.adr,
		m2_dat_o=>timer_wb.wdata,
		m2_dat_i=>timer_wb.rdata,
		
		m3_cyc_o=>coprocessor_wb.cyc,
		m3_stb_o=>coprocessor_wb.stb,
		m3_we_o=>coprocessor_wb.we,
		m3_sel_o=>coprocessor_wb.sel,
		m3_ack_i=>coprocessor_wb.ack,
		m3_adr_o=>coprocessor_wb.adr,
		m3_dat_o=>coprocessor_wb.wdata,
		m3_dat_i=>coprocessor_wb.rdata,

		m4_cyc_o=>timer2_wb.cyc,
		m4_stb_o=>timer2_wb.stb,
		m4_we_o=>timer2_wb.we,
		m4_sel_o=>timer2_wb.sel,
		m4_ack_i=>timer2_wb.ack,
		m4_adr_o=>timer2_wb.adr,
		m4_dat_o=>timer2_wb.wdata,
		m4_dat_i=>timer2_wb.rdata
	);

-- CPU

cpu_rst<=cpu_rst_i or rst_i;

-- Note: we connect the timer IRQ to 2 CPU channels to test
-- handling of simultaneously arriving interrupt requests.

cpu_irq<=""0000""&timer2_irq&coprocessor_irq&timer_elapsed&timer_elapsed;

gen_lxp32u: if not MODEL_LXP32C generate
	lxp32u_top_inst: entity work.lxp32u_top(rtl)
		generic map(
			DBUS_RMW=>CPU_DBUS_RMW,
			DIVIDER_EN=>true,
			MUL_ARCH=>CPU_MUL_ARCH,
			START_ADDR=>(others=>'0')
		)
		port map(
			clk_i=>clk_i,
			rst_i=>cpu_rst,
			
			lli_re_o=>lli_re,
			lli_adr_o=>lli_adr,
			lli_dat_i=>lli_dat,
			lli_busy_i=>lli_busy,
			
			dbus_cyc_o=>cpu_dbus.cyc,
			dbus_stb_o=>cpu_dbus.stb,
			dbus_we_o=>cpu_dbus.we,
			dbus_sel_o=>cpu_dbus.sel,
			dbus_ack_i=>cpu_dbus.ack,
			dbus_adr_o=>cpu_dbus.adr,
			dbus_dat_o=>cpu_dbus.wdata,
			dbus_dat_i=>cpu_dbus.rdata,
			
			irq_i=>cpu_irq
		);
end generate;

gen_lxp32c: if MODEL_LXP32C generate
	lxp32c_top_inst: entity work.lxp32c_top(rtl)
		generic map(
			DBUS_RMW=>CPU_DBUS_RMW,
			DIVIDER_EN=>true,
			IBUS_BURST_SIZE=>16,
			IBUS_PREFETCH_SIZE=>32,
			MUL_ARCH=>CPU_MUL_ARCH,
			START_ADDR=>(others=>'0')
		)
		port map(
			clk_i=>clk_i,
			rst_i=>cpu_rst,
			
			ibus_cyc_o=>cpu_ibus.cyc,
			ibus_stb_o=>cpu_ibus.stb,
			ibus_cti_o=>cpu_ibus.cti,
			ibus_bte_o=>cpu_ibus.bte,
			ibus_ack_i=>cpu_ibus.ack,
			ibus_adr_o=>cpu_ibus.adr,
			ibus_dat_i=>cpu_ibus.dat,
			
			dbus_cyc_o=>cpu_dbus.cyc,
			dbus_stb_o=>cpu_dbus.stb,
			dbus_we_o=>cpu_dbus.we,
			dbus_sel_o=>cpu_dbus.sel,
			dbus_ack_i=>cpu_dbus.ack,
			dbus_adr_o=>cpu_dbus.adr,
			dbus_dat_o=>cpu_dbus.wdata,
			dbus_dat_i=>cpu_dbus.rdata,
			
			irq_i=>cpu_irq
		);
	
	ibus_adapter_inst: entity work.ibus_adapter(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			
			ibus_cyc_i=>cpu_ibus.cyc,
			ibus_stb_i=>cpu_ibus.stb,
			ibus_cti_i=>cpu_ibus.cti,
			ibus_bte_i=>cpu_ibus.bte,
			ibus_ack_o=>cpu_ibus.ack,
			ibus_adr_i=>cpu_ibus.adr,
			ibus_dat_o=>cpu_ibus.dat,
			
			lli_re_o=>lli_re,
			lli_adr_o=>lli_adr,
			lli_dat_i=>lli_dat,
			lli_busy_i=>lli_busy
		);
end generate;

-- DBUS monitor

dbus_monitor_inst: entity work.dbus_monitor(rtl)
	generic map(
		THROTTLE=>THROTTLE_DBUS
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>cpu_dbus.cyc,
		wbs_stb_i=>cpu_dbus.stb,
		wbs_we_i=>cpu_dbus.we,
		wbs_sel_i=>cpu_dbus.sel,
		wbs_ack_o=>cpu_dbus.ack,
		wbs_adr_i=>cpu_dbus.adr,
		wbs_dat_i=>cpu_dbus.wdata,
		wbs_dat_o=>cpu_dbus.rdata,
		
		wbm_cyc_o=>monitor_dbus.cyc,
		wbm_stb_o=>monitor_dbus.stb,
		wbm_we_o=>monitor_dbus.we,
		wbm_sel_o=>monitor_dbus.sel,
		wbm_ack_i=>monitor_dbus.ack,
		wbm_adr_o=>monitor_dbus.adr,
		wbm_dat_o=>monitor_dbus.wdata,
		wbm_dat_i=>monitor_dbus.rdata
	);

-- Program RAM

program_ram_inst: entity work.program_ram(rtl)
	generic map(
		THROTTLE=>THROTTLE_IBUS
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>ram_wb.cyc,
		wbs_stb_i=>ram_wb.stb,
		wbs_we_i=>ram_wb.we,
		wbs_sel_i=>ram_wb.sel,
		wbs_ack_o=>ram_wb.ack,
		wbs_adr_i=>ram_wb.adr,
		wbs_dat_i=>ram_wb.wdata,
		wbs_dat_o=>ram_wb.rdata,
		
		lli_re_i=>lli_re,
		lli_adr_i=>lli_adr,
		lli_dat_o=>lli_dat,
		lli_busy_o=>lli_busy
	);

-- Timer

timer_inst: entity work.timer(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>timer_wb.cyc,
		wbs_stb_i=>timer_wb.stb,
		wbs_we_i=>timer_wb.we,
		wbs_sel_i=>timer_wb.sel,
		wbs_ack_o=>timer_wb.ack,
		wbs_adr_i=>timer_wb.adr,
		wbs_dat_i=>timer_wb.wdata,
		wbs_dat_o=>timer_wb.rdata,
		
		elapsed_o=>timer_elapsed
	);

-- Timer with a level-sensitive IRQ

timer2_inst: entity work.timer(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,

		wbs_cyc_i=>timer2_wb.cyc,
		wbs_stb_i=>timer2_wb.stb,
		wbs_we_i=>timer2_wb.we,
		wbs_sel_i=>timer2_wb.sel,
		wbs_ack_o=>timer2_wb.ack,
		wbs_adr_i=>timer2_wb.adr,
		wbs_dat_i=>timer2_wb.wdata,
		wbs_dat_o=>timer2_wb.rdata,

		elapsed_o=>timer2_irq
	);

-- Coprocessor

coprocessor_inst: entity work.coprocessor(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		wbs_cyc_i=>coprocessor_wb.cyc,
		wbs_stb_i=>coprocessor_wb.stb,
		wbs_we_i=>coprocessor_wb.we,
		wbs_sel_i=>coprocessor_wb.sel,
		wbs_ack_o=>coprocessor_wb.ack,
		wbs_adr_i=>coprocessor_wb.adr,
		wbs_dat_i=>coprocessor_wb.wdata,
		wbs_dat_o=>coprocessor_wb.rdata,
		
		irq_o=>coprocessor_irq
	);

end architecture;
"
"describes a Program RAM (Random Access Memory) component, specifically designed for the LXP32 test platform. This component serves as a crucial element in the system, providing data storage and access interfaces for both the WISHBONE and LLI (Low Latency Interface) buses. The Program RAM component is a dual-port memory module, allowing simultaneous access from both the WISHBONE interface, used for data access, and the LLI interface, utilized for instruction fetching by the LXP32 processor. The component's primary purpose is to store and provide program instructions and data to the processor while ensuring efficient and controlled access. The WISHBONE interface consists of several ports that facilitate data transfer: `wbs_cyc_i`, `wbs_stb_i`, and `wbs_we_i` are control signals that indicate a valid cycle, strobe, and write enable, respectively. The `wbs_sel_i` signal selects the specific byte lanes for data transfer, while `wbs_adr_i` provides the address for memory access. The `wbs_dat_i` and `wbs_dat_o` signals handle input and output data, respectively. The `wbs_ack_o` signal acknowledges the completion of a WISHBONE cycle. Internally, the component utilizes two generated signals, `ram_a_we` and `ram_a_rdata`, to manage write enables and read data for the WISHBONE interface. The `ack_write` and `ack_read` signals are used to track write and read acknowledgments. A process statement generates the `wbs_ack_o` signal based on the `ack_read` and `ack_write` signals. The LLI interface provides an additional access pathway, primarily used for instruction fetching. The `lli_re_i` signal indicates a read request, while `lli_adr_i` supplies the address for the instruction fetch. The `lli_dat_o` signal outputs the fetched instruction data, and `lli_busy_o` indicates whether the interface is busy. The architectural description reveals a dual-port RAM (DP RAM) implementation using a generated `gen_dprams` loop, which instantiates four `generic_dpram` modules. Each DP RAM module has a size of 16384 words (64K bytes) and is configured with a data width of 8 bits and an address width of 14 bits. The component also features optional pseudo-random throttling, controlled by the `THROTTLE` generic. When throttling is enabled, a scrambler module generates a pseudo-random bitstream (`prbs`) to simulate congestion on the LLI interface. This throttling mechanism can be used to mimic real-world conditions and test the system's behavior under various scenarios. The control logic within the component manages the interactions between the WISHBONE and LLI interfaces, the DP RAM, and the throttling mechanism. The `lli_busy` signal plays a crucial role in controlling the LLI interface's behavior, indicating whether the interface is busy due to throttling or reset conditions. Data flow within the component involves the movement of data between the WISHBONE and LLI interfaces, the DP RAM, and the output ports. The component performs transformations on the data, such as byte lane selection and data alignment. Timing and synchronization are critical aspects of the component's operation. The design uses a single clock domain, with the `clk_i` signal driving all internal operations. The component adheres to standard timing constraints, including setup and hold requirements, to ensure reliable data transfer. The Program RAM component has several special features, including the optional throttling mechanism and the ability to operate in different modes, such as with or without throttling. These features make the component versatile and suitable for various applications. The component is typically used in systems requiring a program memory with controlled access interfaces, such as embedded processors, SoCs (System-on-Chip), and FPGA-based designs. The Program RAM's implementation considerations involve performance optimization, resource usage, and design trade-offs. The component's performance is influenced by factors such as the DP RAM size, the throttling mechanism, and the clock frequency. In terms of implementation, the component's resource usage is moderate, given its functionality and features. The design trade-offs involve balancing performance, area, and power consumption. The component's VHDL code is designed for simulation purposes, and its synthesizability may depend on specific implementation requirements. Overall, the Program RAM component is a sophisticated and versatile module, designed to provide efficient and controlled access to program instructions and data for the LXP32 test platform. Its features, such as optional throttling and dual-port RAM, make it suitable for a wide range of applications in embedded systems and SoC design.","---------------------------------------------------------------------
-- Program RAM
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Program RAM for the LXP32 test platform. Has two interfaces:
-- WISHBONE (for data access) and LLI (for LXP32 instruction bus).
-- Optionally performs throttling.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

use work.common_pkg.all;

entity program_ram is
	generic(
		THROTTLE: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(27 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		lli_re_i: in std_logic;
		lli_adr_i: in std_logic_vector(29 downto 0);
		lli_dat_o: out std_logic_vector(31 downto 0);
		lli_busy_o: out std_logic
	);
end entity;

architecture rtl of program_ram is

signal ram_a_we: std_logic_vector(3 downto 0);
signal ram_a_rdata: std_logic_vector(31 downto 0);

signal ram_b_re: std_logic;
signal ram_b_rdata: std_logic_vector(31 downto 0);

signal ack_write: std_logic;
signal ack_read: std_logic;

signal prbs: std_logic;
signal lli_busy: std_logic:='0';

begin

-- The total memory size is 16384 words, i.e. 64K bytes

gen_dprams: for i in 3 downto 0 generate
	generic_dpram_inst: entity work.generic_dpram(rtl)
		generic map(
			DATA_WIDTH=>8,
			ADDR_WIDTH=>14,
			SIZE=>16384,
			MODE=>""DONTCARE""
		)
		port map(
			clka_i=>clk_i,
			cea_i=>'1',
			wea_i=>ram_a_we(i),
			addra_i=>wbs_adr_i(15 downto 2),
			da_i=>wbs_dat_i(i*8+7 downto i*8),
			da_o=>ram_a_rdata(i*8+7 downto i*8),
			
			clkb_i=>clk_i,
			ceb_i=>ram_b_re,
			addrb_i=>lli_adr_i(13 downto 0),
			db_o=>ram_b_rdata(i*8+7 downto i*8)
		);
end generate;

-- WISHBONE interface

gen_ram_a_we: for i in 3 downto 0 generate
	ram_a_we(i)<='1' when wbs_cyc_i='1' and wbs_stb_i='1' and wbs_we_i='1'
		and wbs_sel_i(i)='1' and wbs_adr_i(27 downto 16)=""000000000000"" else '0';
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		ack_read<=wbs_cyc_i and wbs_stb_i and not wbs_we_i and not ack_read;
	end if;
end process;

ack_write<=wbs_cyc_i and wbs_stb_i and wbs_we_i;

wbs_ack_o<=ack_read or ack_write;
wbs_dat_o<=ram_a_rdata;

-- Low Latency Interface (with optional pseudo-random throttling)

process (clk_i) is
begin
	if rising_edge(clk_i) then
		assert lli_re_i='0' or lli_adr_i(lli_adr_i'high downto 14)=X""0000""
			report ""Attempted to fetch instruction from a non-existent address 0x""&
				hex_string(lli_adr_i&""00"")
			severity failure;
	end if;
end process;

gen_throttling: if THROTTLE generate
	throttle_inst: entity work.scrambler(rtl)
		generic map(TAP1=>9,TAP2=>11)
		port map(clk_i=>clk_i,rst_i=>rst_i,ce_i=>'1',d_o=>prbs);
end generate;

gen_no_throttling: if not THROTTLE generate
	prbs<='0';
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			lli_busy<='0';
		elsif prbs='1' and lli_re_i='1' then
			lli_busy<='1';
		elsif prbs='0' then
			lli_busy<='0';
		end if;
	end if;
end process;

ram_b_re<=lli_re_i and not lli_busy;

lli_busy_o<=lli_busy;
lli_dat_o<=ram_b_rdata when lli_busy='0' else (others=>'-');

end architecture;
"
"The scrambler component is a digital circuit designed to generate a pseudo-random binary sequence using a Linear-Feedback Shift Register (LFSR) architecture. Its primary purpose is to produce a maximum-length sequence, which is a characteristic of LFSRs, making it suitable for various applications such as data scrambling, error detection, and test pattern generation. The scrambler plays a crucial role in larger systems, particularly in communication and data transmission systems, where data needs to be scrambled or randomized to prevent data patterns from being easily identifiable. The scrambler has four ports: `clk_i`, `rst_i`, `ce_i`, and `d_o`. The `clk_i` port is a clock input that drives the internal sequential logic, and it is expected to be a periodic signal with a defined clock period. The `rst_i` port is an asynchronous reset input that initializes the internal state of the scrambler to a predefined value, typically used to ensure a known starting point for the LFSR sequence. The `ce_i` port is a clock enable input that controls whether the scrambler should update its internal state on the rising edge of the clock; when `ce_i` is high, the scrambler updates its state, and when it is low, the state remains unchanged. The `d_o` port is the output of the scrambler, which produces a single-bit pseudo-random binary sequence. Internally, the scrambler consists of a single register, `reg`, which is a shift register with a bit width equal to `TAP2`. The register is initialized to all ones, which is a common initial value for LFSRs. The scrambler uses two generic parameters, `TAP1` and `TAP2`, which define the taps of the LFSR. These taps determine the polynomial used to generate the pseudo-random sequence, and they must be chosen such that the polynomial is primitive, ensuring a maximum-length sequence is generated. The scrambler's architectural description reveals a straightforward implementation of an LFSR. The internal process is sensitive to the rising edge of the clock and is reset asynchronously by the `rst_i` input. When the clock enable `ce_i` is high, the register is updated by shifting its contents one bit to the right and computing the new most significant bit as the XOR of the bits at positions `TAP1` and `TAP2`. This update process is the core of the LFSR operation, generating a pseudo-random sequence. The functional behavior of the scrambler can be described step-by-step. On the rising edge of the clock, if the reset input `rst_i` is high, the register is reset to all ones. If the clock enable `ce_i` is high, the register is updated according to the LFSR recurrence relation. The output `d_o` is simply the least significant bit of the register. This behavior results in a pseudo-random binary sequence being generated on the `d_o` output. The control logic of the scrambler is primarily governed by the clock enable `ce_i` and the reset `rst_i`. The reset input asynchronously resets the register to its initial state, ensuring a predictable starting point for the sequence. The clock enable input controls whether the LFSR sequence advances on the rising edge of the clock. The state transitions are determined by the LFSR recurrence relation, which is defined by the `TAP1` and `TAP2` generic parameters. Data flow through the component is straightforward; the internal register is updated based on its current state and the LFSR recurrence relation, and the output is directly derived from the least significant bit of the register. There are no complex data transformations; the scrambler simply generates a pseudo-random sequence based on its internal state. In terms of timing and synchronization, the scrambler operates within a single clock domain defined by the `clk_i` input. The setup and hold requirements for the inputs are implicitly defined by the clock and the asynchronous reset. The scrambler's output `d_o` is updated on the rising edge of the clock, and its timing is directly related to the clock period. A special feature of this scrambler is its configurability through the `TAP1` and `TAP2` generic parameters, which allow different LFSR polynomials to be used. This configurability enables the generation of various pseudo-random sequences, making the scrambler versatile for different applications. The scrambler is typically used in communication systems, data transmission protocols, and test pattern generation. Its ability to generate a pseudo-random sequence makes it suitable for scrambling data, testing communication channels, or generating test patterns. When implementing the scrambler, designers should consider performance, resource usage, and design trade-offs. The component's simplicity and straightforward architecture suggest a low resource utilization, making it suitable for FPGA and ASIC implementations. However, the choice of `TAP1` and `TAP2` values significantly affects the sequence's properties, such as its length and statistical randomness. Designers must carefully select these parameters to meet the requirements of their specific application. Additionally, while the scrambler was designed for simulation purposes, its synthesizable subset of VHDL ensures that it can be implemented in hardware with minimal modifications.","---------------------------------------------------------------------
-- Scrambler
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Generates a pseudo-random binary sequence using a Linear-Feedback
-- Shift Register (LFSR).
--
-- In order to generate a maximum-length sequence, 1+x^TAP1+x^TAP2
-- must be a primitive polynomial. Typical polynomials include:
-- (6,7), (9,11), (14,15).
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity scrambler is
	generic(
		TAP1: integer;
		TAP2: integer
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		d_o: out std_logic
	);
end entity;

architecture rtl of scrambler is

signal reg: std_logic_vector(TAP2 downto 1):=(others=>'1');

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			reg<=(others=>'1');
		elsif ce_i='1' then
			reg<=reg(TAP2-1 downto 1)&(reg(TAP2) xor reg(TAP1));
		end if;
	end if;
end process;

d_o<=reg(1);

end architecture;
"
"describes a simple programmable interval timer, referred to as the ""timer"" component. This component is part of the LXP32 test platform and is designed for simulation purposes. The timer's primary function is to generate a periodic signal, `elapsed_o`, based on a programmable interval, and to provide a simple interface for configuring and monitoring the timer. The timer has a Wishbone interface, which is a standard interface for System-on-Chip (SoC) design, allowing it to be easily integrated with other components. The interface consists of several input ports: `clk_i`, `rst_i`, `wbs_cyc_i`, `wbs_stb_i`, `wbs_we_i`, `wbs_sel_i`, `wbs_adr_i`, and `wbs_dat_i`, as well as output ports: `wbs_ack_o`, `wbs_dat_o`, and `elapsed_o`. The `clk_i` port is the clock input, while `rst_i` is the asynchronous reset input. The `wbs_cyc_i`, `wbs_stb_i`, and `wbs_we_i` inputs are used to control the Wishbone interface. `wbs_cyc_i` indicates a valid cycle, `wbs_stb_i` indicates a strobe signal, and `wbs_we_i` indicates a write enable. The `wbs_sel_i` input selects which byte lanes are being written or read. The `wbs_adr_i` input provides the address for the Wishbone interface, and `wbs_dat_i` provides the data to be written. The timer has several internal signals that control its operation. The `pulses` signal represents the number of intervals remaining, while the `interval` signal represents the current interval value. The `cnt` signal is a counter that decrements on each clock cycle. The `elapsed` signal indicates whether the timer has expired. The timer's internal structure consists of a single process that is sensitive to the `clk_i` input. On each rising edge of the clock, the process checks if the reset input `rst_i` is high, and if so, resets all internal signals to their initial values. Otherwise, it checks if the `irq_level_triggered` signal is low, and if so, clears the `elapsed` signal. The process then checks if the `pulses` or `cnt` signals are non-zero. If either signal is non-zero, it decrements the `cnt` signal on each clock cycle. When the `cnt` signal reaches zero, it is reloaded with the `interval` value, and the `pulses` signal is decremented if it is non-zero. When the `cnt` signal reaches one, the `elapsed` signal is set high. The process also checks for Wishbone write cycles, and if a write cycle is detected, it updates the internal signals accordingly. The `wbs_ack_o` output is asserted on each cycle where `wbs_cyc_i` and `wbs_stb_i` are high. The `wbs_dat_o` output provides the current value of the `pulses` or `interval` signals, depending on the address provided on the `wbs_adr_i` input. The `elapsed_o` output provides the current value of the `elapsed` signal, inverted if the `irq_invert` signal is high. The timer's control logic is primarily contained within the single process. The `irq_level_triggered` and `irq_invert` signals control the behavior of the `elapsed_o` output. The `wbs_sel_i` input controls which byte lanes are being written or read. The timer's data flow is straightforward, with data moving from the Wishbone interface into the internal registers, and then being used to control the timer's operation. The timer's output is generated based on the internal state of the `elapsed` signal. In terms of timing and synchronization, the timer has a single clock domain, and all internal signals are synchronized to the `clk_i` input. The timer has no specific setup or hold requirements, as it is designed to operate in a standard synchronous manner. The timer has several special features, including a programmable interval, a level-triggered interrupt output, and a simple Wishbone interface. The timer can be used in a variety of applications, including embedded systems, industrial control systems, and communication systems. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The timer's simple design makes it suitable for implementation on a variety of platforms, including FPGAs and ASICs. However, designers should carefully consider the timing requirements of the system, as well as the resource usage of the timer, to ensure that it meets the system's performance and area requirements. Overall, the timer component provides a simple and flexible solution for generating periodic signals in a variety of systems. Its Wishbone interface makes it easy to integrate with other components, and its programmable interval and level-triggered interrupt output make it suitable for a wide range of applications.","---------------------------------------------------------------------
-- Timer
--
-- Part of the LXP32 test platform
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A simple programmable interval timer.
--
-- Note: regardless of whether this description is synthesizable,
-- it was designed exclusively for simulation purposes.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity timer is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		wbs_cyc_i: in std_logic;
		wbs_stb_i: in std_logic;
		wbs_we_i: in std_logic;
		wbs_sel_i: in std_logic_vector(3 downto 0);
		wbs_ack_o: out std_logic;
		wbs_adr_i: in std_logic_vector(27 downto 2);
		wbs_dat_i: in std_logic_vector(31 downto 0);
		wbs_dat_o: out std_logic_vector(31 downto 0);
		
		elapsed_o: out std_logic
	);
end entity;

architecture rtl of timer is

signal irq_level_triggered: std_logic:='0';
signal irq_invert: std_logic:='0';

signal pulses: unsigned(31 downto 0):=(others=>'0');
signal interval: unsigned(31 downto 0):=(others=>'0');
signal cnt: unsigned(31 downto 0):=(others=>'0');
signal elapsed: std_logic:='0';

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			pulses<=(others=>'0');
			interval<=(others=>'0');
			cnt<=(others=>'0');
			elapsed<='0';
		else
			if irq_level_triggered='0' then
				elapsed<='0';
			end if;
			if pulses/=X""00000000"" or cnt/=X""00000000"" then
				if cnt=X""00000000"" then
					if pulses/=X""FFFFFFFF"" then
						pulses<=pulses-1;
					end if;
					if pulses/=X""00000000"" then
						cnt<=interval;
					end if;
				else
					cnt<=cnt-1;
				end if;
				if cnt=X""00000001"" then
					elapsed<='1';
				end if;
			end if;
			
			if wbs_cyc_i='1' and wbs_stb_i='1' and wbs_we_i='1' then
				for i in wbs_sel_i'range loop
					if wbs_sel_i(i)='1' then
						if wbs_adr_i=""00""&X""000000"" then
							pulses(i*8+7 downto i*8)<=
								unsigned(wbs_dat_i(i*8+7 downto i*8));
							cnt<=(others=>'0');
						end if;
						if wbs_adr_i=""00""&X""000001"" then
							interval(i*8+7 downto i*8)<=
								unsigned(wbs_dat_i(i*8+7 downto i*8));
							cnt<=(others=>'0');
						end if;
						if wbs_adr_i=""00""&X""000002"" and i=0 then
							irq_level_triggered<=wbs_dat_i(0);
							irq_invert<=wbs_dat_i(1);
						end if;
						if wbs_adr_i=""00""&X""000003"" and wbs_dat_i(0)='1' and i=0 then
							elapsed<='0';
						end if;
					end if;
				end loop;
			end if;
		end if;
	end if;
end process;

wbs_ack_o<=wbs_cyc_i and wbs_stb_i;
wbs_dat_o<=std_logic_vector(pulses) when wbs_adr_i=""00""&X""000000"" else
	std_logic_vector(interval) when wbs_adr_i=""00""&X""000001"" else
	(others=>'-');

elapsed_o<=elapsed xor irq_invert;

end architecture;
"
"The LXP32 Arithmetic Logic Unit (ALU) is a critical component of the LXP32 CPU, responsible for executing arithmetic and logic operations. Its primary purpose is to perform a wide range of operations, including addition, subtraction, multiplication, division, comparison, and bitwise operations, which are essential for the CPU's execution of instructions. The ALU features a generic interface, allowing for flexibility in its configuration. The `DIVIDER_EN` generic enables or disables the divider module, while the `MUL_ARCH` generic selects the multiplier architecture, which can be implemented using a digital signal processing (DSP) block, an optimized module, or a sequential module. The entity has a total of 20 ports, including clock and reset inputs, command and data inputs, and result and status outputs. The input ports include `clk_i` and `rst_i` for clock and reset, respectively, as well as `valid_i` to indicate the validity of the input data. The command inputs, such as `cmd_addsub_i`, `cmd_mul_i`, and `cmd_div_i`, determine the operation to be performed. The data inputs, `op1_i` and `op2_i`, are 32-bit vectors that provide the operands for the operations. The output ports include `result_o`, which provides the result of the operation, and status outputs, such as `cmp_eq_o`, `cmp_ug_o`, and `cmp_sg_o`, which indicate the results of comparison operations. Internally, the ALU consists of several modules, including an adder, a comparator, logic operation modules, a multiplier, a divider, and a shifter. The adder performs addition and subtraction operations, while the comparator executes comparison operations. The logic operation modules perform bitwise AND, OR, and XOR operations. The multiplier and divider modules are instantiated based on the `MUL_ARCH` and `DIVIDER_EN` generics, respectively. The ALU's architectural description reveals a complex interplay between these modules. The adder and comparator operate on the input operands, producing results that are then multiplexed with the results from other modules. The multiplier and divider modules have their own control signals, such as `mul_ce` and `div_ce`, which enable their operation. The shifter module performs shift operations on the input data. The functional behavior of the ALU can be described as follows: when the `valid_i` signal is high, the ALU performs the operation specified by the command inputs. The result is then provided on the `result_o` output, and the status outputs are updated accordingly. The ALU's operation is synchronized with the clock, and the `busy_o` output indicates whether the ALU is currently performing an operation. The control logic of the ALU is distributed across various modules. The `adder_we` signal enables the adder's result to be written to the output, while the `logic_we`, `mul_we`, `div_we`, and `shift_we` signals control the output of the corresponding modules. The `busy` signal is generated based on the control signals and the clock, indicating whether the ALU is busy performing an operation. Data flow through the ALU involves the input operands being processed by the various modules, with the results being multiplexed and provided on the output. The ALU performs transformations on the input data, such as sign extension, negation, and shifting. The timing and synchronization of the ALU are critical to its correct operation. The ALU operates in a single clock domain, with the clock and reset inputs controlling its behavior. The setup and hold requirements for the input signals are not explicitly specified, but it is assumed that they meet the standard requirements for a digital circuit. The ALU features several special features, including support for signed and unsigned operations, as well as a configurable multiplier architecture. The divider module can be enabled or disabled, allowing for flexibility in the ALU's configuration. The LXP32 ALU is typically used in the execution stage of a CPU pipeline, where it performs arithmetic and logic operations on the operands provided by the instruction decoder. Its applications include general-purpose computing, embedded systems, and digital signal processing. In terms of implementation considerations, the ALU's performance is dependent on the technology used to implement the various modules. The resource usage of the ALU is moderate, with a reasonable number of logic cells and registers required to implement the various modules. The design trade-offs include the choice of multiplier architecture, the inclusion of the divider module, and the optimization of the logic operation modules. Overall, the LXP32 ALU is a complex digital component that plays a critical role in the execution of instructions in the LXP32 CPU. Its architectural description reveals a sophisticated interplay between various modules, and its functional behavior is synchronized with the clock to ensure correct operation.","---------------------------------------------------------------------
-- Arithmetic logic unit
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Performs arithmetic and logic operations.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_alu is
	generic(
		DIVIDER_EN: boolean;
		MUL_ARCH: string
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		valid_i: in std_logic;
		
		cmd_signed_i: in std_logic;
		cmd_addsub_i: in std_logic;
		cmd_mul_i: in std_logic;
		cmd_div_i: in std_logic;
		cmd_div_mod_i: in std_logic;
		cmd_cmp_i: in std_logic;
		cmd_negate_op2_i: in std_logic;
		cmd_and_i: in std_logic;
		cmd_xor_i: in std_logic;
		cmd_shift_i: in std_logic;
		cmd_shift_right_i: in std_logic;
		
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		
		result_o: out std_logic_vector(31 downto 0);
		
		cmp_eq_o: out std_logic;
		cmp_ug_o: out std_logic;
		cmp_sg_o: out std_logic;
		
		we_o: out std_logic;
		busy_o: out std_logic
	);
end entity;

architecture rtl of lxp32_alu is

signal addend1: unsigned(31 downto 0);
signal addend2: unsigned(31 downto 0);
signal adder_result: unsigned(32 downto 0);
signal adder_we: std_logic;

signal cmp_eq: std_logic;
signal cmp_carry: std_logic;
signal cmp_s1: std_logic;
signal cmp_s2: std_logic;

signal logic_result: std_logic_vector(31 downto 0);
signal logic_we: std_logic;

signal mul_result: std_logic_vector(31 downto 0);
signal mul_ce: std_logic;
signal mul_we: std_logic;

signal div_result: std_logic_vector(31 downto 0);
signal div_ce: std_logic;
signal div_we: std_logic;

signal shift_result: std_logic_vector(31 downto 0);
signal shift_ce: std_logic;
signal shift_we: std_logic;

signal result_mux: std_logic_vector(31 downto 0);
signal result_we: std_logic;

signal busy: std_logic:='0';

begin

assert MUL_ARCH=""dsp"" or MUL_ARCH=""seq"" or MUL_ARCH=""opt""
	report ""Invalid MUL_ARCH generic value: dsp, opt or seq expected""
	severity failure;

-- Add/subtract

addend1<=unsigned(op1_i);

addend2_gen: for i in addend2'range generate
	addend2(i)<=op2_i(i) xor cmd_negate_op2_i;
end generate;

adder_result<=(""0""&addend1)+(""0""&addend2)+(to_unsigned(0,adder_result'length-1)&cmd_negate_op2_i);
adder_we<=cmd_addsub_i and valid_i;

-- Comparator (needs cmd_negate_op2_i to work correctly)

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if valid_i='1' and cmd_cmp_i='1' then
			if op1_i=op2_i then
				cmp_eq<='1';
			else
				cmp_eq<='0';
			end if;
			
			cmp_carry<=adder_result(adder_result'high);
			cmp_s1<=op1_i(op1_i'high);
			cmp_s2<=op2_i(op2_i'high);
		end if;
	end if;
end process;

cmp_eq_o<=cmp_eq;
cmp_ug_o<=cmp_carry and not cmp_eq;
cmp_sg_o<=((cmp_s1 and cmp_s2 and cmp_carry) or
	(not cmp_s1 and not cmp_s2 and cmp_carry) or
	(not cmp_s1 and cmp_s2)) and not cmp_eq;

-- Bitwise operations (and, or, xor)
-- Note: (a or b) = (a and b) or (a xor b)

logic_result_gen: for i in logic_result'range generate
	logic_result(i)<=((op1_i(i) and op2_i(i)) and cmd_and_i) or
		((op1_i(i) xor op2_i(i)) and cmd_xor_i);
end generate;

logic_we<=(cmd_and_i or cmd_xor_i) and valid_i;

-- Multiplier

mul_ce<=cmd_mul_i and valid_i;

gen_mul_dsp: if MUL_ARCH=""dsp"" generate
	mul_inst: entity work.lxp32_mul_dsp(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>mul_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			ce_o=>mul_we,
			result_o=>mul_result
		);
end generate;

gen_mul_opt: if MUL_ARCH=""opt"" generate
	mul_inst: entity work.lxp32_mul_opt(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>mul_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			ce_o=>mul_we,
			result_o=>mul_result
		);
end generate;

gen_mul_seq: if MUL_ARCH=""seq"" generate
	mul_inst: entity work.lxp32_mul_seq(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>mul_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			ce_o=>mul_we,
			result_o=>mul_result
		);
end generate;

-- Divider

div_ce<=cmd_div_i and valid_i;

gen_divider: if DIVIDER_EN generate
	divider_inst: entity work.lxp32_divider(rtl)
		port map(
			clk_i=>clk_i,
			rst_i=>rst_i,
			ce_i=>div_ce,
			op1_i=>op1_i,
			op2_i=>op2_i,
			signed_i=>cmd_signed_i,
			rem_i=>cmd_div_mod_i,
			ce_o=>div_we,
			result_o=>div_result
		);
end generate;

gen_no_divider: if not DIVIDER_EN generate
	div_we<=div_ce;
	div_result<=(others=>'0');
end generate;

-- Shifter

shift_ce<=cmd_shift_i and valid_i;

shifter_inst: entity work.lxp32_shifter(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		ce_i=>shift_ce,
		d_i=>op1_i,
		s_i=>op2_i(4 downto 0),
		right_i=>cmd_shift_right_i,
		sig_i=>cmd_signed_i,
		ce_o=>shift_we,
		d_o=>shift_result
	);

-- Result multiplexer

result_mux_gen: for i in result_mux'range generate
	result_mux(i)<=(adder_result(i) and adder_we) or
		(logic_result(i) and logic_we) or
		(mul_result(i) and mul_we) or
		(div_result(i) and div_we) or
		(shift_result(i) and shift_we);
end generate;

result_o<=result_mux;

result_we<=adder_we or logic_we or mul_we or div_we or shift_we;
we_o<=result_we;

-- Pipeline control

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' or result_we='1' then
			busy<='0';
		elsif shift_ce='1' or mul_ce='1' or div_ce='1' then
			busy<='1';
		end if;
	end if;
end process;

busy_o<=busy;

end architecture;
"
"The LXP32_Compl component is a digital circuit designed to compute the two's complement of its input data. As part of the LXP32 CPU, it serves as an auxiliary unit in the divider, suggesting its role in handling signed arithmetic operations. The component accepts a 32-bit input data signal, a clock signal, and a complement control signal, producing a 32-bit output data signal. The input ports of the LXP32_Compl component are crucial to its operation. The `clk_i` port is a clock signal that drives the internal sequential logic, necessitating a stable and precise clock source to ensure accurate computations. The `compl_i` port is a control signal that determines whether the input data should be complemented; when asserted, it inverts the bits of the input data and adjusts the arithmetic operations accordingly. The `d_i` port is a 32-bit input data signal that provides the data to be complemented. The output port, `d_o`, is also a 32-bit signal that presents the computed two's complement of the input data. Internally, the LXP32_Compl component consists of several key signals and operations. The `d_prepared` signal is generated by XORing each bit of the input data `d_i` with the complement control signal `compl_i`. This operation effectively inverts the input data bits when the complement control signal is asserted. The component then splits the prepared data into two parts: `d_high` and `d_prepared(15 downto 0)`, which are processed separately to compute the two's complement. The architectural description reveals a multi-stage process. First, on the rising edge of the clock signal, the component calculates `sum_low` by adding a zero-extended version of the lower 16 bits of `d_prepared` and the complement control signal. Simultaneously, it captures the upper 16 bits of `d_prepared` into `d_high`. Then, it computes `sum_high` by adding `d_high` and an extended version of the most significant bit of `sum_low`. This process effectively calculates the two's complement by adding 1 to the inverted input data. The functional behavior of the LXP32_Compl component can be described step-by-step. Upon receiving the input data and the complement control signal, the component inverts the input data bits if required. It then performs the arithmetic operations to compute the two's complement. The output data is produced by concatenating `sum_high` and the lower 16 bits of `sum_low`. This process occurs on each rising edge of the clock signal, indicating that the component operates in a pipelined fashion. The control logic of the LXP32_Compl component is primarily governed by the clock signal and the complement control signal. The component's operation is enabled on the rising edge of the clock signal, ensuring that the internal state transitions occur synchronously. The reset behavior is not explicitly defined, implying that the component may rely on the system's reset mechanism or an asynchronous reset not shown in the provided code. The data flow within the LXP32_Compl component involves several transformations. The input data is first inverted if required, then split into two parts for processing. The lower part is zero-extended and added to the complement control signal, while the upper part is added to the carry from the lower part. The final output is produced by concatenating the results of these additions. The component's timing and synchronization are critical to its correct operation. The clock domain is defined by the `clk_i` signal, and the component requires a stable clock source to ensure accurate computations. The setup and hold requirements for the input data and control signals are not explicitly specified, implying that they should adhere to standard digital design constraints. A notable feature of the LXP32_Compl component is its ability to compute the two's complement in a single clock cycle, making it suitable for high-speed arithmetic operations. The component's design also suggests a compact implementation, as it only requires a minimal number of logic gates and registers. The LXP32_Compl component is typically used in digital systems that require signed arithmetic operations, such as dividers, multipliers, or arithmetic logic units. Its application in the LXP32 CPU's divider unit highlights its role in handling two's complement arithmetic. When implementing the LXP32_Compl component, designers should consider performance, resource usage, and design trade-offs. The component's compact design and single-cycle operation suggest a high-performance implementation. However, the actual implementation may depend on the target technology, design constraints, and optimization goals. Designers should also consider the component's interaction with other system components, such as the divider unit, to ensure seamless integration and correct functionality. Overall, the LXP32_Compl component is a well-structured and efficient digital circuit that plays a critical role in the LXP32 CPU's arithmetic operations.","---------------------------------------------------------------------
-- Complementor
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Computes a 2's complement of its input. Used as an auxiliary
-- unit in the divider.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_compl is
	port(
		clk_i: in std_logic;
		compl_i: in std_logic;
		d_i: in std_logic_vector(31 downto 0);
		d_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_compl is

signal d_prepared: unsigned(d_i'range);
signal sum_low: unsigned(16 downto 0);
signal d_high: unsigned(15 downto 0);
signal sum_high: unsigned(15 downto 0);

begin

d_prepared_gen: for i in d_prepared'range generate
	d_prepared(i)<=d_i(i) xor compl_i;
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		sum_low<=(""0""&d_prepared(15 downto 0))+(to_unsigned(0,16)&compl_i);
		d_high<=d_prepared(31 downto 16);
	end if;
end process;

sum_high<=d_high+(to_unsigned(0,15)&sum_low(sum_low'high));

d_o<=std_logic_vector(sum_high&sum_low(15 downto 0));

end architecture;
"
"The LXP32 CPU Core is a 32-bit central processing unit designed to execute instructions and manage data transfer between various components. As the primary component of the LXP32 CPU, it plays a crucial role in larger systems, serving as the brain of the operation, executing instructions, and controlling data flow. The LXP32 CPU Core has several input and output ports that facilitate communication with other components. The clock input (clk_i) and reset input (rst_i) are essential for synchronizing and resetting the core. The lli_re_o, lli_adr_o, and lli_dat_i ports are used for instruction fetching, where lli_re_o is the read enable signal, lli_adr_o is the address output, and lli_dat_i is the instruction data input. The lli_busy_i signal indicates whether the instruction fetch is busy. The dbus_cyc_o, dbus_stb_o, dbus_we_o, dbus_sel_o, dbus_ack_i, dbus_adr_o, dbus_dat_o, and dbus_dat_i ports are used for data bus operations, including cycle, strobe, write enable, select, acknowledge, address, data output, and data input. The irq_i port receives interrupt requests. Internally, the LXP32 CPU Core consists of several key components, including the instruction fetch unit (fetch_inst), instruction decode unit (decode_inst), execution unit (execute_inst), scratchpad (scratchpad_inst), and interrupt multiplexer (interrupt_mux_inst). The fetch_inst unit fetches instructions from memory and provides the fetched instruction word, next instruction address, current instruction address, and validity signal. The decode_inst unit decodes the instruction and generates control signals, including command signals for load operation, signed operation, data bus operation, and arithmetic operations. The execute_inst unit executes the decoded instructions, performing arithmetic and logical operations, and generates the results. The scratchpad_inst provides a small on-chip memory for storing data, and the interrupt_mux_inst handles interrupt requests. The LXP32 CPU Core operates in a step-by-step manner, with each stage dependent on the previous one. The instruction fetch unit fetches an instruction, which is then decoded by the decode unit. The decoded instruction is then executed by the execute unit, which performs the required operations. The scratchpad provides data storage, and the interrupt multiplexer handles interrupt requests. The core's operation is synchronized by the clock input, and reset is performed using the reset input. The control logic of the LXP32 CPU Core is distributed across various components. The fetch_inst unit controls instruction fetching, and the decode_inst unit generates control signals for the execute_inst unit. The execute_inst unit has its own control logic, which manages data flow and operation execution. The interrupt_mux_inst has control logic for handling interrupt requests. Data flow through the LXP32 CPU Core is primarily managed by the execute_inst unit, which performs arithmetic and logical operations on data received from the decode_inst unit. The data is then stored in the scratchpad or transferred to other components via the data bus. The LXP32 CPU Core has specific timing and synchronization requirements. The clock input (clk_i) is used to synchronize the core's operation, and the reset input (rst_i) is used to reset the core. The core has setup and hold requirements for the clock and data signals. One of the special features of the LXP32 CPU Core is its support for interrupts, which are handled by the interrupt_mux_inst. The core also has a scratchpad memory for storing data. The LXP32 CPU Core is typically used in embedded systems, microcontrollers, and other applications requiring a compact and efficient CPU. When implementing the LXP32 CPU Core, designers must consider performance, resource usage, and design trade-offs. The core's performance is influenced by the clock frequency, instruction set architecture, and data path width. Resource usage is affected by the core's complexity, instruction set, and data path width. Design trade-offs include balancing performance, power consumption, and area. In terms of implementation considerations, designers should consider the target technology, clock frequency, and performance requirements. They must also optimize the core's resource usage, including logic cells, memory, and I/O pins. Additionally, designers should consider design-for-testability and verification methodologies to ensure the core's correct functionality. The LXP32 CPU Core's architecture and functionality make it suitable for a wide range of applications, from simple embedded systems to complex digital systems. Its efficient instruction set, interrupt handling, and scratchpad memory make it an attractive option for designers seeking to implement a compact and efficient CPU. The LXP32 CPU core provides flexibility through its generic parameters, such as DBUS_RMW, DIVIDER_EN, and MUL_ARCH, which allow designers to customize the core's functionality and optimize its performance for specific applications. Overall, the LXP32 CPU Core is a well-structured and efficient design that provides a solid foundation for building complex digital systems. Its modular architecture, efficient instruction set, and interrupt handling make it suitable for a wide range of applications.","---------------------------------------------------------------------
-- LXP32 CPU Core
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_cpu is
	generic(
		DBUS_RMW: boolean;
		DIVIDER_EN: boolean;
		MUL_ARCH: string;
		START_ADDR: std_logic_vector(31 downto 0)
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		irq_i: in std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32_cpu is

signal fetch_word: std_logic_vector(31 downto 0);
signal fetch_next_ip: std_logic_vector(29 downto 0);
signal fetch_current_ip: std_logic_vector(29 downto 0);
signal fetch_valid: std_logic;
signal fetch_jump_ready: std_logic;

signal decode_ready: std_logic;
signal decode_valid: std_logic;

signal decode_cmd_loadop3: std_logic;
signal decode_cmd_signed: std_logic;
signal decode_cmd_dbus: std_logic;
signal decode_cmd_dbus_store: std_logic;
signal decode_cmd_dbus_byte: std_logic;
signal decode_cmd_addsub: std_logic;
signal decode_cmd_mul: std_logic;
signal decode_cmd_div: std_logic;
signal decode_cmd_div_mod: std_logic;
signal decode_cmd_cmp: std_logic;
signal decode_cmd_jump: std_logic;
signal decode_cmd_negate_op2: std_logic;
signal decode_cmd_and: std_logic;
signal decode_cmd_xor: std_logic;
signal decode_cmd_shift: std_logic;
signal decode_cmd_shift_right: std_logic;

signal decode_jump_type: std_logic_vector(3 downto 0);

signal decode_op1: std_logic_vector(31 downto 0);
signal decode_op2: std_logic_vector(31 downto 0);
signal decode_op3: std_logic_vector(31 downto 0);
signal decode_dst: std_logic_vector(7 downto 0);

signal execute_ready: std_logic;
signal execute_jump_valid: std_logic;
signal execute_jump_dst: std_logic_vector(29 downto 0);

signal sp_raddr1: std_logic_vector(7 downto 0);
signal sp_rdata1: std_logic_vector(31 downto 0);
signal sp_raddr2: std_logic_vector(7 downto 0);
signal sp_rdata2: std_logic_vector(31 downto 0);
signal sp_waddr: std_logic_vector(7 downto 0);
signal sp_we: std_logic;
signal sp_wdata: std_logic_vector(31 downto 0);

signal interrupt_valid: std_logic;
signal interrupt_vector: std_logic_vector(2 downto 0);
signal interrupt_ready: std_logic;
signal interrupt_return: std_logic;
signal interrupt_wakeup: std_logic;

begin

fetch_inst: entity work.lxp32_fetch(rtl)
	generic map(
		START_ADDR=>START_ADDR
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_o=>lli_re_o,
		lli_adr_o=>lli_adr_o,
		lli_dat_i=>lli_dat_i,
		lli_busy_i=>lli_busy_i,
		
		word_o=>fetch_word,
		next_ip_o=>fetch_next_ip,
		current_ip_o=>fetch_current_ip,
		valid_o=>fetch_valid,
		ready_i=>decode_ready,
		
		jump_valid_i=>execute_jump_valid,
		jump_dst_i=>execute_jump_dst,
		jump_ready_o=>fetch_jump_ready
	);

decode_inst: entity work.lxp32_decode(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		word_i=>fetch_word,
		next_ip_i=>fetch_next_ip,
		current_ip_i=>fetch_current_ip,
		valid_i=>fetch_valid,
		jump_valid_i=>execute_jump_valid,
		ready_o=>decode_ready,
		
		interrupt_valid_i=>interrupt_valid,
		interrupt_vector_i=>interrupt_vector,
		interrupt_ready_o=>interrupt_ready,

		wakeup_i=>interrupt_wakeup,
		
		sp_raddr1_o=>sp_raddr1,
		sp_rdata1_i=>sp_rdata1,
		sp_raddr2_o=>sp_raddr2,
		sp_rdata2_i=>sp_rdata2,
		
		ready_i=>execute_ready,
		valid_o=>decode_valid,
		
		cmd_loadop3_o=>decode_cmd_loadop3,
		cmd_signed_o=>decode_cmd_signed,
		cmd_dbus_o=>decode_cmd_dbus,
		cmd_dbus_store_o=>decode_cmd_dbus_store,
		cmd_dbus_byte_o=>decode_cmd_dbus_byte,
		cmd_addsub_o=>decode_cmd_addsub,
		cmd_mul_o=>decode_cmd_mul,
		cmd_div_o=>decode_cmd_div,
		cmd_div_mod_o=>decode_cmd_div_mod,
		cmd_cmp_o=>decode_cmd_cmp,
		cmd_jump_o=>decode_cmd_jump,
		cmd_negate_op2_o=>decode_cmd_negate_op2,
		cmd_and_o=>decode_cmd_and,
		cmd_xor_o=>decode_cmd_xor,
		cmd_shift_o=>decode_cmd_shift,
		cmd_shift_right_o=>decode_cmd_shift_right,
		
		jump_type_o=>decode_jump_type,
		
		op1_o=>decode_op1,
		op2_o=>decode_op2,
		op3_o=>decode_op3,
		dst_o=>decode_dst
	);

execute_inst: entity work.lxp32_execute(rtl)
	generic map(
		DBUS_RMW=>DBUS_RMW,
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		cmd_loadop3_i=>decode_cmd_loadop3,
		cmd_signed_i=>decode_cmd_signed,
		cmd_dbus_i=>decode_cmd_dbus,
		cmd_dbus_store_i=>decode_cmd_dbus_store,
		cmd_dbus_byte_i=>decode_cmd_dbus_byte,
		cmd_addsub_i=>decode_cmd_addsub,
		cmd_mul_i=>decode_cmd_mul,
		cmd_div_i=>decode_cmd_div,
		cmd_div_mod_i=>decode_cmd_div_mod,
		cmd_cmp_i=>decode_cmd_cmp,
		cmd_jump_i=>decode_cmd_jump,
		cmd_negate_op2_i=>decode_cmd_negate_op2,
		cmd_and_i=>decode_cmd_and,
		cmd_xor_i=>decode_cmd_xor,
		cmd_shift_i=>decode_cmd_shift,
		cmd_shift_right_i=>decode_cmd_shift_right,
		
		jump_type_i=>decode_jump_type,
		
		op1_i=>decode_op1,
		op2_i=>decode_op2,
		op3_i=>decode_op3,
		dst_i=>decode_dst,
		
		sp_waddr_o=>sp_waddr,
		sp_we_o=>sp_we,
		sp_wdata_o=>sp_wdata,
		
		valid_i=>decode_valid,
		ready_o=>execute_ready,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i,
		
		jump_valid_o=>execute_jump_valid,
		jump_dst_o=>execute_jump_dst,
		jump_ready_i=>fetch_jump_ready,
		
		interrupt_return_o=>interrupt_return
	);

scratchpad_inst: entity work.lxp32_scratchpad(rtl)
	port map(
		clk_i=>clk_i,
		
		raddr1_i=>sp_raddr1,
		rdata1_o=>sp_rdata1,
		raddr2_i=>sp_raddr2,
		rdata2_o=>sp_rdata2,
		
		waddr_i=>sp_waddr,
		we_i=>sp_we,
		wdata_i=>sp_wdata
	);

interrupt_mux_inst: entity work.lxp32_interrupt_mux(rtl)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		irq_i=>irq_i,
		
		interrupt_valid_o=>interrupt_valid,
		interrupt_vector_o=>interrupt_vector,
		interrupt_ready_i=>interrupt_ready,
		interrupt_return_i=>interrupt_return,

		wakeup_o=>interrupt_wakeup,
		
		sp_waddr_i=>sp_waddr,
		sp_we_i=>sp_we,
		sp_wdata_i=>sp_wdata
	);

end architecture;
"
"The LXP32 DBUS master component is a crucial part of the LXP32 CPU, responsible for managing data bus (DBUS) access. Its primary purpose is to facilitate data transfer between the CPU and external devices connected to the DBUS. This component plays a vital role in larger systems, enabling the CPU to interact with memory, peripherals, and other devices. The component has a range of input ports that control its operation. The `clk_i` and `rst_i` ports are used for clocking and resetting the component, respectively. The `valid_i` port indicates whether the input data is valid, while `cmd_dbus_i`, `cmd_dbus_store_i`, `cmd_dbus_byte_i`, and `cmd_signed_i` ports determine the type of DBUS operation to be performed. The `addr_i` and `wdata_i` ports provide the address and write data for the DBUS operation. The component also has several output ports, including `rdata_o`, `we_o`, and `busy_o`, which indicate the read data, write enable, and busy status, respectively. Additionally, the `dbus_cyc_o`, `dbus_stb_o`, `dbus_we_o`, `dbus_sel_o`, `dbus_adr_o`, `dbus_dat_o`, and `dbus_dat_i` ports are used to interact with the DBUS. Internally, the component consists of several signals and registers that manage the DBUS operation. The `strobe` signal indicates when a DBUS operation is in progress, while `we_out` and `we` signals control the write enable. The `byte_mode` signal determines whether the operation is performed in byte or word mode, and `sel` signal selects the specific byte or bytes to be accessed. The `rmw_mode` signal indicates whether the operation is a read-modify-write (RMW) operation. The component also has several registers, including `dbus_rdata` and `selected_byte`, which store the read data and selected byte, respectively. The component's operation can be described as follows: when the `valid_i` and `cmd_dbus_i` signals are high, the component initiates a DBUS operation. The `strobe` signal is set high, and the `dbus_adr_o` and `dbus_dat_o` signals are driven with the address and write data, respectively. The component then waits for the `dbus_ack_i` signal to indicate that the DBUS operation is complete. If the operation is an RMW operation, the component updates the `dbus_dat_o` signal with the read data. Once the operation is complete, the `strobe` signal is reset, and the `we_out` signal is set high to indicate that the write enable is active. The control logic of the component is primarily managed by the `strobe` and `we` signals. The `strobe` signal enables the DBUS operation, while the `we` signal controls the write enable. The component also has a reset behavior, where all signals are reset to their initial values when the `rst_i` signal is high. The state transitions are managed by the `strobe` and `dbus_ack_i` signals, which determine when the component transitions between states. The data flow through the component is as follows: the `wdata_i` signal is driven onto the `dbus_dat_o` signal, and the `dbus_dat_i` signal is driven onto the `dbus_rdata` signal. The component also performs data transformations, such as byte selection and sign extension, depending on the `byte_mode` and `sig` signals. The component has specific timing and synchronization requirements. The `clk_i` signal is used to clock the component, and the `rst_i` signal is used to reset the component. The component also has setup and hold requirements for the `dbus_ack_i` signal, which must be met to ensure proper operation. One of the special features of this component is its support for RMW operations. When the `RMW` generic is set to `true`, the component performs RMW operations, which allow for more efficient data transfer. The component also has a byte mode, which allows for byte-granular access to the DBUS. The LXP32 DBUS master component is typically used in systems where the CPU needs to interact with external devices connected to the DBUS. This component can be used in a wide range of applications, including embedded systems, microcontrollers, and system-on-chip (SoC) designs. In terms of implementation considerations, the component's performance and resource usage depend on the specific technology and synthesis tools used. However, the component's design is optimized for efficient data transfer and minimal resource usage. The component's generic `RMW` parameter allows for flexibility in configuring the component for different applications. Overall, the LXP32 DBUS master component is a critical component in the LXP32 CPU, enabling efficient and flexible data transfer between the CPU and external devices connected to the DBUS.","---------------------------------------------------------------------
-- DBUS master
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Manages data bus (DBUS) access.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_dbus is
	generic(
		RMW: boolean
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		valid_i: in std_logic;
		
		cmd_dbus_i: in std_logic;
		cmd_dbus_store_i: in std_logic;
		cmd_dbus_byte_i: in std_logic;
		cmd_signed_i: in std_logic;
		addr_i: in std_logic_vector(31 downto 0);
		wdata_i: in std_logic_vector(31 downto 0);
		
		rdata_o: out std_logic_vector(31 downto 0);
		we_o: out std_logic;
		busy_o: out std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_dbus is

signal strobe: std_logic:='0';
signal we_out: std_logic:='0';
signal we: std_logic;
signal byte_mode: std_logic;
signal sel: std_logic_vector(3 downto 0);
signal sig: std_logic;
signal rmw_mode: std_logic;

signal dbus_rdata: std_logic_vector(31 downto 0);
signal selected_byte: std_logic_vector(7 downto 0);

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			we_out<='0';
			strobe<='0';
			sig<='-';
			byte_mode<='-';
			sel<=(others=>'-');
			we<='-';
			rmw_mode<='-';
			dbus_adr_o<=(others=>'-');
			dbus_dat_o<=(others=>'-');
		else
			we_out<='0';
			if strobe='0' then
				if valid_i='1' and cmd_dbus_i='1' then
					strobe<='1';
					sig<=cmd_signed_i;
					
					dbus_adr_o<=addr_i(31 downto 2);
					
					if cmd_dbus_byte_i='0' then
						byte_mode<='0';
						dbus_dat_o<=wdata_i;
						sel<=""1111"";
						
						-- synthesis translate_off
						assert addr_i(1 downto 0)=""00""
							report ""Misaligned word-granular access on data bus""
							severity warning;
						-- synthesis translate_on
					else
						byte_mode<='1';
						dbus_dat_o<=wdata_i(7 downto 0)&wdata_i(7 downto 0)&
							wdata_i(7 downto 0)&wdata_i(7 downto 0);
						
						case addr_i(1 downto 0) is
						when ""00"" => sel<=""0001"";
						when ""01"" => sel<=""0010"";
						when ""10"" => sel<=""0100"";
						when ""11"" => sel<=""1000"";
						when others =>
						end case;
					end if;
					
					if not RMW then
						we<=cmd_dbus_store_i;
						rmw_mode<='0';
					else
						we<=cmd_dbus_store_i and not cmd_dbus_byte_i;
						rmw_mode<=cmd_dbus_store_i and cmd_dbus_byte_i;
					end if;
				end if;
			else
				if dbus_ack_i='1' then
					if rmw_mode='1' and we='0' and RMW then
						we<='1';
						for i in sel'range loop
							if sel(i)='0' then
								dbus_dat_o(i*8+7 downto i*8)<=
									dbus_dat_i(i*8+7 downto i*8);
							end if;
						end loop;
					else
						strobe<='0';
						if we='0' then
							we_out<='1';
						end if;
					end if;
				end if;
			end if;
		end if;
	end if;
end process;

dbus_cyc_o<=strobe;
dbus_stb_o<=strobe;
dbus_we_o<=we;

sel_no_rmw_gen: if not RMW generate
	dbus_sel_o<=sel;
end generate;

sel_rmw_gen: if RMW generate
	dbus_sel_o<=(others=>'1');
end generate;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		dbus_rdata<=dbus_dat_i;
	end if;
end process;

selected_byte_gen: for i in selected_byte'range generate
	selected_byte(i)<=(dbus_rdata(i) and sel(0)) or
		(dbus_rdata(i+8) and sel(1)) or
		(dbus_rdata(i+16) and sel(2)) or
		(dbus_rdata(i+24) and sel(3));
end generate;

rdata_o<=dbus_rdata when byte_mode='0' else
	X""000000""&selected_byte when selected_byte(selected_byte'high)='0' or sig='0' else
	X""FFFFFF""&selected_byte;

we_o<=we_out;
busy_o<=strobe or we_out;

end architecture;
"
"The Instruction Decoder (lxp32_decode) is a crucial component of the LXP32 CPU, serving as the second stage of the pipeline. Its primary purpose is to decode incoming instructions, extract relevant information, and generate control signals for subsequent pipeline stages. The decoder plays a vital role in determining the operation to be performed, identifying operands, and controlling data flow within the CPU. The decoder has several input ports, each with specific purposes and bit widths. The clk_i and rst_i ports are used for clocking and resetting the component, respectively. The word_i port, a 32-bit vector, carries the instruction to be decoded. The next_ip_i and current_ip_i ports, both 30-bit vectors, provide the next and current instruction pointers, respectively. The valid_i port indicates the validity of the instruction, while jump_valid_i signals a jump instruction. The interrupt_valid_i and interrupt_vector_i ports are used for handling interrupts. The decoder's output ports are equally important. The ready_o port indicates whether the decoder is ready to accept new instructions. The interrupt_ready_o port signals that an interrupt has been handled. The sp_raddr1_o and sp_raddr2_o ports generate addresses for register file access, while sp_rdata1_i and sp_rdata2_i are used to retrieve data from the register file. The valid_o port indicates the validity of the decoded instruction. Various command signals, such as cmd_loadop3_o, cmd_signed_o, and cmd_jump_o, control the operation to be performed. Internally, the decoder consists of a finite state machine (FSM) with five states: Regular, ContinueLc, ContinueCjmp, ContinueInterrupt, and Halt. The FSM controls the decoding process, handling different instruction types and interrupt handling. The decoder also features several registers and signals to manage operand decoding, pipeline control, and interrupt handling. The decoder's operation can be described step-by-step. Upon reset, the FSM enters the Regular state. When a valid instruction is received, the decoder dissects the instruction into opcode, operands, and destination register. Based on the opcode, the decoder generates control signals for the operation to be performed. For example, if the opcode corresponds to a load instruction, the decoder sets the cmd_loadop3_o signal. The decoder also handles jump instructions, setting the cmd_jump_o signal and updating the instruction pointer. The decoder's control logic is primarily implemented using a combination of case statements and conditional assignments. The FSM transitions between states based on the current state, opcode, and input signals. For instance, when an interrupt occurs, the FSM transitions to the ContinueInterrupt state, handling the interrupt and updating the instruction pointer. Data flow within the decoder involves the extraction of operands from the instruction and register file. The decoder uses signals such as rd1_select and rd2_select to determine whether to use direct or register operands. The op1_o and op2_o ports output the decoded operands. The decoder's timing and synchronization are critical to its operation. The component is clocked by the clk_i signal, and its outputs are synchronized with the clock. The decoder also has setup and hold requirements for its inputs, ensuring that data is properly captured and processed. One of the decoder's special features is its ability to handle interrupts. When an interrupt occurs, the decoder transitions to the ContinueInterrupt state, handling the interrupt and updating the instruction pointer. The decoder also supports a Halt state, which allows the CPU to pause execution. The Instruction Decoder is typically used in pipelined CPU architectures, where instruction decoding and execution are performed in a sequence of stages. The decoder's outputs are used to control subsequent pipeline stages, such as execution and memory access. In terms of implementation considerations, the decoder's performance and resource usage depend on the target technology and synthesis tools used. The decoder's area and power consumption can be optimized by minimizing the number of logic gates and registers required. Design trade-offs may involve balancing performance, area, and power consumption to meet specific application requirements. Overall, the Instruction Decoder is a critical component of the LXP32 CPU, responsible for decoding instructions and generating control signals for subsequent pipeline stages. Its internal structure, state machines, and control logic work together to ensure efficient and correct execution of instructions.","---------------------------------------------------------------------
-- Instruction decoder
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The second stage of the LXP32 pipeline.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_decode is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		word_i: in std_logic_vector(31 downto 0);
		next_ip_i: in std_logic_vector(29 downto 0);
		current_ip_i: in std_logic_vector(29 downto 0);
		valid_i: in std_logic;
		jump_valid_i: in std_logic;
		ready_o: out std_logic;
		
		interrupt_valid_i: in std_logic;
		interrupt_vector_i: in std_logic_vector(2 downto 0);
		interrupt_ready_o: out std_logic;

		wakeup_i: in std_logic;
		
		sp_raddr1_o: out std_logic_vector(7 downto 0);
		sp_rdata1_i: in std_logic_vector(31 downto 0);
		sp_raddr2_o: out std_logic_vector(7 downto 0);
		sp_rdata2_i: in std_logic_vector(31 downto 0);
		
		ready_i: in std_logic;
		valid_o: out std_logic;
		
		cmd_loadop3_o: out std_logic;
		cmd_signed_o: out std_logic;
		cmd_dbus_o: out std_logic;
		cmd_dbus_store_o: out std_logic;
		cmd_dbus_byte_o: out std_logic;
		cmd_addsub_o: out std_logic;
		cmd_mul_o: out std_logic;
		cmd_div_o: out std_logic;
		cmd_div_mod_o: out std_logic;
		cmd_cmp_o: out std_logic;
		cmd_jump_o: out std_logic;
		cmd_negate_op2_o: out std_logic;
		cmd_and_o: out std_logic;
		cmd_xor_o: out std_logic;
		cmd_shift_o: out std_logic;
		cmd_shift_right_o: out std_logic;
		
		jump_type_o: out std_logic_vector(3 downto 0);
		
		op1_o: out std_logic_vector(31 downto 0);
		op2_o: out std_logic_vector(31 downto 0);
		op3_o: out std_logic_vector(31 downto 0);
		dst_o: out std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32_decode is

-- Decoder FSM state

type DecoderState is (Regular,ContinueLc,ContinueCjmp,ContinueInterrupt,Halt);
signal state: DecoderState:=Regular;

-- Input instruction portions

signal opcode: std_logic_vector(5 downto 0);
signal t1: std_logic;
signal t2: std_logic;
signal destination: std_logic_vector(7 downto 0);
signal rd1: std_logic_vector(7 downto 0);
signal rd2: std_logic_vector(7 downto 0);

-- Signals related to pipeline control

signal downstream_busy: std_logic;
signal self_busy: std_logic:='0';
signal busy: std_logic;
signal valid_out: std_logic:='0';

signal dst_out: std_logic_vector(7 downto 0);

-- Signals related to RD operand decoding

signal rd1_reg: std_logic_vector(7 downto 0);
signal rd2_reg: std_logic_vector(7 downto 0);

signal rd1_select: std_logic;
signal rd1_direct: std_logic_vector(31 downto 0);
signal rd2_select: std_logic;
signal rd2_direct: std_logic_vector(31 downto 0);

-- Signals related to interrupt handling

signal interrupt_ready: std_logic:='0';
signal wakeup_reg: std_logic:='0';

begin

-- Dissect input word

opcode<=word_i(31 downto 26);
t1<=word_i(25);
t2<=word_i(24);
destination<=word_i(23 downto 16);
rd1<=word_i(15 downto 8);
rd2<=word_i(7 downto 0);

-- Pipeline control

downstream_busy<=valid_out and not ready_i;
busy<=downstream_busy or self_busy;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			valid_out<='0';
			self_busy<='0';
			state<=Regular;
			interrupt_ready<='0';
			cmd_loadop3_o<='-';
			cmd_signed_o<='-';
			cmd_dbus_o<='-';
			cmd_dbus_store_o<='-';
			cmd_dbus_byte_o<='-';
			cmd_addsub_o<='-';
			cmd_negate_op2_o<='-';
			cmd_mul_o<='-';
			cmd_div_o<='-';
			cmd_div_mod_o<='-';
			cmd_cmp_o<='-';
			cmd_jump_o<='-';
			cmd_and_o<='-';
			cmd_xor_o<='-';
			cmd_shift_o<='-';
			cmd_shift_right_o<='-';
			rd1_select<='-';
			rd1_direct<=(others=>'-');
			rd2_select<='-';
			rd2_direct<=(others=>'-');
			op3_o<=(others=>'-');
			jump_type_o<=(others=>'-');
			dst_out<=(others=>'-');
			wakeup_reg<='0';
		else
			interrupt_ready<='0';
			wakeup_reg<=wakeup_reg or wakeup_i;
			if jump_valid_i='1' then
				valid_out<='0';
				self_busy<='0';
				state<=Regular;
			elsif downstream_busy='0' then
				op3_o<=(others=>'-');
				rd1_direct<=std_logic_vector(resize(signed(rd1),rd1_direct'length));
				rd2_direct<=std_logic_vector(resize(signed(rd2),rd2_direct'length));
				
				cmd_signed_o<=opcode(0);
				cmd_div_mod_o<=opcode(1);
				cmd_shift_right_o<=opcode(1);
				cmd_dbus_byte_o<=opcode(1);
				cmd_dbus_store_o<=opcode(2);
				
				case state is
				when Regular =>
					cmd_loadop3_o<='0';
					cmd_dbus_o<='0';
					cmd_addsub_o<='0';
					cmd_negate_op2_o<='0';
					cmd_mul_o<='0';
					cmd_div_o<='0';
					cmd_cmp_o<='0';
					cmd_jump_o<='0';
					cmd_and_o<='0';
					cmd_xor_o<='0';
					cmd_shift_o<='0';
					
					jump_type_o<=opcode(3 downto 0);
					
					if interrupt_valid_i='1' and valid_i='1' then
						cmd_jump_o<='1';
						cmd_loadop3_o<='1';
						op3_o<=current_ip_i&""01""; -- LSB indicates interrupt return
						dst_out<=X""FD""; -- interrupt return pointer
						rd1_select<='1';
						rd2_select<='0';
						valid_out<='1';
						interrupt_ready<='1';
						self_busy<='1';
						state<=ContinueInterrupt;
					else
						if opcode(5 downto 3)=""101"" or opcode=""000001"" then -- lc or lcs
							cmd_loadop3_o<='1';
-- Setting op3_o here only affects the lcs instruction
							op3_o<=std_logic_vector(resize(signed(opcode(2 downto 0)&
								t1&t2&rd1&rd2),op3_o'length));
						end if;
						
						if opcode(5 downto 3)=""001"" then
							cmd_dbus_o<='1';
						end if;
						
						if opcode(5 downto 1)=""01000"" then
							cmd_addsub_o<='1';
						end if;
						
						cmd_negate_op2_o<=opcode(0);
						
						if opcode=""010010"" then
							cmd_mul_o<='1';
						end if;
						
						if opcode(5 downto 2)=""0101"" then
							cmd_div_o<='1';
						end if;
						
						if opcode(5 downto 3)=""100"" then -- jump or call
							cmd_jump_o<='1';
							cmd_loadop3_o<=opcode(0);
-- Setting op3_o here only affects the call instruction
							op3_o<=next_ip_i&""00"";
						end if;
						
						-- Note: (a or b) = (a and b) or (a xor b)
						
						if opcode(5 downto 1)=""01100"" then
							cmd_and_o<='1';
						end if;
						
						if opcode=""011010"" or opcode=""011001"" then
							cmd_xor_o<='1';
						end if;
						
						if opcode(5 downto 2)=""0111"" then
							cmd_shift_o<='1';
						end if;
						
						if opcode(5 downto 4)=""11"" then
							cmd_cmp_o<='1';
							cmd_negate_op2_o<='1';
						end if;
						
						rd1_select<=t1;
						rd2_select<=t2;
						
						dst_out<=destination;
						
						if valid_i='1' then
							if opcode=""000001"" then
								valid_out<='0';
								self_busy<='0';
								state<=ContinueLc;
							elsif opcode=""000010"" then
								valid_out<='0';
								self_busy<='1';
								wakeup_reg<='0';
								state<=Halt;
							elsif opcode(5 downto 4)=""11"" then
								valid_out<='1';
								self_busy<='1';
								state<=ContinueCjmp;
							else
								valid_out<='1';
							end if;
						else
							valid_out<='0';
						end if;
					end if;
				when ContinueLc =>
					if valid_i='1' then
						valid_out<='1';
						op3_o<=word_i;
						self_busy<='0';
						state<=Regular;
					end if;
				when ContinueCjmp =>
					valid_out<='1';
					cmd_jump_o<='1';
					rd1_select<='1';
					self_busy<='0';
					state<=Regular;
				when ContinueInterrupt =>
					valid_out<='0';
				when Halt =>
					if interrupt_valid_i='1' or wakeup_i='1' or wakeup_reg='1' then
						self_busy<='0';
						state<=Regular;
					end if;
				end case;
			end if;
		end if;
	end if;
end process;

valid_o<=valid_out;
dst_o<=dst_out;

ready_o<=not busy;

interrupt_ready_o<=interrupt_ready;

-- Decode RD (register/direct) operands

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if busy='0' then
			rd1_reg<=rd1;
			rd2_reg<=rd2;
		end if;
	end if;
end process;

sp_raddr1_o<=""11110""&interrupt_vector_i when (state=Regular and interrupt_valid_i='1' and downstream_busy='0') or state=ContinueInterrupt else
	dst_out when (state=ContinueCjmp and downstream_busy='0') else
	rd1_reg when busy='1' else
	rd1;

sp_raddr2_o<=rd2_reg when busy='1' else rd2;

op1_o<=sp_rdata1_i when rd1_select='1' else rd1_direct;
op2_o<=sp_rdata2_i when rd2_select='1' else rd2_direct;

end architecture;
"
"The LXP32 Divider is a digital component designed as part of the LXP32 CPU, implementing the Non-Restoring Division (NRD) algorithm. Its primary purpose is to perform division and remainder operations on 32-bit integers, with support for signed numbers and remainder calculation. The divider plays a crucial role in the LXP32 CPU, enabling efficient execution of division and modulus instructions. The component features a comprehensive set of input ports, including `clk_i`, `rst_i`, `ce_i`, `op1_i`, `op2_i`, `signed_i`, and `rem_i`. The `clk_i` port is the clock input, while `rst_i` is the asynchronous reset signal. The `ce_i` port is the clock enable signal, which controls the divider's operation. The `op1_i` and `op2_i` ports are 32-bit input operands, and `signed_i` indicates whether the operation should be performed on signed numbers. The `rem_i` port specifies whether the remainder should be calculated. The output ports include `ce_o` and `result_o`. The `ce_o` port is the output clock enable signal, indicating when the result is valid, and `result_o` is the 32-bit result of the division or remainder operation. Internally, the divider consists of several key components, including a complementor, a state machine, an adder/subtractor, and an output restoration circuit. The complementor is responsible for generating the two's complement of the input operands, while the state machine controls the division process. The adder/subtractor performs the actual division and remainder calculations. The divider's architectural description reveals a complex interplay between various signals and components. The `compl_inv` signal controls the complementor, and `compl_mux` selects the input to the complementor. The `fsm_ce` signal enables the state machine, which manages the division process. The `dividend`, `divisor`, and `partial_remainder` signals are critical in the division algorithm, while `sum` and `sum_positive` are used to compute the partial remainder. The state machine is implemented using a counter, `cnt`, which controls the number of iterations required for the division or remainder calculation. The `ceo` signal is generated based on the counter value, indicating when the result is valid. The control logic is distributed across several processes, which manage the state machine, complementor, and output restoration circuit. The control signals, such as `fsm_ce`, `sum_subtract`, and `inv_res`, are generated based on the input operands, `signed_i`, and `rem_i`. The reset behavior is handled by the asynchronous reset signal, `rst_i`, which initializes the divider's internal state. Data flow through the component involves several transformations. The input operands are first complemented if necessary, then fed into the state machine. The state machine manages the division process, generating the partial remainder and quotient. The output restoration circuit adjusts the result based on the sign of the operands and the remainder. The divider's timing and synchronization are critical to its correct operation. The component operates in a single clock domain, with the `clk_i` signal controlling all internal operations. The setup and hold requirements are implicit in the VHDL code, with the component designed to operate with standard synchronous logic. A notable feature of the LXP32 Divider is its support for signed numbers and remainder calculation. The component can operate in two modes: division and remainder calculation. The `signed_i` and `rem_i` inputs control the mode of operation. The LXP32 Divider is typically used in digital systems requiring division and remainder operations, such as CPUs, microcontrollers, and digital signal processing (DSP) systems. Its implementation considerations include performance, resource usage, and design trade-offs. The component's performance is optimized for the NRD algorithm, which provides a balance between area and speed. The resource usage is moderate, with a reasonable number of logic cells and registers required for implementation. In conclusion, the LXP32 Divider is a sophisticated digital component that provides efficient division and remainder operations for 32-bit integers. Its comprehensive set of input and output ports, internal architecture, and control logic make it an essential component in digital systems. The component's features, such as support for signed numbers and remainder calculation, make it versatile and suitable for a wide range of applications.","---------------------------------------------------------------------
-- Divider
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Based on the NRD (Non Restoring Division) algorithm. Takes
-- 36 cycles to calculate quotient (37 for remainder).
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_divider is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		signed_i: in std_logic;
		rem_i: in std_logic;
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_divider is

-- Complementor signals

signal compl_inv: std_logic;
signal compl_mux: std_logic_vector(31 downto 0);
signal compl_out: std_logic_vector(31 downto 0);

signal inv_res: std_logic;

-- Divider FSM signals

signal fsm_ce: std_logic:='0';

signal dividend: unsigned(31 downto 0);
signal divisor: unsigned(32 downto 0);
signal want_remainder: std_logic;

signal partial_remainder: unsigned(32 downto 0);
signal addend: unsigned(32 downto 0);
signal sum: unsigned(32 downto 0);
signal sum_positive: std_logic;
signal sum_subtract: std_logic;

signal cnt: integer range 0 to 34:=0;

signal ceo: std_logic:='0';

-- Output restoration signals

signal remainder_corrector: unsigned(31 downto 0);
signal remainder_corrector_1: std_logic;
signal remainder_pos: unsigned(31 downto 0);
signal result_pos: unsigned(31 downto 0);

begin

compl_inv<=op1_i(31) and signed_i when ce_i='1' else inv_res;
compl_mux<=op1_i when ce_i='1' else std_logic_vector(result_pos);

compl_op1_inst: entity work.lxp32_compl(rtl)
	port map(
		clk_i=>clk_i,
		compl_i=>compl_inv,
		d_i=>compl_mux,
		d_o=>compl_out
	);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			fsm_ce<='0';
			want_remainder<='-';
			inv_res<='-';
		else
			fsm_ce<=ce_i;
			if ce_i='1' then
				want_remainder<=rem_i;
				if rem_i='1' then
					inv_res<=op1_i(31) and signed_i;
				else
					inv_res<=(op1_i(31) xor op2_i(31)) and signed_i;
				end if;
			end if;
		end if;
	end if;
end process;

-- Main adder/subtractor

addend_gen: for i in addend'range generate
	addend(i)<=divisor(i) xor sum_subtract;
end generate;

sum<=partial_remainder+addend+(to_unsigned(0,32)&sum_subtract);
sum_positive<=not sum(32);

-- Divider state machine

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			cnt<=0;
			ceo<='0';
			divisor<=(others=>'-');
			dividend<=(others=>'-');
			partial_remainder<=(others=>'-');
			sum_subtract<='-';
		else
			if cnt=1 then
				ceo<='1';
			else
				ceo<='0';
			end if;
			
			if ce_i='1' then
				divisor(31 downto 0)<=unsigned(op2_i);
				divisor(32)<=op2_i(31) and signed_i;
			end if;
			
			if fsm_ce='1' then
				dividend<=unsigned(compl_out(30 downto 0)&""0"");
				partial_remainder<=to_unsigned(0,32)&compl_out(31);
				sum_subtract<=not divisor(32);
				if want_remainder='1' then
					cnt<=34;
				else
					cnt<=33;
				end if;
			else
				partial_remainder<=sum(31 downto 0)&dividend(31);
				sum_subtract<=sum_positive xor divisor(32);
				dividend<=dividend(30 downto 0)&sum_positive;
				if cnt>0 then
					cnt<=cnt-1;
				end if;
			end if;
		end if;
	end if;
end process;

-- Output restoration circuit

process (clk_i) is
begin
	if rising_edge(clk_i) then
		for i in remainder_corrector'range loop
			remainder_corrector(i)<=(divisor(i) xor divisor(32)) and not sum_positive;
		end loop;
		remainder_corrector_1<=divisor(32) and not sum_positive;
		remainder_pos<=partial_remainder(32 downto 1)+remainder_corrector+
			(to_unsigned(0,31)&remainder_corrector_1);
	end if;
end process;

result_pos<=remainder_pos when want_remainder='1' else dividend;

result_o<=compl_out;
ce_o<=ceo;

end architecture;
"
"The LXP32 Execute component is a crucial stage in the LXP32 CPU pipeline, responsible for executing arithmetic, logical, and memory operations. Its primary purpose is to perform the actual computation and data manipulation based on the instructions decoded in the previous pipeline stages. This component plays a vital role in the overall CPU operation, as it directly affects the program's execution flow and data integrity. The LXP32 Execute component features a multitude of input ports that control its operation. The `cmd_loadop3_i`, `cmd_signed_i`, `cmd_dbus_i`, and other command signals determine the type of operation to be performed. These signals are typically generated by the instruction decoder and are used to configure the component for specific tasks. The `op1_i`, `op2_i`, and `op3_i` ports receive the operands for the operations, while the `dst_i` port specifies the destination register. The `valid_i` signal indicates that the input data is valid and ready for processing. The component's output ports provide the results of the executed operations. The `sp_waddr_o`, `sp_we_o`, and `sp_wdata_o` ports are used to write the results to the register file or memory. The `dbus_cyc_o`, `dbus_stb_o`, `dbus_we_o`, and `dbus_sel_o` ports control the memory access, while the `dbus_adr_o` and `dbus_dat_o` ports provide the address and data for the memory transactions. The `jump_valid_o`, `jump_dst_o`, and `interrupt_return_o` ports are used for jump and interrupt handling. Internally, the LXP32 Execute component consists of several key modules. The Arithmetic Logic Unit (ALU) performs arithmetic and logical operations, such as addition, subtraction, multiplication, and division. The ALU's operation is controlled by the command signals, and its results are stored in the `alu_result` register. The OP3 loader module is responsible for loading the third operand into the `op3_i` register. The Jump machine module handles jump instructions, determining the jump condition based on the ALU's comparison results and the jump type. The component's functional behavior can be described as follows: when the `valid_i` signal is asserted, the component checks the command signals to determine the operation to be performed. If an ALU operation is required, the ALU is activated, and its result is stored in the `alu_result` register. If a memory access is required, the DBUS access module is activated, and the memory transaction is performed. The results of the operations are then multiplexed and written to the destination register or memory. The control logic of the LXP32 Execute component is primarily driven by the command signals and the `valid_i` signal. The `busy` signal indicates that the component is currently performing an operation and cannot accept new instructions. The `can_execute` signal is used to enable the component's operation when the input data is valid and the component is not busy. The `result_valid` signal indicates that the result of the operation is valid and can be written to the destination register or memory. The data flow through the component can be described as follows: the operands are received on the `op1_i`, `op2_i`, and `op3_i` ports and are processed by the ALU or DBUS access module. The results of the operations are then multiplexed and written to the destination register or memory through the `sp_waddr_o`, `sp_we_o`, and `sp_wdata_o` ports. The LXP32 Execute component has specific timing and synchronization requirements. The `clk_i` signal drives the component's clock domain, and the `rst_i` signal is used for reset. The component has setup and hold requirements for the input signals, which must be met to ensure proper operation. One of the special features of the LXP32 Execute component is its support for different multiplier architectures, which can be selected through the `MUL_ARCH` generic. Additionally, the component has a configurable divider, which can be enabled or disabled through the `DIVIDER_EN` generic. The LXP32 Execute component is typically used in pipelined CPU architectures, where it serves as a critical stage in the execution pipeline. Its applications include general-purpose computing, embedded systems, and digital signal processing. In terms of implementation considerations, the LXP32 Execute component's performance is dependent on the specific technology and synthesis tools used. The component's resource usage can be optimized by adjusting the generic parameters, such as the multiplier architecture and divider enable. The design trade-offs include balancing performance, area, and power consumption, which must be carefully considered during the design and synthesis process. Overall, the LXP32 Execute component is a complex digital circuit that plays a vital role in the LXP32 CPU pipeline. Its comprehensive feature set, including support for various operations, jump handling, and interrupt management, makes it a versatile and efficient component for a wide range of applications.","---------------------------------------------------------------------
-- Execution unit
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The third stage of the LXP32 pipeline.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_execute is
	generic(
		DBUS_RMW: boolean;
		DIVIDER_EN: boolean;
		MUL_ARCH: string
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		cmd_loadop3_i: in std_logic;
		cmd_signed_i: in std_logic;
		cmd_dbus_i: in std_logic;
		cmd_dbus_store_i: in std_logic;
		cmd_dbus_byte_i: in std_logic;
		cmd_addsub_i: in std_logic;
		cmd_mul_i: in std_logic;
		cmd_div_i: in std_logic;
		cmd_div_mod_i: in std_logic;
		cmd_cmp_i: in std_logic;
		cmd_jump_i: in std_logic;
		cmd_negate_op2_i: in std_logic;
		cmd_and_i: in std_logic;
		cmd_xor_i: in std_logic;
		cmd_shift_i: in std_logic;
		cmd_shift_right_i: in std_logic;
		
		jump_type_i: in std_logic_vector(3 downto 0);
		
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		op3_i: in std_logic_vector(31 downto 0);
		dst_i: in std_logic_vector(7 downto 0);
		
		sp_waddr_o: out std_logic_vector(7 downto 0);
		sp_we_o: out std_logic;
		sp_wdata_o: out std_logic_vector(31 downto 0);
		
		valid_i: in std_logic;
		ready_o: out std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		jump_valid_o: out std_logic;
		jump_dst_o: out std_logic_vector(29 downto 0);
		jump_ready_i: in std_logic;
		
		interrupt_return_o: out std_logic
	);
end entity;

architecture rtl of lxp32_execute is

-- Pipeline control signals

signal busy: std_logic;
signal can_execute: std_logic;

-- ALU signals

signal alu_result: std_logic_vector(31 downto 0);
signal alu_we: std_logic;
signal alu_busy: std_logic;

signal alu_cmp_eq: std_logic;
signal alu_cmp_ug: std_logic;
signal alu_cmp_sg: std_logic;

-- OP3 loader signals

signal loadop3_we: std_logic;

-- Jump machine signals

signal jump_condition: std_logic;
signal jump_valid: std_logic:='0';
signal jump_dst: std_logic_vector(jump_dst_o'range);

-- DBUS signals

signal dbus_result: std_logic_vector(31 downto 0);
signal dbus_busy: std_logic;
signal dbus_we: std_logic;

-- Result mux signals

signal result_mux: std_logic_vector(31 downto 0);
signal result_valid: std_logic;
signal result_regaddr: std_logic_vector(7 downto 0);

signal dst_reg: std_logic_vector(7 downto 0);

-- Signals related to interrupt handling

signal interrupt_return: std_logic:='0';

begin

-- Pipeline control

busy<=alu_busy or dbus_busy;
ready_o<=not busy;
can_execute<=valid_i and not busy;

-- ALU

alu_inst: entity work.lxp32_alu(rtl)
	generic map(
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		valid_i=>can_execute,
		
		cmd_signed_i=>cmd_signed_i,
		cmd_addsub_i=>cmd_addsub_i,
		cmd_mul_i=>cmd_mul_i,
		cmd_div_i=>cmd_div_i,
		cmd_div_mod_i=>cmd_div_mod_i,
		cmd_cmp_i=>cmd_cmp_i,
		cmd_negate_op2_i=>cmd_negate_op2_i,
		cmd_and_i=>cmd_and_i,
		cmd_xor_i=>cmd_xor_i,
		cmd_shift_i=>cmd_shift_i,
		cmd_shift_right_i=>cmd_shift_right_i,
		
		op1_i=>op1_i,
		op2_i=>op2_i,
		
		result_o=>alu_result,
		
		cmp_eq_o=>alu_cmp_eq,
		cmp_ug_o=>alu_cmp_ug,
		cmp_sg_o=>alu_cmp_sg,
		
		we_o=>alu_we,
		busy_o=>alu_busy
	);

-- OP3 loader

loadop3_we<=can_execute and cmd_loadop3_i;

-- Jump logic

jump_condition<=(not cmd_cmp_i) or (jump_type_i(3) and alu_cmp_eq) or
	(jump_type_i(2) and not alu_cmp_eq) or (jump_type_i(1) and alu_cmp_ug) or
	(jump_type_i(0) and alu_cmp_sg);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			jump_valid<='0';
			interrupt_return<='0';
			jump_dst<=(others=>'-');
		else
			if jump_valid='0' then
				jump_dst<=op1_i(31 downto 2);
				if can_execute='1' and cmd_jump_i='1' and jump_condition='1' then
					jump_valid<='1';
					interrupt_return<=op1_i(0);
				end if;
			elsif jump_ready_i='1' then
				jump_valid<='0';
				interrupt_return<='0';
			end if;
		end if;
	end if;
end process;

jump_valid_o<=jump_valid or (can_execute and cmd_jump_i and jump_condition);
jump_dst_o<=jump_dst when jump_valid='1' else op1_i(31 downto 2);

interrupt_return_o<=interrupt_return;

-- DBUS access

dbus_inst: entity work.lxp32_dbus(rtl)
	generic map(
		RMW=>DBUS_RMW
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		valid_i=>can_execute,
		
		cmd_dbus_i=>cmd_dbus_i,
		cmd_dbus_store_i=>cmd_dbus_store_i,
		cmd_dbus_byte_i=>cmd_dbus_byte_i,
		cmd_signed_i=>cmd_signed_i,
		addr_i=>op1_i,
		wdata_i=>op2_i,
		
		rdata_o=>dbus_result,
		busy_o=>dbus_busy,
		we_o=>dbus_we,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i
	);

-- Result multiplexer

result_mux_gen: for i in result_mux'range generate
	result_mux(i)<=(alu_result(i) and alu_we) or
		(op3_i(i) and loadop3_we) or
		(dbus_result(i) and dbus_we);
end generate;

result_valid<=alu_we or loadop3_we or dbus_we;

-- Write destination register

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if can_execute='1' then
			dst_reg<=dst_i;
		end if;
	end if;
end process;

result_regaddr<=dst_i when can_execute='1' else dst_reg;

sp_we_o<=result_valid;
sp_waddr_o<=result_regaddr;
sp_wdata_o<=result_mux;

end architecture;
"
"The LXP32 Fetch component is a crucial stage in the LXP32 CPU pipeline, responsible for fetching instructions from memory. Its primary purpose is to retrieve instructions from a memory location, and it plays a vital role in the overall operation of the CPU. The component has several input and output ports that facilitate its operation. The clock input, `clk_i`, and reset input, `rst_i`, control the component's timing and reset behavior. The `lli_re_o`, `lli_adr_o`, and `lli_dat_i` ports are used to interact with the Low-Level Interface (LLI) bus, which connects the CPU to memory. The `lli_busy_i` input indicates whether the LLI bus is busy, and the `ready_i` input signals that the CPU is ready to process instructions. The `jump_valid_i` and `jump_dst_i` inputs are used to handle jump instructions, and the `jump_ready_o` output indicates that a jump instruction has been processed. The component's internal structure consists of several registers, counters, and a small instruction buffer. The `init` signal controls the initialization process, which involves generating ""mov rN,0"" instructions for each register to ensure that all CPU registers are zero-initialized after reset. The `init_cnt` counter keeps track of the initialization progress. The `fetch_addr` register stores the current fetch address, and the `next_ip` and `current_ip` registers store the next and current instruction pointers, respectively. The component's architectural description reveals a complex interplay between the initialization process, fetch state machine, and instruction buffer. During initialization, the component generates a sequence of ""mov rN,0"" instructions to zero-initialize the CPU registers. Once initialization is complete, the fetch state machine takes control, fetching instructions from memory and storing them in the instruction buffer. The buffer is implemented as a small FIFO, which helps to improve performance by allowing the CPU to continue executing instructions while waiting for new instructions to be fetched. The component's functional behavior can be described as follows: during initialization, the component generates a sequence of ""mov rN,0"" instructions to zero-initialize the CPU registers. Once initialization is complete, the fetch state machine fetches instructions from memory, storing them in the instruction buffer. When the CPU is ready to process instructions, the component outputs the fetched instruction and updates the instruction pointers. The component also handles jump instructions by redirecting the fetch address to the jump destination. The control logic of the component is responsible for managing the initialization process, fetch state machine, and instruction buffer. The `init` signal and `init_cnt` counter control the initialization process, while the `fetch_addr` register and `next_ip` and `current_ip` registers manage the fetch state machine. The `fifo_rst`, `fifo_we`, and `fifo_re` signals control the instruction buffer. The data flow through the component involves several transformations. Instructions are fetched from memory, stored in the instruction buffer, and then output to the CPU. The component also performs address calculations to update the fetch address and instruction pointers. The component's timing and synchronization are critical to its operation. The `clk_i` input controls the component's timing, and the `rst_i` input resets the component's internal state. The component has specific setup and hold requirements to ensure proper operation. One of the special features of the component is its ability to handle jump instructions. When a jump instruction is encountered, the component redirects the fetch address to the jump destination, ensuring that the CPU executes the correct instructions. The LXP32 Fetch component is typically used in CPU designs where instruction fetching is a critical component of the pipeline. Its applications include a wide range of computing systems, from embedded systems to high-performance computing. In terms of implementation considerations, the component's performance is critical to the overall operation of the CPU. The component's resource usage is moderate, and design trade-offs are made to balance performance, area, and power consumption. The component's VHDL code is designed to be synthesizable and compatible with a range of FPGA and ASIC technologies. Overall, the LXP32 Fetch component is a complex digital circuit that plays a vital role in the LXP32 CPU pipeline. Its comprehensive design and implementation ensure that it provides high-performance instruction fetching while meeting the requirements of a wide range of computing systems.","---------------------------------------------------------------------
-- Instruction fetch
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The first stage of the LXP32 pipeline.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_fetch is
	generic(
		START_ADDR: std_logic_vector(31 downto 0)
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic;
		
		word_o: out std_logic_vector(31 downto 0);
		current_ip_o: out std_logic_vector(29 downto 0);
		next_ip_o: out std_logic_vector(29 downto 0);
		valid_o: out std_logic;
		ready_i: in std_logic;
		
		jump_valid_i: in std_logic;
		jump_dst_i: in std_logic_vector(29 downto 0);
		jump_ready_o: out std_logic
	);
end entity;

architecture rtl of lxp32_fetch is

signal init: std_logic:='1';
signal init_cnt: unsigned(7 downto 0):=(others=>'0');

signal fetch_addr: std_logic_vector(29 downto 0):=START_ADDR(31 downto 2);

signal next_word: std_logic;
signal suppress_re: std_logic:='0';
signal re: std_logic;
signal requested: std_logic:='0';

signal fifo_rst: std_logic;
signal fifo_we: std_logic;
signal fifo_din: std_logic_vector(31 downto 0);
signal fifo_re: std_logic;
signal fifo_dout: std_logic_vector(31 downto 0);
signal fifo_empty: std_logic;
signal fifo_full: std_logic;

signal jr: std_logic:='0';

signal next_ip: std_logic_vector(fetch_addr'range);
signal current_ip: std_logic_vector(fetch_addr'range);

begin

-- INIT state machine (to initialize all registers)

-- All CPU registers are expected to be zero-initialized after reset.
-- Since these registers are implemented as a RAM block, we perform
-- the initialization sequentially by generating ""mov rN, 0"" instructions
-- for each N from 0 to 255.
--
-- With SRAM-based FPGAs, flip-flops and RAM blocks have deterministic
-- state after configuration. On these technologies the CPU can operate
-- without reset and the initialization procedure described above is not
-- needed. However, the initialization is still performed as usual when
-- external reset signal is asserted.

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			init<='0';
			init_cnt<=(others=>'0');
		else
			if init='0' and ready_i='1' then
				init_cnt<=init_cnt+1;
				if init_cnt=X""FF"" then
					init<='1';
				end if;
			end if;
		end if;
	end if;
end process;

-- FETCH state machine

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			fetch_addr<=START_ADDR(31 downto 2);
			requested<='0';
			jr<='0';
			suppress_re<='0';
			next_ip<=(others=>'-');
		else
			jr<='0';
-- Suppress LLI request if jump signal is active but will not be processed
-- in this cycle. Helps to reduce jump latency with high-latency LLI slaves.
-- Note: gating ""re"" with ""jump_valid_i and not jr"" asynchronously would
-- reduce jump latency even more, but we really want to avoid too large
-- clock-to-out on LLI outputs.
			suppress_re<=jump_valid_i and not jr and not next_word;
			if lli_busy_i='0' then
				requested<=re and not (jump_valid_i and not jr);
			end if;
			if next_word='1' then
-- It's not immediately obvious why, but current_ip and next_ip will contain
-- the addresses of the current instruction and the next instruction to be
-- fetched, respectively, by the time the instruction is passed to the decode
-- stage. Basically, this is because when either the decoder or the IBUS
-- stalls, the fetch_addr counter will also stop incrementing.
				next_ip<=fetch_addr;
				current_ip<=next_ip;
				if jump_valid_i='1' and jr='0' then
					fetch_addr<=jump_dst_i;
					jr<='1';
				else
					fetch_addr<=std_logic_vector(unsigned(fetch_addr)+1);
				end if;
			end if;
		end if;
	end if;
end process;

next_word<=(fifo_empty or ready_i) and not lli_busy_i and init;
re<=(fifo_empty or ready_i) and init and not suppress_re;
lli_re_o<=re;
lli_adr_o<=fetch_addr;

jump_ready_o<=jr;

-- Small instruction buffer

fifo_rst<=rst_i or (jump_valid_i and not jr);
fifo_we<=requested and not lli_busy_i;
fifo_din<=lli_dat_i;
fifo_re<=ready_i and not fifo_empty;

ubuf_inst: entity work.lxp32_ubuf(rtl)
	generic map(
		DATA_WIDTH=>32
	)
	port map(
		clk_i=>clk_i,
		rst_i=>fifo_rst,
		
		we_i=>fifo_we,
		d_i=>fifo_din,
		re_i=>fifo_re,
		d_o=>fifo_dout,
		
		empty_o=>fifo_empty,
		full_o=>fifo_full
	);

next_ip_o<=next_ip;
current_ip_o<=current_ip;
word_o<=fifo_dout when init='1' else X""40""&std_logic_vector(init_cnt)&X""0000"";
valid_o<=not fifo_empty or not init;

-- Note: the following code contains a few simulation-only assertions
-- to check that current_ip and next_ip signals, used in procedure calls
-- and interrupts, are correct. 
-- This code should be ignored by a synthesizer since it doesn't drive
-- any signals, but we also surround it by metacomments, just in case.

-- synthesis translate_off

process (clk_i) is
	type Pair is record
		addr: std_logic_vector(fetch_addr'range);
		data: std_logic_vector(31 downto 0);
	end record;
	type Pairs is array (7 downto 0) of Pair;
	variable buf: Pairs;
	variable count: integer range buf'range:=0;
	variable current_pair: Pair;
begin
	if rising_edge(clk_i) then
		if fifo_rst='1' then -- jump
			count:=0;
		elsif fifo_we='1' then -- LLI returned data
			current_pair.data:=fifo_din;
			buf(count):=current_pair;
			count:=count+1;
		end if;
		if re='1' and lli_busy_i='0' then -- data requested
			current_pair.addr:=fetch_addr;
		end if;
		if fifo_empty='0' and fifo_rst='0' then -- fetch output is valid
			assert count>0
				report ""Fetch: buffer should be empty""
				severity failure;
			assert buf(0).data=fifo_dout
				report ""Fetch: incorrect data""
				severity failure;
			assert buf(0).addr=current_ip
				report ""Fetch: incorrect current_ip""
				severity failure;
			assert std_logic_vector(unsigned(buf(0).addr)+1)=next_ip
				report ""Fetch: incorrect next_ip""
				severity failure;
			if ready_i='1' then
				buf(buf'high-1 downto 0):=buf(buf'high downto 1); -- we don't care about the highest item
				count:=count-1;
			end if;
		end if;
	end if;
end process;

-- synthesis translate_on

end architecture;
"
"The Instruction Cache (ICache) component, specifically designed for the LXP32 CPU, serves as a crucial element in enhancing system performance by providing both caching and prefetching capabilities. Its primary purpose is to mitigate the latency associated with accessing high-latency memory, such as external SDRAM, thereby improving overall system efficiency. The ICache features a simple, single-page buffer architecture. It is parameterized by two generics: `BURST_SIZE` and `PREFETCH_SIZE`, which dictate the size of the burst and prefetch operations, respectively. These parameters significantly influence the component's behavior and performance. ### Component Overview The ICache is a critical component in the memory hierarchy of the LXP32 CPU, designed to reduce the memory access latency. It acts as an intermediary between the CPU and the external memory, providing a faster access interface for instructions. ### Detailed Input/Output Analysis The ICache has several input and output ports that facilitate its interaction with the CPU and external memory: - **clk_i**: The clock input, which drives the internal operations of the ICache. - **rst_i**: The reset input, used to initialize the component to a known state. - **lli_re_i**: The read enable signal from the CPU, indicating a request for instruction data. - **lli_adr_i**: The address input from the CPU, specifying the location of the requested instruction. - **lli_dat_o**: The instruction data output to the CPU. - **lli_busy_o**: The busy signal output to the CPU, indicating whether the ICache is currently servicing a request. On the memory interface side: - **wbm_cyc_o**, **wbm_stb_o**, **wbm_cti_o**, and **wbm_bte_o** are outputs that control the memory access, specifying the cycle type, strobe, and burst characteristics. - **wbm_ack_i**: The acknowledge signal from the memory, indicating the completion of a memory access. - **wbm_adr_o**: The address output to the memory. - **wbm_dat_i**: The data input from the memory. ### Architectural Description Internally, the ICache comprises several key components and signals: - **Address Registers**: Such as `lli_adr_reg` and `lli_adr_mux`, which manage the address inputs and determine the correct address to access. - **Cache RAM**: Implemented using the `lxp32_ram256x32` entity, it stores the cached instructions. - **Control Signals**: Like `wb_stb`, `burst_cnt`, and `wrap_cnt`, which control the burst operations and cache management. The ICache uses a ring buffer approach for caching, with the lower 8 bits of the address determining the position within the buffer. The design includes logic for detecting hits (`hitc` and `hitp`) and misses, and for managing the prefetch and burst operations. ### Functional Behavior The ICache operates by first checking if a requested instruction is cached (hit) or not (miss). On a hit, it directly provides the instruction to the CPU. On a miss, it initiates a memory access to fetch the required instruction and potentially prefetches additional instructions. The operation involves several steps: 1. **Request Receipt**: The ICache receives a request from the CPU. 2. **Hit/Miss Detection**: It checks if the request hits in the cache; if not, a memory access is initiated. 3. **Memory Access**: The ICache generates the necessary control signals for the memory access. 4. **Prefetching**: Based on the `PREFETCH_SIZE` and `BURST_SIZE`, it prefetches instructions. ### Control Logic The control logic manages the state transitions based on the hit/miss conditions, memory acknowledge signals, and the current state of the burst and prefetch operations. The `init` signal is set when the first `lli_re_i` is detected, marking the beginning of an operation. ### Data Flow Data moves through the component as follows: The CPU requests an instruction, and the ICache checks its cache. If the instruction is not cached, it fetches from memory, stores it in the cache, and then provides it to the CPU. The cache is filled in bursts, and prefetching is dynamically adjusted based on the `prefetch_distance`. ### Timing and Synchronization The ICache operates in the clock domain defined by `clk_i`. It adheres to standard timing constraints for memory accesses, ensuring that setup and hold times are met for both the CPU interface and the memory interface. ### Special Features - **Dynamic Prefetching**: Adjusts prefetching based on the distance between the requested and currently cached instructions. - **Burst Operations**: Supports burst transactions to efficiently fetch multiple instructions. ### Applications and Use Cases The ICache is particularly useful in systems with high-latency memory, such as those employing external SDRAM. It can significantly improve system performance by reducing the effective memory access latency. ### Implementation Considerations The implementation involves careful consideration of performance, resource usage, and design trade-offs. The generics `BURST_SIZE` and `PREFETCH_SIZE` allow for flexibility in optimizing these aspects. However, larger burst and prefetch sizes increase resource usage but may improve performance. The design must balance these factors based on the specific system requirements.","---------------------------------------------------------------------
-- Instruction cache
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A simple single-page buffer providing both caching and
-- prefetching capabilities. Useful for high-latency memory,
-- such as external SDRAM.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_icache is
	generic(
		BURST_SIZE: integer;
		PREFETCH_SIZE: integer
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_i: in std_logic;
		lli_adr_i: in std_logic_vector(29 downto 0);
		lli_dat_o: out std_logic_vector(31 downto 0);
		lli_busy_o: out std_logic;
		
		wbm_cyc_o: out std_logic;
		wbm_stb_o: out std_logic;
		wbm_cti_o: out std_logic_vector(2 downto 0);
		wbm_bte_o: out std_logic_vector(1 downto 0);
		wbm_ack_i: in std_logic;
		wbm_adr_o: out std_logic_vector(29 downto 0);
		wbm_dat_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_icache is

signal lli_adr_reg: std_logic_vector(lli_adr_i'range);
signal lli_adr_mux: std_logic_vector(lli_adr_i'range);

signal ram_waddr: std_logic_vector(7 downto 0);
signal ram_raddr: std_logic_vector(7 downto 0);
signal ram_re: std_logic;
signal ram_we: std_logic;

signal read_base: unsigned(21 downto 0);
signal read_offset: unsigned(7 downto 0);

signal init: std_logic:='0';
signal burst1: std_logic;
signal terminate_burst: std_logic;
signal near_miss: std_logic:='0';
signal prefetch_distance: unsigned(7 downto 0);
signal wrap_cnt: integer range 0 to 3:=0;
signal burst_cnt: integer range 0 to BURST_SIZE:=0;
signal wb_stb: std_logic:='0';
signal wb_cti: std_logic_vector(2 downto 0);

-- Note: the following five signals are zero-initialized for
-- simulation only, to suppress warnings from numeric_std.
-- This initialization is not required for synthesis.

signal current_base: unsigned(21 downto 0):=(others=>'0');
signal current_offset: unsigned(7 downto 0):=(others=>'0');
signal prev_base: unsigned(21 downto 0):=(others=>'0');
signal next_base: unsigned(21 downto 0):=(others=>'0');
signal start_offset: unsigned(7 downto 0):=(others=>'0');

signal hitc: std_logic;
signal hitp: std_logic;
signal miss: std_logic:='0';

begin

assert PREFETCH_SIZE>=4
	report ""PREFETCH_SIZE cannot be less than 4""
	severity failure;
assert BURST_SIZE>=4
	report ""BURST_SIZE cannot be less than 4""
	severity failure;
assert PREFETCH_SIZE+BURST_SIZE<=128
	report ""PREFETCH_SIZE and BURST_SIZE combined cannot be greater than 128""
	severity failure;


process (clk_i) is
begin
	if rising_edge(clk_i) then
		if miss='0' then
			lli_adr_reg<=lli_adr_i;
		end if;
	end if;
end process;

lli_adr_mux<=lli_adr_i when miss='0' else lli_adr_reg;

read_base<=unsigned(lli_adr_mux(29 downto 8));
read_offset<=unsigned(lli_adr_mux(7 downto 0));

-- Cache RAM

ram_waddr<=std_logic_vector(current_offset);
ram_raddr<=std_logic_vector(read_offset);
ram_we<=wb_stb and wbm_ack_i;
ram_re<=lli_re_i or miss;

ram_inst: entity work.lxp32_ram256x32(rtl)
	port map(
		clk_i=>clk_i,
		
		we_i=>ram_we,
		waddr_i=>ram_waddr,
		wdata_i=>wbm_dat_i,
		
		re_i=>ram_re,
		raddr_i=>ram_raddr,
		rdata_o=>lli_dat_o
	);

-- Determine hit/miss

-- This cache uses a single ring buffer. Address in buffer corresponds
-- to the lower 8 bits of the full address. The part of the buffer that
-- is higher than current_offset represents a previous block (""p""), the
-- other part represents a current block (""c"").

hitc<='1' when read_base=current_base and read_offset<current_offset and
	((wrap_cnt=1 and read_offset>=start_offset) or
	wrap_cnt=2 or wrap_cnt=3) else '0';

hitp<='1' when read_base=prev_base and read_offset>current_offset and
	((wrap_cnt=2 and read_offset>=start_offset) or
	wrap_cnt=3) else '0';

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			miss<='0';
		else
			if hitc='0' and hitp='0' and ram_re='1' then
				miss<='1';
			else
				miss<='0';
			end if;
		end if;
	end if;
end process;

lli_busy_o<=miss;

-- Set INIT flag when the first lli_re_i signal is detected

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			init<='0';
		elsif lli_re_i='1' then
			init<='1';
		end if;
	end if;
end process;

-- Fill cache

prefetch_distance<=current_offset-read_offset;

-- Note: ""near_miss"" signal prevents cache invalidation when difference
-- between the requested address and the currently fetched address 
-- is too small (and, therefore, the requested data will be fetched soon
-- without invalidation).

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			near_miss<='0';
		elsif wrap_cnt>0 and read_offset-current_offset<=to_unsigned(BURST_SIZE/2,8) and
			((read_base=current_base and read_offset>=current_offset) or
			(read_base=next_base and read_offset<current_offset))
		then
			near_miss<='1';
		else
			near_miss<='0';
		end if;
	end if;
end process;

terminate_burst<='1' when burst_cnt<BURST_SIZE-1 and miss='1' and
	(burst_cnt>2 or burst1='0') and near_miss='0' else '0';

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			burst_cnt<=0;
			wb_stb<='0';
			wrap_cnt<=0;
			wb_cti<=(others=>'-');
			burst1<='-';
			current_offset<=(others=>'-');
			start_offset<=(others=>'-');
			current_base<=(others=>'-');
			next_base<=(others=>'-');
			prev_base<=(others=>'-');
			
			-- To suppress numeric_std warnings
			-- synthesis translate_off
			current_offset<=(others=>'0');
			start_offset<=(others=>'0');
			current_base<=(others=>'0');
			next_base<=(others=>'0');
			prev_base<=(others=>'0');
			-- synthesis translate_on
		else
			if burst_cnt=0 and init='1' then
				if miss='1' and near_miss='0' then
					wb_stb<='1';
					wb_cti<=""010"";
					current_offset<=read_offset;
					start_offset<=read_offset;
					current_base<=read_base;
					next_base<=read_base+1;
					burst_cnt<=1;
					burst1<='1';
					wrap_cnt<=1;
				elsif prefetch_distance<to_unsigned(PREFETCH_SIZE,8) or near_miss='1' then
					wb_stb<='1';
					wb_cti<=""010"";
					burst_cnt<=1;
					burst1<='0';
				end if;
			else
				if wbm_ack_i='1' then
					current_offset<=current_offset+1;
					if current_offset=X""FF"" then
						current_base<=next_base;
						next_base<=next_base+1;
						prev_base<=current_base;
						if wrap_cnt<3 then
							wrap_cnt<=wrap_cnt+1;
						end if;
					end if;
					if burst_cnt=BURST_SIZE-1 or terminate_burst='1' then
						burst_cnt<=BURST_SIZE;
						wb_cti<=""111"";
					elsif burst_cnt<BURST_SIZE-1 then
						burst_cnt<=burst_cnt+1;
						wb_cti<=""010"";
					else
						if miss='1' and near_miss='0' then
							wb_stb<='1';
							wb_cti<=""010"";
							current_offset<=read_offset;
							start_offset<=read_offset;
							current_base<=read_base;
							next_base<=read_base+1;
							burst_cnt<=1;
							burst1<='1';
							wrap_cnt<=1;
						elsif prefetch_distance<to_unsigned(PREFETCH_SIZE,8) or near_miss='1' then
							wb_stb<='1';
							wb_cti<=""010"";
							burst_cnt<=1;
							burst1<='0';
						else
							burst_cnt<=0;
							wb_stb<='0';
						end if;
					end if;
				end if;
			end if;
		end if;
	end if;
end process;

wbm_cyc_o<=wb_stb;
wbm_stb_o<=wb_stb;
wbm_cti_o<=wb_cti;
wbm_bte_o<=""00"";
wbm_adr_o<=std_logic_vector(current_base&current_offset);

end architecture;
"
"The LXP32 Interrupt Multiplexer is a crucial component of the LXP32 CPU, responsible for managing interrupts and prioritizing them based on their numbers, with lower numbers having higher priority. Its primary purpose is to handle interrupt requests, determine the highest-priority interrupt, and signal the CPU to handle it. This component plays a vital role in ensuring that the CPU responds to interrupts in a timely and efficient manner. The interrupt multiplexer has several input ports, including `clk_i`, `rst_i`, `irq_i`, `interrupt_ready_i`, `interrupt_return_i`, `sp_waddr_i`, `sp_we_i`, and `sp_wdata_i`. The `clk_i` and `rst_i` ports are used for clocking and resetting the component, respectively. The `irq_i` port is an 8-bit input that receives interrupt requests from various sources. The `interrupt_ready_i` and `interrupt_return_i` ports are used to communicate with the CPU, indicating when the CPU is ready to handle an interrupt and when it has completed handling an interrupt, respectively. The `sp_waddr_i`, `sp_we_i`, and `sp_wdata_i` ports are used to configure the interrupt multiplexer, allowing the CPU to write to its registers. Internally, the interrupt multiplexer has a state machine with three states: `Ready`, `Requested`, and `WaitForExit`. The state machine is used to manage the interrupt handling process. In the `Ready` state, the component checks for pending interrupts and prioritizes them based on their numbers. When an interrupt is detected, the component transitions to the `Requested` state, signaling the CPU to handle the interrupt. The CPU then asserts `interrupt_ready_i`, and the component transitions to the `WaitForExit` state. Once the CPU has completed handling the interrupt and asserts `interrupt_return_i`, the component returns to the `Ready` state. The component has several registers, including `irq_reg`, `pending_interrupts`, `interrupts_enabled`, `interrupts_wakeup`, `interrupts_level`, and `interrupts_invert`. These registers are used to store the current state of the interrupts, enable or disable interrupts, and configure the interrupt behavior. The `irq_reg` register stores the current state of the interrupt requests, while the `pending_interrupts` register stores the pending interrupts that have not been handled yet. The `interrupts_enabled`, `interrupts_wakeup`, `interrupts_level`, and `interrupts_invert` registers are used to configure the interrupt behavior, such as enabling or disabling interrupts, specifying wake-up interrupts, and setting the interrupt level and inversion. The component's functional behavior can be described as follows: when an interrupt request is received, the component checks if the interrupt is enabled and if it has a higher priority than other pending interrupts. If so, the component signals the CPU to handle the interrupt by asserting `interrupt_valid_o` and providing the interrupt vector on `interrupt_vector_o`. The CPU then handles the interrupt, and once it has completed, it asserts `interrupt_return_i`, which causes the component to return to the `Ready` state. The control logic of the component is primarily implemented using the state machine and the registers. The state machine manages the interrupt handling process, while the registers are used to configure the interrupt behavior. The component also has several control signals, including `interrupt_valid_o`, `interrupt_vector_o`, and `wakeup_o`, which are used to communicate with the CPU and other components. Data flows through the component as follows: interrupt requests are received on `irq_i` and stored in `irq_reg`. The component then checks for pending interrupts and prioritizes them based on their numbers. Once an interrupt is detected, the component signals the CPU to handle it by asserting `interrupt_valid_o` and providing the interrupt vector on `interrupt_vector_o`. The CPU then handles the interrupt, and once it has completed, it asserts `interrupt_return_i`, which causes the component to return to the `Ready` state. In terms of timing and synchronization, the component operates in a single clock domain, with the `clk_i` port used to clock the component. The component has setup and hold requirements for the `irq_i` and `interrupt_ready_i` inputs, which must be met to ensure proper operation. The component also has timing constraints related to the interrupt handling process, such as the time required for the CPU to handle an interrupt and the time required for the component to return to the `Ready` state. One of the special features of this component is its ability to handle both edge-triggered and level-triggered interrupts. The `interrupts_level` register is used to configure the interrupt behavior, allowing the component to handle interrupts with different triggering characteristics. Another special feature is the ability to enable or disable interrupts, allowing the CPU to control which interrupts are handled. The LXP32 Interrupt Multiplexer is typically used in systems that require interrupt handling, such as embedded systems, microcontrollers, and CPUs. Its implementation considerations include performance, resource usage, and design trade-offs. The component's performance is critical, as it must handle interrupts in a timely and efficient manner. The component's resource usage is also important, as it must be implemented using a minimal amount of logic and registers. Design trade-offs include balancing the component's performance and resource usage, as well as ensuring that it meets the required timing and synchronization constraints. In terms of implementation, the component can be implemented using a combination of logic and registers. The state machine can be implemented using a finite state machine (FSM) approach, while the registers can be implemented using flip-flops or other storage elements. The component's logic can be optimized to minimize resource usage while meeting the required performance and timing constraints. Overall, the LXP32 Interrupt Multiplexer is a critical component of the LXP32 CPU, responsible for managing interrupts and prioritizing them based on their","---------------------------------------------------------------------
-- Interrupt multiplexer
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Manages LXP32 interrupts. Interrupts with lower numbers have
-- higher priority.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_interrupt_mux is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		irq_i: in std_logic_vector(7 downto 0);
		
		interrupt_valid_o: out std_logic;
		interrupt_vector_o: out std_logic_vector(2 downto 0);
		interrupt_ready_i: in std_logic;
		interrupt_return_i: in std_logic;

		wakeup_o: out std_logic;
		
		sp_waddr_i: in std_logic_vector(7 downto 0);
		sp_we_i: in std_logic;
		sp_wdata_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_interrupt_mux is

signal irq: std_logic_vector(irq_i'range);
signal irq_reg: std_logic_vector(irq_i'range):=(others=>'0');

type state_type is (Ready,Requested,WaitForExit);
signal state: state_type:=Ready;

signal pending_interrupts: std_logic_vector(irq_i'range):=(others=>'0');

signal interrupt_valid: std_logic:='0';

signal interrupts_enabled: std_logic_vector(7 downto 0):=(others=>'0');
signal interrupts_wakeup: std_logic_vector(7 downto 0):=(others=>'0');
signal interrupts_level: std_logic_vector(7 downto 0):=(others=>'0');
signal interrupts_invert: std_logic_vector(7 downto 0):=(others=>'0');

begin

irq<=irq_i xor interrupts_invert;

-- Note: ""disabled"" interrupts (i.e. for which interrupts_enabled_i(i)='0')
-- are ignored completely, meaning that the interrupt handler won't be
-- called even if the interrupt is enabled later.

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			irq_reg<=(others=>'0');
			pending_interrupts<=(others=>'0');
			state<=Ready;
			interrupt_valid<='0';
			interrupt_vector_o<=(others=>'-');
			wakeup_o<='0';
		else
			irq_reg<=irq;
			
			pending_interrupts<=(pending_interrupts or 
				(irq and not irq_reg)) and not interrupts_level and
				interrupts_enabled and not interrupts_wakeup;
			
			case state is
			when Ready =>
				for i in irq'reverse_range loop -- lower interrupts have priority
					if (interrupts_level(i)='0' and pending_interrupts(i)='1') or
							(interrupts_level(i)='1' and irq(i)='1' and
							interrupts_enabled(i)='1' and interrupts_wakeup(i)='0') then
						pending_interrupts(i)<='0';
						interrupt_valid<='1';
						interrupt_vector_o<=std_logic_vector(to_unsigned(i,3));
						state<=Requested;
						exit;
					end if;
				end loop;
			when Requested =>
				if interrupt_ready_i='1' then
					interrupt_valid<='0';
					state<=WaitForExit;
				end if;
			when WaitForExit =>
				if interrupt_return_i='1' then
					state<=Ready;
				end if;
			end case;

			wakeup_o<='0';
			for i in irq'range loop
				if interrupts_enabled(i)='1' and interrupts_wakeup(i)='1' then
					if interrupts_level(i)='0' then -- edge triggered
						if irq(i)='1' and irq_reg(i)='0' then
							wakeup_o<='1';
						end if;
					else -- level triggered
						if irq(i)='1' then
							wakeup_o<='1';
						end if;
					end if;
				end if;
			end loop;
		end if;
	end if;
end process;

interrupt_valid_o<=interrupt_valid;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			interrupts_enabled<=(others=>'0');
			interrupts_wakeup<=(others=>'0');
			interrupts_level<=(others=>'0');
			interrupts_invert<=(others=>'0');
		elsif sp_we_i='1' and sp_waddr_i=X""FC"" then
			interrupts_enabled<=sp_wdata_i(7 downto 0);
			interrupts_wakeup<=sp_wdata_i(15 downto 8);
			interrupts_level<=sp_wdata_i(23 downto 16);
			interrupts_invert<=sp_wdata_i(31 downto 24);
		end if;
	end if;
end process;

end architecture;
"
"The `lxp32_mul16x16` component is a fundamental digital circuit designed to perform 16-bit parallel multiplication, playing a crucial role in the LXP32 CPU as a basic building block for arithmetic operations. Its primary purpose is to multiply two 16-bit input values and produce a 32-bit output result, which is then registered and made available for further processing. The component features four ports: `clk_i`, `a_i`, `b_i`, and `p_o`. The `clk_i` port is a clock input, a single-bit signal that drives the sequential logic within the component, dictating when the multiplication operation is performed and when the result is updated. The `a_i` and `b_i` ports are 16-bit input vectors that provide the operands for the multiplication, while the `p_o` port is a 32-bit output vector that presents the product of `a_i` and `b_i`. The bit widths of these ports are carefully chosen to accommodate the 16-bit multiplication result, which inherently requires 32 bits to represent all possible outcomes without overflow. Internally, the component's architecture is straightforward, leveraging a simple process statement sensitive to the rising edge of `clk_i`. On every clock cycle, when `clk_i` transitions from '0' to '1', the process performs the multiplication of the unsigned representations of `a_i` and `b_i` and assigns the result to `p_o`. This operation is facilitated by the `unsigned` type conversion function from the `ieee.numeric_std` package, ensuring that the operands are treated as unsigned integers during the multiplication. The result is then converted back to a `std_logic_vector` using the `std_logic_vector` function, ensuring compatibility with the output port `p_o`. The functional behavior of the `lxp32_mul16x16` component can be described as follows: on each rising edge of the clock, it captures the current values of `a_i` and `b_i`, multiplies them, and immediately updates `p_o` with the product. This step-by-step operation implies that the component acts as a combinational multiplier with a registered output, where the registration is inherently handled by the process statement's sensitivity to the clock edge. Control logic within the component is minimal, primarily governed by the clock signal. The enable condition for the multiplication operation is implicitly the rising edge of `clk_i`, and there is no explicit reset behavior defined within the provided code. This implies that the component will retain its last computed value if the clock continues to toggle, or it will produce a result from the last sampled inputs if the system is otherwise reset or powered down. Data flow through the component is straightforward: 16-bit data enters through `a_i` and `b_i`, is multiplied, and the 32-bit result exits through `p_o`. There are no transformations applied to the data other than the multiplication and type conversions necessary for the operation. In terms of timing and synchronization, the component operates within a single clock domain defined by `clk_i`. The setup and hold requirements for the input signals `a_i` and `b_i` are implicitly dictated by the clock's timing characteristics, as the multiplication and output update occur synchronously with the clock edge. This synchronous operation helps in avoiding metastability issues and ensures that the output `p_o` is updated reliably on each clock cycle. The component does not exhibit any special features or modes of operation beyond its basic multiplication functionality. It operates in a single mode, continuously multiplying its inputs and presenting the result at the output. Given its function and simplicity, the `lxp32_mul16x16` multiplier is typically used within digital systems that require rapid multiplication of 16-bit numbers, such as in CPUs, DSPs, and other digital signal processing or computing architectures. Its straightforward implementation makes it suitable for a wide range of applications where fast and accurate multiplication is necessary. Implementation considerations for the `lxp32_mul16x16` component focus on performance, resource usage, and design trade-offs. The behavioral description provided is highly efficient in terms of design effort but may not yield the most optimal hardware implementation in terms of area or speed compared to a structural description or a module specifically designed and optimized for a target FPGA or ASIC technology. However, for many applications, especially within a CPU like the LXP32, such straightforward implementations are preferred for their simplicity and ease of verification. Resource usage will depend on the synthesis tool's optimization capabilities and the target technology, but generally, this multiplier would require a minimal amount of combinational logic and perhaps a small output register, leading to a relatively low resource utilization profile.","---------------------------------------------------------------------
-- A basic parallel 16x16 multiplier with an output register
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A straightforward behavioral description. Can be replaced
-- with a library component wrapper if needed.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul16x16 is
	port(
		clk_i: in std_logic;
		a_i: in std_logic_vector(15 downto 0);
		b_i: in std_logic_vector(15 downto 0);
		p_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul16x16 is

begin

process (clk_i) is
begin
	if rising_edge(clk_i) then
		p_o<=std_logic_vector(unsigned(a_i)*unsigned(b_i));
	end if;
end process;

end architecture;
"
"The VHDL code provided describes a digital signal processing (DSP) multiplier component, specifically designed for the LXP32 CPU. This multiplier is tailored for modern FPGA families that offer fast 16x16 multipliers, enabling efficient multiplication operations. The primary purpose of this component is to perform 32-bit multiplication, leveraging the built-in DSP blocks of the target FPGA technology. The component has several key ports that facilitate its operation. The `clk_i` port is the clock input, which drives the internal logic and synchronization of the multiplier. The `rst_i` port is the reset input, used to initialize the component to a known state. The `ce_i` port is the clock enable input, which controls whether the multiplier is actively operating or in a standby mode. The `op1_i` and `op2_i` ports are 32-bit inputs that provide the operands for multiplication. The `ce_o` port is the clock enable output, which indicates whether the multiplier is currently operational. Lastly, the `result_o` port is the 32-bit output that delivers the product of the two input operands. Internally, the multiplier utilizes three instances of a 16x16 multiplier module, denoted as `lxp32_mul16x16`. These modules are instantiated to perform partial product calculations, which are then combined to yield the final 32-bit product. The input operands are split into 16-bit segments to feed into these multiplier modules. Specifically, `mul00_inst`, `mul01_inst`, and `mul10_inst` perform multiplications on different segments of the input operands. The outputs of these multipliers, `pp00`, `pp01`, and `pp10`, are then combined through addition to form the higher and lower 16 bits of the product. The architectural description reveals a straightforward yet efficient design. The use of dedicated 16x16 multipliers within the FPGA allows for a significant reduction in logic resources and improvement in performance. The internal signal `product` accumulates the partial products and provides the final result. The `ceo` signal, which drives the `ce_o` output, is generated based on the clock enable input `ce_i` and reset input `rst_i`, ensuring that the component only outputs valid results when enabled. In terms of functional behavior, the multiplier operates in a pipelined fashion, with one multiplication taking two cycles to complete. On the first cycle, the partial products are generated, and on the second cycle, these products are summed to produce the final result. The timing relationships are critical, as the component relies on the clock and clock enable signals to synchronize its operations. Control logic within the component manages the clock enable output `ce_o` based on the reset and clock enable inputs. When the reset is asserted, the clock enable output is deasserted, ensuring that the component does not produce spurious outputs during reset. The state transitions are simple, primarily governed by the clock and reset signals. Data flow through the component involves the segmentation of input operands, their multiplication within the 16x16 multiplier modules, and the combination of partial products to form the final result. There are no complex transformations; the data simply flows through the multiplier, undergoing multiplication. Timing and synchronization are crucial for the correct operation of the multiplier. The component operates within a single clock domain, with the clock input `clk_i` driving all internal operations. The setup and hold requirements are implicitly managed through the use of the clock enable and reset signals, ensuring that data is sampled and processed correctly. A special feature of this multiplier is its utilization of FPGA-specific DSP blocks for 16x16 multiplication. This approach maximizes performance while minimizing the utilization of general logic resources. The component operates in a standard multiplication mode, with no unique modes of operation described. This DSP multiplier component would typically be used within digital signal processing systems, microprocessors, or any application requiring high-speed multiplication operations. Its design makes it suitable for FPGA-based projects, especially those targeting modern FPGA families with built-in DSP blocks. Implementation considerations include optimizing the use of FPGA resources, particularly the DSP blocks, to achieve high performance. The design trade-offs involve balancing resource utilization with operational speed and the number of cycles required for multiplication. Given its efficient use of FPGA resources and streamlined architecture, this multiplier component offers a high-performance solution for multiplication operations within the LXP32 CPU and similar applications.","---------------------------------------------------------------------
-- DSP multiplier
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This multiplier is designed for technologies that provide fast
-- 16x16 multipliers, including most modern FPGA families. One
-- multiplication takes 2 cycles.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul_dsp is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul_dsp is

signal pp00: std_logic_vector(31 downto 0);
signal pp01: std_logic_vector(31 downto 0);
signal pp10: std_logic_vector(31 downto 0);

signal product: unsigned(31 downto 0);

signal ceo: std_logic:='0';

begin

mul00_inst: entity work.lxp32_mul16x16
	port map(
		clk_i=>clk_i,
		a_i=>op1_i(15 downto 0),
		b_i=>op2_i(15 downto 0),
		p_o=>pp00
	);

mul01_inst: entity work.lxp32_mul16x16
	port map(
		clk_i=>clk_i,
		a_i=>op1_i(15 downto 0),
		b_i=>op2_i(31 downto 16),
		p_o=>pp01
	);

mul10_inst: entity work.lxp32_mul16x16
	port map(
		clk_i=>clk_i,
		a_i=>op1_i(31 downto 16),
		b_i=>op2_i(15 downto 0),
		p_o=>pp10
	);

product(31 downto 16)<=unsigned(pp00(31 downto 16))+unsigned(pp01(15 downto 0))+unsigned(pp10(15 downto 0));
product(15 downto 0)<=unsigned(pp00(15 downto 0));
result_o<=std_logic_vector(product);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
		else
			ceo<=ce_i;
		end if;
	end if;
end process;

ce_o<=ceo;

end architecture;
"
"The `lxp32_mul_opt` component is a VHDL-designed, optimized multiplier module, specifically tailored for technologies that lack fast 16x16 multipliers. This module plays a crucial role in the LXP32 CPU, serving as a fundamental component for executing multiplication operations. Its primary purpose is to efficiently perform 32-bit multiplication using a carry-save accumulation of partial products algorithm, ensuring a multiplication operation is completed within six cycles. The component features several key ports that dictate its operation and interaction with other system components. The `clk_i` port is the clock input, which drives the internal state machine and registers, necessitating a stable and precise clock signal for proper functionality. The `rst_i` port is the reset input, used to initialize the component to a known state, typically upon system power-up or during a system reset. The `ce_i` port serves as the clock enable, allowing the multiplier to operate synchronously with the system clock while providing a means to pause or gate the clock for power management or other operational reasons. The `op1_i` and `op2_i` ports are 32-bit input operands for the multiplication operation. Lastly, `ce_o` and `result_o` are output ports, with `ce_o` indicating when the multiplication result is valid and `result_o` providing the 32-bit result of the multiplication. Internally, the component utilizes several registers (`reg1` and `reg2`) to store the input operands during the multiplication process. It generates eight partial products in parallel through a series of shift and conditional operations based on the input operands. These partial products are then added using a carry-save adder tree structure, which significantly reduces the complexity and speed requirements of the multiplier. The adder tree consists of multiple levels of carry-save adders (CSA), which compute the sum and carry for each bit position. The final result is accumulated in `acc_sum` and `acc_carry` signals, representing the sum and carry outputs of the last stage of the adder tree. The architectural description reveals a highly structured and pipelined approach to multiplication. The process of generating partial products, adding them through the carry-save tree, and accumulating the result is managed by an internal state machine. This state machine is implicitly defined through the process statement sensitive to the `clk_i`. It controls the flow of data through the registers, manages the clock enable output (`ce_o`), and oversees the multiplication process over six cycles. The functional behavior of the `lxp32_mul_opt` can be described step-by-step. Upon receiving a clock enable (`ce_i='1'`), the multiplier captures the input operands (`op1_i` and `op2_i`) and initializes the accumulation registers. Over the next five cycles, it shifts and adds partial products, effectively performing the multiplication. On the sixth cycle, it asserts `ce_o` to indicate the result is valid and outputs the product through `result_o`. Control logic within the component manages the enable conditions, reset behavior, and state transitions. The `ce_o` signal is asserted for one cycle when the multiplication result is ready, indicating to the system that the result can be used. The reset behavior reinitializes all registers and counters to their default states, ensuring a clean start for new operations. Data flow through the component involves the transformation of input operands into partial products, their accumulation through a carry-save adder tree, and the final summation to produce the multiplication result. This process involves minimal data transformation outside of the arithmetic operations inherent to multiplication and the algorithmic optimizations. In terms of timing and synchronization, the component operates within a single clock domain defined by `clk_i`. The setup and hold requirements for the input signals (`op1_i`, `op2_i`, `ce_i`, and `rst_i`) are implicitly defined by the clock and the combinatorial logic driving the registers. The design adheres to standard VHDL timing semantics, ensuring that data is sampled at the rising edge of the clock. A special feature of this multiplier is its use of a carry-save accumulation algorithm to efficiently compute the product without requiring fast 16x16 multipliers. This approach allows for a more efficient use of FPGA resources or ASIC standard cells, particularly in technologies not optimized for large multiplier structures. The `lxp32_mul_opt` multiplier is typically used in CPU architectures like the LXP32, where efficient and accurate multiplication operations are essential. Its design allows for integration into a wide range of digital systems requiring fast and efficient multiplication. Implementation considerations include performance optimization through pipelining and algorithmic efficiency, resource usage minimization through the use of a structured and repetitive carry-save adder tree, and design trade-offs between speed, area, and power consumption. The design's performance is characterized by its ability to complete a multiplication in six cycles, making it suitable for applications requiring rapid execution of multiplication operations. Resource usage is optimized through the structured approach to partial product generation and accumulation, minimizing the required logic and registers. Overall, the `lxp32_mul_opt` offers a balanced trade-off between performance, resource utilization, and operational efficiency, making it a valuable component in digital system design.","---------------------------------------------------------------------
-- Optimized multiplier
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This multiplier is designed for technologies that don't provide
-- fast 16x16 multipliers. One multiplication takes 6 cycles.
--
-- The multiplication algorithm is based on carry-save accumulation
-- of partial products.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul_opt is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul_opt is

function csa_sum(a: unsigned; b: unsigned; c: unsigned; n: integer) return unsigned is
	variable r: unsigned(n-1 downto 0);
begin
	for i in r'range loop
		r(i):=a(i) xor b(i) xor c(i);
	end loop;
	return r;
end function;

function csa_carry(a: unsigned; b: unsigned; c: unsigned; n: integer) return unsigned is
	variable r: unsigned(n-1 downto 0);
begin
	for i in r'range loop
		r(i):=(a(i) and b(i)) or (a(i) and c(i)) or (b(i) and c(i));
	end loop;
	return r&""0"";
end function;

signal reg1: unsigned(op1_i'range);
signal reg2: unsigned(op2_i'range);

type pp_type is array (7 downto 0) of unsigned(31 downto 0);
signal pp: pp_type;

type pp_sum_type is array (7 downto 0) of unsigned(31 downto 0);
signal pp_sum: pp_sum_type;

type pp_carry_type is array (7 downto 0) of unsigned(32 downto 0);
signal pp_carry: pp_carry_type;

signal acc_sum: unsigned(31 downto 0);
signal acc_carry: unsigned(31 downto 0);

signal cnt: integer range 0 to 4:=0;

signal result: std_logic_vector(result_o'range);
signal ceo: std_logic:='0';

begin

-- Calculate 8 partial products in parallel

pp_gen: for i in pp'range generate
	pp(i)<=shift_left(reg1,i) when reg2(i)='1' else (others=>'0');
end generate;

-- Add partial products to the accumulator using carry-save adder tree

pp_sum(0)<=csa_sum(pp(0),pp(1),pp(2),32);
pp_carry(0)<=csa_carry(pp(0),pp(1),pp(2),32);

pp_sum(1)<=csa_sum(pp(3),pp(4),pp(5),32);
pp_carry(1)<=csa_carry(pp(3),pp(4),pp(5),32);

pp_sum(2)<=csa_sum(pp(6),pp(7),acc_sum,32);
pp_carry(2)<=csa_carry(pp(6),pp(7),acc_sum,32);

pp_sum(3)<=csa_sum(pp_sum(0),pp_carry(0),pp_sum(1),32);
pp_carry(3)<=csa_carry(pp_sum(0),pp_carry(0),pp_sum(1),32);

pp_sum(4)<=csa_sum(pp_carry(1),pp_sum(2),pp_carry(2),32);
pp_carry(4)<=csa_carry(pp_carry(1),pp_sum(2),pp_carry(2),32);

pp_sum(5)<=csa_sum(pp_sum(3),pp_carry(3),pp_sum(4),32);
pp_carry(5)<=csa_carry(pp_sum(3),pp_carry(3),pp_sum(4),32);

pp_sum(6)<=csa_sum(pp_sum(5),pp_carry(5),pp_carry(4),32);
pp_carry(6)<=csa_carry(pp_sum(5),pp_carry(5),pp_carry(4),32);

pp_sum(7)<=csa_sum(pp_sum(6),pp_carry(6),acc_carry,32);
pp_carry(7)<=csa_carry(pp_sum(6),pp_carry(6),acc_carry,32);

-- Multiplier state machine

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
			cnt<=0;
			reg1<=(others=>'-');
			reg2<=(others=>'-');
			acc_sum<=(others=>'-');
			acc_carry<=(others=>'-');
		else
			if cnt=1 then
				ceo<='1';
			else
				ceo<='0';
			end if;
			
			if ce_i='1' then
				cnt<=4;
				reg1<=unsigned(op1_i);
				reg2<=unsigned(op2_i);
				acc_sum<=(others=>'0');
				acc_carry<=(others=>'0');
			else
				acc_sum<=pp_sum(7);
				acc_carry<=pp_carry(7)(acc_carry'range);
				reg1<=reg1(reg1'high-8 downto 0)&X""00"";
				reg2<=X""00""&reg2(reg2'high downto 8);
				if cnt>0 then
					cnt<=cnt-1;
				end if;
			end if;
		end if;
	end if;
end process;

result<=std_logic_vector(acc_sum+acc_carry);

result_o<=result;
ce_o<=ceo;

-- A simulation-time multiplication check

-- synthesis translate_off

process (clk_i) is
	variable p: unsigned(op1_i'length+op2_i'length-1 downto 0);
begin
	if rising_edge(clk_i) then
		if ce_i='1' then
			p:=unsigned(op1_i)*unsigned(op2_i);
		elsif ceo='1' then
			assert result=std_logic_vector(p(result'range))
				report ""Incorrect multiplication result""
				severity failure;
		end if;
	end if;
end process;

-- synthesis translate_on

end architecture;
"
"The LXP32 sequential multiplier, denoted as `lxp32_mul_seq`, is a digital component designed to perform multiplication operations within the LXP32 CPU. Its primary purpose is to compute the product of two 32-bit operands, `op1_i` and `op2_i`, and produce a 32-bit result, `result_o`. This component plays a crucial role in the LXP32 CPU, enabling the execution of multiplication instructions. The component features a straightforward port configuration, with a total of seven ports. The clock input, `clk_i`, and reset input, `rst_i`, are essential for synchronizing and resetting the component's internal state. The `ce_i` port serves as an enable signal, controlling the initiation of multiplication operations. The two 32-bit input ports, `op1_i` and `op2_i`, receive the operands to be multiplied. The `ce_o` output port indicates when the multiplication operation is complete, while the `result_o` port outputs the 32-bit product. Internally, the component comprises several key registers and signals. The `reg1` and `reg2` registers store the operand values, while the `pp` signal represents the partial product, which is either the value of `reg1` or a zero vector, depending on the least significant bit of `reg2`. The `acc_sum` register accumulates the partial products, and the `cnt` counter tracks the number of cycles required for the multiplication operation. The `ceo` signal is generated based on the counter value, indicating when the operation is complete. The architectural description reveals a simple, iterative design. The multiplication operation is performed using an accumulator, where the partial products are added to the accumulator over multiple cycles. The process begins when the `ce_i` enable signal is asserted, and the component loads the operand values into `reg1` and `reg2`. The `cnt` counter is then initialized to 32, and the multiplication process commences. In each cycle, the partial product is added to the accumulator, and the `reg1` and `reg2` registers are shifted. The `ceo` signal is asserted when the counter reaches 1, indicating that the multiplication operation is complete. The functional behavior of the component can be described as follows: when the `ce_i` enable signal is asserted, the component initiates the multiplication operation by loading the operand values and resetting the accumulator. Over the next 32 cycles, the component iteratively adds partial products to the accumulator, shifting the `reg1` and `reg2` registers in each cycle. Once the counter reaches 0, the `ceo` signal is asserted, and the final product is output on the `result_o` port. The control logic of the component is primarily governed by the `ce_i` enable signal, which initiates the multiplication operation. The `rst_i` reset signal asynchronously resets the component's internal state. The `ceo` signal is generated based on the counter value, and it indicates when the multiplication operation is complete. The state transitions are straightforward, with the component transitioning from an idle state to an active state when the `ce_i` enable signal is asserted. Data flow within the component is straightforward, with the operand values being loaded into the `reg1` and `reg2` registers at the start of the multiplication operation. The partial products are then generated and added to the accumulator over multiple cycles. The final product is output on the `result_o` port once the multiplication operation is complete. In terms of timing and synchronization, the component operates within a single clock domain, with the `clk_i` clock input governing all internal operations. The component has specific setup and hold requirements, which must be met to ensure correct operation. The timing constraints are primarily dictated by the clock frequency and the number of cycles required for the multiplication operation. One special feature of this component is its ability to perform multiplication operations using an accumulator, which reduces the hardware requirements compared to other multiplier architectures. The component has two modes of operation: idle and active, which are controlled by the `ce_i` enable signal. The LXP32 sequential multiplier is typically used in digital systems that require multiplication operations, such as CPUs, DSPs, and other digital processing units. Its applications include scientific simulations, data processing, and embedded systems. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The component's performance is primarily dictated by the clock frequency and the number of cycles required for the multiplication operation. The resource usage is relatively low, as the component only requires a small number of registers and logic gates. However, the design trade-offs include the choice of accumulator width, the number of cycles required for the multiplication operation, and the optimization of the control logic. Overall, the LXP32 sequential multiplier is a simple, efficient, and effective component for performing multiplication operations in digital systems.","---------------------------------------------------------------------
-- Sequential multiplier
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- The smallest possible multiplier. Implemented using
-- an accumulator. One multiplication takes 34 cycles.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_mul_seq is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		op1_i: in std_logic_vector(31 downto 0);
		op2_i: in std_logic_vector(31 downto 0);
		ce_o: out std_logic;
		result_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_mul_seq is

signal reg1: unsigned(op1_i'range);
signal reg2: unsigned(op2_i'range);
signal pp: unsigned(31 downto 0);
signal acc_sum: unsigned(31 downto 0);
signal cnt: integer range 0 to 32:=0;
signal ceo: std_logic:='0';

begin

pp<=reg1 when reg2(0)='1' else (others=>'0');

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
			cnt<=0;
			reg1<=(others=>'-');
			reg2<=(others=>'-');
			acc_sum<=(others=>'-');
		else
			if cnt=1 then
				ceo<='1';
			else
				ceo<='0';
			end if;
			
			if ce_i='1' then
				cnt<=32;
				reg1<=unsigned(op1_i);
				reg2<=unsigned(op2_i);
				acc_sum<=(others=>'0');
			else
				acc_sum<=acc_sum+pp;
				reg1<=reg1(reg1'high-1 downto 0)&""0"";
				reg2<=""0""&reg2(reg2'high downto 1);
				if cnt>0 then
					cnt<=cnt-1;
				end if;
			end if;
		end if;
	end if;
end process;

result_o<=std_logic_vector(acc_sum);
ce_o<=ceo;

end architecture;
"
"The VHDL code provided describes a generic dual-port memory component, specifically designed for the LXP32 CPU. This component serves as a crucial element in digital systems, enabling the storage and retrieval of data. Its primary purpose is to provide a flexible and efficient memory solution, capable of handling both write and read operations. The component features a single write port and a single read port, allowing for concurrent access to the memory. The write port is controlled by the `we_i` signal, which enables the write operation when asserted high. The write address is specified by the `waddr_i` signal, a 8-bit vector that selects one of the 256 memory locations. The data to be written is provided by the `wdata_i` signal, a 32-bit vector. On the other hand, the read port is controlled by the `re_i` signal, which enables the read operation when asserted high. The read address is specified by the `raddr_i` signal, also an 8-bit vector. The data being read is output on the `rdata_o` signal, a 32-bit vector. Internally, the component consists of a 256x32-bit RAM array, implemented using a type declaration `ram_type`. The RAM array is initialized with all zeros, which is suitable for SRAM-based FPGAs. The `syn_ramstyle` and `ram_style` attributes are used to guide the synthesis tool in inferring on-chip block RAM, optimizing the design for the target FPGA architecture. Specifically, the `syn_ramstyle` attribute is set to ""no_rw_check"" to disable read/write checking, while the `ram_style` attribute is set to ""block"" to enforce the use of block RAM. The write port operation is straightforward: on the rising edge of the clock `clk_i`, if the write enable `we_i` is high, the data `wdata_i` is written to the memory location specified by `waddr_i`. The read port operation is similarly straightforward: on the rising edge of the clock `clk_i`, if the read enable `re_i` is high, the data is read from the memory location specified by `raddr_i` and output on `rdata_o`. If the read address is unknown (i.e., contains don't-care values), the output is driven to all 'X' values to avoid simulation warnings. The control logic is primarily governed by the clock `clk_i`, which drives the write and read operations. The write and read enables, `we_i` and `re_i`, respectively, act as control signals that dictate when data is written or read. The reset behavior is implicit, as the RAM array is initialized with zeros and does not have any explicit reset logic. State transitions are solely based on the clock and control signals. Data flow through the component is straightforward: write data is presented on `wdata_i` and stored in the RAM array at the address specified by `waddr_i`. Read data is retrieved from the RAM array at the address specified by `raddr_i` and output on `rdata_o`. There are no complex data transformations; the component simply stores and retrieves data as dictated by the write and read operations. In terms of timing and synchronization, the component operates within a single clock domain, with all operations synchronized to the rising edge of `clk_i`. The setup and hold requirements are implicitly defined by the FPGA's clock constraints, which must be considered during the design flow. The component does not have any specific timing constraints, other than those imposed by the FPGA's clock and the interface signals. A notable feature of this component is its ability to be inferred as on-chip block RAM by major FPGA synthesis tools. This allows for efficient use of FPGA resources and optimized performance. Additionally, the component can be replaced with a library component wrapper if needed, providing flexibility in design implementation. This dual-port memory component is typically used in digital systems where data needs to be stored and retrieved efficiently. It can be used in a wide range of applications, from simple data buffering to more complex systems requiring concurrent access to memory. When implementing this component, designers should consider performance, resource usage, and design trade-offs. The use of block RAM can significantly impact the FPGA's resource utilization and performance. Designers should carefully evaluate the clock frequency, data throughput, and memory requirements to ensure optimal performance. Additionally, designers should consider the FPGA's architecture and the synthesis tool's capabilities to optimize the design for the target platform. By carefully balancing performance, resource usage, and design complexity, designers can effectively utilize this dual-port memory component in their digital system designs.","---------------------------------------------------------------------
-- Generic dual-port memory
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Portable description of a dual-port memory block with one write
-- port. Major FPGA synthesis tools can infer on-chip block RAM
-- from this description. Can be replaced with a library component
-- wrapper if needed.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lxp32_ram256x32 is
	port(
		clk_i: in std_logic;
		
		we_i: in std_logic;
		waddr_i: in std_logic_vector(7 downto 0);
		wdata_i: in std_logic_vector(31 downto 0);
		
		re_i: in std_logic;
		raddr_i: in std_logic_vector(7 downto 0);
		rdata_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_ram256x32 is

type ram_type is array(255 downto 0) of std_logic_vector(31 downto 0);
signal ram: ram_type:=(others=>(others=>'0')); -- zero-initialize for SRAM-based FPGAs

attribute syn_ramstyle: string;
attribute syn_ramstyle of ram: signal is ""no_rw_check"";
attribute ram_style: string; -- for Xilinx
attribute ram_style of ram: signal is ""block"";

begin

-- Write port

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if we_i='1' then
			ram(to_integer(unsigned(waddr_i)))<=wdata_i;
		end if;
	end if;
end process;

-- Read port

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if re_i='1' then
			if is_x(raddr_i) then -- to avoid numeric_std warnings during simulation
				rdata_o<=(others=>'X');
			else
				rdata_o<=ram(to_integer(unsigned(raddr_i)));
			end if;
		end if;
	end if;
end process;

end architecture;
"
"The LXP32 Scratchpad is a crucial component of the LXP32 CPU, functioning as a register file implemented using a RAM block. Its primary purpose is to provide fast access to a set of registers, enabling the CPU to perform efficient data processing. The Scratchpad plays a vital role in larger systems, as it serves as a bridge between the CPU's execution units and the memory hierarchy. The component features a total of seven ports: `clk_i`, `raddr1_i`, `rdata1_o`, `raddr2_i`, `rdata2_o`, `waddr_i`, `we_i`, and `wdata_i`. The `clk_i` port is a clock input that drives the internal operations of the Scratchpad. The `raddr1_i` and `raddr2_i` ports are 8-bit inputs that specify the addresses of the registers to be read, while `rdata1_o` and `rdata2_o` are 32-bit outputs that provide the corresponding register values. The `waddr_i` port is an 8-bit input that specifies the address of the register to be written, and `we_i` is a write enable signal that controls the write operation. The `wdata_i` port is a 32-bit input that provides the data to be written. Internally, the Scratchpad consists of two identical RAM blocks, `ram_inst1` and `ram_inst2`, each with a capacity of 256x32 bits. These RAM blocks are instances of the `lxp32_ram256x32` entity, which is not shown in the provided code. The RAM blocks are used to store the register values, and they operate in parallel to enable simultaneous reads from two registers. The outputs of the RAM blocks are stored in the `ram1_rdata` and `ram2_rdata` signals. The Scratchpad also includes a write data register, `wdata_reg`, which captures the write data on every clock cycle. This register is used to handle read/write collisions, where a write operation is performed to a register that is being read simultaneously. The component detects read/write collisions by monitoring the write address and enable signal, and comparing them to the read addresses. If a collision is detected, the corresponding output is switched to the write data register, ensuring that the most recent value is provided. This is achieved through the `ram1_collision` and `ram2_collision` signals, which are generated using a process that runs on the rising edge of the clock. The Scratchpad's functional behavior can be described as follows: on every clock cycle, the component performs two simultaneous read operations from the RAM blocks, using the `raddr1_i` and `raddr2_i` addresses. If a write operation is performed, the write data is captured in the `wdata_reg` and checked for collisions with the read addresses. If a collision is detected, the output is switched to the write data register; otherwise, the output is taken directly from the RAM block. The control logic of the Scratchpad is primarily driven by the clock and the write enable signal. The write enable signal controls the write operation, and the clock drives the read operations and the collision detection process. The reset behavior is not explicitly shown in the provided code, but it can be inferred that the component will reset to a known state when the clock is not present or when a reset signal is asserted. Data flows through the component as follows: read data is provided to the outputs `rdata1_o` and `rdata2_o`, while write data is captured in the `wdata_reg` and written to the RAM blocks. The component performs a transformation on the write data by capturing it in a register and checking for collisions. The Scratchpad operates in a single clock domain, with the clock driving all internal operations. The component requires careful consideration of setup and hold times to ensure that the read and write operations are performed correctly. The timing constraints are primarily determined by the clock frequency and the RAM block access times. A special feature of the Scratchpad is its ability to handle read/write collisions, which is essential for efficient CPU operation. The component also supports simultaneous reads from two registers, which enhances CPU performance. The LXP32 Scratchpad is typically used in CPU architectures that require fast access to a set of registers. It can be used in a variety of applications, including embedded systems, microcontrollers, and digital signal processing. In terms of implementation considerations, the Scratchpad's performance is primarily determined by the RAM block access times and the clock frequency. The component's resource usage is moderate, as it requires two RAM blocks and a small amount of logic for collision detection. Design trade-offs include optimizing the RAM block size and the clock frequency to achieve the required performance while minimizing resource usage. Overall, the LXP32 Scratchpad is a well-designed component that provides efficient and reliable register file functionality for CPU architectures.","---------------------------------------------------------------------
-- Scratchpad
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- LXP32 register file implemented as a RAM block. Since we need
-- to read two registers simultaneously, the memory is duplicated.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_scratchpad is
	port(
		clk_i: in std_logic;
		
		raddr1_i: in std_logic_vector(7 downto 0);
		rdata1_o: out std_logic_vector(31 downto 0);
		raddr2_i: in std_logic_vector(7 downto 0);
		rdata2_o: out std_logic_vector(31 downto 0);
		
		waddr_i: in std_logic_vector(7 downto 0);
		we_i: in std_logic;
		wdata_i: in std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_scratchpad is

signal wdata_reg: std_logic_vector(wdata_i'range);
signal ram1_rdata: std_logic_vector(31 downto 0);
signal ram2_rdata: std_logic_vector(31 downto 0);

signal ram1_collision: std_logic;
signal ram2_collision: std_logic;

begin

-- RAM 1

ram_inst1: entity work.lxp32_ram256x32(rtl)
	port map(
		clk_i=>clk_i,
		
		we_i=>we_i,
		waddr_i=>waddr_i,
		wdata_i=>wdata_i,
		
		re_i=>'1',
		raddr_i=>raddr1_i,
		rdata_o=>ram1_rdata
	);

-- RAM 2

ram_inst2: entity work.lxp32_ram256x32(rtl)
	port map(
		clk_i=>clk_i,
		
		we_i=>we_i,
		waddr_i=>waddr_i,
		wdata_i=>wdata_i,
		
		re_i=>'1',
		raddr_i=>raddr2_i,
		rdata_o=>ram2_rdata
	);

-- Read/write collision detection

process (clk_i) is
begin
	if rising_edge(clk_i) then
		wdata_reg<=wdata_i;
		if waddr_i=raddr1_i and we_i='1' then
			ram1_collision<='1';
		else
			ram1_collision<='0';
		end if;
		if waddr_i=raddr2_i and we_i='1' then
			ram2_collision<='1';
		else
			ram2_collision<='0';
		end if;
	end if;
end process;

rdata1_o<=ram1_rdata when ram1_collision='0' else wdata_reg;
rdata2_o<=ram2_rdata when ram2_collision='0' else wdata_reg;

end architecture;
"
"describes a barrel shifter component, specifically designed for the LXP32 CPU. This component is responsible for performing logical (unsigned) and arithmetic (signed) shifts in both directions, with a pipeline latency of one cycle. The barrel shifter is a crucial component in many digital systems, enabling efficient data manipulation and alignment. The component has several input ports, each serving a distinct purpose. The `clk_i` port is the clock input, which drives the internal sequential logic. The `rst_i` port is the asynchronous reset input, used to initialize the component to a known state. The `ce_i` port is the clock enable input, which controls the flow of data through the component. The `d_i` port is a 32-bit data input, which provides the data to be shifted. The `s_i` port is a 5-bit shift amount input, specifying the number of bits to shift. The `right_i` port is a single-bit input that determines the direction of the shift (right or left). The `sig_i` port is a single-bit input that indicates whether the shift should be signed (arithmetic) or unsigned (logical). The output ports of the component include `ce_o`, a clock enable output that indicates when the output data is valid, and `d_o`, a 32-bit data output that provides the shifted result. Internally, the component consists of several key elements. The input data is first processed by a set of combinational logic that performs the initial data alignment and bit reversal, depending on the shift direction. This is achieved through a generate statement, `data_gen`, which creates a set of multiplexers that reorder the input data bits according to the `right_i` signal. The core of the barrel shifter is a cascaded set of shifters, implemented as a series of multiplexers and concatenations. The `cascades` signal is an array of 5 elements, each representing a stage of the shifter. The first three stages are implemented using a generate statement, where each stage shifts the data by a power of two (1, 2, or 4 bits) based on the corresponding bit in the `s_i` signal. The final two stages are implemented sequentially, using a process statement that registers the data and control signals. The control logic of the component is primarily driven by the `ce_i`, `rst_i`, and `clk_i` signals. The `ceo` signal is generated based on the `ce_i` signal and is used to indicate when the output data is valid. The component also includes a set of registers that store the intermediate results and control signals between clock cycles. The functional behavior of the component can be described as follows: when the `ce_i` signal is high, the component shifts the input data by the amount specified by the `s_i` signal, in the direction specified by the `right_i` signal, and with a signed or unsigned interpretation based on the `sig_i` signal. The shifted result is then registered and output on the `d_o` port. The data flow through the component can be described as follows: the input data is first aligned and reordered according to the shift direction. The data is then shifted in a series of stages, with each stage shifting the data by a power of two. The final shifted result is then registered and output. The component has specific timing and synchronization requirements. The input data and control signals must be stable for one clock cycle before the rising edge of the clock. The component also has a setup and hold time requirement for the input signals, which must be met to ensure proper operation. One of the special features of this component is its ability to perform both logical and arithmetic shifts. The `sig_i` signal controls the interpretation of the shift operation, allowing the component to handle both signed and unsigned data. The barrel shifter component is commonly used in digital systems that require efficient data manipulation and alignment, such as in CPUs, DSPs, and other digital processing units. In the context of the LXP32 CPU, this component plays a critical role in enabling efficient execution of shift instructions. When implementing this component, designers must consider performance, resource usage, and design trade-offs. The component's performance is primarily determined by the clock frequency and the number of stages in the shifter. The resource usage is determined by the number of multiplexers, registers, and other logic elements required to implement the component. Designers must balance these factors to achieve optimal performance while minimizing resource usage. In conclusion, the provided VHDL code describes a sophisticated barrel shifter component that provides efficient and flexible data manipulation capabilities. The component's internal structure, control logic, and functional behavior are carefully designed to meet the requirements of the LXP32 CPU. By understanding the detailed operation of this component, designers can effectively integrate it into larger digital systems and leverage its capabilities to optimize system performance.","---------------------------------------------------------------------
-- Barrel shifter
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- Performs logical (unsigned) and arithmetic (signed) shifts
-- in both directions. Pipeline latency: 1 cycle.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_shifter is
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		ce_i: in std_logic;
		d_i: in std_logic_vector(31 downto 0);
		s_i: in std_logic_vector(4 downto 0);
		right_i: in std_logic;
		sig_i: in std_logic;
		ce_o: out std_logic;
		d_o: out std_logic_vector(31 downto 0)
	);
end entity;

architecture rtl of lxp32_shifter is

signal data: std_logic_vector(d_i'range);
signal data_shifted: std_logic_vector(d_i'range);

signal fill: std_logic; -- 0 for unsigned shifts, sign bit for signed ones
signal fill_v: std_logic_vector(3 downto 0);

type cascades_type is array (4 downto 0) of std_logic_vector(d_i'range);
signal cascades: cascades_type;

signal stage2_data: std_logic_vector(d_i'range);
signal stage2_s: std_logic_vector(s_i'range);
signal stage2_fill: std_logic;
signal stage2_fill_v: std_logic_vector(15 downto 0);
signal stage2_right: std_logic;

signal ceo: std_logic:='0';

begin

-- Internally, data are shifted in left direction. For right shifts
-- we reverse the argument's bit order

data_gen: for i in data'range generate
	data(i)<=d_i(i) when right_i='0' else d_i(d_i'high-i);
end generate;

-- A set of cascaded shifters shifting by powers of two

fill<=sig_i and data(0);
fill_v<=(others=>fill);

cascades(0)<=data(30 downto 0)&fill_v(0) when s_i(0)='1' else data;
cascades(1)<=cascades(0)(29 downto 0)&fill_v(1 downto 0) when s_i(1)='1' else cascades(0);
cascades(2)<=cascades(1)(27 downto 0)&fill_v(3 downto 0) when s_i(2)='1' else cascades(1);

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			ceo<='0';
			stage2_data<=(others=>'-');
			stage2_s<=(others=>'-');
			stage2_fill<='-';
			stage2_right<='-';
		else
			ceo<=ce_i;
			stage2_data<=cascades(2);
			stage2_s<=s_i;
			stage2_fill<=fill;
			stage2_right<=right_i;
		end if;
	end if;
end process;

stage2_fill_v<=(others=>stage2_fill);

cascades(3)<=stage2_data(23 downto 0)&stage2_fill_v(7 downto 0) when stage2_s(3)='1' else stage2_data;
cascades(4)<=cascades(3)(15 downto 0)&stage2_fill_v(15 downto 0) when stage2_s(4)='1' else cascades(3);

-- Reverse bit order back, if needed

data_shifted_gen: for i in data_shifted'range generate
	data_shifted(i)<=cascades(4)(i) when stage2_right='0' else cascades(4)(cascades(4)'high-i);
end generate;

d_o<=data_shifted;
ce_o<=ceo;

end architecture;
"
"The Microbuffer component, specifically the `lxp32_ubuf` entity, is a fundamental building block within the LXP32 CPU, designed to provide a small, register-based buffer with a FIFO-like interface. Its primary purpose is to temporarily store data in a First-In-First-Out (FIFO) manner, facilitating efficient data transfer between different parts of the system. This component plays a crucial role in managing data flow, enabling the system to handle data processing and buffering with improved performance. The `lxp32_ubuf` entity features a generic `DATA_WIDTH` parameter, allowing for flexible configuration of the data bus width. The component has several input and output ports that facilitate its operation. The `clk_i` and `rst_i` ports are used for clocking and resetting the component, respectively. The `we_i` and `re_i` ports are write and read enable signals, which control the flow of data into and out of the buffer. The `d_i` and `d_o` ports are used for data input and output, with the output being a `std_logic_vector` of width `DATA_WIDTH`. Additionally, the `empty_o` and `full_o` ports provide status signals indicating whether the buffer is empty or full. Internally, the component consists of a small array of registers, specifically a two-register array (`regs`) of width `DATA_WIDTH`, along with some control logic. The `regs_mux` signal is used to select the input data for the registers, based on the write enable and empty/full conditions. The `empty` and `full` signals are used to track the status of the buffer, and are updated based on the write and read enable signals. The component's architectural description reveals a straightforward, synchronous design, with a single clock domain and simple control logic. The functional behavior of the Microbuffer can be described as follows: when the `we_i` signal is asserted and the buffer is not full, data is written into the buffer. Conversely, when the `re_i` signal is asserted and the buffer is not empty, data is read out of the buffer. The `empty_o` and `full_o` status signals are updated accordingly. The component's operation is synchronized to the rising edge of the clock, ensuring that data is processed and transferred in a predictable and reliable manner. The control logic within the component is responsible for managing the flow of data and updating the buffer status signals. The `we` and `re` signals are generated based on the input enable signals and the buffer's status, ensuring that data is written or read only when the buffer is in a valid state. The reset behavior is also well-defined, with the buffer being reset to an empty state when the `rst_i` signal is asserted. Data flow through the component is straightforward, with data being written into the buffer through the `d_i` port and read out through the `d_o` port. The component does not perform any data transformations; instead, it simply stores and forwards data as needed. In terms of timing and synchronization, the Microbuffer operates within a single clock domain, with all operations being synchronized to the rising edge of the clock. The component's setup and hold requirements are typical for a synchronous design, with the input signals being sampled on the rising edge of the clock. One special feature of the Microbuffer is its ability to operate in a FIFO-like manner, with the buffer being able to store and forward data in a First-In-First-Out order. This makes it an essential component in many digital systems, particularly those requiring efficient data buffering and transfer. The Microbuffer is typically used in digital systems where data buffering and transfer are critical, such as in CPUs, data acquisition systems, and digital signal processing applications. Its small size and efficient operation make it an attractive solution for systems requiring low-latency data buffering. When implementing the Microbuffer, designers should consider performance, resource usage, and design trade-offs. The component's simplicity and small register array make it an efficient solution in terms of resource usage. However, designers may need to optimize the component's configuration, such as the `DATA_WIDTH` parameter, to meet specific system requirements. Additionally, careful consideration should be given to the component's clocking and synchronization requirements to ensure reliable operation in the target system. Overall, the Microbuffer is a well-designed component that provides efficient data buffering and transfer capabilities, making it a valuable addition to many digital systems.","---------------------------------------------------------------------
-- Microbuffer
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- A small buffer with a FIFO-like interface, implemented
-- using registers.
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32_ubuf is
	generic(
		DATA_WIDTH: integer
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		we_i: in std_logic;
		d_i: in std_logic_vector(DATA_WIDTH-1 downto 0);
		re_i: in std_logic;
		d_o: out std_logic_vector(DATA_WIDTH-1 downto 0);
		
		empty_o: out std_logic;
		full_o: out std_logic
	);
end entity;

architecture rtl of lxp32_ubuf is

signal we: std_logic;
signal re: std_logic;

signal empty: std_logic:='1';
signal full: std_logic:='0';

type regs_type is array (1 downto 0) of std_logic_vector(DATA_WIDTH-1 downto 0);
signal regs: regs_type;
signal regs_mux: regs_type;

begin

we<=we_i and not full;
re<=re_i and not empty;

process (clk_i) is
begin
	if rising_edge(clk_i) then
		if rst_i='1' then
			empty<='1';
			full<='0';
			regs<=(others=>(others=>'-'));
		else
			if re='0' then
				regs(0)<=regs_mux(0);
			else
				regs(0)<=regs_mux(1);
			end if;
			
			regs(1)<=regs_mux(1);
			
			if we='1' and re='0' then
				empty<='0';
				full<=not empty;
			elsif we='0' and re='1' then
				empty<=not full;
				full<='0';
			end if;
		end if;
	end if;
end process;

regs_mux(0)<=regs(0) when we='0' or empty='0' else d_i;
regs_mux(1)<=regs(1) when we='0' or empty='1' else d_i;

d_o<=regs(0);
empty_o<=empty;
full_o<=full;

end architecture;
"
"The LXP32C CPU top-level module is a VHDL design that represents the central processing unit (CPU) of the LXP32 processor family, specifically the C-series variant with an instruction cache. This module serves as the primary component of the LXP32 CPU, responsible for executing instructions and managing data transfer between various system components. The LXP32C CPU is designed to work with high-latency program memory, such as external SDRAM chips, and utilizes the Wishbone B3 interface for the instruction bus (IBUS). The LXP32C CPU top-level module has several generic parameters that allow for customization of its behavior. These parameters include DBUS_RMW, which determines whether to use a read-modify-write (RMW) cycle instead of the SEL_O() signal for byte-granular access to the data bus; DIVIDER_EN, which enables or disables the divider; IBUS_BURST_SIZE, which sets the size of the burst for the instruction bus; IBUS_PREFETCH_SIZE, which determines the number of words left in the buffer before initiating a read burst; MUL_ARCH, which specifies the multiplier architecture; and START_ADDR, which sets the starting address in program memory where execution begins. The module has several input and output ports that facilitate communication with other system components. The clock input (clk_i) and reset input (rst_i) are used to synchronize and reset the CPU, respectively. The instruction bus ports (ibus_cyc_o, ibus_stb_o, ibus_cti_o, ibus_bte_o, ibus_ack_i, ibus_adr_o, and ibus_dat_i) are used to interact with the instruction memory, while the data bus ports (dbus_cyc_o, dbus_stb_o, dbus_we_o, dbus_sel_o, dbus_ack_i, dbus_adr_o, dbus_dat_o, and dbus_dat_i) are used for data transfer. The irq_i port is used to receive interrupt requests. Internally, the LXP32C CPU top-level module consists of two main components: the LXP32 CPU core (cpu_inst) and the instruction cache (icache_inst). The CPU core is responsible for executing instructions and managing data transfer, while the instruction cache is used to improve performance by storing frequently accessed instructions. The CPU core and instruction cache communicate through a local interface, which consists of the lli_re, lli_adr, lli_dat, and lli_busy signals. The CPU core is instantiated with the specified generic parameters and is connected to the data bus ports, interrupt request port, and local interface signals. The instruction cache is also instantiated with the specified generic parameters and is connected to the instruction bus ports, local interface signals, and clock and reset inputs. The LXP32C CPU top-level module operates by first fetching instructions from the instruction memory through the instruction cache. The instruction cache uses a burst-based approach to fetch instructions, with the burst size and prefetch size determined by the IBUS_BURST_SIZE and IBUS_PREFETCH_SIZE parameters, respectively. Once an instruction is fetched, it is executed by the CPU core, which performs the necessary operations and generates data transfer requests to the data bus. The CPU core uses a combination of control signals, enable conditions, and state transitions to manage its operation. The control signals include the clock and reset inputs, as well as the interrupt request input. The enable conditions determine when the CPU core can perform certain operations, such as executing instructions or generating data transfer requests. The state transitions manage the CPU core's operational states, including instruction fetch, decode, execute, and data transfer. The data flow through the LXP32C CPU top-level module involves the transfer of instructions and data between the instruction memory, data memory, and CPU core. Instructions are fetched from the instruction memory through the instruction cache and are then executed by the CPU core. Data is transferred between the data memory and CPU core through the data bus. The LXP32C CPU top-level module has specific timing and synchronization requirements. The clock input (clk_i) is used to synchronize the CPU core and instruction cache, while the reset input (rst_i) is used to reset the CPU core and instruction cache. The setup and hold requirements for the instruction and data bus signals must be met to ensure proper operation. One of the special features of the LXP32C CPU top-level module is its support for different multiplier architectures, which can be specified using the MUL_ARCH parameter. This allows designers to optimize the CPU core for specific applications. Additionally, the instruction cache can be configured to use different burst sizes and prefetch sizes, which can impact performance. The LXP32C CPU top-level module is typically used in embedded systems, such as microcontrollers, industrial control systems, and communication devices. Its performance and resource usage can be optimized for specific applications by adjusting the generic parameters and selecting the appropriate multiplier architecture. In terms of implementation considerations, the LXP32C CPU top-level module requires careful attention to performance, resource usage, and design trade-offs. The CPU core and instruction cache can be optimized for performance by adjusting the generic parameters, such as the burst size and prefetch size. However, this may come at the cost of increased resource usage. Designers must balance performance and resource usage to meet the requirements of their specific application. Overall, the LXP32C CPU top-level module is a complex VHDL design that requires a thorough understanding of CPU architecture, instruction cache design, and VHDL design principles. Its comprehensive analysis involves examining the component's overview, input/output ports, internal structure, functional behavior, control logic, data flow, timing and synchronization, special features, and implementation considerations.","---------------------------------------------------------------------
-- LXP32C CPU top-level module (C-series, with instruction cache)
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This version uses Wishbone B3 interface for the instruction bus
-- (IBUS). It is designed for high-latency program memory, such as
-- external SDRAM chips.
--
-- Parameters:
--     DBUS_RMW:           Use RMW cycle instead of SEL_O() signal
--                         for byte-granular access to data bus
--     DIVIDER_EN:         enable divider
--     IBUS_BURST_SIZE:    size of the burst
--     IBUS_PREFETCH_SIZE: initiate read burst if number of words
--                         left in the buffer is less than specified
--     MUL_ARCH:           multiplier architecture (""dsp"", ""opt""
--                         or ""seq"")
--     START_ADDR:         address in program memory where execution
--                         starts
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32c_top is
	generic(
		DBUS_RMW: boolean:=false;
		DIVIDER_EN: boolean:=true;
		IBUS_BURST_SIZE: integer:=16;
		IBUS_PREFETCH_SIZE: integer:=32;
		MUL_ARCH: string:=""dsp"";
		START_ADDR: std_logic_vector(31 downto 0):=(others=>'0')
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		ibus_cyc_o: out std_logic;
		ibus_stb_o: out std_logic;
		ibus_cti_o: out std_logic_vector(2 downto 0);
		ibus_bte_o: out std_logic_vector(1 downto 0);
		ibus_ack_i: in std_logic;
		ibus_adr_o: out std_logic_vector(29 downto 0);
		ibus_dat_i: in std_logic_vector(31 downto 0);
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		irq_i: in std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32c_top is

signal lli_re: std_logic;
signal lli_adr: std_logic_vector(29 downto 0);
signal lli_dat: std_logic_vector(31 downto 0);
signal lli_busy: std_logic;

begin

cpu_inst: entity work.lxp32_cpu(rtl)
	generic map(
		DBUS_RMW=>DBUS_RMW,
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH,
		START_ADDR=>START_ADDR
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_o=>lli_re,
		lli_adr_o=>lli_adr,
		lli_dat_i=>lli_dat,
		lli_busy_i=>lli_busy,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i,
		
		irq_i=>irq_i
	);

icache_inst: entity work.lxp32_icache(rtl)
	generic map(
		BURST_SIZE=>IBUS_BURST_SIZE,
		PREFETCH_SIZE=>IBUS_PREFETCH_SIZE
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_i=>lli_re,
		lli_adr_i=>lli_adr,
		lli_dat_o=>lli_dat,
		lli_busy_o=>lli_busy,
		
		wbm_cyc_o=>ibus_cyc_o,
		wbm_stb_o=>ibus_stb_o,
		wbm_cti_o=>ibus_cti_o,
		wbm_bte_o=>ibus_bte_o,
		wbm_ack_i=>ibus_ack_i,
		wbm_adr_o=>ibus_adr_o,
		wbm_dat_i=>ibus_dat_i
	);

end architecture;
"
"The LXP32U CPU top-level module is a digital design component that serves as the primary processing unit in a system-on-chip (SoC) or a standalone processor. Its primary purpose is to execute instructions and manage data transfer between various peripherals and memory elements. This component is part of the LXP32 CPU family and is specifically designed without an instruction cache, which implies that it relies on a Low Latency Interface (LLI) for instruction fetching. The LXP32U CPU top-level module is designed to operate with low-latency slaves, such as on-chip RAM blocks, which are typically used in embedded systems for fast data access. The module's architecture is highly configurable through generics, allowing designers to tailor its behavior to specific application requirements. For instance, the DBUS_RMW generic parameter enables the use of a Read-Modify-Write (RMW) cycle instead of a select signal for byte-granular access to the data bus, which can impact performance and data integrity. Additionally, the DIVIDER_EN parameter controls the inclusion of a divider module, while the MUL_ARCH parameter determines the multiplier architecture, offering options for ""dsp"", ""opt"", or ""seq"" implementations. The START_ADDR generic sets the initial address in program memory where execution begins. From an input/output perspective, the LXP32U CPU top-level module features a range of ports that facilitate communication with other system components. The clock input (clk_i) and reset input (rst_i) are essential for synchronizing and resetting the module's internal state. The LLI interface, comprising lli_re_o, lli_adr_o, lli_dat_i, and lli_busy_i, enables the CPU to fetch instructions from low-latency memory slaves. The data bus interface, consisting of dbus_cyc_o, dbus_stb_o, dbus_we_o, dbus_sel_o, dbus_ack_i, dbus_adr_o, dbus_dat_o, and dbus_dat_i, allows the CPU to access and exchange data with other system components. The irq_i port receives interrupt requests from peripherals, enabling the CPU to respond to asynchronous events. Internally, the LXP32U CPU top-level module consists of a CPU instance (cpu_inst) that encapsulates the core processing logic. This instance is a separate entity, likely designed using a Register-Transfer Level (RTL) approach, which is a common design methodology for digital circuits. The cpu_inst entity is parameterized using the same generics as the top-level module, ensuring consistency in configuration. The internal structure of the cpu_inst entity likely comprises various registers, counters, and state machines that manage instruction execution, data processing, and interaction with the LLI and data bus interfaces. The functional behavior of the LXP32U CPU top-level module can be described as a step-by-step process. Initially, the module resets to a known state upon assertion of the rst_i signal. Upon release of the reset, the CPU begins executing instructions from the address specified by the START_ADDR generic. The CPU fetches instructions through the LLI interface and decodes them to determine the operation to be performed. Data processing involves accessing data from memory or peripherals through the data bus interface, performing computations, and storing results back in memory or registers. Interrupt requests received on the irq_i port can preempt the current instruction stream, allowing the CPU to respond to asynchronous events. Control logic within the LXP32U CPU top-level module manages the flow of data and instructions. The module uses a clock signal (clk_i) to synchronize internal operations and ensure that data is processed and transferred in a timely manner. The control logic also generates control signals, such as dbus_cyc_o and dbus_stb_o, to initiate data bus transactions and dbus_sel_o to select specific bytes for data transfer. The module's reset behavior is determined by the rst_i signal, which resets the internal state to a known condition. Data flow within the LXP32U CPU top-level module involves the movement of instructions and data between various interfaces and internal registers. Instructions are fetched from low-latency memory slaves through the LLI interface and then decoded and executed by the CPU core. Data is exchanged with peripherals and memory through the data bus interface, with the CPU core performing read and write operations as needed. The module's architecture ensures that data is properly synchronized and transferred between different clock domains, if present. Timing and synchronization are critical aspects of the LXP32U CPU top-level module's design. The module operates within a single clock domain, with the clk_i signal driving all internal operations. The design adheres to standard timing constraints, including setup and hold times, to ensure that data is properly captured and transferred. The use of a Low Latency Interface for instruction fetching implies that the module is designed to operate with low-latency memory slaves, which can provide instructions quickly. One of the special features of the LXP32U CPU top-level module is its configurability through generics, which allows designers to tailor the module's behavior to specific application requirements. The module also supports a range of multiplier architectures, offering flexibility in terms of performance and resource usage. Additionally, the module's use of a Low Latency Interface for instruction fetching enables fast instruction access, which can improve overall system performance. The LXP32U CPU top-level module is suitable for a variety of applications, including embedded systems, SoCs, and standalone processors. Its configurability and support for low-latency memory slaves make it an attractive option for systems requiring fast instruction access and efficient data processing. In terms of implementation considerations, the LXP32U CPU top-level module's performance is influenced by the chosen multiplier architecture, the presence or absence of a divider, and the use of RMW cycles for data bus access. The module's resource usage is determined by the specific FPGA or ASIC technology used for implementation, as well","---------------------------------------------------------------------
-- LXP32U CPU top-level module (U-series, without instruction cache)
--
-- Part of the LXP32 CPU
--
-- Copyright (c) 2016 by Alex I. Kuznetsov
--
-- This version uses a Low Latency Interface for the instruction bus
-- (IBUS). It is designed for low-latency slaves such as on-chip
-- RAM blocks.
--
-- Parameters:
--     DBUS_RMW:           Use RMW cycle instead of SEL_O() signal
--                         for byte-granular access to data bus
--     DIVIDER_EN:         enable divider
--     MUL_ARCH:           multiplier architecture (""dsp"", ""opt""
--                         or ""seq"")
--     START_ADDR:         address in program memory where execution
--                         starts
---------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity lxp32u_top is
	generic(
		DBUS_RMW: boolean:=false;
		DIVIDER_EN: boolean:=true;
		MUL_ARCH: string:=""dsp"";
		START_ADDR: std_logic_vector(31 downto 0):=(others=>'0')
	);
	port(
		clk_i: in std_logic;
		rst_i: in std_logic;
		
		lli_re_o: out std_logic;
		lli_adr_o: out std_logic_vector(29 downto 0);
		lli_dat_i: in std_logic_vector(31 downto 0);
		lli_busy_i: in std_logic;
		
		dbus_cyc_o: out std_logic;
		dbus_stb_o: out std_logic;
		dbus_we_o: out std_logic;
		dbus_sel_o: out std_logic_vector(3 downto 0);
		dbus_ack_i: in std_logic;
		dbus_adr_o: out std_logic_vector(31 downto 2);
		dbus_dat_o: out std_logic_vector(31 downto 0);
		dbus_dat_i: in std_logic_vector(31 downto 0);
		
		irq_i: in std_logic_vector(7 downto 0)
	);
end entity;

architecture rtl of lxp32u_top is

begin

cpu_inst: entity work.lxp32_cpu(rtl)
	generic map(
		DBUS_RMW=>DBUS_RMW,
		DIVIDER_EN=>DIVIDER_EN,
		MUL_ARCH=>MUL_ARCH,
		START_ADDR=>START_ADDR
	)
	port map(
		clk_i=>clk_i,
		rst_i=>rst_i,
		
		lli_re_o=>lli_re_o,
		lli_adr_o=>lli_adr_o,
		lli_dat_i=>lli_dat_i,
		lli_busy_i=>lli_busy_i,
		
		dbus_cyc_o=>dbus_cyc_o,
		dbus_stb_o=>dbus_stb_o,
		dbus_we_o=>dbus_we_o,
		dbus_sel_o=>dbus_sel_o,
		dbus_ack_i=>dbus_ack_i,
		dbus_adr_o=>dbus_adr_o,
		dbus_dat_o=>dbus_dat_o,
		dbus_dat_i=>dbus_dat_i,
		
		irq_i=>irq_i
	);

end architecture;
"
